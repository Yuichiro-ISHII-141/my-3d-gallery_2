(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();function iN(c){return c&&c.__esModule&&Object.prototype.hasOwnProperty.call(c,"default")?c.default:c}var Ky={exports:{}},Ju={};var y1;function rN(){if(y1)return Ju;y1=1;var c=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(s,i,r){var a=null;if(r!==void 0&&(a=""+r),i.key!==void 0&&(a=""+i.key),"key"in i){r={};for(var o in i)o!=="key"&&(r[o]=i[o])}else r=i;return i=r.ref,{$$typeof:c,type:s,key:a,ref:i!==void 0?i:null,props:r}}return Ju.Fragment=e,Ju.jsx=t,Ju.jsxs=t,Ju}var x1;function aN(){return x1||(x1=1,Ky.exports=rN()),Ky.exports}var ge=aN(),Zy={exports:{}},Le={};var T1;function nN(){if(T1)return Le;T1=1;var c=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),a=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),m=Symbol.for("react.activity"),_=Symbol.iterator;function g(F){return F===null||typeof F!="object"?null:(F=_&&F[_]||F["@@iterator"],typeof F=="function"?F:null)}var S={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},x=Object.assign,T={};function E(F,U,K){this.props=F,this.context=U,this.refs=T,this.updater=K||S}E.prototype.isReactComponent={},E.prototype.setState=function(F,U){if(typeof F!="object"&&typeof F!="function"&&F!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,F,U,"setState")},E.prototype.forceUpdate=function(F){this.updater.enqueueForceUpdate(this,F,"forceUpdate")};function b(){}b.prototype=E.prototype;function C(F,U,K){this.props=F,this.context=U,this.refs=T,this.updater=K||S}var w=C.prototype=new b;w.constructor=C,x(w,E.prototype),w.isPureReactComponent=!0;var P=Array.isArray;function I(){}var M={H:null,A:null,T:null,S:null},R=Object.prototype.hasOwnProperty;function L(F,U,K){var se=K.ref;return{$$typeof:c,type:F,key:U,ref:se!==void 0?se:null,props:K}}function B(F,U){return L(F.type,U,F.props)}function G(F){return typeof F=="object"&&F!==null&&F.$$typeof===c}function H(F){var U={"=":"=0",":":"=2"};return"$"+F.replace(/[=:]/g,function(K){return U[K]})}var ee=/\/+/g;function j(F,U){return typeof F=="object"&&F!==null&&F.key!=null?H(""+F.key):U.toString(36)}function ae(F){switch(F.status){case"fulfilled":return F.value;case"rejected":throw F.reason;default:switch(typeof F.status=="string"?F.then(I,I):(F.status="pending",F.then(function(U){F.status==="pending"&&(F.status="fulfilled",F.value=U)},function(U){F.status==="pending"&&(F.status="rejected",F.reason=U)})),F.status){case"fulfilled":return F.value;case"rejected":throw F.reason}}throw F}function k(F,U,K,se,le){var re=typeof F;(re==="undefined"||re==="boolean")&&(F=null);var de=!1;if(F===null)de=!0;else switch(re){case"bigint":case"string":case"number":de=!0;break;case"object":switch(F.$$typeof){case c:case e:de=!0;break;case f:return de=F._init,k(de(F._payload),U,K,se,le)}}if(de)return le=le(F),de=se===""?"."+j(F,0):se,P(le)?(K="",de!=null&&(K=de.replace(ee,"$&/")+"/"),k(le,U,K,"",function(et){return et})):le!=null&&(G(le)&&(le=B(le,K+(le.key==null||F&&F.key===le.key?"":(""+le.key).replace(ee,"$&/")+"/")+de)),U.push(le)),1;de=0;var ye=se===""?".":se+":";if(P(F))for(var Me=0;Me<F.length;Me++)se=F[Me],re=ye+j(se,Me),de+=k(se,U,K,re,le);else if(Me=g(F),typeof Me=="function")for(F=Me.call(F),Me=0;!(se=F.next()).done;)se=se.value,re=ye+j(se,Me++),de+=k(se,U,K,re,le);else if(re==="object"){if(typeof F.then=="function")return k(ae(F),U,K,se,le);throw U=String(F),Error("Objects are not valid as a React child (found: "+(U==="[object Object]"?"object with keys {"+Object.keys(F).join(", ")+"}":U)+"). If you meant to render a collection of children, use an array instead.")}return de}function O(F,U,K){if(F==null)return F;var se=[],le=0;return k(F,se,"","",function(re){return U.call(K,re,le++)}),se}function z(F){if(F._status===-1){var U=F._result;U=U(),U.then(function(K){(F._status===0||F._status===-1)&&(F._status=1,F._result=K)},function(K){(F._status===0||F._status===-1)&&(F._status=2,F._result=K)}),F._status===-1&&(F._status=0,F._result=U)}if(F._status===1)return F._result.default;throw F._result}var X=typeof reportError=="function"?reportError:function(F){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var U=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof F=="object"&&F!==null&&typeof F.message=="string"?String(F.message):String(F),error:F});if(!window.dispatchEvent(U))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",F);return}console.error(F)},Y={map:O,forEach:function(F,U,K){O(F,function(){U.apply(this,arguments)},K)},count:function(F){var U=0;return O(F,function(){U++}),U},toArray:function(F){return O(F,function(U){return U})||[]},only:function(F){if(!G(F))throw Error("React.Children.only expected to receive a single React element child.");return F}};return Le.Activity=m,Le.Children=Y,Le.Component=E,Le.Fragment=t,Le.Profiler=i,Le.PureComponent=C,Le.StrictMode=s,Le.Suspense=h,Le.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=M,Le.__COMPILER_RUNTIME={__proto__:null,c:function(F){return M.H.useMemoCache(F)}},Le.cache=function(F){return function(){return F.apply(null,arguments)}},Le.cacheSignal=function(){return null},Le.cloneElement=function(F,U,K){if(F==null)throw Error("The argument must be a React element, but you passed "+F+".");var se=x({},F.props),le=F.key;if(U!=null)for(re in U.key!==void 0&&(le=""+U.key),U)!R.call(U,re)||re==="key"||re==="__self"||re==="__source"||re==="ref"&&U.ref===void 0||(se[re]=U[re]);var re=arguments.length-2;if(re===1)se.children=K;else if(1<re){for(var de=Array(re),ye=0;ye<re;ye++)de[ye]=arguments[ye+2];se.children=de}return L(F.type,le,se)},Le.createContext=function(F){return F={$$typeof:a,_currentValue:F,_currentValue2:F,_threadCount:0,Provider:null,Consumer:null},F.Provider=F,F.Consumer={$$typeof:r,_context:F},F},Le.createElement=function(F,U,K){var se,le={},re=null;if(U!=null)for(se in U.key!==void 0&&(re=""+U.key),U)R.call(U,se)&&se!=="key"&&se!=="__self"&&se!=="__source"&&(le[se]=U[se]);var de=arguments.length-2;if(de===1)le.children=K;else if(1<de){for(var ye=Array(de),Me=0;Me<de;Me++)ye[Me]=arguments[Me+2];le.children=ye}if(F&&F.defaultProps)for(se in de=F.defaultProps,de)le[se]===void 0&&(le[se]=de[se]);return L(F,re,le)},Le.createRef=function(){return{current:null}},Le.forwardRef=function(F){return{$$typeof:o,render:F}},Le.isValidElement=G,Le.lazy=function(F){return{$$typeof:f,_payload:{_status:-1,_result:F},_init:z}},Le.memo=function(F,U){return{$$typeof:u,type:F,compare:U===void 0?null:U}},Le.startTransition=function(F){var U=M.T,K={};M.T=K;try{var se=F(),le=M.S;le!==null&&le(K,se),typeof se=="object"&&se!==null&&typeof se.then=="function"&&se.then(I,X)}catch(re){X(re)}finally{U!==null&&K.types!==null&&(U.types=K.types),M.T=U}},Le.unstable_useCacheRefresh=function(){return M.H.useCacheRefresh()},Le.use=function(F){return M.H.use(F)},Le.useActionState=function(F,U,K){return M.H.useActionState(F,U,K)},Le.useCallback=function(F,U){return M.H.useCallback(F,U)},Le.useContext=function(F){return M.H.useContext(F)},Le.useDebugValue=function(){},Le.useDeferredValue=function(F,U){return M.H.useDeferredValue(F,U)},Le.useEffect=function(F,U){return M.H.useEffect(F,U)},Le.useEffectEvent=function(F){return M.H.useEffectEvent(F)},Le.useId=function(){return M.H.useId()},Le.useImperativeHandle=function(F,U,K){return M.H.useImperativeHandle(F,U,K)},Le.useInsertionEffect=function(F,U){return M.H.useInsertionEffect(F,U)},Le.useLayoutEffect=function(F,U){return M.H.useLayoutEffect(F,U)},Le.useMemo=function(F,U){return M.H.useMemo(F,U)},Le.useOptimistic=function(F,U){return M.H.useOptimistic(F,U)},Le.useReducer=function(F,U,K){return M.H.useReducer(F,U,K)},Le.useRef=function(F){return M.H.useRef(F)},Le.useState=function(F){return M.H.useState(F)},Le.useSyncExternalStore=function(F,U,K){return M.H.useSyncExternalStore(F,U,K)},Le.useTransition=function(){return M.H.useTransition()},Le.version="19.2.4",Le}var E1;function zT(){return E1||(E1=1,Zy.exports=nN()),Zy.exports}var q=zT();const b1=iN(q);var Qy={exports:{}},ed={},Jy={exports:{}},e0={};var A1;function oN(){return A1||(A1=1,(function(c){function e(k,O){var z=k.length;k.push(O);e:for(;0<z;){var X=z-1>>>1,Y=k[X];if(0<i(Y,O))k[X]=O,k[z]=Y,z=X;else break e}}function t(k){return k.length===0?null:k[0]}function s(k){if(k.length===0)return null;var O=k[0],z=k.pop();if(z!==O){k[0]=z;e:for(var X=0,Y=k.length,F=Y>>>1;X<F;){var U=2*(X+1)-1,K=k[U],se=U+1,le=k[se];if(0>i(K,z))se<Y&&0>i(le,K)?(k[X]=le,k[se]=z,X=se):(k[X]=K,k[U]=z,X=U);else if(se<Y&&0>i(le,z))k[X]=le,k[se]=z,X=se;else break e}}return O}function i(k,O){var z=k.sortIndex-O.sortIndex;return z!==0?z:k.id-O.id}if(c.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;c.unstable_now=function(){return r.now()}}else{var a=Date,o=a.now();c.unstable_now=function(){return a.now()-o}}var h=[],u=[],f=1,m=null,_=3,g=!1,S=!1,x=!1,T=!1,E=typeof setTimeout=="function"?setTimeout:null,b=typeof clearTimeout=="function"?clearTimeout:null,C=typeof setImmediate<"u"?setImmediate:null;function w(k){for(var O=t(u);O!==null;){if(O.callback===null)s(u);else if(O.startTime<=k)s(u),O.sortIndex=O.expirationTime,e(h,O);else break;O=t(u)}}function P(k){if(x=!1,w(k),!S)if(t(h)!==null)S=!0,I||(I=!0,H());else{var O=t(u);O!==null&&ae(P,O.startTime-k)}}var I=!1,M=-1,R=5,L=-1;function B(){return T?!0:!(c.unstable_now()-L<R)}function G(){if(T=!1,I){var k=c.unstable_now();L=k;var O=!0;try{e:{S=!1,x&&(x=!1,b(M),M=-1),g=!0;var z=_;try{t:{for(w(k),m=t(h);m!==null&&!(m.expirationTime>k&&B());){var X=m.callback;if(typeof X=="function"){m.callback=null,_=m.priorityLevel;var Y=X(m.expirationTime<=k);if(k=c.unstable_now(),typeof Y=="function"){m.callback=Y,w(k),O=!0;break t}m===t(h)&&s(h),w(k)}else s(h);m=t(h)}if(m!==null)O=!0;else{var F=t(u);F!==null&&ae(P,F.startTime-k),O=!1}}break e}finally{m=null,_=z,g=!1}O=void 0}}finally{O?H():I=!1}}}var H;if(typeof C=="function")H=function(){C(G)};else if(typeof MessageChannel<"u"){var ee=new MessageChannel,j=ee.port2;ee.port1.onmessage=G,H=function(){j.postMessage(null)}}else H=function(){E(G,0)};function ae(k,O){M=E(function(){k(c.unstable_now())},O)}c.unstable_IdlePriority=5,c.unstable_ImmediatePriority=1,c.unstable_LowPriority=4,c.unstable_NormalPriority=3,c.unstable_Profiling=null,c.unstable_UserBlockingPriority=2,c.unstable_cancelCallback=function(k){k.callback=null},c.unstable_forceFrameRate=function(k){0>k||125<k?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<k?Math.floor(1e3/k):5},c.unstable_getCurrentPriorityLevel=function(){return _},c.unstable_next=function(k){switch(_){case 1:case 2:case 3:var O=3;break;default:O=_}var z=_;_=O;try{return k()}finally{_=z}},c.unstable_requestPaint=function(){T=!0},c.unstable_runWithPriority=function(k,O){switch(k){case 1:case 2:case 3:case 4:case 5:break;default:k=3}var z=_;_=k;try{return O()}finally{_=z}},c.unstable_scheduleCallback=function(k,O,z){var X=c.unstable_now();switch(typeof z=="object"&&z!==null?(z=z.delay,z=typeof z=="number"&&0<z?X+z:X):z=X,k){case 1:var Y=-1;break;case 2:Y=250;break;case 5:Y=1073741823;break;case 4:Y=1e4;break;default:Y=5e3}return Y=z+Y,k={id:f++,callback:O,priorityLevel:k,startTime:z,expirationTime:Y,sortIndex:-1},z>X?(k.sortIndex=z,e(u,k),t(h)===null&&k===t(u)&&(x?(b(M),M=-1):x=!0,ae(P,z-X))):(k.sortIndex=Y,e(h,k),S||g||(S=!0,I||(I=!0,H()))),k},c.unstable_shouldYield=B,c.unstable_wrapCallback=function(k){var O=_;return function(){var z=_;_=O;try{return k.apply(this,arguments)}finally{_=z}}}})(e0)),e0}var w1;function lN(){return w1||(w1=1,Jy.exports=oN()),Jy.exports}var t0={exports:{}},ws={};var C1;function cN(){if(C1)return ws;C1=1;var c=zT();function e(h){var u="https://react.dev/errors/"+h;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)u+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+h+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var s={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},i=Symbol.for("react.portal");function r(h,u,f){var m=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:m==null?null:""+m,children:h,containerInfo:u,implementation:f}}var a=c.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(h,u){if(h==="font")return"";if(typeof u=="string")return u==="use-credentials"?u:""}return ws.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=s,ws.createPortal=function(h,u){var f=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!u||u.nodeType!==1&&u.nodeType!==9&&u.nodeType!==11)throw Error(e(299));return r(h,u,null,f)},ws.flushSync=function(h){var u=a.T,f=s.p;try{if(a.T=null,s.p=2,h)return h()}finally{a.T=u,s.p=f,s.d.f()}},ws.preconnect=function(h,u){typeof h=="string"&&(u?(u=u.crossOrigin,u=typeof u=="string"?u==="use-credentials"?u:"":void 0):u=null,s.d.C(h,u))},ws.prefetchDNS=function(h){typeof h=="string"&&s.d.D(h)},ws.preinit=function(h,u){if(typeof h=="string"&&u&&typeof u.as=="string"){var f=u.as,m=o(f,u.crossOrigin),_=typeof u.integrity=="string"?u.integrity:void 0,g=typeof u.fetchPriority=="string"?u.fetchPriority:void 0;f==="style"?s.d.S(h,typeof u.precedence=="string"?u.precedence:void 0,{crossOrigin:m,integrity:_,fetchPriority:g}):f==="script"&&s.d.X(h,{crossOrigin:m,integrity:_,fetchPriority:g,nonce:typeof u.nonce=="string"?u.nonce:void 0})}},ws.preinitModule=function(h,u){if(typeof h=="string")if(typeof u=="object"&&u!==null){if(u.as==null||u.as==="script"){var f=o(u.as,u.crossOrigin);s.d.M(h,{crossOrigin:f,integrity:typeof u.integrity=="string"?u.integrity:void 0,nonce:typeof u.nonce=="string"?u.nonce:void 0})}}else u==null&&s.d.M(h)},ws.preload=function(h,u){if(typeof h=="string"&&typeof u=="object"&&u!==null&&typeof u.as=="string"){var f=u.as,m=o(f,u.crossOrigin);s.d.L(h,f,{crossOrigin:m,integrity:typeof u.integrity=="string"?u.integrity:void 0,nonce:typeof u.nonce=="string"?u.nonce:void 0,type:typeof u.type=="string"?u.type:void 0,fetchPriority:typeof u.fetchPriority=="string"?u.fetchPriority:void 0,referrerPolicy:typeof u.referrerPolicy=="string"?u.referrerPolicy:void 0,imageSrcSet:typeof u.imageSrcSet=="string"?u.imageSrcSet:void 0,imageSizes:typeof u.imageSizes=="string"?u.imageSizes:void 0,media:typeof u.media=="string"?u.media:void 0})}},ws.preloadModule=function(h,u){if(typeof h=="string")if(u){var f=o(u.as,u.crossOrigin);s.d.m(h,{as:typeof u.as=="string"&&u.as!=="script"?u.as:void 0,crossOrigin:f,integrity:typeof u.integrity=="string"?u.integrity:void 0})}else s.d.m(h)},ws.requestFormReset=function(h){s.d.r(h)},ws.unstable_batchedUpdates=function(h,u){return h(u)},ws.useFormState=function(h,u,f){return a.H.useFormState(h,u,f)},ws.useFormStatus=function(){return a.H.useHostTransitionStatus()},ws.version="19.2.4",ws}var D1;function hN(){if(D1)return t0.exports;D1=1;function c(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c)}catch(e){console.error(e)}}return c(),t0.exports=cN(),t0.exports}var P1;function uN(){if(P1)return ed;P1=1;var c=lN(),e=zT(),t=hN();function s(n){var l="https://react.dev/errors/"+n;if(1<arguments.length){l+="?args[]="+encodeURIComponent(arguments[1]);for(var d=2;d<arguments.length;d++)l+="&args[]="+encodeURIComponent(arguments[d])}return"Minified React error #"+n+"; visit "+l+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11)}function r(n){var l=n,d=n;if(n.alternate)for(;l.return;)l=l.return;else{n=l;do l=n,(l.flags&4098)!==0&&(d=l.return),n=l.return;while(n)}return l.tag===3?d:null}function a(n){if(n.tag===13){var l=n.memoizedState;if(l===null&&(n=n.alternate,n!==null&&(l=n.memoizedState)),l!==null)return l.dehydrated}return null}function o(n){if(n.tag===31){var l=n.memoizedState;if(l===null&&(n=n.alternate,n!==null&&(l=n.memoizedState)),l!==null)return l.dehydrated}return null}function h(n){if(r(n)!==n)throw Error(s(188))}function u(n){var l=n.alternate;if(!l){if(l=r(n),l===null)throw Error(s(188));return l!==n?null:n}for(var d=n,p=l;;){var v=d.return;if(v===null)break;var y=v.alternate;if(y===null){if(p=v.return,p!==null){d=p;continue}break}if(v.child===y.child){for(y=v.child;y;){if(y===d)return h(v),n;if(y===p)return h(v),l;y=y.sibling}throw Error(s(188))}if(d.return!==p.return)d=v,p=y;else{for(var A=!1,N=v.child;N;){if(N===d){A=!0,d=v,p=y;break}if(N===p){A=!0,p=v,d=y;break}N=N.sibling}if(!A){for(N=y.child;N;){if(N===d){A=!0,d=y,p=v;break}if(N===p){A=!0,p=y,d=v;break}N=N.sibling}if(!A)throw Error(s(189))}}if(d.alternate!==p)throw Error(s(190))}if(d.tag!==3)throw Error(s(188));return d.stateNode.current===d?n:l}function f(n){var l=n.tag;if(l===5||l===26||l===27||l===6)return n;for(n=n.child;n!==null;){if(l=f(n),l!==null)return l;n=n.sibling}return null}var m=Object.assign,_=Symbol.for("react.element"),g=Symbol.for("react.transitional.element"),S=Symbol.for("react.portal"),x=Symbol.for("react.fragment"),T=Symbol.for("react.strict_mode"),E=Symbol.for("react.profiler"),b=Symbol.for("react.consumer"),C=Symbol.for("react.context"),w=Symbol.for("react.forward_ref"),P=Symbol.for("react.suspense"),I=Symbol.for("react.suspense_list"),M=Symbol.for("react.memo"),R=Symbol.for("react.lazy"),L=Symbol.for("react.activity"),B=Symbol.for("react.memo_cache_sentinel"),G=Symbol.iterator;function H(n){return n===null||typeof n!="object"?null:(n=G&&n[G]||n["@@iterator"],typeof n=="function"?n:null)}var ee=Symbol.for("react.client.reference");function j(n){if(n==null)return null;if(typeof n=="function")return n.$$typeof===ee?null:n.displayName||n.name||null;if(typeof n=="string")return n;switch(n){case x:return"Fragment";case E:return"Profiler";case T:return"StrictMode";case P:return"Suspense";case I:return"SuspenseList";case L:return"Activity"}if(typeof n=="object")switch(n.$$typeof){case S:return"Portal";case C:return n.displayName||"Context";case b:return(n._context.displayName||"Context")+".Consumer";case w:var l=n.render;return n=n.displayName,n||(n=l.displayName||l.name||"",n=n!==""?"ForwardRef("+n+")":"ForwardRef"),n;case M:return l=n.displayName||null,l!==null?l:j(n.type)||"Memo";case R:l=n._payload,n=n._init;try{return j(n(l))}catch{}}return null}var ae=Array.isArray,k=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,O=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,z={pending:!1,data:null,method:null,action:null},X=[],Y=-1;function F(n){return{current:n}}function U(n){0>Y||(n.current=X[Y],X[Y]=null,Y--)}function K(n,l){Y++,X[Y]=n.current,n.current=l}var se=F(null),le=F(null),re=F(null),de=F(null);function ye(n,l){switch(K(re,l),K(le,n),K(se,null),l.nodeType){case 9:case 11:n=(n=l.documentElement)&&(n=n.namespaceURI)?HC(n):0;break;default:if(n=l.tagName,l=l.namespaceURI)l=HC(l),n=WC(l,n);else switch(n){case"svg":n=1;break;case"math":n=2;break;default:n=0}}U(se),K(se,n)}function Me(){U(se),U(le),U(re)}function et(n){n.memoizedState!==null&&K(de,n);var l=se.current,d=WC(l,n.type);l!==d&&(K(le,n),K(se,d))}function Qe(n){le.current===n&&(U(se),U(le)),de.current===n&&(U(de),$u._currentValue=z)}var ls,xr;function ms(n){if(ls===void 0)try{throw Error()}catch(d){var l=d.stack.trim().match(/\n( *(at )?)/);ls=l&&l[1]||"",xr=-1<d.stack.indexOf(`
    at`)?" (<anonymous>)":-1<d.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ls+n+xr}var $r=!1;function vo(n,l){if(!n||$r)return"";$r=!0;var d=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var p={DetermineComponentFrameRoot:function(){try{if(l){var he=function(){throw Error()};if(Object.defineProperty(he.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(he,[])}catch(ie){var te=ie}Reflect.construct(n,[],he)}else{try{he.call()}catch(ie){te=ie}n.call(he.prototype)}}else{try{throw Error()}catch(ie){te=ie}(he=n())&&typeof he.catch=="function"&&he.catch(function(){})}}catch(ie){if(ie&&te&&typeof ie.stack=="string")return[ie.stack,te.stack]}return[null,null]}};p.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var v=Object.getOwnPropertyDescriptor(p.DetermineComponentFrameRoot,"name");v&&v.configurable&&Object.defineProperty(p.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var y=p.DetermineComponentFrameRoot(),A=y[0],N=y[1];if(A&&N){var V=A.split(`
`),Q=N.split(`
`);for(v=p=0;p<V.length&&!V[p].includes("DetermineComponentFrameRoot");)p++;for(;v<Q.length&&!Q[v].includes("DetermineComponentFrameRoot");)v++;if(p===V.length||v===Q.length)for(p=V.length-1,v=Q.length-1;1<=p&&0<=v&&V[p]!==Q[v];)v--;for(;1<=p&&0<=v;p--,v--)if(V[p]!==Q[v]){if(p!==1||v!==1)do if(p--,v--,0>v||V[p]!==Q[v]){var oe=`
`+V[p].replace(" at new "," at ");return n.displayName&&oe.includes("<anonymous>")&&(oe=oe.replace("<anonymous>",n.displayName)),oe}while(1<=p&&0<=v);break}}}finally{$r=!1,Error.prepareStackTrace=d}return(d=n?n.displayName||n.name:"")?ms(d):""}function Bv(n,l){switch(n.tag){case 26:case 27:case 5:return ms(n.type);case 16:return ms("Lazy");case 13:return n.child!==l&&l!==null?ms("Suspense Fallback"):ms("Suspense");case 19:return ms("SuspenseList");case 0:case 15:return vo(n.type,!1);case 11:return vo(n.type.render,!1);case 1:return vo(n.type,!0);case 31:return ms("Activity");default:return""}}function ve(n){try{var l="",d=null;do l+=Bv(n,d),d=n,n=n.return;while(n);return l}catch(p){return`
Error generating stack: `+p.message+`
`+p.stack}}var kl=Object.prototype.hasOwnProperty,ln=c.unstable_scheduleCallback,So=c.unstable_cancelCallback,au=c.unstable_shouldYield,am=c.unstable_requestPaint,Wt=c.unstable_now,Tr=c.unstable_getCurrentPriorityLevel,tt=c.unstable_ImmediatePriority,yo=c.unstable_UserBlockingPriority,Kr=c.unstable_NormalPriority,nu=c.unstable_LowPriority,nm=c.unstable_IdlePriority,om=c.log,lm=c.unstable_setDisableYieldValue,ou=null,ri=null;function cn(n){if(typeof om=="function"&&lm(n),ri&&typeof ri.setStrictMode=="function")try{ri.setStrictMode(ou,n)}catch{}}var ai=Math.clz32?Math.clz32:HI,VI=Math.log,GI=Math.LN2;function HI(n){return n>>>=0,n===0?32:31-(VI(n)/GI|0)|0}var cm=256,hm=262144,um=4194304;function xo(n){var l=n&42;if(l!==0)return l;switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return n&261888;case 262144:case 524288:case 1048576:case 2097152:return n&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return n&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return n}}function dm(n,l,d){var p=n.pendingLanes;if(p===0)return 0;var v=0,y=n.suspendedLanes,A=n.pingedLanes;n=n.warmLanes;var N=p&134217727;return N!==0?(p=N&~y,p!==0?v=xo(p):(A&=N,A!==0?v=xo(A):d||(d=N&~n,d!==0&&(v=xo(d))))):(N=p&~y,N!==0?v=xo(N):A!==0?v=xo(A):d||(d=p&~n,d!==0&&(v=xo(d)))),v===0?0:l!==0&&l!==v&&(l&y)===0&&(y=v&-v,d=l&-l,y>=d||y===32&&(d&4194048)!==0)?l:v}function lu(n,l){return(n.pendingLanes&~(n.suspendedLanes&~n.pingedLanes)&l)===0}function WI(n,l){switch(n){case 1:case 2:case 4:case 8:case 64:return l+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return l+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function bb(){var n=um;return um<<=1,(um&62914560)===0&&(um=4194304),n}function Uv(n){for(var l=[],d=0;31>d;d++)l.push(n);return l}function cu(n,l){n.pendingLanes|=l,l!==268435456&&(n.suspendedLanes=0,n.pingedLanes=0,n.warmLanes=0)}function XI(n,l,d,p,v,y){var A=n.pendingLanes;n.pendingLanes=d,n.suspendedLanes=0,n.pingedLanes=0,n.warmLanes=0,n.expiredLanes&=d,n.entangledLanes&=d,n.errorRecoveryDisabledLanes&=d,n.shellSuspendCounter=0;var N=n.entanglements,V=n.expirationTimes,Q=n.hiddenUpdates;for(d=A&~d;0<d;){var oe=31-ai(d),he=1<<oe;N[oe]=0,V[oe]=-1;var te=Q[oe];if(te!==null)for(Q[oe]=null,oe=0;oe<te.length;oe++){var ie=te[oe];ie!==null&&(ie.lane&=-536870913)}d&=~he}p!==0&&Ab(n,p,0),y!==0&&v===0&&n.tag!==0&&(n.suspendedLanes|=y&~(A&~l))}function Ab(n,l,d){n.pendingLanes|=l,n.suspendedLanes&=~l;var p=31-ai(l);n.entangledLanes|=l,n.entanglements[p]=n.entanglements[p]|1073741824|d&261930}function wb(n,l){var d=n.entangledLanes|=l;for(n=n.entanglements;d;){var p=31-ai(d),v=1<<p;v&l|n[p]&l&&(n[p]|=l),d&=~v}}function Cb(n,l){var d=l&-l;return d=(d&42)!==0?1:zv(d),(d&(n.suspendedLanes|l))!==0?0:d}function zv(n){switch(n){case 2:n=1;break;case 8:n=4;break;case 32:n=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:n=128;break;case 268435456:n=134217728;break;default:n=0}return n}function kv(n){return n&=-n,2<n?8<n?(n&134217727)!==0?32:268435456:8:2}function Db(){var n=O.p;return n!==0?n:(n=window.event,n===void 0?32:f1(n.type))}function Pb(n,l){var d=O.p;try{return O.p=n,l()}finally{O.p=d}}var hn=Math.random().toString(36).slice(2),ys="__reactFiber$"+hn,Vs="__reactProps$"+hn,Vl="__reactContainer$"+hn,Vv="__reactEvents$"+hn,qI="__reactListeners$"+hn,YI="__reactHandles$"+hn,Rb="__reactResources$"+hn,hu="__reactMarker$"+hn;function Gv(n){delete n[ys],delete n[Vs],delete n[Vv],delete n[qI],delete n[YI]}function Gl(n){var l=n[ys];if(l)return l;for(var d=n.parentNode;d;){if(l=d[Vl]||d[ys]){if(d=l.alternate,l.child!==null||d!==null&&d.child!==null)for(n=ZC(n);n!==null;){if(d=n[ys])return d;n=ZC(n)}return l}n=d,d=n.parentNode}return null}function Hl(n){if(n=n[ys]||n[Vl]){var l=n.tag;if(l===5||l===6||l===13||l===31||l===26||l===27||l===3)return n}return null}function uu(n){var l=n.tag;if(l===5||l===26||l===27||l===6)return n.stateNode;throw Error(s(33))}function Wl(n){var l=n[Rb];return l||(l=n[Rb]={hoistableStyles:new Map,hoistableScripts:new Map}),l}function ps(n){n[hu]=!0}var Mb=new Set,Lb={};function To(n,l){Xl(n,l),Xl(n+"Capture",l)}function Xl(n,l){for(Lb[n]=l,n=0;n<l.length;n++)Mb.add(l[n])}var jI=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Ib={},Ob={};function $I(n){return kl.call(Ob,n)?!0:kl.call(Ib,n)?!1:jI.test(n)?Ob[n]=!0:(Ib[n]=!0,!1)}function fm(n,l,d){if($I(l))if(d===null)n.removeAttribute(l);else{switch(typeof d){case"undefined":case"function":case"symbol":n.removeAttribute(l);return;case"boolean":var p=l.toLowerCase().slice(0,5);if(p!=="data-"&&p!=="aria-"){n.removeAttribute(l);return}}n.setAttribute(l,""+d)}}function mm(n,l,d){if(d===null)n.removeAttribute(l);else{switch(typeof d){case"undefined":case"function":case"symbol":case"boolean":n.removeAttribute(l);return}n.setAttribute(l,""+d)}}function Zr(n,l,d,p){if(p===null)n.removeAttribute(d);else{switch(typeof p){case"undefined":case"function":case"symbol":case"boolean":n.removeAttribute(d);return}n.setAttributeNS(l,d,""+p)}}function Ai(n){switch(typeof n){case"bigint":case"boolean":case"number":case"string":case"undefined":return n;case"object":return n;default:return""}}function Nb(n){var l=n.type;return(n=n.nodeName)&&n.toLowerCase()==="input"&&(l==="checkbox"||l==="radio")}function KI(n,l,d){var p=Object.getOwnPropertyDescriptor(n.constructor.prototype,l);if(!n.hasOwnProperty(l)&&typeof p<"u"&&typeof p.get=="function"&&typeof p.set=="function"){var v=p.get,y=p.set;return Object.defineProperty(n,l,{configurable:!0,get:function(){return v.call(this)},set:function(A){d=""+A,y.call(this,A)}}),Object.defineProperty(n,l,{enumerable:p.enumerable}),{getValue:function(){return d},setValue:function(A){d=""+A},stopTracking:function(){n._valueTracker=null,delete n[l]}}}}function Hv(n){if(!n._valueTracker){var l=Nb(n)?"checked":"value";n._valueTracker=KI(n,l,""+n[l])}}function Fb(n){if(!n)return!1;var l=n._valueTracker;if(!l)return!0;var d=l.getValue(),p="";return n&&(p=Nb(n)?n.checked?"true":"false":n.value),n=p,n!==d?(l.setValue(n),!0):!1}function pm(n){if(n=n||(typeof document<"u"?document:void 0),typeof n>"u")return null;try{return n.activeElement||n.body}catch{return n.body}}var ZI=/[\n"\\]/g;function wi(n){return n.replace(ZI,function(l){return"\\"+l.charCodeAt(0).toString(16)+" "})}function Wv(n,l,d,p,v,y,A,N){n.name="",A!=null&&typeof A!="function"&&typeof A!="symbol"&&typeof A!="boolean"?n.type=A:n.removeAttribute("type"),l!=null?A==="number"?(l===0&&n.value===""||n.value!=l)&&(n.value=""+Ai(l)):n.value!==""+Ai(l)&&(n.value=""+Ai(l)):A!=="submit"&&A!=="reset"||n.removeAttribute("value"),l!=null?Xv(n,A,Ai(l)):d!=null?Xv(n,A,Ai(d)):p!=null&&n.removeAttribute("value"),v==null&&y!=null&&(n.defaultChecked=!!y),v!=null&&(n.checked=v&&typeof v!="function"&&typeof v!="symbol"),N!=null&&typeof N!="function"&&typeof N!="symbol"&&typeof N!="boolean"?n.name=""+Ai(N):n.removeAttribute("name")}function Bb(n,l,d,p,v,y,A,N){if(y!=null&&typeof y!="function"&&typeof y!="symbol"&&typeof y!="boolean"&&(n.type=y),l!=null||d!=null){if(!(y!=="submit"&&y!=="reset"||l!=null)){Hv(n);return}d=d!=null?""+Ai(d):"",l=l!=null?""+Ai(l):d,N||l===n.value||(n.value=l),n.defaultValue=l}p=p??v,p=typeof p!="function"&&typeof p!="symbol"&&!!p,n.checked=N?n.checked:!!p,n.defaultChecked=!!p,A!=null&&typeof A!="function"&&typeof A!="symbol"&&typeof A!="boolean"&&(n.name=A),Hv(n)}function Xv(n,l,d){l==="number"&&pm(n.ownerDocument)===n||n.defaultValue===""+d||(n.defaultValue=""+d)}function ql(n,l,d,p){if(n=n.options,l){l={};for(var v=0;v<d.length;v++)l["$"+d[v]]=!0;for(d=0;d<n.length;d++)v=l.hasOwnProperty("$"+n[d].value),n[d].selected!==v&&(n[d].selected=v),v&&p&&(n[d].defaultSelected=!0)}else{for(d=""+Ai(d),l=null,v=0;v<n.length;v++){if(n[v].value===d){n[v].selected=!0,p&&(n[v].defaultSelected=!0);return}l!==null||n[v].disabled||(l=n[v])}l!==null&&(l.selected=!0)}}function Ub(n,l,d){if(l!=null&&(l=""+Ai(l),l!==n.value&&(n.value=l),d==null)){n.defaultValue!==l&&(n.defaultValue=l);return}n.defaultValue=d!=null?""+Ai(d):""}function zb(n,l,d,p){if(l==null){if(p!=null){if(d!=null)throw Error(s(92));if(ae(p)){if(1<p.length)throw Error(s(93));p=p[0]}d=p}d==null&&(d=""),l=d}d=Ai(l),n.defaultValue=d,p=n.textContent,p===d&&p!==""&&p!==null&&(n.value=p),Hv(n)}function Yl(n,l){if(l){var d=n.firstChild;if(d&&d===n.lastChild&&d.nodeType===3){d.nodeValue=l;return}}n.textContent=l}var QI=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function kb(n,l,d){var p=l.indexOf("--")===0;d==null||typeof d=="boolean"||d===""?p?n.setProperty(l,""):l==="float"?n.cssFloat="":n[l]="":p?n.setProperty(l,d):typeof d!="number"||d===0||QI.has(l)?l==="float"?n.cssFloat=d:n[l]=(""+d).trim():n[l]=d+"px"}function Vb(n,l,d){if(l!=null&&typeof l!="object")throw Error(s(62));if(n=n.style,d!=null){for(var p in d)!d.hasOwnProperty(p)||l!=null&&l.hasOwnProperty(p)||(p.indexOf("--")===0?n.setProperty(p,""):p==="float"?n.cssFloat="":n[p]="");for(var v in l)p=l[v],l.hasOwnProperty(v)&&d[v]!==p&&kb(n,v,p)}else for(var y in l)l.hasOwnProperty(y)&&kb(n,y,l[y])}function qv(n){if(n.indexOf("-")===-1)return!1;switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var JI=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),e3=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function _m(n){return e3.test(""+n)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":n}function Qr(){}var Yv=null;function jv(n){return n=n.target||n.srcElement||window,n.correspondingUseElement&&(n=n.correspondingUseElement),n.nodeType===3?n.parentNode:n}var jl=null,$l=null;function Gb(n){var l=Hl(n);if(l&&(n=l.stateNode)){var d=n[Vs]||null;e:switch(n=l.stateNode,l.type){case"input":if(Wv(n,d.value,d.defaultValue,d.defaultValue,d.checked,d.defaultChecked,d.type,d.name),l=d.name,d.type==="radio"&&l!=null){for(d=n;d.parentNode;)d=d.parentNode;for(d=d.querySelectorAll('input[name="'+wi(""+l)+'"][type="radio"]'),l=0;l<d.length;l++){var p=d[l];if(p!==n&&p.form===n.form){var v=p[Vs]||null;if(!v)throw Error(s(90));Wv(p,v.value,v.defaultValue,v.defaultValue,v.checked,v.defaultChecked,v.type,v.name)}}for(l=0;l<d.length;l++)p=d[l],p.form===n.form&&Fb(p)}break e;case"textarea":Ub(n,d.value,d.defaultValue);break e;case"select":l=d.value,l!=null&&ql(n,!!d.multiple,l,!1)}}}var $v=!1;function Hb(n,l,d){if($v)return n(l,d);$v=!0;try{var p=n(l);return p}finally{if($v=!1,(jl!==null||$l!==null)&&(ip(),jl&&(l=jl,n=$l,$l=jl=null,Gb(l),n)))for(l=0;l<n.length;l++)Gb(n[l])}}function du(n,l){var d=n.stateNode;if(d===null)return null;var p=d[Vs]||null;if(p===null)return null;d=p[l];e:switch(l){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(p=!p.disabled)||(n=n.type,p=!(n==="button"||n==="input"||n==="select"||n==="textarea")),n=!p;break e;default:n=!1}if(n)return null;if(d&&typeof d!="function")throw Error(s(231,l,typeof d));return d}var Jr=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Kv=!1;if(Jr)try{var fu={};Object.defineProperty(fu,"passive",{get:function(){Kv=!0}}),window.addEventListener("test",fu,fu),window.removeEventListener("test",fu,fu)}catch{Kv=!1}var un=null,Zv=null,gm=null;function Wb(){if(gm)return gm;var n,l=Zv,d=l.length,p,v="value"in un?un.value:un.textContent,y=v.length;for(n=0;n<d&&l[n]===v[n];n++);var A=d-n;for(p=1;p<=A&&l[d-p]===v[y-p];p++);return gm=v.slice(n,1<p?1-p:void 0)}function vm(n){var l=n.keyCode;return"charCode"in n?(n=n.charCode,n===0&&l===13&&(n=13)):n=l,n===10&&(n=13),32<=n||n===13?n:0}function Sm(){return!0}function Xb(){return!1}function Gs(n){function l(d,p,v,y,A){this._reactName=d,this._targetInst=v,this.type=p,this.nativeEvent=y,this.target=A,this.currentTarget=null;for(var N in n)n.hasOwnProperty(N)&&(d=n[N],this[N]=d?d(y):y[N]);return this.isDefaultPrevented=(y.defaultPrevented!=null?y.defaultPrevented:y.returnValue===!1)?Sm:Xb,this.isPropagationStopped=Xb,this}return m(l.prototype,{preventDefault:function(){this.defaultPrevented=!0;var d=this.nativeEvent;d&&(d.preventDefault?d.preventDefault():typeof d.returnValue!="unknown"&&(d.returnValue=!1),this.isDefaultPrevented=Sm)},stopPropagation:function(){var d=this.nativeEvent;d&&(d.stopPropagation?d.stopPropagation():typeof d.cancelBubble!="unknown"&&(d.cancelBubble=!0),this.isPropagationStopped=Sm)},persist:function(){},isPersistent:Sm}),l}var Eo={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ym=Gs(Eo),mu=m({},Eo,{view:0,detail:0}),t3=Gs(mu),Qv,Jv,pu,xm=m({},mu,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:tS,button:0,buttons:0,relatedTarget:function(n){return n.relatedTarget===void 0?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==pu&&(pu&&n.type==="mousemove"?(Qv=n.screenX-pu.screenX,Jv=n.screenY-pu.screenY):Jv=Qv=0,pu=n),Qv)},movementY:function(n){return"movementY"in n?n.movementY:Jv}}),qb=Gs(xm),s3=m({},xm,{dataTransfer:0}),i3=Gs(s3),r3=m({},mu,{relatedTarget:0}),eS=Gs(r3),a3=m({},Eo,{animationName:0,elapsedTime:0,pseudoElement:0}),n3=Gs(a3),o3=m({},Eo,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),l3=Gs(o3),c3=m({},Eo,{data:0}),Yb=Gs(c3),h3={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},u3={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},d3={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function f3(n){var l=this.nativeEvent;return l.getModifierState?l.getModifierState(n):(n=d3[n])?!!l[n]:!1}function tS(){return f3}var m3=m({},mu,{key:function(n){if(n.key){var l=h3[n.key]||n.key;if(l!=="Unidentified")return l}return n.type==="keypress"?(n=vm(n),n===13?"Enter":String.fromCharCode(n)):n.type==="keydown"||n.type==="keyup"?u3[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:tS,charCode:function(n){return n.type==="keypress"?vm(n):0},keyCode:function(n){return n.type==="keydown"||n.type==="keyup"?n.keyCode:0},which:function(n){return n.type==="keypress"?vm(n):n.type==="keydown"||n.type==="keyup"?n.keyCode:0}}),p3=Gs(m3),_3=m({},xm,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),jb=Gs(_3),g3=m({},mu,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:tS}),v3=Gs(g3),S3=m({},Eo,{propertyName:0,elapsedTime:0,pseudoElement:0}),y3=Gs(S3),x3=m({},xm,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),T3=Gs(x3),E3=m({},Eo,{newState:0,oldState:0}),b3=Gs(E3),A3=[9,13,27,32],sS=Jr&&"CompositionEvent"in window,_u=null;Jr&&"documentMode"in document&&(_u=document.documentMode);var w3=Jr&&"TextEvent"in window&&!_u,$b=Jr&&(!sS||_u&&8<_u&&11>=_u),Kb=" ",Zb=!1;function Qb(n,l){switch(n){case"keyup":return A3.indexOf(l.keyCode)!==-1;case"keydown":return l.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Jb(n){return n=n.detail,typeof n=="object"&&"data"in n?n.data:null}var Kl=!1;function C3(n,l){switch(n){case"compositionend":return Jb(l);case"keypress":return l.which!==32?null:(Zb=!0,Kb);case"textInput":return n=l.data,n===Kb&&Zb?null:n;default:return null}}function D3(n,l){if(Kl)return n==="compositionend"||!sS&&Qb(n,l)?(n=Wb(),gm=Zv=un=null,Kl=!1,n):null;switch(n){case"paste":return null;case"keypress":if(!(l.ctrlKey||l.altKey||l.metaKey)||l.ctrlKey&&l.altKey){if(l.char&&1<l.char.length)return l.char;if(l.which)return String.fromCharCode(l.which)}return null;case"compositionend":return $b&&l.locale!=="ko"?null:l.data;default:return null}}var P3={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function eA(n){var l=n&&n.nodeName&&n.nodeName.toLowerCase();return l==="input"?!!P3[n.type]:l==="textarea"}function tA(n,l,d,p){jl?$l?$l.push(p):$l=[p]:jl=p,l=hp(l,"onChange"),0<l.length&&(d=new ym("onChange","change",null,d,p),n.push({event:d,listeners:l}))}var gu=null,vu=null;function R3(n){BC(n,0)}function Tm(n){var l=uu(n);if(Fb(l))return n}function sA(n,l){if(n==="change")return l}var iA=!1;if(Jr){var iS;if(Jr){var rS="oninput"in document;if(!rS){var rA=document.createElement("div");rA.setAttribute("oninput","return;"),rS=typeof rA.oninput=="function"}iS=rS}else iS=!1;iA=iS&&(!document.documentMode||9<document.documentMode)}function aA(){gu&&(gu.detachEvent("onpropertychange",nA),vu=gu=null)}function nA(n){if(n.propertyName==="value"&&Tm(vu)){var l=[];tA(l,vu,n,jv(n)),Hb(R3,l)}}function M3(n,l,d){n==="focusin"?(aA(),gu=l,vu=d,gu.attachEvent("onpropertychange",nA)):n==="focusout"&&aA()}function L3(n){if(n==="selectionchange"||n==="keyup"||n==="keydown")return Tm(vu)}function I3(n,l){if(n==="click")return Tm(l)}function O3(n,l){if(n==="input"||n==="change")return Tm(l)}function N3(n,l){return n===l&&(n!==0||1/n===1/l)||n!==n&&l!==l}var ni=typeof Object.is=="function"?Object.is:N3;function Su(n,l){if(ni(n,l))return!0;if(typeof n!="object"||n===null||typeof l!="object"||l===null)return!1;var d=Object.keys(n),p=Object.keys(l);if(d.length!==p.length)return!1;for(p=0;p<d.length;p++){var v=d[p];if(!kl.call(l,v)||!ni(n[v],l[v]))return!1}return!0}function oA(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function lA(n,l){var d=oA(n);n=0;for(var p;d;){if(d.nodeType===3){if(p=n+d.textContent.length,n<=l&&p>=l)return{node:d,offset:l-n};n=p}e:{for(;d;){if(d.nextSibling){d=d.nextSibling;break e}d=d.parentNode}d=void 0}d=oA(d)}}function cA(n,l){return n&&l?n===l?!0:n&&n.nodeType===3?!1:l&&l.nodeType===3?cA(n,l.parentNode):"contains"in n?n.contains(l):n.compareDocumentPosition?!!(n.compareDocumentPosition(l)&16):!1:!1}function hA(n){n=n!=null&&n.ownerDocument!=null&&n.ownerDocument.defaultView!=null?n.ownerDocument.defaultView:window;for(var l=pm(n.document);l instanceof n.HTMLIFrameElement;){try{var d=typeof l.contentWindow.location.href=="string"}catch{d=!1}if(d)n=l.contentWindow;else break;l=pm(n.document)}return l}function aS(n){var l=n&&n.nodeName&&n.nodeName.toLowerCase();return l&&(l==="input"&&(n.type==="text"||n.type==="search"||n.type==="tel"||n.type==="url"||n.type==="password")||l==="textarea"||n.contentEditable==="true")}var F3=Jr&&"documentMode"in document&&11>=document.documentMode,Zl=null,nS=null,yu=null,oS=!1;function uA(n,l,d){var p=d.window===d?d.document:d.nodeType===9?d:d.ownerDocument;oS||Zl==null||Zl!==pm(p)||(p=Zl,"selectionStart"in p&&aS(p)?p={start:p.selectionStart,end:p.selectionEnd}:(p=(p.ownerDocument&&p.ownerDocument.defaultView||window).getSelection(),p={anchorNode:p.anchorNode,anchorOffset:p.anchorOffset,focusNode:p.focusNode,focusOffset:p.focusOffset}),yu&&Su(yu,p)||(yu=p,p=hp(nS,"onSelect"),0<p.length&&(l=new ym("onSelect","select",null,l,d),n.push({event:l,listeners:p}),l.target=Zl)))}function bo(n,l){var d={};return d[n.toLowerCase()]=l.toLowerCase(),d["Webkit"+n]="webkit"+l,d["Moz"+n]="moz"+l,d}var Ql={animationend:bo("Animation","AnimationEnd"),animationiteration:bo("Animation","AnimationIteration"),animationstart:bo("Animation","AnimationStart"),transitionrun:bo("Transition","TransitionRun"),transitionstart:bo("Transition","TransitionStart"),transitioncancel:bo("Transition","TransitionCancel"),transitionend:bo("Transition","TransitionEnd")},lS={},dA={};Jr&&(dA=document.createElement("div").style,"AnimationEvent"in window||(delete Ql.animationend.animation,delete Ql.animationiteration.animation,delete Ql.animationstart.animation),"TransitionEvent"in window||delete Ql.transitionend.transition);function Ao(n){if(lS[n])return lS[n];if(!Ql[n])return n;var l=Ql[n],d;for(d in l)if(l.hasOwnProperty(d)&&d in dA)return lS[n]=l[d];return n}var fA=Ao("animationend"),mA=Ao("animationiteration"),pA=Ao("animationstart"),B3=Ao("transitionrun"),U3=Ao("transitionstart"),z3=Ao("transitioncancel"),_A=Ao("transitionend"),gA=new Map,cS="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");cS.push("scrollEnd");function Ji(n,l){gA.set(n,l),To(l,[n])}var Em=typeof reportError=="function"?reportError:function(n){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var l=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof n=="object"&&n!==null&&typeof n.message=="string"?String(n.message):String(n),error:n});if(!window.dispatchEvent(l))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",n);return}console.error(n)},Ci=[],Jl=0,hS=0;function bm(){for(var n=Jl,l=hS=Jl=0;l<n;){var d=Ci[l];Ci[l++]=null;var p=Ci[l];Ci[l++]=null;var v=Ci[l];Ci[l++]=null;var y=Ci[l];if(Ci[l++]=null,p!==null&&v!==null){var A=p.pending;A===null?v.next=v:(v.next=A.next,A.next=v),p.pending=v}y!==0&&vA(d,v,y)}}function Am(n,l,d,p){Ci[Jl++]=n,Ci[Jl++]=l,Ci[Jl++]=d,Ci[Jl++]=p,hS|=p,n.lanes|=p,n=n.alternate,n!==null&&(n.lanes|=p)}function uS(n,l,d,p){return Am(n,l,d,p),wm(n)}function wo(n,l){return Am(n,null,null,l),wm(n)}function vA(n,l,d){n.lanes|=d;var p=n.alternate;p!==null&&(p.lanes|=d);for(var v=!1,y=n.return;y!==null;)y.childLanes|=d,p=y.alternate,p!==null&&(p.childLanes|=d),y.tag===22&&(n=y.stateNode,n===null||n._visibility&1||(v=!0)),n=y,y=y.return;return n.tag===3?(y=n.stateNode,v&&l!==null&&(v=31-ai(d),n=y.hiddenUpdates,p=n[v],p===null?n[v]=[l]:p.push(l),l.lane=d|536870912),y):null}function wm(n){if(50<Gu)throw Gu=0,yy=null,Error(s(185));for(var l=n.return;l!==null;)n=l,l=n.return;return n.tag===3?n.stateNode:null}var ec={};function k3(n,l,d,p){this.tag=n,this.key=d,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=l,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=p,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function oi(n,l,d,p){return new k3(n,l,d,p)}function dS(n){return n=n.prototype,!(!n||!n.isReactComponent)}function ea(n,l){var d=n.alternate;return d===null?(d=oi(n.tag,l,n.key,n.mode),d.elementType=n.elementType,d.type=n.type,d.stateNode=n.stateNode,d.alternate=n,n.alternate=d):(d.pendingProps=l,d.type=n.type,d.flags=0,d.subtreeFlags=0,d.deletions=null),d.flags=n.flags&65011712,d.childLanes=n.childLanes,d.lanes=n.lanes,d.child=n.child,d.memoizedProps=n.memoizedProps,d.memoizedState=n.memoizedState,d.updateQueue=n.updateQueue,l=n.dependencies,d.dependencies=l===null?null:{lanes:l.lanes,firstContext:l.firstContext},d.sibling=n.sibling,d.index=n.index,d.ref=n.ref,d.refCleanup=n.refCleanup,d}function SA(n,l){n.flags&=65011714;var d=n.alternate;return d===null?(n.childLanes=0,n.lanes=l,n.child=null,n.subtreeFlags=0,n.memoizedProps=null,n.memoizedState=null,n.updateQueue=null,n.dependencies=null,n.stateNode=null):(n.childLanes=d.childLanes,n.lanes=d.lanes,n.child=d.child,n.subtreeFlags=0,n.deletions=null,n.memoizedProps=d.memoizedProps,n.memoizedState=d.memoizedState,n.updateQueue=d.updateQueue,n.type=d.type,l=d.dependencies,n.dependencies=l===null?null:{lanes:l.lanes,firstContext:l.firstContext}),n}function Cm(n,l,d,p,v,y){var A=0;if(p=n,typeof n=="function")dS(n)&&(A=1);else if(typeof n=="string")A=XO(n,d,se.current)?26:n==="html"||n==="head"||n==="body"?27:5;else e:switch(n){case L:return n=oi(31,d,l,v),n.elementType=L,n.lanes=y,n;case x:return Co(d.children,v,y,l);case T:A=8,v|=24;break;case E:return n=oi(12,d,l,v|2),n.elementType=E,n.lanes=y,n;case P:return n=oi(13,d,l,v),n.elementType=P,n.lanes=y,n;case I:return n=oi(19,d,l,v),n.elementType=I,n.lanes=y,n;default:if(typeof n=="object"&&n!==null)switch(n.$$typeof){case C:A=10;break e;case b:A=9;break e;case w:A=11;break e;case M:A=14;break e;case R:A=16,p=null;break e}A=29,d=Error(s(130,n===null?"null":typeof n,"")),p=null}return l=oi(A,d,l,v),l.elementType=n,l.type=p,l.lanes=y,l}function Co(n,l,d,p){return n=oi(7,n,p,l),n.lanes=d,n}function fS(n,l,d){return n=oi(6,n,null,l),n.lanes=d,n}function yA(n){var l=oi(18,null,null,0);return l.stateNode=n,l}function mS(n,l,d){return l=oi(4,n.children!==null?n.children:[],n.key,l),l.lanes=d,l.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},l}var xA=new WeakMap;function Di(n,l){if(typeof n=="object"&&n!==null){var d=xA.get(n);return d!==void 0?d:(l={value:n,source:l,stack:ve(l)},xA.set(n,l),l)}return{value:n,source:l,stack:ve(l)}}var tc=[],sc=0,Dm=null,xu=0,Pi=[],Ri=0,dn=null,Er=1,br="";function ta(n,l){tc[sc++]=xu,tc[sc++]=Dm,Dm=n,xu=l}function TA(n,l,d){Pi[Ri++]=Er,Pi[Ri++]=br,Pi[Ri++]=dn,dn=n;var p=Er;n=br;var v=32-ai(p)-1;p&=~(1<<v),d+=1;var y=32-ai(l)+v;if(30<y){var A=v-v%5;y=(p&(1<<A)-1).toString(32),p>>=A,v-=A,Er=1<<32-ai(l)+v|d<<v|p,br=y+n}else Er=1<<y|d<<v|p,br=n}function pS(n){n.return!==null&&(ta(n,1),TA(n,1,0))}function _S(n){for(;n===Dm;)Dm=tc[--sc],tc[sc]=null,xu=tc[--sc],tc[sc]=null;for(;n===dn;)dn=Pi[--Ri],Pi[Ri]=null,br=Pi[--Ri],Pi[Ri]=null,Er=Pi[--Ri],Pi[Ri]=null}function EA(n,l){Pi[Ri++]=Er,Pi[Ri++]=br,Pi[Ri++]=dn,Er=l.id,br=l.overflow,dn=n}var xs=null,Mt=null,Ke=!1,fn=null,Mi=!1,gS=Error(s(519));function mn(n){var l=Error(s(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Tu(Di(l,n)),gS}function bA(n){var l=n.stateNode,d=n.type,p=n.memoizedProps;switch(l[ys]=n,l[Vs]=p,d){case"dialog":qe("cancel",l),qe("close",l);break;case"iframe":case"object":case"embed":qe("load",l);break;case"video":case"audio":for(d=0;d<Wu.length;d++)qe(Wu[d],l);break;case"source":qe("error",l);break;case"img":case"image":case"link":qe("error",l),qe("load",l);break;case"details":qe("toggle",l);break;case"input":qe("invalid",l),Bb(l,p.value,p.defaultValue,p.checked,p.defaultChecked,p.type,p.name,!0);break;case"select":qe("invalid",l);break;case"textarea":qe("invalid",l),zb(l,p.value,p.defaultValue,p.children)}d=p.children,typeof d!="string"&&typeof d!="number"&&typeof d!="bigint"||l.textContent===""+d||p.suppressHydrationWarning===!0||VC(l.textContent,d)?(p.popover!=null&&(qe("beforetoggle",l),qe("toggle",l)),p.onScroll!=null&&qe("scroll",l),p.onScrollEnd!=null&&qe("scrollend",l),p.onClick!=null&&(l.onclick=Qr),l=!0):l=!1,l||mn(n,!0)}function AA(n){for(xs=n.return;xs;)switch(xs.tag){case 5:case 31:case 13:Mi=!1;return;case 27:case 3:Mi=!0;return;default:xs=xs.return}}function ic(n){if(n!==xs)return!1;if(!Ke)return AA(n),Ke=!0,!1;var l=n.tag,d;if((d=l!==3&&l!==27)&&((d=l===5)&&(d=n.type,d=!(d!=="form"&&d!=="button")||Ny(n.type,n.memoizedProps)),d=!d),d&&Mt&&mn(n),AA(n),l===13){if(n=n.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(s(317));Mt=KC(n)}else if(l===31){if(n=n.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(s(317));Mt=KC(n)}else l===27?(l=Mt,Dn(n.type)?(n=ky,ky=null,Mt=n):Mt=l):Mt=xs?Ii(n.stateNode.nextSibling):null;return!0}function Do(){Mt=xs=null,Ke=!1}function vS(){var n=fn;return n!==null&&(qs===null?qs=n:qs.push.apply(qs,n),fn=null),n}function Tu(n){fn===null?fn=[n]:fn.push(n)}var SS=F(null),Po=null,sa=null;function pn(n,l,d){K(SS,l._currentValue),l._currentValue=d}function ia(n){n._currentValue=SS.current,U(SS)}function yS(n,l,d){for(;n!==null;){var p=n.alternate;if((n.childLanes&l)!==l?(n.childLanes|=l,p!==null&&(p.childLanes|=l)):p!==null&&(p.childLanes&l)!==l&&(p.childLanes|=l),n===d)break;n=n.return}}function xS(n,l,d,p){var v=n.child;for(v!==null&&(v.return=n);v!==null;){var y=v.dependencies;if(y!==null){var A=v.child;y=y.firstContext;e:for(;y!==null;){var N=y;y=v;for(var V=0;V<l.length;V++)if(N.context===l[V]){y.lanes|=d,N=y.alternate,N!==null&&(N.lanes|=d),yS(y.return,d,n),p||(A=null);break e}y=N.next}}else if(v.tag===18){if(A=v.return,A===null)throw Error(s(341));A.lanes|=d,y=A.alternate,y!==null&&(y.lanes|=d),yS(A,d,n),A=null}else A=v.child;if(A!==null)A.return=v;else for(A=v;A!==null;){if(A===n){A=null;break}if(v=A.sibling,v!==null){v.return=A.return,A=v;break}A=A.return}v=A}}function rc(n,l,d,p){n=null;for(var v=l,y=!1;v!==null;){if(!y){if((v.flags&524288)!==0)y=!0;else if((v.flags&262144)!==0)break}if(v.tag===10){var A=v.alternate;if(A===null)throw Error(s(387));if(A=A.memoizedProps,A!==null){var N=v.type;ni(v.pendingProps.value,A.value)||(n!==null?n.push(N):n=[N])}}else if(v===de.current){if(A=v.alternate,A===null)throw Error(s(387));A.memoizedState.memoizedState!==v.memoizedState.memoizedState&&(n!==null?n.push($u):n=[$u])}v=v.return}n!==null&&xS(l,n,d,p),l.flags|=262144}function Pm(n){for(n=n.firstContext;n!==null;){if(!ni(n.context._currentValue,n.memoizedValue))return!0;n=n.next}return!1}function Ro(n){Po=n,sa=null,n=n.dependencies,n!==null&&(n.firstContext=null)}function Ts(n){return wA(Po,n)}function Rm(n,l){return Po===null&&Ro(n),wA(n,l)}function wA(n,l){var d=l._currentValue;if(l={context:l,memoizedValue:d,next:null},sa===null){if(n===null)throw Error(s(308));sa=l,n.dependencies={lanes:0,firstContext:l},n.flags|=524288}else sa=sa.next=l;return d}var V3=typeof AbortController<"u"?AbortController:function(){var n=[],l=this.signal={aborted:!1,addEventListener:function(d,p){n.push(p)}};this.abort=function(){l.aborted=!0,n.forEach(function(d){return d()})}},G3=c.unstable_scheduleCallback,H3=c.unstable_NormalPriority,es={$$typeof:C,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function TS(){return{controller:new V3,data:new Map,refCount:0}}function Eu(n){n.refCount--,n.refCount===0&&G3(H3,function(){n.controller.abort()})}var bu=null,ES=0,ac=0,nc=null;function W3(n,l){if(bu===null){var d=bu=[];ES=0,ac=wy(),nc={status:"pending",value:void 0,then:function(p){d.push(p)}}}return ES++,l.then(CA,CA),l}function CA(){if(--ES===0&&bu!==null){nc!==null&&(nc.status="fulfilled");var n=bu;bu=null,ac=0,nc=null;for(var l=0;l<n.length;l++)(0,n[l])()}}function X3(n,l){var d=[],p={status:"pending",value:null,reason:null,then:function(v){d.push(v)}};return n.then(function(){p.status="fulfilled",p.value=l;for(var v=0;v<d.length;v++)(0,d[v])(l)},function(v){for(p.status="rejected",p.reason=v,v=0;v<d.length;v++)(0,d[v])(void 0)}),p}var DA=k.S;k.S=function(n,l){uC=Wt(),typeof l=="object"&&l!==null&&typeof l.then=="function"&&W3(n,l),DA!==null&&DA(n,l)};var Mo=F(null);function bS(){var n=Mo.current;return n!==null?n:St.pooledCache}function Mm(n,l){l===null?K(Mo,Mo.current):K(Mo,l.pool)}function PA(){var n=bS();return n===null?null:{parent:es._currentValue,pool:n}}var oc=Error(s(460)),AS=Error(s(474)),Lm=Error(s(542)),Im={then:function(){}};function RA(n){return n=n.status,n==="fulfilled"||n==="rejected"}function MA(n,l,d){switch(d=n[d],d===void 0?n.push(l):d!==l&&(l.then(Qr,Qr),l=d),l.status){case"fulfilled":return l.value;case"rejected":throw n=l.reason,IA(n),n;default:if(typeof l.status=="string")l.then(Qr,Qr);else{if(n=St,n!==null&&100<n.shellSuspendCounter)throw Error(s(482));n=l,n.status="pending",n.then(function(p){if(l.status==="pending"){var v=l;v.status="fulfilled",v.value=p}},function(p){if(l.status==="pending"){var v=l;v.status="rejected",v.reason=p}})}switch(l.status){case"fulfilled":return l.value;case"rejected":throw n=l.reason,IA(n),n}throw Io=l,oc}}function Lo(n){try{var l=n._init;return l(n._payload)}catch(d){throw d!==null&&typeof d=="object"&&typeof d.then=="function"?(Io=d,oc):d}}var Io=null;function LA(){if(Io===null)throw Error(s(459));var n=Io;return Io=null,n}function IA(n){if(n===oc||n===Lm)throw Error(s(483))}var lc=null,Au=0;function Om(n){var l=Au;return Au+=1,lc===null&&(lc=[]),MA(lc,n,l)}function wu(n,l){l=l.props.ref,n.ref=l!==void 0?l:null}function Nm(n,l){throw l.$$typeof===_?Error(s(525)):(n=Object.prototype.toString.call(l),Error(s(31,n==="[object Object]"?"object with keys {"+Object.keys(l).join(", ")+"}":n)))}function OA(n){function l($,W){if(n){var Z=$.deletions;Z===null?($.deletions=[W],$.flags|=16):Z.push(W)}}function d($,W){if(!n)return null;for(;W!==null;)l($,W),W=W.sibling;return null}function p($){for(var W=new Map;$!==null;)$.key!==null?W.set($.key,$):W.set($.index,$),$=$.sibling;return W}function v($,W){return $=ea($,W),$.index=0,$.sibling=null,$}function y($,W,Z){return $.index=Z,n?(Z=$.alternate,Z!==null?(Z=Z.index,Z<W?($.flags|=67108866,W):Z):($.flags|=67108866,W)):($.flags|=1048576,W)}function A($){return n&&$.alternate===null&&($.flags|=67108866),$}function N($,W,Z,ce){return W===null||W.tag!==6?(W=fS(Z,$.mode,ce),W.return=$,W):(W=v(W,Z),W.return=$,W)}function V($,W,Z,ce){var we=Z.type;return we===x?oe($,W,Z.props.children,ce,Z.key):W!==null&&(W.elementType===we||typeof we=="object"&&we!==null&&we.$$typeof===R&&Lo(we)===W.type)?(W=v(W,Z.props),wu(W,Z),W.return=$,W):(W=Cm(Z.type,Z.key,Z.props,null,$.mode,ce),wu(W,Z),W.return=$,W)}function Q($,W,Z,ce){return W===null||W.tag!==4||W.stateNode.containerInfo!==Z.containerInfo||W.stateNode.implementation!==Z.implementation?(W=mS(Z,$.mode,ce),W.return=$,W):(W=v(W,Z.children||[]),W.return=$,W)}function oe($,W,Z,ce,we){return W===null||W.tag!==7?(W=Co(Z,$.mode,ce,we),W.return=$,W):(W=v(W,Z),W.return=$,W)}function he($,W,Z){if(typeof W=="string"&&W!==""||typeof W=="number"||typeof W=="bigint")return W=fS(""+W,$.mode,Z),W.return=$,W;if(typeof W=="object"&&W!==null){switch(W.$$typeof){case g:return Z=Cm(W.type,W.key,W.props,null,$.mode,Z),wu(Z,W),Z.return=$,Z;case S:return W=mS(W,$.mode,Z),W.return=$,W;case R:return W=Lo(W),he($,W,Z)}if(ae(W)||H(W))return W=Co(W,$.mode,Z,null),W.return=$,W;if(typeof W.then=="function")return he($,Om(W),Z);if(W.$$typeof===C)return he($,Rm($,W),Z);Nm($,W)}return null}function te($,W,Z,ce){var we=W!==null?W.key:null;if(typeof Z=="string"&&Z!==""||typeof Z=="number"||typeof Z=="bigint")return we!==null?null:N($,W,""+Z,ce);if(typeof Z=="object"&&Z!==null){switch(Z.$$typeof){case g:return Z.key===we?V($,W,Z,ce):null;case S:return Z.key===we?Q($,W,Z,ce):null;case R:return Z=Lo(Z),te($,W,Z,ce)}if(ae(Z)||H(Z))return we!==null?null:oe($,W,Z,ce,null);if(typeof Z.then=="function")return te($,W,Om(Z),ce);if(Z.$$typeof===C)return te($,W,Rm($,Z),ce);Nm($,Z)}return null}function ie($,W,Z,ce,we){if(typeof ce=="string"&&ce!==""||typeof ce=="number"||typeof ce=="bigint")return $=$.get(Z)||null,N(W,$,""+ce,we);if(typeof ce=="object"&&ce!==null){switch(ce.$$typeof){case g:return $=$.get(ce.key===null?Z:ce.key)||null,V(W,$,ce,we);case S:return $=$.get(ce.key===null?Z:ce.key)||null,Q(W,$,ce,we);case R:return ce=Lo(ce),ie($,W,Z,ce,we)}if(ae(ce)||H(ce))return $=$.get(Z)||null,oe(W,$,ce,we,null);if(typeof ce.then=="function")return ie($,W,Z,Om(ce),we);if(ce.$$typeof===C)return ie($,W,Z,Rm(W,ce),we);Nm(W,ce)}return null}function Se($,W,Z,ce){for(var we=null,st=null,xe=W,Fe=W=0,je=null;xe!==null&&Fe<Z.length;Fe++){xe.index>Fe?(je=xe,xe=null):je=xe.sibling;var it=te($,xe,Z[Fe],ce);if(it===null){xe===null&&(xe=je);break}n&&xe&&it.alternate===null&&l($,xe),W=y(it,W,Fe),st===null?we=it:st.sibling=it,st=it,xe=je}if(Fe===Z.length)return d($,xe),Ke&&ta($,Fe),we;if(xe===null){for(;Fe<Z.length;Fe++)xe=he($,Z[Fe],ce),xe!==null&&(W=y(xe,W,Fe),st===null?we=xe:st.sibling=xe,st=xe);return Ke&&ta($,Fe),we}for(xe=p(xe);Fe<Z.length;Fe++)je=ie(xe,$,Fe,Z[Fe],ce),je!==null&&(n&&je.alternate!==null&&xe.delete(je.key===null?Fe:je.key),W=y(je,W,Fe),st===null?we=je:st.sibling=je,st=je);return n&&xe.forEach(function(In){return l($,In)}),Ke&&ta($,Fe),we}function Ce($,W,Z,ce){if(Z==null)throw Error(s(151));for(var we=null,st=null,xe=W,Fe=W=0,je=null,it=Z.next();xe!==null&&!it.done;Fe++,it=Z.next()){xe.index>Fe?(je=xe,xe=null):je=xe.sibling;var In=te($,xe,it.value,ce);if(In===null){xe===null&&(xe=je);break}n&&xe&&In.alternate===null&&l($,xe),W=y(In,W,Fe),st===null?we=In:st.sibling=In,st=In,xe=je}if(it.done)return d($,xe),Ke&&ta($,Fe),we;if(xe===null){for(;!it.done;Fe++,it=Z.next())it=he($,it.value,ce),it!==null&&(W=y(it,W,Fe),st===null?we=it:st.sibling=it,st=it);return Ke&&ta($,Fe),we}for(xe=p(xe);!it.done;Fe++,it=Z.next())it=ie(xe,$,Fe,it.value,ce),it!==null&&(n&&it.alternate!==null&&xe.delete(it.key===null?Fe:it.key),W=y(it,W,Fe),st===null?we=it:st.sibling=it,st=it);return n&&xe.forEach(function(sN){return l($,sN)}),Ke&&ta($,Fe),we}function gt($,W,Z,ce){if(typeof Z=="object"&&Z!==null&&Z.type===x&&Z.key===null&&(Z=Z.props.children),typeof Z=="object"&&Z!==null){switch(Z.$$typeof){case g:e:{for(var we=Z.key;W!==null;){if(W.key===we){if(we=Z.type,we===x){if(W.tag===7){d($,W.sibling),ce=v(W,Z.props.children),ce.return=$,$=ce;break e}}else if(W.elementType===we||typeof we=="object"&&we!==null&&we.$$typeof===R&&Lo(we)===W.type){d($,W.sibling),ce=v(W,Z.props),wu(ce,Z),ce.return=$,$=ce;break e}d($,W);break}else l($,W);W=W.sibling}Z.type===x?(ce=Co(Z.props.children,$.mode,ce,Z.key),ce.return=$,$=ce):(ce=Cm(Z.type,Z.key,Z.props,null,$.mode,ce),wu(ce,Z),ce.return=$,$=ce)}return A($);case S:e:{for(we=Z.key;W!==null;){if(W.key===we)if(W.tag===4&&W.stateNode.containerInfo===Z.containerInfo&&W.stateNode.implementation===Z.implementation){d($,W.sibling),ce=v(W,Z.children||[]),ce.return=$,$=ce;break e}else{d($,W);break}else l($,W);W=W.sibling}ce=mS(Z,$.mode,ce),ce.return=$,$=ce}return A($);case R:return Z=Lo(Z),gt($,W,Z,ce)}if(ae(Z))return Se($,W,Z,ce);if(H(Z)){if(we=H(Z),typeof we!="function")throw Error(s(150));return Z=we.call(Z),Ce($,W,Z,ce)}if(typeof Z.then=="function")return gt($,W,Om(Z),ce);if(Z.$$typeof===C)return gt($,W,Rm($,Z),ce);Nm($,Z)}return typeof Z=="string"&&Z!==""||typeof Z=="number"||typeof Z=="bigint"?(Z=""+Z,W!==null&&W.tag===6?(d($,W.sibling),ce=v(W,Z),ce.return=$,$=ce):(d($,W),ce=fS(Z,$.mode,ce),ce.return=$,$=ce),A($)):d($,W)}return function($,W,Z,ce){try{Au=0;var we=gt($,W,Z,ce);return lc=null,we}catch(xe){if(xe===oc||xe===Lm)throw xe;var st=oi(29,xe,null,$.mode);return st.lanes=ce,st.return=$,st}}}var Oo=OA(!0),NA=OA(!1),_n=!1;function wS(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function CS(n,l){n=n.updateQueue,l.updateQueue===n&&(l.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,callbacks:null})}function gn(n){return{lane:n,tag:0,payload:null,callback:null,next:null}}function vn(n,l,d){var p=n.updateQueue;if(p===null)return null;if(p=p.shared,(at&2)!==0){var v=p.pending;return v===null?l.next=l:(l.next=v.next,v.next=l),p.pending=l,l=wm(n),vA(n,null,d),l}return Am(n,p,l,d),wm(n)}function Cu(n,l,d){if(l=l.updateQueue,l!==null&&(l=l.shared,(d&4194048)!==0)){var p=l.lanes;p&=n.pendingLanes,d|=p,l.lanes=d,wb(n,d)}}function DS(n,l){var d=n.updateQueue,p=n.alternate;if(p!==null&&(p=p.updateQueue,d===p)){var v=null,y=null;if(d=d.firstBaseUpdate,d!==null){do{var A={lane:d.lane,tag:d.tag,payload:d.payload,callback:null,next:null};y===null?v=y=A:y=y.next=A,d=d.next}while(d!==null);y===null?v=y=l:y=y.next=l}else v=y=l;d={baseState:p.baseState,firstBaseUpdate:v,lastBaseUpdate:y,shared:p.shared,callbacks:p.callbacks},n.updateQueue=d;return}n=d.lastBaseUpdate,n===null?d.firstBaseUpdate=l:n.next=l,d.lastBaseUpdate=l}var PS=!1;function Du(){if(PS){var n=nc;if(n!==null)throw n}}function Pu(n,l,d,p){PS=!1;var v=n.updateQueue;_n=!1;var y=v.firstBaseUpdate,A=v.lastBaseUpdate,N=v.shared.pending;if(N!==null){v.shared.pending=null;var V=N,Q=V.next;V.next=null,A===null?y=Q:A.next=Q,A=V;var oe=n.alternate;oe!==null&&(oe=oe.updateQueue,N=oe.lastBaseUpdate,N!==A&&(N===null?oe.firstBaseUpdate=Q:N.next=Q,oe.lastBaseUpdate=V))}if(y!==null){var he=v.baseState;A=0,oe=Q=V=null,N=y;do{var te=N.lane&-536870913,ie=te!==N.lane;if(ie?(Ye&te)===te:(p&te)===te){te!==0&&te===ac&&(PS=!0),oe!==null&&(oe=oe.next={lane:0,tag:N.tag,payload:N.payload,callback:null,next:null});e:{var Se=n,Ce=N;te=l;var gt=d;switch(Ce.tag){case 1:if(Se=Ce.payload,typeof Se=="function"){he=Se.call(gt,he,te);break e}he=Se;break e;case 3:Se.flags=Se.flags&-65537|128;case 0:if(Se=Ce.payload,te=typeof Se=="function"?Se.call(gt,he,te):Se,te==null)break e;he=m({},he,te);break e;case 2:_n=!0}}te=N.callback,te!==null&&(n.flags|=64,ie&&(n.flags|=8192),ie=v.callbacks,ie===null?v.callbacks=[te]:ie.push(te))}else ie={lane:te,tag:N.tag,payload:N.payload,callback:N.callback,next:null},oe===null?(Q=oe=ie,V=he):oe=oe.next=ie,A|=te;if(N=N.next,N===null){if(N=v.shared.pending,N===null)break;ie=N,N=ie.next,ie.next=null,v.lastBaseUpdate=ie,v.shared.pending=null}}while(!0);oe===null&&(V=he),v.baseState=V,v.firstBaseUpdate=Q,v.lastBaseUpdate=oe,y===null&&(v.shared.lanes=0),En|=A,n.lanes=A,n.memoizedState=he}}function FA(n,l){if(typeof n!="function")throw Error(s(191,n));n.call(l)}function BA(n,l){var d=n.callbacks;if(d!==null)for(n.callbacks=null,n=0;n<d.length;n++)FA(d[n],l)}var cc=F(null),Fm=F(0);function UA(n,l){n=da,K(Fm,n),K(cc,l),da=n|l.baseLanes}function RS(){K(Fm,da),K(cc,cc.current)}function MS(){da=Fm.current,U(cc),U(Fm)}var li=F(null),Li=null;function Sn(n){var l=n.alternate;K(Kt,Kt.current&1),K(li,n),Li===null&&(l===null||cc.current!==null||l.memoizedState!==null)&&(Li=n)}function LS(n){K(Kt,Kt.current),K(li,n),Li===null&&(Li=n)}function zA(n){n.tag===22?(K(Kt,Kt.current),K(li,n),Li===null&&(Li=n)):yn()}function yn(){K(Kt,Kt.current),K(li,li.current)}function ci(n){U(li),Li===n&&(Li=null),U(Kt)}var Kt=F(0);function Bm(n){for(var l=n;l!==null;){if(l.tag===13){var d=l.memoizedState;if(d!==null&&(d=d.dehydrated,d===null||Uy(d)||zy(d)))return l}else if(l.tag===19&&(l.memoizedProps.revealOrder==="forwards"||l.memoizedProps.revealOrder==="backwards"||l.memoizedProps.revealOrder==="unstable_legacy-backwards"||l.memoizedProps.revealOrder==="together")){if((l.flags&128)!==0)return l}else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===n)break;for(;l.sibling===null;){if(l.return===null||l.return===n)return null;l=l.return}l.sibling.return=l.return,l=l.sibling}return null}var ra=0,Ie=null,pt=null,ts=null,Um=!1,hc=!1,No=!1,zm=0,Ru=0,uc=null,q3=0;function Xt(){throw Error(s(321))}function IS(n,l){if(l===null)return!1;for(var d=0;d<l.length&&d<n.length;d++)if(!ni(n[d],l[d]))return!1;return!0}function OS(n,l,d,p,v,y){return ra=y,Ie=l,l.memoizedState=null,l.updateQueue=null,l.lanes=0,k.H=n===null||n.memoizedState===null?Tw:$S,No=!1,y=d(p,v),No=!1,hc&&(y=VA(l,d,p,v)),kA(n),y}function kA(n){k.H=Iu;var l=pt!==null&&pt.next!==null;if(ra=0,ts=pt=Ie=null,Um=!1,Ru=0,uc=null,l)throw Error(s(300));n===null||ss||(n=n.dependencies,n!==null&&Pm(n)&&(ss=!0))}function VA(n,l,d,p){Ie=n;var v=0;do{if(hc&&(uc=null),Ru=0,hc=!1,25<=v)throw Error(s(301));if(v+=1,ts=pt=null,n.updateQueue!=null){var y=n.updateQueue;y.lastEffect=null,y.events=null,y.stores=null,y.memoCache!=null&&(y.memoCache.index=0)}k.H=Ew,y=l(d,p)}while(hc);return y}function Y3(){var n=k.H,l=n.useState()[0];return l=typeof l.then=="function"?Mu(l):l,n=n.useState()[0],(pt!==null?pt.memoizedState:null)!==n&&(Ie.flags|=1024),l}function NS(){var n=zm!==0;return zm=0,n}function FS(n,l,d){l.updateQueue=n.updateQueue,l.flags&=-2053,n.lanes&=~d}function BS(n){if(Um){for(n=n.memoizedState;n!==null;){var l=n.queue;l!==null&&(l.pending=null),n=n.next}Um=!1}ra=0,ts=pt=Ie=null,hc=!1,Ru=zm=0,uc=null}function Ls(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return ts===null?Ie.memoizedState=ts=n:ts=ts.next=n,ts}function Zt(){if(pt===null){var n=Ie.alternate;n=n!==null?n.memoizedState:null}else n=pt.next;var l=ts===null?Ie.memoizedState:ts.next;if(l!==null)ts=l,pt=n;else{if(n===null)throw Ie.alternate===null?Error(s(467)):Error(s(310));pt=n,n={memoizedState:pt.memoizedState,baseState:pt.baseState,baseQueue:pt.baseQueue,queue:pt.queue,next:null},ts===null?Ie.memoizedState=ts=n:ts=ts.next=n}return ts}function km(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Mu(n){var l=Ru;return Ru+=1,uc===null&&(uc=[]),n=MA(uc,n,l),l=Ie,(ts===null?l.memoizedState:ts.next)===null&&(l=l.alternate,k.H=l===null||l.memoizedState===null?Tw:$S),n}function Vm(n){if(n!==null&&typeof n=="object"){if(typeof n.then=="function")return Mu(n);if(n.$$typeof===C)return Ts(n)}throw Error(s(438,String(n)))}function US(n){var l=null,d=Ie.updateQueue;if(d!==null&&(l=d.memoCache),l==null){var p=Ie.alternate;p!==null&&(p=p.updateQueue,p!==null&&(p=p.memoCache,p!=null&&(l={data:p.data.map(function(v){return v.slice()}),index:0})))}if(l==null&&(l={data:[],index:0}),d===null&&(d=km(),Ie.updateQueue=d),d.memoCache=l,d=l.data[l.index],d===void 0)for(d=l.data[l.index]=Array(n),p=0;p<n;p++)d[p]=B;return l.index++,d}function aa(n,l){return typeof l=="function"?l(n):l}function Gm(n){var l=Zt();return zS(l,pt,n)}function zS(n,l,d){var p=n.queue;if(p===null)throw Error(s(311));p.lastRenderedReducer=d;var v=n.baseQueue,y=p.pending;if(y!==null){if(v!==null){var A=v.next;v.next=y.next,y.next=A}l.baseQueue=v=y,p.pending=null}if(y=n.baseState,v===null)n.memoizedState=y;else{l=v.next;var N=A=null,V=null,Q=l,oe=!1;do{var he=Q.lane&-536870913;if(he!==Q.lane?(Ye&he)===he:(ra&he)===he){var te=Q.revertLane;if(te===0)V!==null&&(V=V.next={lane:0,revertLane:0,gesture:null,action:Q.action,hasEagerState:Q.hasEagerState,eagerState:Q.eagerState,next:null}),he===ac&&(oe=!0);else if((ra&te)===te){Q=Q.next,te===ac&&(oe=!0);continue}else he={lane:0,revertLane:Q.revertLane,gesture:null,action:Q.action,hasEagerState:Q.hasEagerState,eagerState:Q.eagerState,next:null},V===null?(N=V=he,A=y):V=V.next=he,Ie.lanes|=te,En|=te;he=Q.action,No&&d(y,he),y=Q.hasEagerState?Q.eagerState:d(y,he)}else te={lane:he,revertLane:Q.revertLane,gesture:Q.gesture,action:Q.action,hasEagerState:Q.hasEagerState,eagerState:Q.eagerState,next:null},V===null?(N=V=te,A=y):V=V.next=te,Ie.lanes|=he,En|=he;Q=Q.next}while(Q!==null&&Q!==l);if(V===null?A=y:V.next=N,!ni(y,n.memoizedState)&&(ss=!0,oe&&(d=nc,d!==null)))throw d;n.memoizedState=y,n.baseState=A,n.baseQueue=V,p.lastRenderedState=y}return v===null&&(p.lanes=0),[n.memoizedState,p.dispatch]}function kS(n){var l=Zt(),d=l.queue;if(d===null)throw Error(s(311));d.lastRenderedReducer=n;var p=d.dispatch,v=d.pending,y=l.memoizedState;if(v!==null){d.pending=null;var A=v=v.next;do y=n(y,A.action),A=A.next;while(A!==v);ni(y,l.memoizedState)||(ss=!0),l.memoizedState=y,l.baseQueue===null&&(l.baseState=y),d.lastRenderedState=y}return[y,p]}function GA(n,l,d){var p=Ie,v=Zt(),y=Ke;if(y){if(d===void 0)throw Error(s(407));d=d()}else d=l();var A=!ni((pt||v).memoizedState,d);if(A&&(v.memoizedState=d,ss=!0),v=v.queue,HS(XA.bind(null,p,v,n),[n]),v.getSnapshot!==l||A||ts!==null&&ts.memoizedState.tag&1){if(p.flags|=2048,dc(9,{destroy:void 0},WA.bind(null,p,v,d,l),null),St===null)throw Error(s(349));y||(ra&127)!==0||HA(p,l,d)}return d}function HA(n,l,d){n.flags|=16384,n={getSnapshot:l,value:d},l=Ie.updateQueue,l===null?(l=km(),Ie.updateQueue=l,l.stores=[n]):(d=l.stores,d===null?l.stores=[n]:d.push(n))}function WA(n,l,d,p){l.value=d,l.getSnapshot=p,qA(l)&&YA(n)}function XA(n,l,d){return d(function(){qA(l)&&YA(n)})}function qA(n){var l=n.getSnapshot;n=n.value;try{var d=l();return!ni(n,d)}catch{return!0}}function YA(n){var l=wo(n,2);l!==null&&Ys(l,n,2)}function VS(n){var l=Ls();if(typeof n=="function"){var d=n;if(n=d(),No){cn(!0);try{d()}finally{cn(!1)}}}return l.memoizedState=l.baseState=n,l.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:aa,lastRenderedState:n},l}function jA(n,l,d,p){return n.baseState=d,zS(n,pt,typeof p=="function"?p:aa)}function j3(n,l,d,p,v){if(Xm(n))throw Error(s(485));if(n=l.action,n!==null){var y={payload:v,action:n,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(A){y.listeners.push(A)}};k.T!==null?d(!0):y.isTransition=!1,p(y),d=l.pending,d===null?(y.next=l.pending=y,$A(l,y)):(y.next=d.next,l.pending=d.next=y)}}function $A(n,l){var d=l.action,p=l.payload,v=n.state;if(l.isTransition){var y=k.T,A={};k.T=A;try{var N=d(v,p),V=k.S;V!==null&&V(A,N),KA(n,l,N)}catch(Q){GS(n,l,Q)}finally{y!==null&&A.types!==null&&(y.types=A.types),k.T=y}}else try{y=d(v,p),KA(n,l,y)}catch(Q){GS(n,l,Q)}}function KA(n,l,d){d!==null&&typeof d=="object"&&typeof d.then=="function"?d.then(function(p){ZA(n,l,p)},function(p){return GS(n,l,p)}):ZA(n,l,d)}function ZA(n,l,d){l.status="fulfilled",l.value=d,QA(l),n.state=d,l=n.pending,l!==null&&(d=l.next,d===l?n.pending=null:(d=d.next,l.next=d,$A(n,d)))}function GS(n,l,d){var p=n.pending;if(n.pending=null,p!==null){p=p.next;do l.status="rejected",l.reason=d,QA(l),l=l.next;while(l!==p)}n.action=null}function QA(n){n=n.listeners;for(var l=0;l<n.length;l++)(0,n[l])()}function JA(n,l){return l}function ew(n,l){if(Ke){var d=St.formState;if(d!==null){e:{var p=Ie;if(Ke){if(Mt){t:{for(var v=Mt,y=Mi;v.nodeType!==8;){if(!y){v=null;break t}if(v=Ii(v.nextSibling),v===null){v=null;break t}}y=v.data,v=y==="F!"||y==="F"?v:null}if(v){Mt=Ii(v.nextSibling),p=v.data==="F!";break e}}mn(p)}p=!1}p&&(l=d[0])}}return d=Ls(),d.memoizedState=d.baseState=l,p={pending:null,lanes:0,dispatch:null,lastRenderedReducer:JA,lastRenderedState:l},d.queue=p,d=Sw.bind(null,Ie,p),p.dispatch=d,p=VS(!1),y=jS.bind(null,Ie,!1,p.queue),p=Ls(),v={state:l,dispatch:null,action:n,pending:null},p.queue=v,d=j3.bind(null,Ie,v,y,d),v.dispatch=d,p.memoizedState=n,[l,d,!1]}function tw(n){var l=Zt();return sw(l,pt,n)}function sw(n,l,d){if(l=zS(n,l,JA)[0],n=Gm(aa)[0],typeof l=="object"&&l!==null&&typeof l.then=="function")try{var p=Mu(l)}catch(A){throw A===oc?Lm:A}else p=l;l=Zt();var v=l.queue,y=v.dispatch;return d!==l.memoizedState&&(Ie.flags|=2048,dc(9,{destroy:void 0},$3.bind(null,v,d),null)),[p,y,n]}function $3(n,l){n.action=l}function iw(n){var l=Zt(),d=pt;if(d!==null)return sw(l,d,n);Zt(),l=l.memoizedState,d=Zt();var p=d.queue.dispatch;return d.memoizedState=n,[l,p,!1]}function dc(n,l,d,p){return n={tag:n,create:d,deps:p,inst:l,next:null},l=Ie.updateQueue,l===null&&(l=km(),Ie.updateQueue=l),d=l.lastEffect,d===null?l.lastEffect=n.next=n:(p=d.next,d.next=n,n.next=p,l.lastEffect=n),n}function rw(){return Zt().memoizedState}function Hm(n,l,d,p){var v=Ls();Ie.flags|=n,v.memoizedState=dc(1|l,{destroy:void 0},d,p===void 0?null:p)}function Wm(n,l,d,p){var v=Zt();p=p===void 0?null:p;var y=v.memoizedState.inst;pt!==null&&p!==null&&IS(p,pt.memoizedState.deps)?v.memoizedState=dc(l,y,d,p):(Ie.flags|=n,v.memoizedState=dc(1|l,y,d,p))}function aw(n,l){Hm(8390656,8,n,l)}function HS(n,l){Wm(2048,8,n,l)}function K3(n){Ie.flags|=4;var l=Ie.updateQueue;if(l===null)l=km(),Ie.updateQueue=l,l.events=[n];else{var d=l.events;d===null?l.events=[n]:d.push(n)}}function nw(n){var l=Zt().memoizedState;return K3({ref:l,nextImpl:n}),function(){if((at&2)!==0)throw Error(s(440));return l.impl.apply(void 0,arguments)}}function ow(n,l){return Wm(4,2,n,l)}function lw(n,l){return Wm(4,4,n,l)}function cw(n,l){if(typeof l=="function"){n=n();var d=l(n);return function(){typeof d=="function"?d():l(null)}}if(l!=null)return n=n(),l.current=n,function(){l.current=null}}function hw(n,l,d){d=d!=null?d.concat([n]):null,Wm(4,4,cw.bind(null,l,n),d)}function WS(){}function uw(n,l){var d=Zt();l=l===void 0?null:l;var p=d.memoizedState;return l!==null&&IS(l,p[1])?p[0]:(d.memoizedState=[n,l],n)}function dw(n,l){var d=Zt();l=l===void 0?null:l;var p=d.memoizedState;if(l!==null&&IS(l,p[1]))return p[0];if(p=n(),No){cn(!0);try{n()}finally{cn(!1)}}return d.memoizedState=[p,l],p}function XS(n,l,d){return d===void 0||(ra&1073741824)!==0&&(Ye&261930)===0?n.memoizedState=l:(n.memoizedState=d,n=fC(),Ie.lanes|=n,En|=n,d)}function fw(n,l,d,p){return ni(d,l)?d:cc.current!==null?(n=XS(n,d,p),ni(n,l)||(ss=!0),n):(ra&42)===0||(ra&1073741824)!==0&&(Ye&261930)===0?(ss=!0,n.memoizedState=d):(n=fC(),Ie.lanes|=n,En|=n,l)}function mw(n,l,d,p,v){var y=O.p;O.p=y!==0&&8>y?y:8;var A=k.T,N={};k.T=N,jS(n,!1,l,d);try{var V=v(),Q=k.S;if(Q!==null&&Q(N,V),V!==null&&typeof V=="object"&&typeof V.then=="function"){var oe=X3(V,p);Lu(n,l,oe,di(n))}else Lu(n,l,p,di(n))}catch(he){Lu(n,l,{then:function(){},status:"rejected",reason:he},di())}finally{O.p=y,A!==null&&N.types!==null&&(A.types=N.types),k.T=A}}function Z3(){}function qS(n,l,d,p){if(n.tag!==5)throw Error(s(476));var v=pw(n).queue;mw(n,v,l,z,d===null?Z3:function(){return _w(n),d(p)})}function pw(n){var l=n.memoizedState;if(l!==null)return l;l={memoizedState:z,baseState:z,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:aa,lastRenderedState:z},next:null};var d={};return l.next={memoizedState:d,baseState:d,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:aa,lastRenderedState:d},next:null},n.memoizedState=l,n=n.alternate,n!==null&&(n.memoizedState=l),l}function _w(n){var l=pw(n);l.next===null&&(l=n.alternate.memoizedState),Lu(n,l.next.queue,{},di())}function YS(){return Ts($u)}function gw(){return Zt().memoizedState}function vw(){return Zt().memoizedState}function Q3(n){for(var l=n.return;l!==null;){switch(l.tag){case 24:case 3:var d=di();n=gn(d);var p=vn(l,n,d);p!==null&&(Ys(p,l,d),Cu(p,l,d)),l={cache:TS()},n.payload=l;return}l=l.return}}function J3(n,l,d){var p=di();d={lane:p,revertLane:0,gesture:null,action:d,hasEagerState:!1,eagerState:null,next:null},Xm(n)?yw(l,d):(d=uS(n,l,d,p),d!==null&&(Ys(d,n,p),xw(d,l,p)))}function Sw(n,l,d){var p=di();Lu(n,l,d,p)}function Lu(n,l,d,p){var v={lane:p,revertLane:0,gesture:null,action:d,hasEagerState:!1,eagerState:null,next:null};if(Xm(n))yw(l,v);else{var y=n.alternate;if(n.lanes===0&&(y===null||y.lanes===0)&&(y=l.lastRenderedReducer,y!==null))try{var A=l.lastRenderedState,N=y(A,d);if(v.hasEagerState=!0,v.eagerState=N,ni(N,A))return Am(n,l,v,0),St===null&&bm(),!1}catch{}if(d=uS(n,l,v,p),d!==null)return Ys(d,n,p),xw(d,l,p),!0}return!1}function jS(n,l,d,p){if(p={lane:2,revertLane:wy(),gesture:null,action:p,hasEagerState:!1,eagerState:null,next:null},Xm(n)){if(l)throw Error(s(479))}else l=uS(n,d,p,2),l!==null&&Ys(l,n,2)}function Xm(n){var l=n.alternate;return n===Ie||l!==null&&l===Ie}function yw(n,l){hc=Um=!0;var d=n.pending;d===null?l.next=l:(l.next=d.next,d.next=l),n.pending=l}function xw(n,l,d){if((d&4194048)!==0){var p=l.lanes;p&=n.pendingLanes,d|=p,l.lanes=d,wb(n,d)}}var Iu={readContext:Ts,use:Vm,useCallback:Xt,useContext:Xt,useEffect:Xt,useImperativeHandle:Xt,useLayoutEffect:Xt,useInsertionEffect:Xt,useMemo:Xt,useReducer:Xt,useRef:Xt,useState:Xt,useDebugValue:Xt,useDeferredValue:Xt,useTransition:Xt,useSyncExternalStore:Xt,useId:Xt,useHostTransitionStatus:Xt,useFormState:Xt,useActionState:Xt,useOptimistic:Xt,useMemoCache:Xt,useCacheRefresh:Xt};Iu.useEffectEvent=Xt;var Tw={readContext:Ts,use:Vm,useCallback:function(n,l){return Ls().memoizedState=[n,l===void 0?null:l],n},useContext:Ts,useEffect:aw,useImperativeHandle:function(n,l,d){d=d!=null?d.concat([n]):null,Hm(4194308,4,cw.bind(null,l,n),d)},useLayoutEffect:function(n,l){return Hm(4194308,4,n,l)},useInsertionEffect:function(n,l){Hm(4,2,n,l)},useMemo:function(n,l){var d=Ls();l=l===void 0?null:l;var p=n();if(No){cn(!0);try{n()}finally{cn(!1)}}return d.memoizedState=[p,l],p},useReducer:function(n,l,d){var p=Ls();if(d!==void 0){var v=d(l);if(No){cn(!0);try{d(l)}finally{cn(!1)}}}else v=l;return p.memoizedState=p.baseState=v,n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:v},p.queue=n,n=n.dispatch=J3.bind(null,Ie,n),[p.memoizedState,n]},useRef:function(n){var l=Ls();return n={current:n},l.memoizedState=n},useState:function(n){n=VS(n);var l=n.queue,d=Sw.bind(null,Ie,l);return l.dispatch=d,[n.memoizedState,d]},useDebugValue:WS,useDeferredValue:function(n,l){var d=Ls();return XS(d,n,l)},useTransition:function(){var n=VS(!1);return n=mw.bind(null,Ie,n.queue,!0,!1),Ls().memoizedState=n,[!1,n]},useSyncExternalStore:function(n,l,d){var p=Ie,v=Ls();if(Ke){if(d===void 0)throw Error(s(407));d=d()}else{if(d=l(),St===null)throw Error(s(349));(Ye&127)!==0||HA(p,l,d)}v.memoizedState=d;var y={value:d,getSnapshot:l};return v.queue=y,aw(XA.bind(null,p,y,n),[n]),p.flags|=2048,dc(9,{destroy:void 0},WA.bind(null,p,y,d,l),null),d},useId:function(){var n=Ls(),l=St.identifierPrefix;if(Ke){var d=br,p=Er;d=(p&~(1<<32-ai(p)-1)).toString(32)+d,l="_"+l+"R_"+d,d=zm++,0<d&&(l+="H"+d.toString(32)),l+="_"}else d=q3++,l="_"+l+"r_"+d.toString(32)+"_";return n.memoizedState=l},useHostTransitionStatus:YS,useFormState:ew,useActionState:ew,useOptimistic:function(n){var l=Ls();l.memoizedState=l.baseState=n;var d={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return l.queue=d,l=jS.bind(null,Ie,!0,d),d.dispatch=l,[n,l]},useMemoCache:US,useCacheRefresh:function(){return Ls().memoizedState=Q3.bind(null,Ie)},useEffectEvent:function(n){var l=Ls(),d={impl:n};return l.memoizedState=d,function(){if((at&2)!==0)throw Error(s(440));return d.impl.apply(void 0,arguments)}}},$S={readContext:Ts,use:Vm,useCallback:uw,useContext:Ts,useEffect:HS,useImperativeHandle:hw,useInsertionEffect:ow,useLayoutEffect:lw,useMemo:dw,useReducer:Gm,useRef:rw,useState:function(){return Gm(aa)},useDebugValue:WS,useDeferredValue:function(n,l){var d=Zt();return fw(d,pt.memoizedState,n,l)},useTransition:function(){var n=Gm(aa)[0],l=Zt().memoizedState;return[typeof n=="boolean"?n:Mu(n),l]},useSyncExternalStore:GA,useId:gw,useHostTransitionStatus:YS,useFormState:tw,useActionState:tw,useOptimistic:function(n,l){var d=Zt();return jA(d,pt,n,l)},useMemoCache:US,useCacheRefresh:vw};$S.useEffectEvent=nw;var Ew={readContext:Ts,use:Vm,useCallback:uw,useContext:Ts,useEffect:HS,useImperativeHandle:hw,useInsertionEffect:ow,useLayoutEffect:lw,useMemo:dw,useReducer:kS,useRef:rw,useState:function(){return kS(aa)},useDebugValue:WS,useDeferredValue:function(n,l){var d=Zt();return pt===null?XS(d,n,l):fw(d,pt.memoizedState,n,l)},useTransition:function(){var n=kS(aa)[0],l=Zt().memoizedState;return[typeof n=="boolean"?n:Mu(n),l]},useSyncExternalStore:GA,useId:gw,useHostTransitionStatus:YS,useFormState:iw,useActionState:iw,useOptimistic:function(n,l){var d=Zt();return pt!==null?jA(d,pt,n,l):(d.baseState=n,[n,d.queue.dispatch])},useMemoCache:US,useCacheRefresh:vw};Ew.useEffectEvent=nw;function KS(n,l,d,p){l=n.memoizedState,d=d(p,l),d=d==null?l:m({},l,d),n.memoizedState=d,n.lanes===0&&(n.updateQueue.baseState=d)}var ZS={enqueueSetState:function(n,l,d){n=n._reactInternals;var p=di(),v=gn(p);v.payload=l,d!=null&&(v.callback=d),l=vn(n,v,p),l!==null&&(Ys(l,n,p),Cu(l,n,p))},enqueueReplaceState:function(n,l,d){n=n._reactInternals;var p=di(),v=gn(p);v.tag=1,v.payload=l,d!=null&&(v.callback=d),l=vn(n,v,p),l!==null&&(Ys(l,n,p),Cu(l,n,p))},enqueueForceUpdate:function(n,l){n=n._reactInternals;var d=di(),p=gn(d);p.tag=2,l!=null&&(p.callback=l),l=vn(n,p,d),l!==null&&(Ys(l,n,d),Cu(l,n,d))}};function bw(n,l,d,p,v,y,A){return n=n.stateNode,typeof n.shouldComponentUpdate=="function"?n.shouldComponentUpdate(p,y,A):l.prototype&&l.prototype.isPureReactComponent?!Su(d,p)||!Su(v,y):!0}function Aw(n,l,d,p){n=l.state,typeof l.componentWillReceiveProps=="function"&&l.componentWillReceiveProps(d,p),typeof l.UNSAFE_componentWillReceiveProps=="function"&&l.UNSAFE_componentWillReceiveProps(d,p),l.state!==n&&ZS.enqueueReplaceState(l,l.state,null)}function Fo(n,l){var d=l;if("ref"in l){d={};for(var p in l)p!=="ref"&&(d[p]=l[p])}if(n=n.defaultProps){d===l&&(d=m({},d));for(var v in n)d[v]===void 0&&(d[v]=n[v])}return d}function ww(n){Em(n)}function Cw(n){console.error(n)}function Dw(n){Em(n)}function qm(n,l){try{var d=n.onUncaughtError;d(l.value,{componentStack:l.stack})}catch(p){setTimeout(function(){throw p})}}function Pw(n,l,d){try{var p=n.onCaughtError;p(d.value,{componentStack:d.stack,errorBoundary:l.tag===1?l.stateNode:null})}catch(v){setTimeout(function(){throw v})}}function QS(n,l,d){return d=gn(d),d.tag=3,d.payload={element:null},d.callback=function(){qm(n,l)},d}function Rw(n){return n=gn(n),n.tag=3,n}function Mw(n,l,d,p){var v=d.type.getDerivedStateFromError;if(typeof v=="function"){var y=p.value;n.payload=function(){return v(y)},n.callback=function(){Pw(l,d,p)}}var A=d.stateNode;A!==null&&typeof A.componentDidCatch=="function"&&(n.callback=function(){Pw(l,d,p),typeof v!="function"&&(bn===null?bn=new Set([this]):bn.add(this));var N=p.stack;this.componentDidCatch(p.value,{componentStack:N!==null?N:""})})}function eO(n,l,d,p,v){if(d.flags|=32768,p!==null&&typeof p=="object"&&typeof p.then=="function"){if(l=d.alternate,l!==null&&rc(l,d,v,!0),d=li.current,d!==null){switch(d.tag){case 31:case 13:return Li===null?rp():d.alternate===null&&qt===0&&(qt=3),d.flags&=-257,d.flags|=65536,d.lanes=v,p===Im?d.flags|=16384:(l=d.updateQueue,l===null?d.updateQueue=new Set([p]):l.add(p),Ey(n,p,v)),!1;case 22:return d.flags|=65536,p===Im?d.flags|=16384:(l=d.updateQueue,l===null?(l={transitions:null,markerInstances:null,retryQueue:new Set([p])},d.updateQueue=l):(d=l.retryQueue,d===null?l.retryQueue=new Set([p]):d.add(p)),Ey(n,p,v)),!1}throw Error(s(435,d.tag))}return Ey(n,p,v),rp(),!1}if(Ke)return l=li.current,l!==null?((l.flags&65536)===0&&(l.flags|=256),l.flags|=65536,l.lanes=v,p!==gS&&(n=Error(s(422),{cause:p}),Tu(Di(n,d)))):(p!==gS&&(l=Error(s(423),{cause:p}),Tu(Di(l,d))),n=n.current.alternate,n.flags|=65536,v&=-v,n.lanes|=v,p=Di(p,d),v=QS(n.stateNode,p,v),DS(n,v),qt!==4&&(qt=2)),!1;var y=Error(s(520),{cause:p});if(y=Di(y,d),Vu===null?Vu=[y]:Vu.push(y),qt!==4&&(qt=2),l===null)return!0;p=Di(p,d),d=l;do{switch(d.tag){case 3:return d.flags|=65536,n=v&-v,d.lanes|=n,n=QS(d.stateNode,p,n),DS(d,n),!1;case 1:if(l=d.type,y=d.stateNode,(d.flags&128)===0&&(typeof l.getDerivedStateFromError=="function"||y!==null&&typeof y.componentDidCatch=="function"&&(bn===null||!bn.has(y))))return d.flags|=65536,v&=-v,d.lanes|=v,v=Rw(v),Mw(v,n,d,p),DS(d,v),!1}d=d.return}while(d!==null);return!1}var JS=Error(s(461)),ss=!1;function Es(n,l,d,p){l.child=n===null?NA(l,null,d,p):Oo(l,n.child,d,p)}function Lw(n,l,d,p,v){d=d.render;var y=l.ref;if("ref"in p){var A={};for(var N in p)N!=="ref"&&(A[N]=p[N])}else A=p;return Ro(l),p=OS(n,l,d,A,y,v),N=NS(),n!==null&&!ss?(FS(n,l,v),na(n,l,v)):(Ke&&N&&pS(l),l.flags|=1,Es(n,l,p,v),l.child)}function Iw(n,l,d,p,v){if(n===null){var y=d.type;return typeof y=="function"&&!dS(y)&&y.defaultProps===void 0&&d.compare===null?(l.tag=15,l.type=y,Ow(n,l,y,p,v)):(n=Cm(d.type,null,p,l,l.mode,v),n.ref=l.ref,n.return=l,l.child=n)}if(y=n.child,!oy(n,v)){var A=y.memoizedProps;if(d=d.compare,d=d!==null?d:Su,d(A,p)&&n.ref===l.ref)return na(n,l,v)}return l.flags|=1,n=ea(y,p),n.ref=l.ref,n.return=l,l.child=n}function Ow(n,l,d,p,v){if(n!==null){var y=n.memoizedProps;if(Su(y,p)&&n.ref===l.ref)if(ss=!1,l.pendingProps=p=y,oy(n,v))(n.flags&131072)!==0&&(ss=!0);else return l.lanes=n.lanes,na(n,l,v)}return ey(n,l,d,p,v)}function Nw(n,l,d,p){var v=p.children,y=n!==null?n.memoizedState:null;if(n===null&&l.stateNode===null&&(l.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),p.mode==="hidden"){if((l.flags&128)!==0){if(y=y!==null?y.baseLanes|d:d,n!==null){for(p=l.child=n.child,v=0;p!==null;)v=v|p.lanes|p.childLanes,p=p.sibling;p=v&~y}else p=0,l.child=null;return Fw(n,l,y,d,p)}if((d&536870912)!==0)l.memoizedState={baseLanes:0,cachePool:null},n!==null&&Mm(l,y!==null?y.cachePool:null),y!==null?UA(l,y):RS(),zA(l);else return p=l.lanes=536870912,Fw(n,l,y!==null?y.baseLanes|d:d,d,p)}else y!==null?(Mm(l,y.cachePool),UA(l,y),yn(),l.memoizedState=null):(n!==null&&Mm(l,null),RS(),yn());return Es(n,l,v,d),l.child}function Ou(n,l){return n!==null&&n.tag===22||l.stateNode!==null||(l.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),l.sibling}function Fw(n,l,d,p,v){var y=bS();return y=y===null?null:{parent:es._currentValue,pool:y},l.memoizedState={baseLanes:d,cachePool:y},n!==null&&Mm(l,null),RS(),zA(l),n!==null&&rc(n,l,p,!0),l.childLanes=v,null}function Ym(n,l){return l=$m({mode:l.mode,children:l.children},n.mode),l.ref=n.ref,n.child=l,l.return=n,l}function Bw(n,l,d){return Oo(l,n.child,null,d),n=Ym(l,l.pendingProps),n.flags|=2,ci(l),l.memoizedState=null,n}function tO(n,l,d){var p=l.pendingProps,v=(l.flags&128)!==0;if(l.flags&=-129,n===null){if(Ke){if(p.mode==="hidden")return n=Ym(l,p),l.lanes=536870912,Ou(null,n);if(LS(l),(n=Mt)?(n=$C(n,Mi),n=n!==null&&n.data==="&"?n:null,n!==null&&(l.memoizedState={dehydrated:n,treeContext:dn!==null?{id:Er,overflow:br}:null,retryLane:536870912,hydrationErrors:null},d=yA(n),d.return=l,l.child=d,xs=l,Mt=null)):n=null,n===null)throw mn(l);return l.lanes=536870912,null}return Ym(l,p)}var y=n.memoizedState;if(y!==null){var A=y.dehydrated;if(LS(l),v)if(l.flags&256)l.flags&=-257,l=Bw(n,l,d);else if(l.memoizedState!==null)l.child=n.child,l.flags|=128,l=null;else throw Error(s(558));else if(ss||rc(n,l,d,!1),v=(d&n.childLanes)!==0,ss||v){if(p=St,p!==null&&(A=Cb(p,d),A!==0&&A!==y.retryLane))throw y.retryLane=A,wo(n,A),Ys(p,n,A),JS;rp(),l=Bw(n,l,d)}else n=y.treeContext,Mt=Ii(A.nextSibling),xs=l,Ke=!0,fn=null,Mi=!1,n!==null&&EA(l,n),l=Ym(l,p),l.flags|=4096;return l}return n=ea(n.child,{mode:p.mode,children:p.children}),n.ref=l.ref,l.child=n,n.return=l,n}function jm(n,l){var d=l.ref;if(d===null)n!==null&&n.ref!==null&&(l.flags|=4194816);else{if(typeof d!="function"&&typeof d!="object")throw Error(s(284));(n===null||n.ref!==d)&&(l.flags|=4194816)}}function ey(n,l,d,p,v){return Ro(l),d=OS(n,l,d,p,void 0,v),p=NS(),n!==null&&!ss?(FS(n,l,v),na(n,l,v)):(Ke&&p&&pS(l),l.flags|=1,Es(n,l,d,v),l.child)}function Uw(n,l,d,p,v,y){return Ro(l),l.updateQueue=null,d=VA(l,p,d,v),kA(n),p=NS(),n!==null&&!ss?(FS(n,l,y),na(n,l,y)):(Ke&&p&&pS(l),l.flags|=1,Es(n,l,d,y),l.child)}function zw(n,l,d,p,v){if(Ro(l),l.stateNode===null){var y=ec,A=d.contextType;typeof A=="object"&&A!==null&&(y=Ts(A)),y=new d(p,y),l.memoizedState=y.state!==null&&y.state!==void 0?y.state:null,y.updater=ZS,l.stateNode=y,y._reactInternals=l,y=l.stateNode,y.props=p,y.state=l.memoizedState,y.refs={},wS(l),A=d.contextType,y.context=typeof A=="object"&&A!==null?Ts(A):ec,y.state=l.memoizedState,A=d.getDerivedStateFromProps,typeof A=="function"&&(KS(l,d,A,p),y.state=l.memoizedState),typeof d.getDerivedStateFromProps=="function"||typeof y.getSnapshotBeforeUpdate=="function"||typeof y.UNSAFE_componentWillMount!="function"&&typeof y.componentWillMount!="function"||(A=y.state,typeof y.componentWillMount=="function"&&y.componentWillMount(),typeof y.UNSAFE_componentWillMount=="function"&&y.UNSAFE_componentWillMount(),A!==y.state&&ZS.enqueueReplaceState(y,y.state,null),Pu(l,p,y,v),Du(),y.state=l.memoizedState),typeof y.componentDidMount=="function"&&(l.flags|=4194308),p=!0}else if(n===null){y=l.stateNode;var N=l.memoizedProps,V=Fo(d,N);y.props=V;var Q=y.context,oe=d.contextType;A=ec,typeof oe=="object"&&oe!==null&&(A=Ts(oe));var he=d.getDerivedStateFromProps;oe=typeof he=="function"||typeof y.getSnapshotBeforeUpdate=="function",N=l.pendingProps!==N,oe||typeof y.UNSAFE_componentWillReceiveProps!="function"&&typeof y.componentWillReceiveProps!="function"||(N||Q!==A)&&Aw(l,y,p,A),_n=!1;var te=l.memoizedState;y.state=te,Pu(l,p,y,v),Du(),Q=l.memoizedState,N||te!==Q||_n?(typeof he=="function"&&(KS(l,d,he,p),Q=l.memoizedState),(V=_n||bw(l,d,V,p,te,Q,A))?(oe||typeof y.UNSAFE_componentWillMount!="function"&&typeof y.componentWillMount!="function"||(typeof y.componentWillMount=="function"&&y.componentWillMount(),typeof y.UNSAFE_componentWillMount=="function"&&y.UNSAFE_componentWillMount()),typeof y.componentDidMount=="function"&&(l.flags|=4194308)):(typeof y.componentDidMount=="function"&&(l.flags|=4194308),l.memoizedProps=p,l.memoizedState=Q),y.props=p,y.state=Q,y.context=A,p=V):(typeof y.componentDidMount=="function"&&(l.flags|=4194308),p=!1)}else{y=l.stateNode,CS(n,l),A=l.memoizedProps,oe=Fo(d,A),y.props=oe,he=l.pendingProps,te=y.context,Q=d.contextType,V=ec,typeof Q=="object"&&Q!==null&&(V=Ts(Q)),N=d.getDerivedStateFromProps,(Q=typeof N=="function"||typeof y.getSnapshotBeforeUpdate=="function")||typeof y.UNSAFE_componentWillReceiveProps!="function"&&typeof y.componentWillReceiveProps!="function"||(A!==he||te!==V)&&Aw(l,y,p,V),_n=!1,te=l.memoizedState,y.state=te,Pu(l,p,y,v),Du();var ie=l.memoizedState;A!==he||te!==ie||_n||n!==null&&n.dependencies!==null&&Pm(n.dependencies)?(typeof N=="function"&&(KS(l,d,N,p),ie=l.memoizedState),(oe=_n||bw(l,d,oe,p,te,ie,V)||n!==null&&n.dependencies!==null&&Pm(n.dependencies))?(Q||typeof y.UNSAFE_componentWillUpdate!="function"&&typeof y.componentWillUpdate!="function"||(typeof y.componentWillUpdate=="function"&&y.componentWillUpdate(p,ie,V),typeof y.UNSAFE_componentWillUpdate=="function"&&y.UNSAFE_componentWillUpdate(p,ie,V)),typeof y.componentDidUpdate=="function"&&(l.flags|=4),typeof y.getSnapshotBeforeUpdate=="function"&&(l.flags|=1024)):(typeof y.componentDidUpdate!="function"||A===n.memoizedProps&&te===n.memoizedState||(l.flags|=4),typeof y.getSnapshotBeforeUpdate!="function"||A===n.memoizedProps&&te===n.memoizedState||(l.flags|=1024),l.memoizedProps=p,l.memoizedState=ie),y.props=p,y.state=ie,y.context=V,p=oe):(typeof y.componentDidUpdate!="function"||A===n.memoizedProps&&te===n.memoizedState||(l.flags|=4),typeof y.getSnapshotBeforeUpdate!="function"||A===n.memoizedProps&&te===n.memoizedState||(l.flags|=1024),p=!1)}return y=p,jm(n,l),p=(l.flags&128)!==0,y||p?(y=l.stateNode,d=p&&typeof d.getDerivedStateFromError!="function"?null:y.render(),l.flags|=1,n!==null&&p?(l.child=Oo(l,n.child,null,v),l.child=Oo(l,null,d,v)):Es(n,l,d,v),l.memoizedState=y.state,n=l.child):n=na(n,l,v),n}function kw(n,l,d,p){return Do(),l.flags|=256,Es(n,l,d,p),l.child}var ty={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function sy(n){return{baseLanes:n,cachePool:PA()}}function iy(n,l,d){return n=n!==null?n.childLanes&~d:0,l&&(n|=ui),n}function Vw(n,l,d){var p=l.pendingProps,v=!1,y=(l.flags&128)!==0,A;if((A=y)||(A=n!==null&&n.memoizedState===null?!1:(Kt.current&2)!==0),A&&(v=!0,l.flags&=-129),A=(l.flags&32)!==0,l.flags&=-33,n===null){if(Ke){if(v?Sn(l):yn(),(n=Mt)?(n=$C(n,Mi),n=n!==null&&n.data!=="&"?n:null,n!==null&&(l.memoizedState={dehydrated:n,treeContext:dn!==null?{id:Er,overflow:br}:null,retryLane:536870912,hydrationErrors:null},d=yA(n),d.return=l,l.child=d,xs=l,Mt=null)):n=null,n===null)throw mn(l);return zy(n)?l.lanes=32:l.lanes=536870912,null}var N=p.children;return p=p.fallback,v?(yn(),v=l.mode,N=$m({mode:"hidden",children:N},v),p=Co(p,v,d,null),N.return=l,p.return=l,N.sibling=p,l.child=N,p=l.child,p.memoizedState=sy(d),p.childLanes=iy(n,A,d),l.memoizedState=ty,Ou(null,p)):(Sn(l),ry(l,N))}var V=n.memoizedState;if(V!==null&&(N=V.dehydrated,N!==null)){if(y)l.flags&256?(Sn(l),l.flags&=-257,l=ay(n,l,d)):l.memoizedState!==null?(yn(),l.child=n.child,l.flags|=128,l=null):(yn(),N=p.fallback,v=l.mode,p=$m({mode:"visible",children:p.children},v),N=Co(N,v,d,null),N.flags|=2,p.return=l,N.return=l,p.sibling=N,l.child=p,Oo(l,n.child,null,d),p=l.child,p.memoizedState=sy(d),p.childLanes=iy(n,A,d),l.memoizedState=ty,l=Ou(null,p));else if(Sn(l),zy(N)){if(A=N.nextSibling&&N.nextSibling.dataset,A)var Q=A.dgst;A=Q,p=Error(s(419)),p.stack="",p.digest=A,Tu({value:p,source:null,stack:null}),l=ay(n,l,d)}else if(ss||rc(n,l,d,!1),A=(d&n.childLanes)!==0,ss||A){if(A=St,A!==null&&(p=Cb(A,d),p!==0&&p!==V.retryLane))throw V.retryLane=p,wo(n,p),Ys(A,n,p),JS;Uy(N)||rp(),l=ay(n,l,d)}else Uy(N)?(l.flags|=192,l.child=n.child,l=null):(n=V.treeContext,Mt=Ii(N.nextSibling),xs=l,Ke=!0,fn=null,Mi=!1,n!==null&&EA(l,n),l=ry(l,p.children),l.flags|=4096);return l}return v?(yn(),N=p.fallback,v=l.mode,V=n.child,Q=V.sibling,p=ea(V,{mode:"hidden",children:p.children}),p.subtreeFlags=V.subtreeFlags&65011712,Q!==null?N=ea(Q,N):(N=Co(N,v,d,null),N.flags|=2),N.return=l,p.return=l,p.sibling=N,l.child=p,Ou(null,p),p=l.child,N=n.child.memoizedState,N===null?N=sy(d):(v=N.cachePool,v!==null?(V=es._currentValue,v=v.parent!==V?{parent:V,pool:V}:v):v=PA(),N={baseLanes:N.baseLanes|d,cachePool:v}),p.memoizedState=N,p.childLanes=iy(n,A,d),l.memoizedState=ty,Ou(n.child,p)):(Sn(l),d=n.child,n=d.sibling,d=ea(d,{mode:"visible",children:p.children}),d.return=l,d.sibling=null,n!==null&&(A=l.deletions,A===null?(l.deletions=[n],l.flags|=16):A.push(n)),l.child=d,l.memoizedState=null,d)}function ry(n,l){return l=$m({mode:"visible",children:l},n.mode),l.return=n,n.child=l}function $m(n,l){return n=oi(22,n,null,l),n.lanes=0,n}function ay(n,l,d){return Oo(l,n.child,null,d),n=ry(l,l.pendingProps.children),n.flags|=2,l.memoizedState=null,n}function Gw(n,l,d){n.lanes|=l;var p=n.alternate;p!==null&&(p.lanes|=l),yS(n.return,l,d)}function ny(n,l,d,p,v,y){var A=n.memoizedState;A===null?n.memoizedState={isBackwards:l,rendering:null,renderingStartTime:0,last:p,tail:d,tailMode:v,treeForkCount:y}:(A.isBackwards=l,A.rendering=null,A.renderingStartTime=0,A.last=p,A.tail=d,A.tailMode=v,A.treeForkCount=y)}function Hw(n,l,d){var p=l.pendingProps,v=p.revealOrder,y=p.tail;p=p.children;var A=Kt.current,N=(A&2)!==0;if(N?(A=A&1|2,l.flags|=128):A&=1,K(Kt,A),Es(n,l,p,d),p=Ke?xu:0,!N&&n!==null&&(n.flags&128)!==0)e:for(n=l.child;n!==null;){if(n.tag===13)n.memoizedState!==null&&Gw(n,d,l);else if(n.tag===19)Gw(n,d,l);else if(n.child!==null){n.child.return=n,n=n.child;continue}if(n===l)break e;for(;n.sibling===null;){if(n.return===null||n.return===l)break e;n=n.return}n.sibling.return=n.return,n=n.sibling}switch(v){case"forwards":for(d=l.child,v=null;d!==null;)n=d.alternate,n!==null&&Bm(n)===null&&(v=d),d=d.sibling;d=v,d===null?(v=l.child,l.child=null):(v=d.sibling,d.sibling=null),ny(l,!1,v,d,y,p);break;case"backwards":case"unstable_legacy-backwards":for(d=null,v=l.child,l.child=null;v!==null;){if(n=v.alternate,n!==null&&Bm(n)===null){l.child=v;break}n=v.sibling,v.sibling=d,d=v,v=n}ny(l,!0,d,null,y,p);break;case"together":ny(l,!1,null,null,void 0,p);break;default:l.memoizedState=null}return l.child}function na(n,l,d){if(n!==null&&(l.dependencies=n.dependencies),En|=l.lanes,(d&l.childLanes)===0)if(n!==null){if(rc(n,l,d,!1),(d&l.childLanes)===0)return null}else return null;if(n!==null&&l.child!==n.child)throw Error(s(153));if(l.child!==null){for(n=l.child,d=ea(n,n.pendingProps),l.child=d,d.return=l;n.sibling!==null;)n=n.sibling,d=d.sibling=ea(n,n.pendingProps),d.return=l;d.sibling=null}return l.child}function oy(n,l){return(n.lanes&l)!==0?!0:(n=n.dependencies,!!(n!==null&&Pm(n)))}function sO(n,l,d){switch(l.tag){case 3:ye(l,l.stateNode.containerInfo),pn(l,es,n.memoizedState.cache),Do();break;case 27:case 5:et(l);break;case 4:ye(l,l.stateNode.containerInfo);break;case 10:pn(l,l.type,l.memoizedProps.value);break;case 31:if(l.memoizedState!==null)return l.flags|=128,LS(l),null;break;case 13:var p=l.memoizedState;if(p!==null)return p.dehydrated!==null?(Sn(l),l.flags|=128,null):(d&l.child.childLanes)!==0?Vw(n,l,d):(Sn(l),n=na(n,l,d),n!==null?n.sibling:null);Sn(l);break;case 19:var v=(n.flags&128)!==0;if(p=(d&l.childLanes)!==0,p||(rc(n,l,d,!1),p=(d&l.childLanes)!==0),v){if(p)return Hw(n,l,d);l.flags|=128}if(v=l.memoizedState,v!==null&&(v.rendering=null,v.tail=null,v.lastEffect=null),K(Kt,Kt.current),p)break;return null;case 22:return l.lanes=0,Nw(n,l,d,l.pendingProps);case 24:pn(l,es,n.memoizedState.cache)}return na(n,l,d)}function Ww(n,l,d){if(n!==null)if(n.memoizedProps!==l.pendingProps)ss=!0;else{if(!oy(n,d)&&(l.flags&128)===0)return ss=!1,sO(n,l,d);ss=(n.flags&131072)!==0}else ss=!1,Ke&&(l.flags&1048576)!==0&&TA(l,xu,l.index);switch(l.lanes=0,l.tag){case 16:e:{var p=l.pendingProps;if(n=Lo(l.elementType),l.type=n,typeof n=="function")dS(n)?(p=Fo(n,p),l.tag=1,l=zw(null,l,n,p,d)):(l.tag=0,l=ey(null,l,n,p,d));else{if(n!=null){var v=n.$$typeof;if(v===w){l.tag=11,l=Lw(null,l,n,p,d);break e}else if(v===M){l.tag=14,l=Iw(null,l,n,p,d);break e}}throw l=j(n)||n,Error(s(306,l,""))}}return l;case 0:return ey(n,l,l.type,l.pendingProps,d);case 1:return p=l.type,v=Fo(p,l.pendingProps),zw(n,l,p,v,d);case 3:e:{if(ye(l,l.stateNode.containerInfo),n===null)throw Error(s(387));p=l.pendingProps;var y=l.memoizedState;v=y.element,CS(n,l),Pu(l,p,null,d);var A=l.memoizedState;if(p=A.cache,pn(l,es,p),p!==y.cache&&xS(l,[es],d,!0),Du(),p=A.element,y.isDehydrated)if(y={element:p,isDehydrated:!1,cache:A.cache},l.updateQueue.baseState=y,l.memoizedState=y,l.flags&256){l=kw(n,l,p,d);break e}else if(p!==v){v=Di(Error(s(424)),l),Tu(v),l=kw(n,l,p,d);break e}else for(n=l.stateNode.containerInfo,n.nodeType===9?n=n.body:n=n.nodeName==="HTML"?n.ownerDocument.body:n,Mt=Ii(n.firstChild),xs=l,Ke=!0,fn=null,Mi=!0,d=NA(l,null,p,d),l.child=d;d;)d.flags=d.flags&-3|4096,d=d.sibling;else{if(Do(),p===v){l=na(n,l,d);break e}Es(n,l,p,d)}l=l.child}return l;case 26:return jm(n,l),n===null?(d=t1(l.type,null,l.pendingProps,null))?l.memoizedState=d:Ke||(d=l.type,n=l.pendingProps,p=up(re.current).createElement(d),p[ys]=l,p[Vs]=n,bs(p,d,n),ps(p),l.stateNode=p):l.memoizedState=t1(l.type,n.memoizedProps,l.pendingProps,n.memoizedState),null;case 27:return et(l),n===null&&Ke&&(p=l.stateNode=QC(l.type,l.pendingProps,re.current),xs=l,Mi=!0,v=Mt,Dn(l.type)?(ky=v,Mt=Ii(p.firstChild)):Mt=v),Es(n,l,l.pendingProps.children,d),jm(n,l),n===null&&(l.flags|=4194304),l.child;case 5:return n===null&&Ke&&((v=p=Mt)&&(p=LO(p,l.type,l.pendingProps,Mi),p!==null?(l.stateNode=p,xs=l,Mt=Ii(p.firstChild),Mi=!1,v=!0):v=!1),v||mn(l)),et(l),v=l.type,y=l.pendingProps,A=n!==null?n.memoizedProps:null,p=y.children,Ny(v,y)?p=null:A!==null&&Ny(v,A)&&(l.flags|=32),l.memoizedState!==null&&(v=OS(n,l,Y3,null,null,d),$u._currentValue=v),jm(n,l),Es(n,l,p,d),l.child;case 6:return n===null&&Ke&&((n=d=Mt)&&(d=IO(d,l.pendingProps,Mi),d!==null?(l.stateNode=d,xs=l,Mt=null,n=!0):n=!1),n||mn(l)),null;case 13:return Vw(n,l,d);case 4:return ye(l,l.stateNode.containerInfo),p=l.pendingProps,n===null?l.child=Oo(l,null,p,d):Es(n,l,p,d),l.child;case 11:return Lw(n,l,l.type,l.pendingProps,d);case 7:return Es(n,l,l.pendingProps,d),l.child;case 8:return Es(n,l,l.pendingProps.children,d),l.child;case 12:return Es(n,l,l.pendingProps.children,d),l.child;case 10:return p=l.pendingProps,pn(l,l.type,p.value),Es(n,l,p.children,d),l.child;case 9:return v=l.type._context,p=l.pendingProps.children,Ro(l),v=Ts(v),p=p(v),l.flags|=1,Es(n,l,p,d),l.child;case 14:return Iw(n,l,l.type,l.pendingProps,d);case 15:return Ow(n,l,l.type,l.pendingProps,d);case 19:return Hw(n,l,d);case 31:return tO(n,l,d);case 22:return Nw(n,l,d,l.pendingProps);case 24:return Ro(l),p=Ts(es),n===null?(v=bS(),v===null&&(v=St,y=TS(),v.pooledCache=y,y.refCount++,y!==null&&(v.pooledCacheLanes|=d),v=y),l.memoizedState={parent:p,cache:v},wS(l),pn(l,es,v)):((n.lanes&d)!==0&&(CS(n,l),Pu(l,null,null,d),Du()),v=n.memoizedState,y=l.memoizedState,v.parent!==p?(v={parent:p,cache:p},l.memoizedState=v,l.lanes===0&&(l.memoizedState=l.updateQueue.baseState=v),pn(l,es,p)):(p=y.cache,pn(l,es,p),p!==v.cache&&xS(l,[es],d,!0))),Es(n,l,l.pendingProps.children,d),l.child;case 29:throw l.pendingProps}throw Error(s(156,l.tag))}function oa(n){n.flags|=4}function ly(n,l,d,p,v){if((l=(n.mode&32)!==0)&&(l=!1),l){if(n.flags|=16777216,(v&335544128)===v)if(n.stateNode.complete)n.flags|=8192;else if(gC())n.flags|=8192;else throw Io=Im,AS}else n.flags&=-16777217}function Xw(n,l){if(l.type!=="stylesheet"||(l.state.loading&4)!==0)n.flags&=-16777217;else if(n.flags|=16777216,!n1(l))if(gC())n.flags|=8192;else throw Io=Im,AS}function Km(n,l){l!==null&&(n.flags|=4),n.flags&16384&&(l=n.tag!==22?bb():536870912,n.lanes|=l,_c|=l)}function Nu(n,l){if(!Ke)switch(n.tailMode){case"hidden":l=n.tail;for(var d=null;l!==null;)l.alternate!==null&&(d=l),l=l.sibling;d===null?n.tail=null:d.sibling=null;break;case"collapsed":d=n.tail;for(var p=null;d!==null;)d.alternate!==null&&(p=d),d=d.sibling;p===null?l||n.tail===null?n.tail=null:n.tail.sibling=null:p.sibling=null}}function Lt(n){var l=n.alternate!==null&&n.alternate.child===n.child,d=0,p=0;if(l)for(var v=n.child;v!==null;)d|=v.lanes|v.childLanes,p|=v.subtreeFlags&65011712,p|=v.flags&65011712,v.return=n,v=v.sibling;else for(v=n.child;v!==null;)d|=v.lanes|v.childLanes,p|=v.subtreeFlags,p|=v.flags,v.return=n,v=v.sibling;return n.subtreeFlags|=p,n.childLanes=d,l}function iO(n,l,d){var p=l.pendingProps;switch(_S(l),l.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Lt(l),null;case 1:return Lt(l),null;case 3:return d=l.stateNode,p=null,n!==null&&(p=n.memoizedState.cache),l.memoizedState.cache!==p&&(l.flags|=2048),ia(es),Me(),d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null),(n===null||n.child===null)&&(ic(l)?oa(l):n===null||n.memoizedState.isDehydrated&&(l.flags&256)===0||(l.flags|=1024,vS())),Lt(l),null;case 26:var v=l.type,y=l.memoizedState;return n===null?(oa(l),y!==null?(Lt(l),Xw(l,y)):(Lt(l),ly(l,v,null,p,d))):y?y!==n.memoizedState?(oa(l),Lt(l),Xw(l,y)):(Lt(l),l.flags&=-16777217):(n=n.memoizedProps,n!==p&&oa(l),Lt(l),ly(l,v,n,p,d)),null;case 27:if(Qe(l),d=re.current,v=l.type,n!==null&&l.stateNode!=null)n.memoizedProps!==p&&oa(l);else{if(!p){if(l.stateNode===null)throw Error(s(166));return Lt(l),null}n=se.current,ic(l)?bA(l):(n=QC(v,p,d),l.stateNode=n,oa(l))}return Lt(l),null;case 5:if(Qe(l),v=l.type,n!==null&&l.stateNode!=null)n.memoizedProps!==p&&oa(l);else{if(!p){if(l.stateNode===null)throw Error(s(166));return Lt(l),null}if(y=se.current,ic(l))bA(l);else{var A=up(re.current);switch(y){case 1:y=A.createElementNS("http://www.w3.org/2000/svg",v);break;case 2:y=A.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;default:switch(v){case"svg":y=A.createElementNS("http://www.w3.org/2000/svg",v);break;case"math":y=A.createElementNS("http://www.w3.org/1998/Math/MathML",v);break;case"script":y=A.createElement("div"),y.innerHTML="<script><\/script>",y=y.removeChild(y.firstChild);break;case"select":y=typeof p.is=="string"?A.createElement("select",{is:p.is}):A.createElement("select"),p.multiple?y.multiple=!0:p.size&&(y.size=p.size);break;default:y=typeof p.is=="string"?A.createElement(v,{is:p.is}):A.createElement(v)}}y[ys]=l,y[Vs]=p;e:for(A=l.child;A!==null;){if(A.tag===5||A.tag===6)y.appendChild(A.stateNode);else if(A.tag!==4&&A.tag!==27&&A.child!==null){A.child.return=A,A=A.child;continue}if(A===l)break e;for(;A.sibling===null;){if(A.return===null||A.return===l)break e;A=A.return}A.sibling.return=A.return,A=A.sibling}l.stateNode=y;e:switch(bs(y,v,p),v){case"button":case"input":case"select":case"textarea":p=!!p.autoFocus;break e;case"img":p=!0;break e;default:p=!1}p&&oa(l)}}return Lt(l),ly(l,l.type,n===null?null:n.memoizedProps,l.pendingProps,d),null;case 6:if(n&&l.stateNode!=null)n.memoizedProps!==p&&oa(l);else{if(typeof p!="string"&&l.stateNode===null)throw Error(s(166));if(n=re.current,ic(l)){if(n=l.stateNode,d=l.memoizedProps,p=null,v=xs,v!==null)switch(v.tag){case 27:case 5:p=v.memoizedProps}n[ys]=l,n=!!(n.nodeValue===d||p!==null&&p.suppressHydrationWarning===!0||VC(n.nodeValue,d)),n||mn(l,!0)}else n=up(n).createTextNode(p),n[ys]=l,l.stateNode=n}return Lt(l),null;case 31:if(d=l.memoizedState,n===null||n.memoizedState!==null){if(p=ic(l),d!==null){if(n===null){if(!p)throw Error(s(318));if(n=l.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(s(557));n[ys]=l}else Do(),(l.flags&128)===0&&(l.memoizedState=null),l.flags|=4;Lt(l),n=!1}else d=vS(),n!==null&&n.memoizedState!==null&&(n.memoizedState.hydrationErrors=d),n=!0;if(!n)return l.flags&256?(ci(l),l):(ci(l),null);if((l.flags&128)!==0)throw Error(s(558))}return Lt(l),null;case 13:if(p=l.memoizedState,n===null||n.memoizedState!==null&&n.memoizedState.dehydrated!==null){if(v=ic(l),p!==null&&p.dehydrated!==null){if(n===null){if(!v)throw Error(s(318));if(v=l.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(s(317));v[ys]=l}else Do(),(l.flags&128)===0&&(l.memoizedState=null),l.flags|=4;Lt(l),v=!1}else v=vS(),n!==null&&n.memoizedState!==null&&(n.memoizedState.hydrationErrors=v),v=!0;if(!v)return l.flags&256?(ci(l),l):(ci(l),null)}return ci(l),(l.flags&128)!==0?(l.lanes=d,l):(d=p!==null,n=n!==null&&n.memoizedState!==null,d&&(p=l.child,v=null,p.alternate!==null&&p.alternate.memoizedState!==null&&p.alternate.memoizedState.cachePool!==null&&(v=p.alternate.memoizedState.cachePool.pool),y=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(y=p.memoizedState.cachePool.pool),y!==v&&(p.flags|=2048)),d!==n&&d&&(l.child.flags|=8192),Km(l,l.updateQueue),Lt(l),null);case 4:return Me(),n===null&&Ry(l.stateNode.containerInfo),Lt(l),null;case 10:return ia(l.type),Lt(l),null;case 19:if(U(Kt),p=l.memoizedState,p===null)return Lt(l),null;if(v=(l.flags&128)!==0,y=p.rendering,y===null)if(v)Nu(p,!1);else{if(qt!==0||n!==null&&(n.flags&128)!==0)for(n=l.child;n!==null;){if(y=Bm(n),y!==null){for(l.flags|=128,Nu(p,!1),n=y.updateQueue,l.updateQueue=n,Km(l,n),l.subtreeFlags=0,n=d,d=l.child;d!==null;)SA(d,n),d=d.sibling;return K(Kt,Kt.current&1|2),Ke&&ta(l,p.treeForkCount),l.child}n=n.sibling}p.tail!==null&&Wt()>tp&&(l.flags|=128,v=!0,Nu(p,!1),l.lanes=4194304)}else{if(!v)if(n=Bm(y),n!==null){if(l.flags|=128,v=!0,n=n.updateQueue,l.updateQueue=n,Km(l,n),Nu(p,!0),p.tail===null&&p.tailMode==="hidden"&&!y.alternate&&!Ke)return Lt(l),null}else 2*Wt()-p.renderingStartTime>tp&&d!==536870912&&(l.flags|=128,v=!0,Nu(p,!1),l.lanes=4194304);p.isBackwards?(y.sibling=l.child,l.child=y):(n=p.last,n!==null?n.sibling=y:l.child=y,p.last=y)}return p.tail!==null?(n=p.tail,p.rendering=n,p.tail=n.sibling,p.renderingStartTime=Wt(),n.sibling=null,d=Kt.current,K(Kt,v?d&1|2:d&1),Ke&&ta(l,p.treeForkCount),n):(Lt(l),null);case 22:case 23:return ci(l),MS(),p=l.memoizedState!==null,n!==null?n.memoizedState!==null!==p&&(l.flags|=8192):p&&(l.flags|=8192),p?(d&536870912)!==0&&(l.flags&128)===0&&(Lt(l),l.subtreeFlags&6&&(l.flags|=8192)):Lt(l),d=l.updateQueue,d!==null&&Km(l,d.retryQueue),d=null,n!==null&&n.memoizedState!==null&&n.memoizedState.cachePool!==null&&(d=n.memoizedState.cachePool.pool),p=null,l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(p=l.memoizedState.cachePool.pool),p!==d&&(l.flags|=2048),n!==null&&U(Mo),null;case 24:return d=null,n!==null&&(d=n.memoizedState.cache),l.memoizedState.cache!==d&&(l.flags|=2048),ia(es),Lt(l),null;case 25:return null;case 30:return null}throw Error(s(156,l.tag))}function rO(n,l){switch(_S(l),l.tag){case 1:return n=l.flags,n&65536?(l.flags=n&-65537|128,l):null;case 3:return ia(es),Me(),n=l.flags,(n&65536)!==0&&(n&128)===0?(l.flags=n&-65537|128,l):null;case 26:case 27:case 5:return Qe(l),null;case 31:if(l.memoizedState!==null){if(ci(l),l.alternate===null)throw Error(s(340));Do()}return n=l.flags,n&65536?(l.flags=n&-65537|128,l):null;case 13:if(ci(l),n=l.memoizedState,n!==null&&n.dehydrated!==null){if(l.alternate===null)throw Error(s(340));Do()}return n=l.flags,n&65536?(l.flags=n&-65537|128,l):null;case 19:return U(Kt),null;case 4:return Me(),null;case 10:return ia(l.type),null;case 22:case 23:return ci(l),MS(),n!==null&&U(Mo),n=l.flags,n&65536?(l.flags=n&-65537|128,l):null;case 24:return ia(es),null;case 25:return null;default:return null}}function qw(n,l){switch(_S(l),l.tag){case 3:ia(es),Me();break;case 26:case 27:case 5:Qe(l);break;case 4:Me();break;case 31:l.memoizedState!==null&&ci(l);break;case 13:ci(l);break;case 19:U(Kt);break;case 10:ia(l.type);break;case 22:case 23:ci(l),MS(),n!==null&&U(Mo);break;case 24:ia(es)}}function Fu(n,l){try{var d=l.updateQueue,p=d!==null?d.lastEffect:null;if(p!==null){var v=p.next;d=v;do{if((d.tag&n)===n){p=void 0;var y=d.create,A=d.inst;p=y(),A.destroy=p}d=d.next}while(d!==v)}}catch(N){ft(l,l.return,N)}}function xn(n,l,d){try{var p=l.updateQueue,v=p!==null?p.lastEffect:null;if(v!==null){var y=v.next;p=y;do{if((p.tag&n)===n){var A=p.inst,N=A.destroy;if(N!==void 0){A.destroy=void 0,v=l;var V=d,Q=N;try{Q()}catch(oe){ft(v,V,oe)}}}p=p.next}while(p!==y)}}catch(oe){ft(l,l.return,oe)}}function Yw(n){var l=n.updateQueue;if(l!==null){var d=n.stateNode;try{BA(l,d)}catch(p){ft(n,n.return,p)}}}function jw(n,l,d){d.props=Fo(n.type,n.memoizedProps),d.state=n.memoizedState;try{d.componentWillUnmount()}catch(p){ft(n,l,p)}}function Bu(n,l){try{var d=n.ref;if(d!==null){switch(n.tag){case 26:case 27:case 5:var p=n.stateNode;break;case 30:p=n.stateNode;break;default:p=n.stateNode}typeof d=="function"?n.refCleanup=d(p):d.current=p}}catch(v){ft(n,l,v)}}function Ar(n,l){var d=n.ref,p=n.refCleanup;if(d!==null)if(typeof p=="function")try{p()}catch(v){ft(n,l,v)}finally{n.refCleanup=null,n=n.alternate,n!=null&&(n.refCleanup=null)}else if(typeof d=="function")try{d(null)}catch(v){ft(n,l,v)}else d.current=null}function $w(n){var l=n.type,d=n.memoizedProps,p=n.stateNode;try{e:switch(l){case"button":case"input":case"select":case"textarea":d.autoFocus&&p.focus();break e;case"img":d.src?p.src=d.src:d.srcSet&&(p.srcset=d.srcSet)}}catch(v){ft(n,n.return,v)}}function cy(n,l,d){try{var p=n.stateNode;wO(p,n.type,d,l),p[Vs]=l}catch(v){ft(n,n.return,v)}}function Kw(n){return n.tag===5||n.tag===3||n.tag===26||n.tag===27&&Dn(n.type)||n.tag===4}function hy(n){e:for(;;){for(;n.sibling===null;){if(n.return===null||Kw(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;n.tag!==5&&n.tag!==6&&n.tag!==18;){if(n.tag===27&&Dn(n.type)||n.flags&2||n.child===null||n.tag===4)continue e;n.child.return=n,n=n.child}if(!(n.flags&2))return n.stateNode}}function uy(n,l,d){var p=n.tag;if(p===5||p===6)n=n.stateNode,l?(d.nodeType===9?d.body:d.nodeName==="HTML"?d.ownerDocument.body:d).insertBefore(n,l):(l=d.nodeType===9?d.body:d.nodeName==="HTML"?d.ownerDocument.body:d,l.appendChild(n),d=d._reactRootContainer,d!=null||l.onclick!==null||(l.onclick=Qr));else if(p!==4&&(p===27&&Dn(n.type)&&(d=n.stateNode,l=null),n=n.child,n!==null))for(uy(n,l,d),n=n.sibling;n!==null;)uy(n,l,d),n=n.sibling}function Zm(n,l,d){var p=n.tag;if(p===5||p===6)n=n.stateNode,l?d.insertBefore(n,l):d.appendChild(n);else if(p!==4&&(p===27&&Dn(n.type)&&(d=n.stateNode),n=n.child,n!==null))for(Zm(n,l,d),n=n.sibling;n!==null;)Zm(n,l,d),n=n.sibling}function Zw(n){var l=n.stateNode,d=n.memoizedProps;try{for(var p=n.type,v=l.attributes;v.length;)l.removeAttributeNode(v[0]);bs(l,p,d),l[ys]=n,l[Vs]=d}catch(y){ft(n,n.return,y)}}var la=!1,is=!1,dy=!1,Qw=typeof WeakSet=="function"?WeakSet:Set,_s=null;function aO(n,l){if(n=n.containerInfo,Iy=vp,n=hA(n),aS(n)){if("selectionStart"in n)var d={start:n.selectionStart,end:n.selectionEnd};else e:{d=(d=n.ownerDocument)&&d.defaultView||window;var p=d.getSelection&&d.getSelection();if(p&&p.rangeCount!==0){d=p.anchorNode;var v=p.anchorOffset,y=p.focusNode;p=p.focusOffset;try{d.nodeType,y.nodeType}catch{d=null;break e}var A=0,N=-1,V=-1,Q=0,oe=0,he=n,te=null;t:for(;;){for(var ie;he!==d||v!==0&&he.nodeType!==3||(N=A+v),he!==y||p!==0&&he.nodeType!==3||(V=A+p),he.nodeType===3&&(A+=he.nodeValue.length),(ie=he.firstChild)!==null;)te=he,he=ie;for(;;){if(he===n)break t;if(te===d&&++Q===v&&(N=A),te===y&&++oe===p&&(V=A),(ie=he.nextSibling)!==null)break;he=te,te=he.parentNode}he=ie}d=N===-1||V===-1?null:{start:N,end:V}}else d=null}d=d||{start:0,end:0}}else d=null;for(Oy={focusedElem:n,selectionRange:d},vp=!1,_s=l;_s!==null;)if(l=_s,n=l.child,(l.subtreeFlags&1028)!==0&&n!==null)n.return=l,_s=n;else for(;_s!==null;){switch(l=_s,y=l.alternate,n=l.flags,l.tag){case 0:if((n&4)!==0&&(n=l.updateQueue,n=n!==null?n.events:null,n!==null))for(d=0;d<n.length;d++)v=n[d],v.ref.impl=v.nextImpl;break;case 11:case 15:break;case 1:if((n&1024)!==0&&y!==null){n=void 0,d=l,v=y.memoizedProps,y=y.memoizedState,p=d.stateNode;try{var Se=Fo(d.type,v);n=p.getSnapshotBeforeUpdate(Se,y),p.__reactInternalSnapshotBeforeUpdate=n}catch(Ce){ft(d,d.return,Ce)}}break;case 3:if((n&1024)!==0){if(n=l.stateNode.containerInfo,d=n.nodeType,d===9)By(n);else if(d===1)switch(n.nodeName){case"HEAD":case"HTML":case"BODY":By(n);break;default:n.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((n&1024)!==0)throw Error(s(163))}if(n=l.sibling,n!==null){n.return=l.return,_s=n;break}_s=l.return}}function Jw(n,l,d){var p=d.flags;switch(d.tag){case 0:case 11:case 15:ha(n,d),p&4&&Fu(5,d);break;case 1:if(ha(n,d),p&4)if(n=d.stateNode,l===null)try{n.componentDidMount()}catch(A){ft(d,d.return,A)}else{var v=Fo(d.type,l.memoizedProps);l=l.memoizedState;try{n.componentDidUpdate(v,l,n.__reactInternalSnapshotBeforeUpdate)}catch(A){ft(d,d.return,A)}}p&64&&Yw(d),p&512&&Bu(d,d.return);break;case 3:if(ha(n,d),p&64&&(n=d.updateQueue,n!==null)){if(l=null,d.child!==null)switch(d.child.tag){case 27:case 5:l=d.child.stateNode;break;case 1:l=d.child.stateNode}try{BA(n,l)}catch(A){ft(d,d.return,A)}}break;case 27:l===null&&p&4&&Zw(d);case 26:case 5:ha(n,d),l===null&&p&4&&$w(d),p&512&&Bu(d,d.return);break;case 12:ha(n,d);break;case 31:ha(n,d),p&4&&sC(n,d);break;case 13:ha(n,d),p&4&&iC(n,d),p&64&&(n=d.memoizedState,n!==null&&(n=n.dehydrated,n!==null&&(d=mO.bind(null,d),OO(n,d))));break;case 22:if(p=d.memoizedState!==null||la,!p){l=l!==null&&l.memoizedState!==null||is,v=la;var y=is;la=p,(is=l)&&!y?ua(n,d,(d.subtreeFlags&8772)!==0):ha(n,d),la=v,is=y}break;case 30:break;default:ha(n,d)}}function eC(n){var l=n.alternate;l!==null&&(n.alternate=null,eC(l)),n.child=null,n.deletions=null,n.sibling=null,n.tag===5&&(l=n.stateNode,l!==null&&Gv(l)),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}var Bt=null,Hs=!1;function ca(n,l,d){for(d=d.child;d!==null;)tC(n,l,d),d=d.sibling}function tC(n,l,d){if(ri&&typeof ri.onCommitFiberUnmount=="function")try{ri.onCommitFiberUnmount(ou,d)}catch{}switch(d.tag){case 26:is||Ar(d,l),ca(n,l,d),d.memoizedState?d.memoizedState.count--:d.stateNode&&(d=d.stateNode,d.parentNode.removeChild(d));break;case 27:is||Ar(d,l);var p=Bt,v=Hs;Dn(d.type)&&(Bt=d.stateNode,Hs=!1),ca(n,l,d),qu(d.stateNode),Bt=p,Hs=v;break;case 5:is||Ar(d,l);case 6:if(p=Bt,v=Hs,Bt=null,ca(n,l,d),Bt=p,Hs=v,Bt!==null)if(Hs)try{(Bt.nodeType===9?Bt.body:Bt.nodeName==="HTML"?Bt.ownerDocument.body:Bt).removeChild(d.stateNode)}catch(y){ft(d,l,y)}else try{Bt.removeChild(d.stateNode)}catch(y){ft(d,l,y)}break;case 18:Bt!==null&&(Hs?(n=Bt,YC(n.nodeType===9?n.body:n.nodeName==="HTML"?n.ownerDocument.body:n,d.stateNode),bc(n)):YC(Bt,d.stateNode));break;case 4:p=Bt,v=Hs,Bt=d.stateNode.containerInfo,Hs=!0,ca(n,l,d),Bt=p,Hs=v;break;case 0:case 11:case 14:case 15:xn(2,d,l),is||xn(4,d,l),ca(n,l,d);break;case 1:is||(Ar(d,l),p=d.stateNode,typeof p.componentWillUnmount=="function"&&jw(d,l,p)),ca(n,l,d);break;case 21:ca(n,l,d);break;case 22:is=(p=is)||d.memoizedState!==null,ca(n,l,d),is=p;break;default:ca(n,l,d)}}function sC(n,l){if(l.memoizedState===null&&(n=l.alternate,n!==null&&(n=n.memoizedState,n!==null))){n=n.dehydrated;try{bc(n)}catch(d){ft(l,l.return,d)}}}function iC(n,l){if(l.memoizedState===null&&(n=l.alternate,n!==null&&(n=n.memoizedState,n!==null&&(n=n.dehydrated,n!==null))))try{bc(n)}catch(d){ft(l,l.return,d)}}function nO(n){switch(n.tag){case 31:case 13:case 19:var l=n.stateNode;return l===null&&(l=n.stateNode=new Qw),l;case 22:return n=n.stateNode,l=n._retryCache,l===null&&(l=n._retryCache=new Qw),l;default:throw Error(s(435,n.tag))}}function Qm(n,l){var d=nO(n);l.forEach(function(p){if(!d.has(p)){d.add(p);var v=pO.bind(null,n,p);p.then(v,v)}})}function Ws(n,l){var d=l.deletions;if(d!==null)for(var p=0;p<d.length;p++){var v=d[p],y=n,A=l,N=A;e:for(;N!==null;){switch(N.tag){case 27:if(Dn(N.type)){Bt=N.stateNode,Hs=!1;break e}break;case 5:Bt=N.stateNode,Hs=!1;break e;case 3:case 4:Bt=N.stateNode.containerInfo,Hs=!0;break e}N=N.return}if(Bt===null)throw Error(s(160));tC(y,A,v),Bt=null,Hs=!1,y=v.alternate,y!==null&&(y.return=null),v.return=null}if(l.subtreeFlags&13886)for(l=l.child;l!==null;)rC(l,n),l=l.sibling}var er=null;function rC(n,l){var d=n.alternate,p=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:Ws(l,n),Xs(n),p&4&&(xn(3,n,n.return),Fu(3,n),xn(5,n,n.return));break;case 1:Ws(l,n),Xs(n),p&512&&(is||d===null||Ar(d,d.return)),p&64&&la&&(n=n.updateQueue,n!==null&&(p=n.callbacks,p!==null&&(d=n.shared.hiddenCallbacks,n.shared.hiddenCallbacks=d===null?p:d.concat(p))));break;case 26:var v=er;if(Ws(l,n),Xs(n),p&512&&(is||d===null||Ar(d,d.return)),p&4){var y=d!==null?d.memoizedState:null;if(p=n.memoizedState,d===null)if(p===null)if(n.stateNode===null){e:{p=n.type,d=n.memoizedProps,v=v.ownerDocument||v;t:switch(p){case"title":y=v.getElementsByTagName("title")[0],(!y||y[hu]||y[ys]||y.namespaceURI==="http://www.w3.org/2000/svg"||y.hasAttribute("itemprop"))&&(y=v.createElement(p),v.head.insertBefore(y,v.querySelector("head > title"))),bs(y,p,d),y[ys]=n,ps(y),p=y;break e;case"link":var A=r1("link","href",v).get(p+(d.href||""));if(A){for(var N=0;N<A.length;N++)if(y=A[N],y.getAttribute("href")===(d.href==null||d.href===""?null:d.href)&&y.getAttribute("rel")===(d.rel==null?null:d.rel)&&y.getAttribute("title")===(d.title==null?null:d.title)&&y.getAttribute("crossorigin")===(d.crossOrigin==null?null:d.crossOrigin)){A.splice(N,1);break t}}y=v.createElement(p),bs(y,p,d),v.head.appendChild(y);break;case"meta":if(A=r1("meta","content",v).get(p+(d.content||""))){for(N=0;N<A.length;N++)if(y=A[N],y.getAttribute("content")===(d.content==null?null:""+d.content)&&y.getAttribute("name")===(d.name==null?null:d.name)&&y.getAttribute("property")===(d.property==null?null:d.property)&&y.getAttribute("http-equiv")===(d.httpEquiv==null?null:d.httpEquiv)&&y.getAttribute("charset")===(d.charSet==null?null:d.charSet)){A.splice(N,1);break t}}y=v.createElement(p),bs(y,p,d),v.head.appendChild(y);break;default:throw Error(s(468,p))}y[ys]=n,ps(y),p=y}n.stateNode=p}else a1(v,n.type,n.stateNode);else n.stateNode=i1(v,p,n.memoizedProps);else y!==p?(y===null?d.stateNode!==null&&(d=d.stateNode,d.parentNode.removeChild(d)):y.count--,p===null?a1(v,n.type,n.stateNode):i1(v,p,n.memoizedProps)):p===null&&n.stateNode!==null&&cy(n,n.memoizedProps,d.memoizedProps)}break;case 27:Ws(l,n),Xs(n),p&512&&(is||d===null||Ar(d,d.return)),d!==null&&p&4&&cy(n,n.memoizedProps,d.memoizedProps);break;case 5:if(Ws(l,n),Xs(n),p&512&&(is||d===null||Ar(d,d.return)),n.flags&32){v=n.stateNode;try{Yl(v,"")}catch(Se){ft(n,n.return,Se)}}p&4&&n.stateNode!=null&&(v=n.memoizedProps,cy(n,v,d!==null?d.memoizedProps:v)),p&1024&&(dy=!0);break;case 6:if(Ws(l,n),Xs(n),p&4){if(n.stateNode===null)throw Error(s(162));p=n.memoizedProps,d=n.stateNode;try{d.nodeValue=p}catch(Se){ft(n,n.return,Se)}}break;case 3:if(mp=null,v=er,er=dp(l.containerInfo),Ws(l,n),er=v,Xs(n),p&4&&d!==null&&d.memoizedState.isDehydrated)try{bc(l.containerInfo)}catch(Se){ft(n,n.return,Se)}dy&&(dy=!1,aC(n));break;case 4:p=er,er=dp(n.stateNode.containerInfo),Ws(l,n),Xs(n),er=p;break;case 12:Ws(l,n),Xs(n);break;case 31:Ws(l,n),Xs(n),p&4&&(p=n.updateQueue,p!==null&&(n.updateQueue=null,Qm(n,p)));break;case 13:Ws(l,n),Xs(n),n.child.flags&8192&&n.memoizedState!==null!=(d!==null&&d.memoizedState!==null)&&(ep=Wt()),p&4&&(p=n.updateQueue,p!==null&&(n.updateQueue=null,Qm(n,p)));break;case 22:v=n.memoizedState!==null;var V=d!==null&&d.memoizedState!==null,Q=la,oe=is;if(la=Q||v,is=oe||V,Ws(l,n),is=oe,la=Q,Xs(n),p&8192)e:for(l=n.stateNode,l._visibility=v?l._visibility&-2:l._visibility|1,v&&(d===null||V||la||is||Bo(n)),d=null,l=n;;){if(l.tag===5||l.tag===26){if(d===null){V=d=l;try{if(y=V.stateNode,v)A=y.style,typeof A.setProperty=="function"?A.setProperty("display","none","important"):A.display="none";else{N=V.stateNode;var he=V.memoizedProps.style,te=he!=null&&he.hasOwnProperty("display")?he.display:null;N.style.display=te==null||typeof te=="boolean"?"":(""+te).trim()}}catch(Se){ft(V,V.return,Se)}}}else if(l.tag===6){if(d===null){V=l;try{V.stateNode.nodeValue=v?"":V.memoizedProps}catch(Se){ft(V,V.return,Se)}}}else if(l.tag===18){if(d===null){V=l;try{var ie=V.stateNode;v?jC(ie,!0):jC(V.stateNode,!1)}catch(Se){ft(V,V.return,Se)}}}else if((l.tag!==22&&l.tag!==23||l.memoizedState===null||l===n)&&l.child!==null){l.child.return=l,l=l.child;continue}if(l===n)break e;for(;l.sibling===null;){if(l.return===null||l.return===n)break e;d===l&&(d=null),l=l.return}d===l&&(d=null),l.sibling.return=l.return,l=l.sibling}p&4&&(p=n.updateQueue,p!==null&&(d=p.retryQueue,d!==null&&(p.retryQueue=null,Qm(n,d))));break;case 19:Ws(l,n),Xs(n),p&4&&(p=n.updateQueue,p!==null&&(n.updateQueue=null,Qm(n,p)));break;case 30:break;case 21:break;default:Ws(l,n),Xs(n)}}function Xs(n){var l=n.flags;if(l&2){try{for(var d,p=n.return;p!==null;){if(Kw(p)){d=p;break}p=p.return}if(d==null)throw Error(s(160));switch(d.tag){case 27:var v=d.stateNode,y=hy(n);Zm(n,y,v);break;case 5:var A=d.stateNode;d.flags&32&&(Yl(A,""),d.flags&=-33);var N=hy(n);Zm(n,N,A);break;case 3:case 4:var V=d.stateNode.containerInfo,Q=hy(n);uy(n,Q,V);break;default:throw Error(s(161))}}catch(oe){ft(n,n.return,oe)}n.flags&=-3}l&4096&&(n.flags&=-4097)}function aC(n){if(n.subtreeFlags&1024)for(n=n.child;n!==null;){var l=n;aC(l),l.tag===5&&l.flags&1024&&l.stateNode.reset(),n=n.sibling}}function ha(n,l){if(l.subtreeFlags&8772)for(l=l.child;l!==null;)Jw(n,l.alternate,l),l=l.sibling}function Bo(n){for(n=n.child;n!==null;){var l=n;switch(l.tag){case 0:case 11:case 14:case 15:xn(4,l,l.return),Bo(l);break;case 1:Ar(l,l.return);var d=l.stateNode;typeof d.componentWillUnmount=="function"&&jw(l,l.return,d),Bo(l);break;case 27:qu(l.stateNode);case 26:case 5:Ar(l,l.return),Bo(l);break;case 22:l.memoizedState===null&&Bo(l);break;case 30:Bo(l);break;default:Bo(l)}n=n.sibling}}function ua(n,l,d){for(d=d&&(l.subtreeFlags&8772)!==0,l=l.child;l!==null;){var p=l.alternate,v=n,y=l,A=y.flags;switch(y.tag){case 0:case 11:case 15:ua(v,y,d),Fu(4,y);break;case 1:if(ua(v,y,d),p=y,v=p.stateNode,typeof v.componentDidMount=="function")try{v.componentDidMount()}catch(Q){ft(p,p.return,Q)}if(p=y,v=p.updateQueue,v!==null){var N=p.stateNode;try{var V=v.shared.hiddenCallbacks;if(V!==null)for(v.shared.hiddenCallbacks=null,v=0;v<V.length;v++)FA(V[v],N)}catch(Q){ft(p,p.return,Q)}}d&&A&64&&Yw(y),Bu(y,y.return);break;case 27:Zw(y);case 26:case 5:ua(v,y,d),d&&p===null&&A&4&&$w(y),Bu(y,y.return);break;case 12:ua(v,y,d);break;case 31:ua(v,y,d),d&&A&4&&sC(v,y);break;case 13:ua(v,y,d),d&&A&4&&iC(v,y);break;case 22:y.memoizedState===null&&ua(v,y,d),Bu(y,y.return);break;case 30:break;default:ua(v,y,d)}l=l.sibling}}function fy(n,l){var d=null;n!==null&&n.memoizedState!==null&&n.memoizedState.cachePool!==null&&(d=n.memoizedState.cachePool.pool),n=null,l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(n=l.memoizedState.cachePool.pool),n!==d&&(n!=null&&n.refCount++,d!=null&&Eu(d))}function my(n,l){n=null,l.alternate!==null&&(n=l.alternate.memoizedState.cache),l=l.memoizedState.cache,l!==n&&(l.refCount++,n!=null&&Eu(n))}function tr(n,l,d,p){if(l.subtreeFlags&10256)for(l=l.child;l!==null;)nC(n,l,d,p),l=l.sibling}function nC(n,l,d,p){var v=l.flags;switch(l.tag){case 0:case 11:case 15:tr(n,l,d,p),v&2048&&Fu(9,l);break;case 1:tr(n,l,d,p);break;case 3:tr(n,l,d,p),v&2048&&(n=null,l.alternate!==null&&(n=l.alternate.memoizedState.cache),l=l.memoizedState.cache,l!==n&&(l.refCount++,n!=null&&Eu(n)));break;case 12:if(v&2048){tr(n,l,d,p),n=l.stateNode;try{var y=l.memoizedProps,A=y.id,N=y.onPostCommit;typeof N=="function"&&N(A,l.alternate===null?"mount":"update",n.passiveEffectDuration,-0)}catch(V){ft(l,l.return,V)}}else tr(n,l,d,p);break;case 31:tr(n,l,d,p);break;case 13:tr(n,l,d,p);break;case 23:break;case 22:y=l.stateNode,A=l.alternate,l.memoizedState!==null?y._visibility&2?tr(n,l,d,p):Uu(n,l):y._visibility&2?tr(n,l,d,p):(y._visibility|=2,fc(n,l,d,p,(l.subtreeFlags&10256)!==0||!1)),v&2048&&fy(A,l);break;case 24:tr(n,l,d,p),v&2048&&my(l.alternate,l);break;default:tr(n,l,d,p)}}function fc(n,l,d,p,v){for(v=v&&((l.subtreeFlags&10256)!==0||!1),l=l.child;l!==null;){var y=n,A=l,N=d,V=p,Q=A.flags;switch(A.tag){case 0:case 11:case 15:fc(y,A,N,V,v),Fu(8,A);break;case 23:break;case 22:var oe=A.stateNode;A.memoizedState!==null?oe._visibility&2?fc(y,A,N,V,v):Uu(y,A):(oe._visibility|=2,fc(y,A,N,V,v)),v&&Q&2048&&fy(A.alternate,A);break;case 24:fc(y,A,N,V,v),v&&Q&2048&&my(A.alternate,A);break;default:fc(y,A,N,V,v)}l=l.sibling}}function Uu(n,l){if(l.subtreeFlags&10256)for(l=l.child;l!==null;){var d=n,p=l,v=p.flags;switch(p.tag){case 22:Uu(d,p),v&2048&&fy(p.alternate,p);break;case 24:Uu(d,p),v&2048&&my(p.alternate,p);break;default:Uu(d,p)}l=l.sibling}}var zu=8192;function mc(n,l,d){if(n.subtreeFlags&zu)for(n=n.child;n!==null;)oC(n,l,d),n=n.sibling}function oC(n,l,d){switch(n.tag){case 26:mc(n,l,d),n.flags&zu&&n.memoizedState!==null&&qO(d,er,n.memoizedState,n.memoizedProps);break;case 5:mc(n,l,d);break;case 3:case 4:var p=er;er=dp(n.stateNode.containerInfo),mc(n,l,d),er=p;break;case 22:n.memoizedState===null&&(p=n.alternate,p!==null&&p.memoizedState!==null?(p=zu,zu=16777216,mc(n,l,d),zu=p):mc(n,l,d));break;default:mc(n,l,d)}}function lC(n){var l=n.alternate;if(l!==null&&(n=l.child,n!==null)){l.child=null;do l=n.sibling,n.sibling=null,n=l;while(n!==null)}}function ku(n){var l=n.deletions;if((n.flags&16)!==0){if(l!==null)for(var d=0;d<l.length;d++){var p=l[d];_s=p,hC(p,n)}lC(n)}if(n.subtreeFlags&10256)for(n=n.child;n!==null;)cC(n),n=n.sibling}function cC(n){switch(n.tag){case 0:case 11:case 15:ku(n),n.flags&2048&&xn(9,n,n.return);break;case 3:ku(n);break;case 12:ku(n);break;case 22:var l=n.stateNode;n.memoizedState!==null&&l._visibility&2&&(n.return===null||n.return.tag!==13)?(l._visibility&=-3,Jm(n)):ku(n);break;default:ku(n)}}function Jm(n){var l=n.deletions;if((n.flags&16)!==0){if(l!==null)for(var d=0;d<l.length;d++){var p=l[d];_s=p,hC(p,n)}lC(n)}for(n=n.child;n!==null;){switch(l=n,l.tag){case 0:case 11:case 15:xn(8,l,l.return),Jm(l);break;case 22:d=l.stateNode,d._visibility&2&&(d._visibility&=-3,Jm(l));break;default:Jm(l)}n=n.sibling}}function hC(n,l){for(;_s!==null;){var d=_s;switch(d.tag){case 0:case 11:case 15:xn(8,d,l);break;case 23:case 22:if(d.memoizedState!==null&&d.memoizedState.cachePool!==null){var p=d.memoizedState.cachePool.pool;p!=null&&p.refCount++}break;case 24:Eu(d.memoizedState.cache)}if(p=d.child,p!==null)p.return=d,_s=p;else e:for(d=n;_s!==null;){p=_s;var v=p.sibling,y=p.return;if(eC(p),p===d){_s=null;break e}if(v!==null){v.return=y,_s=v;break e}_s=y}}}var oO={getCacheForType:function(n){var l=Ts(es),d=l.data.get(n);return d===void 0&&(d=n(),l.data.set(n,d)),d},cacheSignal:function(){return Ts(es).controller.signal}},lO=typeof WeakMap=="function"?WeakMap:Map,at=0,St=null,Xe=null,Ye=0,dt=0,hi=null,Tn=!1,pc=!1,py=!1,da=0,qt=0,En=0,Uo=0,_y=0,ui=0,_c=0,Vu=null,qs=null,gy=!1,ep=0,uC=0,tp=1/0,sp=null,bn=null,cs=0,An=null,gc=null,fa=0,vy=0,Sy=null,dC=null,Gu=0,yy=null;function di(){return(at&2)!==0&&Ye!==0?Ye&-Ye:k.T!==null?wy():Db()}function fC(){if(ui===0)if((Ye&536870912)===0||Ke){var n=hm;hm<<=1,(hm&3932160)===0&&(hm=262144),ui=n}else ui=536870912;return n=li.current,n!==null&&(n.flags|=32),ui}function Ys(n,l,d){(n===St&&(dt===2||dt===9)||n.cancelPendingCommit!==null)&&(vc(n,0),wn(n,Ye,ui,!1)),cu(n,d),((at&2)===0||n!==St)&&(n===St&&((at&2)===0&&(Uo|=d),qt===4&&wn(n,Ye,ui,!1)),wr(n))}function mC(n,l,d){if((at&6)!==0)throw Error(s(327));var p=!d&&(l&127)===0&&(l&n.expiredLanes)===0||lu(n,l),v=p?uO(n,l):Ty(n,l,!0),y=p;do{if(v===0){pc&&!p&&wn(n,l,0,!1);break}else{if(d=n.current.alternate,y&&!cO(d)){v=Ty(n,l,!1),y=!1;continue}if(v===2){if(y=l,n.errorRecoveryDisabledLanes&y)var A=0;else A=n.pendingLanes&-536870913,A=A!==0?A:A&536870912?536870912:0;if(A!==0){l=A;e:{var N=n;v=Vu;var V=N.current.memoizedState.isDehydrated;if(V&&(vc(N,A).flags|=256),A=Ty(N,A,!1),A!==2){if(py&&!V){N.errorRecoveryDisabledLanes|=y,Uo|=y,v=4;break e}y=qs,qs=v,y!==null&&(qs===null?qs=y:qs.push.apply(qs,y))}v=A}if(y=!1,v!==2)continue}}if(v===1){vc(n,0),wn(n,l,0,!0);break}e:{switch(p=n,y=v,y){case 0:case 1:throw Error(s(345));case 4:if((l&4194048)!==l)break;case 6:wn(p,l,ui,!Tn);break e;case 2:qs=null;break;case 3:case 5:break;default:throw Error(s(329))}if((l&62914560)===l&&(v=ep+300-Wt(),10<v)){if(wn(p,l,ui,!Tn),dm(p,0,!0)!==0)break e;fa=l,p.timeoutHandle=XC(pC.bind(null,p,d,qs,sp,gy,l,ui,Uo,_c,Tn,y,"Throttled",-0,0),v);break e}pC(p,d,qs,sp,gy,l,ui,Uo,_c,Tn,y,null,-0,0)}}break}while(!0);wr(n)}function pC(n,l,d,p,v,y,A,N,V,Q,oe,he,te,ie){if(n.timeoutHandle=-1,he=l.subtreeFlags,he&8192||(he&16785408)===16785408){he={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Qr},oC(l,y,he);var Se=(y&62914560)===y?ep-Wt():(y&4194048)===y?uC-Wt():0;if(Se=YO(he,Se),Se!==null){fa=y,n.cancelPendingCommit=Se(EC.bind(null,n,l,y,d,p,v,A,N,V,oe,he,null,te,ie)),wn(n,y,A,!Q);return}}EC(n,l,y,d,p,v,A,N,V)}function cO(n){for(var l=n;;){var d=l.tag;if((d===0||d===11||d===15)&&l.flags&16384&&(d=l.updateQueue,d!==null&&(d=d.stores,d!==null)))for(var p=0;p<d.length;p++){var v=d[p],y=v.getSnapshot;v=v.value;try{if(!ni(y(),v))return!1}catch{return!1}}if(d=l.child,l.subtreeFlags&16384&&d!==null)d.return=l,l=d;else{if(l===n)break;for(;l.sibling===null;){if(l.return===null||l.return===n)return!0;l=l.return}l.sibling.return=l.return,l=l.sibling}}return!0}function wn(n,l,d,p){l&=~_y,l&=~Uo,n.suspendedLanes|=l,n.pingedLanes&=~l,p&&(n.warmLanes|=l),p=n.expirationTimes;for(var v=l;0<v;){var y=31-ai(v),A=1<<y;p[y]=-1,v&=~A}d!==0&&Ab(n,d,l)}function ip(){return(at&6)===0?(Hu(0),!1):!0}function xy(){if(Xe!==null){if(dt===0)var n=Xe.return;else n=Xe,sa=Po=null,BS(n),lc=null,Au=0,n=Xe;for(;n!==null;)qw(n.alternate,n),n=n.return;Xe=null}}function vc(n,l){var d=n.timeoutHandle;d!==-1&&(n.timeoutHandle=-1,PO(d)),d=n.cancelPendingCommit,d!==null&&(n.cancelPendingCommit=null,d()),fa=0,xy(),St=n,Xe=d=ea(n.current,null),Ye=l,dt=0,hi=null,Tn=!1,pc=lu(n,l),py=!1,_c=ui=_y=Uo=En=qt=0,qs=Vu=null,gy=!1,(l&8)!==0&&(l|=l&32);var p=n.entangledLanes;if(p!==0)for(n=n.entanglements,p&=l;0<p;){var v=31-ai(p),y=1<<v;l|=n[v],p&=~y}return da=l,bm(),d}function _C(n,l){Ie=null,k.H=Iu,l===oc||l===Lm?(l=LA(),dt=3):l===AS?(l=LA(),dt=4):dt=l===JS?8:l!==null&&typeof l=="object"&&typeof l.then=="function"?6:1,hi=l,Xe===null&&(qt=1,qm(n,Di(l,n.current)))}function gC(){var n=li.current;return n===null?!0:(Ye&4194048)===Ye?Li===null:(Ye&62914560)===Ye||(Ye&536870912)!==0?n===Li:!1}function vC(){var n=k.H;return k.H=Iu,n===null?Iu:n}function SC(){var n=k.A;return k.A=oO,n}function rp(){qt=4,Tn||(Ye&4194048)!==Ye&&li.current!==null||(pc=!0),(En&134217727)===0&&(Uo&134217727)===0||St===null||wn(St,Ye,ui,!1)}function Ty(n,l,d){var p=at;at|=2;var v=vC(),y=SC();(St!==n||Ye!==l)&&(sp=null,vc(n,l)),l=!1;var A=qt;e:do try{if(dt!==0&&Xe!==null){var N=Xe,V=hi;switch(dt){case 8:xy(),A=6;break e;case 3:case 2:case 9:case 6:li.current===null&&(l=!0);var Q=dt;if(dt=0,hi=null,Sc(n,N,V,Q),d&&pc){A=0;break e}break;default:Q=dt,dt=0,hi=null,Sc(n,N,V,Q)}}hO(),A=qt;break}catch(oe){_C(n,oe)}while(!0);return l&&n.shellSuspendCounter++,sa=Po=null,at=p,k.H=v,k.A=y,Xe===null&&(St=null,Ye=0,bm()),A}function hO(){for(;Xe!==null;)yC(Xe)}function uO(n,l){var d=at;at|=2;var p=vC(),v=SC();St!==n||Ye!==l?(sp=null,tp=Wt()+500,vc(n,l)):pc=lu(n,l);e:do try{if(dt!==0&&Xe!==null){l=Xe;var y=hi;t:switch(dt){case 1:dt=0,hi=null,Sc(n,l,y,1);break;case 2:case 9:if(RA(y)){dt=0,hi=null,xC(l);break}l=function(){dt!==2&&dt!==9||St!==n||(dt=7),wr(n)},y.then(l,l);break e;case 3:dt=7;break e;case 4:dt=5;break e;case 7:RA(y)?(dt=0,hi=null,xC(l)):(dt=0,hi=null,Sc(n,l,y,7));break;case 5:var A=null;switch(Xe.tag){case 26:A=Xe.memoizedState;case 5:case 27:var N=Xe;if(A?n1(A):N.stateNode.complete){dt=0,hi=null;var V=N.sibling;if(V!==null)Xe=V;else{var Q=N.return;Q!==null?(Xe=Q,ap(Q)):Xe=null}break t}}dt=0,hi=null,Sc(n,l,y,5);break;case 6:dt=0,hi=null,Sc(n,l,y,6);break;case 8:xy(),qt=6;break e;default:throw Error(s(462))}}dO();break}catch(oe){_C(n,oe)}while(!0);return sa=Po=null,k.H=p,k.A=v,at=d,Xe!==null?0:(St=null,Ye=0,bm(),qt)}function dO(){for(;Xe!==null&&!au();)yC(Xe)}function yC(n){var l=Ww(n.alternate,n,da);n.memoizedProps=n.pendingProps,l===null?ap(n):Xe=l}function xC(n){var l=n,d=l.alternate;switch(l.tag){case 15:case 0:l=Uw(d,l,l.pendingProps,l.type,void 0,Ye);break;case 11:l=Uw(d,l,l.pendingProps,l.type.render,l.ref,Ye);break;case 5:BS(l);default:qw(d,l),l=Xe=SA(l,da),l=Ww(d,l,da)}n.memoizedProps=n.pendingProps,l===null?ap(n):Xe=l}function Sc(n,l,d,p){sa=Po=null,BS(l),lc=null,Au=0;var v=l.return;try{if(eO(n,v,l,d,Ye)){qt=1,qm(n,Di(d,n.current)),Xe=null;return}}catch(y){if(v!==null)throw Xe=v,y;qt=1,qm(n,Di(d,n.current)),Xe=null;return}l.flags&32768?(Ke||p===1?n=!0:pc||(Ye&536870912)!==0?n=!1:(Tn=n=!0,(p===2||p===9||p===3||p===6)&&(p=li.current,p!==null&&p.tag===13&&(p.flags|=16384))),TC(l,n)):ap(l)}function ap(n){var l=n;do{if((l.flags&32768)!==0){TC(l,Tn);return}n=l.return;var d=iO(l.alternate,l,da);if(d!==null){Xe=d;return}if(l=l.sibling,l!==null){Xe=l;return}Xe=l=n}while(l!==null);qt===0&&(qt=5)}function TC(n,l){do{var d=rO(n.alternate,n);if(d!==null){d.flags&=32767,Xe=d;return}if(d=n.return,d!==null&&(d.flags|=32768,d.subtreeFlags=0,d.deletions=null),!l&&(n=n.sibling,n!==null)){Xe=n;return}Xe=n=d}while(n!==null);qt=6,Xe=null}function EC(n,l,d,p,v,y,A,N,V){n.cancelPendingCommit=null;do np();while(cs!==0);if((at&6)!==0)throw Error(s(327));if(l!==null){if(l===n.current)throw Error(s(177));if(y=l.lanes|l.childLanes,y|=hS,XI(n,d,y,A,N,V),n===St&&(Xe=St=null,Ye=0),gc=l,An=n,fa=d,vy=y,Sy=v,dC=p,(l.subtreeFlags&10256)!==0||(l.flags&10256)!==0?(n.callbackNode=null,n.callbackPriority=0,_O(Kr,function(){return DC(),null})):(n.callbackNode=null,n.callbackPriority=0),p=(l.flags&13878)!==0,(l.subtreeFlags&13878)!==0||p){p=k.T,k.T=null,v=O.p,O.p=2,A=at,at|=4;try{aO(n,l,d)}finally{at=A,O.p=v,k.T=p}}cs=1,bC(),AC(),wC()}}function bC(){if(cs===1){cs=0;var n=An,l=gc,d=(l.flags&13878)!==0;if((l.subtreeFlags&13878)!==0||d){d=k.T,k.T=null;var p=O.p;O.p=2;var v=at;at|=4;try{rC(l,n);var y=Oy,A=hA(n.containerInfo),N=y.focusedElem,V=y.selectionRange;if(A!==N&&N&&N.ownerDocument&&cA(N.ownerDocument.documentElement,N)){if(V!==null&&aS(N)){var Q=V.start,oe=V.end;if(oe===void 0&&(oe=Q),"selectionStart"in N)N.selectionStart=Q,N.selectionEnd=Math.min(oe,N.value.length);else{var he=N.ownerDocument||document,te=he&&he.defaultView||window;if(te.getSelection){var ie=te.getSelection(),Se=N.textContent.length,Ce=Math.min(V.start,Se),gt=V.end===void 0?Ce:Math.min(V.end,Se);!ie.extend&&Ce>gt&&(A=gt,gt=Ce,Ce=A);var $=lA(N,Ce),W=lA(N,gt);if($&&W&&(ie.rangeCount!==1||ie.anchorNode!==$.node||ie.anchorOffset!==$.offset||ie.focusNode!==W.node||ie.focusOffset!==W.offset)){var Z=he.createRange();Z.setStart($.node,$.offset),ie.removeAllRanges(),Ce>gt?(ie.addRange(Z),ie.extend(W.node,W.offset)):(Z.setEnd(W.node,W.offset),ie.addRange(Z))}}}}for(he=[],ie=N;ie=ie.parentNode;)ie.nodeType===1&&he.push({element:ie,left:ie.scrollLeft,top:ie.scrollTop});for(typeof N.focus=="function"&&N.focus(),N=0;N<he.length;N++){var ce=he[N];ce.element.scrollLeft=ce.left,ce.element.scrollTop=ce.top}}vp=!!Iy,Oy=Iy=null}finally{at=v,O.p=p,k.T=d}}n.current=l,cs=2}}function AC(){if(cs===2){cs=0;var n=An,l=gc,d=(l.flags&8772)!==0;if((l.subtreeFlags&8772)!==0||d){d=k.T,k.T=null;var p=O.p;O.p=2;var v=at;at|=4;try{Jw(n,l.alternate,l)}finally{at=v,O.p=p,k.T=d}}cs=3}}function wC(){if(cs===4||cs===3){cs=0,am();var n=An,l=gc,d=fa,p=dC;(l.subtreeFlags&10256)!==0||(l.flags&10256)!==0?cs=5:(cs=0,gc=An=null,CC(n,n.pendingLanes));var v=n.pendingLanes;if(v===0&&(bn=null),kv(d),l=l.stateNode,ri&&typeof ri.onCommitFiberRoot=="function")try{ri.onCommitFiberRoot(ou,l,void 0,(l.current.flags&128)===128)}catch{}if(p!==null){l=k.T,v=O.p,O.p=2,k.T=null;try{for(var y=n.onRecoverableError,A=0;A<p.length;A++){var N=p[A];y(N.value,{componentStack:N.stack})}}finally{k.T=l,O.p=v}}(fa&3)!==0&&np(),wr(n),v=n.pendingLanes,(d&261930)!==0&&(v&42)!==0?n===yy?Gu++:(Gu=0,yy=n):Gu=0,Hu(0)}}function CC(n,l){(n.pooledCacheLanes&=l)===0&&(l=n.pooledCache,l!=null&&(n.pooledCache=null,Eu(l)))}function np(){return bC(),AC(),wC(),DC()}function DC(){if(cs!==5)return!1;var n=An,l=vy;vy=0;var d=kv(fa),p=k.T,v=O.p;try{O.p=32>d?32:d,k.T=null,d=Sy,Sy=null;var y=An,A=fa;if(cs=0,gc=An=null,fa=0,(at&6)!==0)throw Error(s(331));var N=at;if(at|=4,cC(y.current),nC(y,y.current,A,d),at=N,Hu(0,!1),ri&&typeof ri.onPostCommitFiberRoot=="function")try{ri.onPostCommitFiberRoot(ou,y)}catch{}return!0}finally{O.p=v,k.T=p,CC(n,l)}}function PC(n,l,d){l=Di(d,l),l=QS(n.stateNode,l,2),n=vn(n,l,2),n!==null&&(cu(n,2),wr(n))}function ft(n,l,d){if(n.tag===3)PC(n,n,d);else for(;l!==null;){if(l.tag===3){PC(l,n,d);break}else if(l.tag===1){var p=l.stateNode;if(typeof l.type.getDerivedStateFromError=="function"||typeof p.componentDidCatch=="function"&&(bn===null||!bn.has(p))){n=Di(d,n),d=Rw(2),p=vn(l,d,2),p!==null&&(Mw(d,p,l,n),cu(p,2),wr(p));break}}l=l.return}}function Ey(n,l,d){var p=n.pingCache;if(p===null){p=n.pingCache=new lO;var v=new Set;p.set(l,v)}else v=p.get(l),v===void 0&&(v=new Set,p.set(l,v));v.has(d)||(py=!0,v.add(d),n=fO.bind(null,n,l,d),l.then(n,n))}function fO(n,l,d){var p=n.pingCache;p!==null&&p.delete(l),n.pingedLanes|=n.suspendedLanes&d,n.warmLanes&=~d,St===n&&(Ye&d)===d&&(qt===4||qt===3&&(Ye&62914560)===Ye&&300>Wt()-ep?(at&2)===0&&vc(n,0):_y|=d,_c===Ye&&(_c=0)),wr(n)}function RC(n,l){l===0&&(l=bb()),n=wo(n,l),n!==null&&(cu(n,l),wr(n))}function mO(n){var l=n.memoizedState,d=0;l!==null&&(d=l.retryLane),RC(n,d)}function pO(n,l){var d=0;switch(n.tag){case 31:case 13:var p=n.stateNode,v=n.memoizedState;v!==null&&(d=v.retryLane);break;case 19:p=n.stateNode;break;case 22:p=n.stateNode._retryCache;break;default:throw Error(s(314))}p!==null&&p.delete(l),RC(n,d)}function _O(n,l){return ln(n,l)}var op=null,yc=null,by=!1,lp=!1,Ay=!1,Cn=0;function wr(n){n!==yc&&n.next===null&&(yc===null?op=yc=n:yc=yc.next=n),lp=!0,by||(by=!0,vO())}function Hu(n,l){if(!Ay&&lp){Ay=!0;do for(var d=!1,p=op;p!==null;){if(n!==0){var v=p.pendingLanes;if(v===0)var y=0;else{var A=p.suspendedLanes,N=p.pingedLanes;y=(1<<31-ai(42|n)+1)-1,y&=v&~(A&~N),y=y&201326741?y&201326741|1:y?y|2:0}y!==0&&(d=!0,OC(p,y))}else y=Ye,y=dm(p,p===St?y:0,p.cancelPendingCommit!==null||p.timeoutHandle!==-1),(y&3)===0||lu(p,y)||(d=!0,OC(p,y));p=p.next}while(d);Ay=!1}}function gO(){MC()}function MC(){lp=by=!1;var n=0;Cn!==0&&DO()&&(n=Cn);for(var l=Wt(),d=null,p=op;p!==null;){var v=p.next,y=LC(p,l);y===0?(p.next=null,d===null?op=v:d.next=v,v===null&&(yc=d)):(d=p,(n!==0||(y&3)!==0)&&(lp=!0)),p=v}cs!==0&&cs!==5||Hu(n),Cn!==0&&(Cn=0)}function LC(n,l){for(var d=n.suspendedLanes,p=n.pingedLanes,v=n.expirationTimes,y=n.pendingLanes&-62914561;0<y;){var A=31-ai(y),N=1<<A,V=v[A];V===-1?((N&d)===0||(N&p)!==0)&&(v[A]=WI(N,l)):V<=l&&(n.expiredLanes|=N),y&=~N}if(l=St,d=Ye,d=dm(n,n===l?d:0,n.cancelPendingCommit!==null||n.timeoutHandle!==-1),p=n.callbackNode,d===0||n===l&&(dt===2||dt===9)||n.cancelPendingCommit!==null)return p!==null&&p!==null&&So(p),n.callbackNode=null,n.callbackPriority=0;if((d&3)===0||lu(n,d)){if(l=d&-d,l===n.callbackPriority)return l;switch(p!==null&&So(p),kv(d)){case 2:case 8:d=yo;break;case 32:d=Kr;break;case 268435456:d=nm;break;default:d=Kr}return p=IC.bind(null,n),d=ln(d,p),n.callbackPriority=l,n.callbackNode=d,l}return p!==null&&p!==null&&So(p),n.callbackPriority=2,n.callbackNode=null,2}function IC(n,l){if(cs!==0&&cs!==5)return n.callbackNode=null,n.callbackPriority=0,null;var d=n.callbackNode;if(np()&&n.callbackNode!==d)return null;var p=Ye;return p=dm(n,n===St?p:0,n.cancelPendingCommit!==null||n.timeoutHandle!==-1),p===0?null:(mC(n,p,l),LC(n,Wt()),n.callbackNode!=null&&n.callbackNode===d?IC.bind(null,n):null)}function OC(n,l){if(np())return null;mC(n,l,!0)}function vO(){RO(function(){(at&6)!==0?ln(tt,gO):MC()})}function wy(){if(Cn===0){var n=ac;n===0&&(n=cm,cm<<=1,(cm&261888)===0&&(cm=256)),Cn=n}return Cn}function NC(n){return n==null||typeof n=="symbol"||typeof n=="boolean"?null:typeof n=="function"?n:_m(""+n)}function FC(n,l){var d=l.ownerDocument.createElement("input");return d.name=l.name,d.value=l.value,n.id&&d.setAttribute("form",n.id),l.parentNode.insertBefore(d,l),n=new FormData(n),d.parentNode.removeChild(d),n}function SO(n,l,d,p,v){if(l==="submit"&&d&&d.stateNode===v){var y=NC((v[Vs]||null).action),A=p.submitter;A&&(l=(l=A[Vs]||null)?NC(l.formAction):A.getAttribute("formAction"),l!==null&&(y=l,A=null));var N=new ym("action","action",null,p,v);n.push({event:N,listeners:[{instance:null,listener:function(){if(p.defaultPrevented){if(Cn!==0){var V=A?FC(v,A):new FormData(v);qS(d,{pending:!0,data:V,method:v.method,action:y},null,V)}}else typeof y=="function"&&(N.preventDefault(),V=A?FC(v,A):new FormData(v),qS(d,{pending:!0,data:V,method:v.method,action:y},y,V))},currentTarget:v}]})}}for(var Cy=0;Cy<cS.length;Cy++){var Dy=cS[Cy],yO=Dy.toLowerCase(),xO=Dy[0].toUpperCase()+Dy.slice(1);Ji(yO,"on"+xO)}Ji(fA,"onAnimationEnd"),Ji(mA,"onAnimationIteration"),Ji(pA,"onAnimationStart"),Ji("dblclick","onDoubleClick"),Ji("focusin","onFocus"),Ji("focusout","onBlur"),Ji(B3,"onTransitionRun"),Ji(U3,"onTransitionStart"),Ji(z3,"onTransitionCancel"),Ji(_A,"onTransitionEnd"),Xl("onMouseEnter",["mouseout","mouseover"]),Xl("onMouseLeave",["mouseout","mouseover"]),Xl("onPointerEnter",["pointerout","pointerover"]),Xl("onPointerLeave",["pointerout","pointerover"]),To("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),To("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),To("onBeforeInput",["compositionend","keypress","textInput","paste"]),To("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),To("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),To("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Wu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),TO=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Wu));function BC(n,l){l=(l&4)!==0;for(var d=0;d<n.length;d++){var p=n[d],v=p.event;p=p.listeners;e:{var y=void 0;if(l)for(var A=p.length-1;0<=A;A--){var N=p[A],V=N.instance,Q=N.currentTarget;if(N=N.listener,V!==y&&v.isPropagationStopped())break e;y=N,v.currentTarget=Q;try{y(v)}catch(oe){Em(oe)}v.currentTarget=null,y=V}else for(A=0;A<p.length;A++){if(N=p[A],V=N.instance,Q=N.currentTarget,N=N.listener,V!==y&&v.isPropagationStopped())break e;y=N,v.currentTarget=Q;try{y(v)}catch(oe){Em(oe)}v.currentTarget=null,y=V}}}}function qe(n,l){var d=l[Vv];d===void 0&&(d=l[Vv]=new Set);var p=n+"__bubble";d.has(p)||(UC(l,n,2,!1),d.add(p))}function Py(n,l,d){var p=0;l&&(p|=4),UC(d,n,p,l)}var cp="_reactListening"+Math.random().toString(36).slice(2);function Ry(n){if(!n[cp]){n[cp]=!0,Mb.forEach(function(d){d!=="selectionchange"&&(TO.has(d)||Py(d,!1,n),Py(d,!0,n))});var l=n.nodeType===9?n:n.ownerDocument;l===null||l[cp]||(l[cp]=!0,Py("selectionchange",!1,l))}}function UC(n,l,d,p){switch(f1(l)){case 2:var v=KO;break;case 8:v=ZO;break;default:v=Xy}d=v.bind(null,l,d,n),v=void 0,!Kv||l!=="touchstart"&&l!=="touchmove"&&l!=="wheel"||(v=!0),p?v!==void 0?n.addEventListener(l,d,{capture:!0,passive:v}):n.addEventListener(l,d,!0):v!==void 0?n.addEventListener(l,d,{passive:v}):n.addEventListener(l,d,!1)}function My(n,l,d,p,v){var y=p;if((l&1)===0&&(l&2)===0&&p!==null)e:for(;;){if(p===null)return;var A=p.tag;if(A===3||A===4){var N=p.stateNode.containerInfo;if(N===v)break;if(A===4)for(A=p.return;A!==null;){var V=A.tag;if((V===3||V===4)&&A.stateNode.containerInfo===v)return;A=A.return}for(;N!==null;){if(A=Gl(N),A===null)return;if(V=A.tag,V===5||V===6||V===26||V===27){p=y=A;continue e}N=N.parentNode}}p=p.return}Hb(function(){var Q=y,oe=jv(d),he=[];e:{var te=gA.get(n);if(te!==void 0){var ie=ym,Se=n;switch(n){case"keypress":if(vm(d)===0)break e;case"keydown":case"keyup":ie=p3;break;case"focusin":Se="focus",ie=eS;break;case"focusout":Se="blur",ie=eS;break;case"beforeblur":case"afterblur":ie=eS;break;case"click":if(d.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ie=qb;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ie=i3;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ie=v3;break;case fA:case mA:case pA:ie=n3;break;case _A:ie=y3;break;case"scroll":case"scrollend":ie=t3;break;case"wheel":ie=T3;break;case"copy":case"cut":case"paste":ie=l3;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ie=jb;break;case"toggle":case"beforetoggle":ie=b3}var Ce=(l&4)!==0,gt=!Ce&&(n==="scroll"||n==="scrollend"),$=Ce?te!==null?te+"Capture":null:te;Ce=[];for(var W=Q,Z;W!==null;){var ce=W;if(Z=ce.stateNode,ce=ce.tag,ce!==5&&ce!==26&&ce!==27||Z===null||$===null||(ce=du(W,$),ce!=null&&Ce.push(Xu(W,ce,Z))),gt)break;W=W.return}0<Ce.length&&(te=new ie(te,Se,null,d,oe),he.push({event:te,listeners:Ce}))}}if((l&7)===0){e:{if(te=n==="mouseover"||n==="pointerover",ie=n==="mouseout"||n==="pointerout",te&&d!==Yv&&(Se=d.relatedTarget||d.fromElement)&&(Gl(Se)||Se[Vl]))break e;if((ie||te)&&(te=oe.window===oe?oe:(te=oe.ownerDocument)?te.defaultView||te.parentWindow:window,ie?(Se=d.relatedTarget||d.toElement,ie=Q,Se=Se?Gl(Se):null,Se!==null&&(gt=r(Se),Ce=Se.tag,Se!==gt||Ce!==5&&Ce!==27&&Ce!==6)&&(Se=null)):(ie=null,Se=Q),ie!==Se)){if(Ce=qb,ce="onMouseLeave",$="onMouseEnter",W="mouse",(n==="pointerout"||n==="pointerover")&&(Ce=jb,ce="onPointerLeave",$="onPointerEnter",W="pointer"),gt=ie==null?te:uu(ie),Z=Se==null?te:uu(Se),te=new Ce(ce,W+"leave",ie,d,oe),te.target=gt,te.relatedTarget=Z,ce=null,Gl(oe)===Q&&(Ce=new Ce($,W+"enter",Se,d,oe),Ce.target=Z,Ce.relatedTarget=gt,ce=Ce),gt=ce,ie&&Se)t:{for(Ce=EO,$=ie,W=Se,Z=0,ce=$;ce;ce=Ce(ce))Z++;ce=0;for(var we=W;we;we=Ce(we))ce++;for(;0<Z-ce;)$=Ce($),Z--;for(;0<ce-Z;)W=Ce(W),ce--;for(;Z--;){if($===W||W!==null&&$===W.alternate){Ce=$;break t}$=Ce($),W=Ce(W)}Ce=null}else Ce=null;ie!==null&&zC(he,te,ie,Ce,!1),Se!==null&&gt!==null&&zC(he,gt,Se,Ce,!0)}}e:{if(te=Q?uu(Q):window,ie=te.nodeName&&te.nodeName.toLowerCase(),ie==="select"||ie==="input"&&te.type==="file")var st=sA;else if(eA(te))if(iA)st=O3;else{st=L3;var xe=M3}else ie=te.nodeName,!ie||ie.toLowerCase()!=="input"||te.type!=="checkbox"&&te.type!=="radio"?Q&&qv(Q.elementType)&&(st=sA):st=I3;if(st&&(st=st(n,Q))){tA(he,st,d,oe);break e}xe&&xe(n,te,Q),n==="focusout"&&Q&&te.type==="number"&&Q.memoizedProps.value!=null&&Xv(te,"number",te.value)}switch(xe=Q?uu(Q):window,n){case"focusin":(eA(xe)||xe.contentEditable==="true")&&(Zl=xe,nS=Q,yu=null);break;case"focusout":yu=nS=Zl=null;break;case"mousedown":oS=!0;break;case"contextmenu":case"mouseup":case"dragend":oS=!1,uA(he,d,oe);break;case"selectionchange":if(F3)break;case"keydown":case"keyup":uA(he,d,oe)}var Fe;if(sS)e:{switch(n){case"compositionstart":var je="onCompositionStart";break e;case"compositionend":je="onCompositionEnd";break e;case"compositionupdate":je="onCompositionUpdate";break e}je=void 0}else Kl?Qb(n,d)&&(je="onCompositionEnd"):n==="keydown"&&d.keyCode===229&&(je="onCompositionStart");je&&($b&&d.locale!=="ko"&&(Kl||je!=="onCompositionStart"?je==="onCompositionEnd"&&Kl&&(Fe=Wb()):(un=oe,Zv="value"in un?un.value:un.textContent,Kl=!0)),xe=hp(Q,je),0<xe.length&&(je=new Yb(je,n,null,d,oe),he.push({event:je,listeners:xe}),Fe?je.data=Fe:(Fe=Jb(d),Fe!==null&&(je.data=Fe)))),(Fe=w3?C3(n,d):D3(n,d))&&(je=hp(Q,"onBeforeInput"),0<je.length&&(xe=new Yb("onBeforeInput","beforeinput",null,d,oe),he.push({event:xe,listeners:je}),xe.data=Fe)),SO(he,n,Q,d,oe)}BC(he,l)})}function Xu(n,l,d){return{instance:n,listener:l,currentTarget:d}}function hp(n,l){for(var d=l+"Capture",p=[];n!==null;){var v=n,y=v.stateNode;if(v=v.tag,v!==5&&v!==26&&v!==27||y===null||(v=du(n,d),v!=null&&p.unshift(Xu(n,v,y)),v=du(n,l),v!=null&&p.push(Xu(n,v,y))),n.tag===3)return p;n=n.return}return[]}function EO(n){if(n===null)return null;do n=n.return;while(n&&n.tag!==5&&n.tag!==27);return n||null}function zC(n,l,d,p,v){for(var y=l._reactName,A=[];d!==null&&d!==p;){var N=d,V=N.alternate,Q=N.stateNode;if(N=N.tag,V!==null&&V===p)break;N!==5&&N!==26&&N!==27||Q===null||(V=Q,v?(Q=du(d,y),Q!=null&&A.unshift(Xu(d,Q,V))):v||(Q=du(d,y),Q!=null&&A.push(Xu(d,Q,V)))),d=d.return}A.length!==0&&n.push({event:l,listeners:A})}var bO=/\r\n?/g,AO=/\u0000|\uFFFD/g;function kC(n){return(typeof n=="string"?n:""+n).replace(bO,`
`).replace(AO,"")}function VC(n,l){return l=kC(l),kC(n)===l}function _t(n,l,d,p,v,y){switch(d){case"children":typeof p=="string"?l==="body"||l==="textarea"&&p===""||Yl(n,p):(typeof p=="number"||typeof p=="bigint")&&l!=="body"&&Yl(n,""+p);break;case"className":mm(n,"class",p);break;case"tabIndex":mm(n,"tabindex",p);break;case"dir":case"role":case"viewBox":case"width":case"height":mm(n,d,p);break;case"style":Vb(n,p,y);break;case"data":if(l!=="object"){mm(n,"data",p);break}case"src":case"href":if(p===""&&(l!=="a"||d!=="href")){n.removeAttribute(d);break}if(p==null||typeof p=="function"||typeof p=="symbol"||typeof p=="boolean"){n.removeAttribute(d);break}p=_m(""+p),n.setAttribute(d,p);break;case"action":case"formAction":if(typeof p=="function"){n.setAttribute(d,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof y=="function"&&(d==="formAction"?(l!=="input"&&_t(n,l,"name",v.name,v,null),_t(n,l,"formEncType",v.formEncType,v,null),_t(n,l,"formMethod",v.formMethod,v,null),_t(n,l,"formTarget",v.formTarget,v,null)):(_t(n,l,"encType",v.encType,v,null),_t(n,l,"method",v.method,v,null),_t(n,l,"target",v.target,v,null)));if(p==null||typeof p=="symbol"||typeof p=="boolean"){n.removeAttribute(d);break}p=_m(""+p),n.setAttribute(d,p);break;case"onClick":p!=null&&(n.onclick=Qr);break;case"onScroll":p!=null&&qe("scroll",n);break;case"onScrollEnd":p!=null&&qe("scrollend",n);break;case"dangerouslySetInnerHTML":if(p!=null){if(typeof p!="object"||!("__html"in p))throw Error(s(61));if(d=p.__html,d!=null){if(v.children!=null)throw Error(s(60));n.innerHTML=d}}break;case"multiple":n.multiple=p&&typeof p!="function"&&typeof p!="symbol";break;case"muted":n.muted=p&&typeof p!="function"&&typeof p!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(p==null||typeof p=="function"||typeof p=="boolean"||typeof p=="symbol"){n.removeAttribute("xlink:href");break}d=_m(""+p),n.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",d);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":p!=null&&typeof p!="function"&&typeof p!="symbol"?n.setAttribute(d,""+p):n.removeAttribute(d);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":p&&typeof p!="function"&&typeof p!="symbol"?n.setAttribute(d,""):n.removeAttribute(d);break;case"capture":case"download":p===!0?n.setAttribute(d,""):p!==!1&&p!=null&&typeof p!="function"&&typeof p!="symbol"?n.setAttribute(d,p):n.removeAttribute(d);break;case"cols":case"rows":case"size":case"span":p!=null&&typeof p!="function"&&typeof p!="symbol"&&!isNaN(p)&&1<=p?n.setAttribute(d,p):n.removeAttribute(d);break;case"rowSpan":case"start":p==null||typeof p=="function"||typeof p=="symbol"||isNaN(p)?n.removeAttribute(d):n.setAttribute(d,p);break;case"popover":qe("beforetoggle",n),qe("toggle",n),fm(n,"popover",p);break;case"xlinkActuate":Zr(n,"http://www.w3.org/1999/xlink","xlink:actuate",p);break;case"xlinkArcrole":Zr(n,"http://www.w3.org/1999/xlink","xlink:arcrole",p);break;case"xlinkRole":Zr(n,"http://www.w3.org/1999/xlink","xlink:role",p);break;case"xlinkShow":Zr(n,"http://www.w3.org/1999/xlink","xlink:show",p);break;case"xlinkTitle":Zr(n,"http://www.w3.org/1999/xlink","xlink:title",p);break;case"xlinkType":Zr(n,"http://www.w3.org/1999/xlink","xlink:type",p);break;case"xmlBase":Zr(n,"http://www.w3.org/XML/1998/namespace","xml:base",p);break;case"xmlLang":Zr(n,"http://www.w3.org/XML/1998/namespace","xml:lang",p);break;case"xmlSpace":Zr(n,"http://www.w3.org/XML/1998/namespace","xml:space",p);break;case"is":fm(n,"is",p);break;case"innerText":case"textContent":break;default:(!(2<d.length)||d[0]!=="o"&&d[0]!=="O"||d[1]!=="n"&&d[1]!=="N")&&(d=JI.get(d)||d,fm(n,d,p))}}function Ly(n,l,d,p,v,y){switch(d){case"style":Vb(n,p,y);break;case"dangerouslySetInnerHTML":if(p!=null){if(typeof p!="object"||!("__html"in p))throw Error(s(61));if(d=p.__html,d!=null){if(v.children!=null)throw Error(s(60));n.innerHTML=d}}break;case"children":typeof p=="string"?Yl(n,p):(typeof p=="number"||typeof p=="bigint")&&Yl(n,""+p);break;case"onScroll":p!=null&&qe("scroll",n);break;case"onScrollEnd":p!=null&&qe("scrollend",n);break;case"onClick":p!=null&&(n.onclick=Qr);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Lb.hasOwnProperty(d))e:{if(d[0]==="o"&&d[1]==="n"&&(v=d.endsWith("Capture"),l=d.slice(2,v?d.length-7:void 0),y=n[Vs]||null,y=y!=null?y[d]:null,typeof y=="function"&&n.removeEventListener(l,y,v),typeof p=="function")){typeof y!="function"&&y!==null&&(d in n?n[d]=null:n.hasAttribute(d)&&n.removeAttribute(d)),n.addEventListener(l,p,v);break e}d in n?n[d]=p:p===!0?n.setAttribute(d,""):fm(n,d,p)}}}function bs(n,l,d){switch(l){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":qe("error",n),qe("load",n);var p=!1,v=!1,y;for(y in d)if(d.hasOwnProperty(y)){var A=d[y];if(A!=null)switch(y){case"src":p=!0;break;case"srcSet":v=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(s(137,l));default:_t(n,l,y,A,d,null)}}v&&_t(n,l,"srcSet",d.srcSet,d,null),p&&_t(n,l,"src",d.src,d,null);return;case"input":qe("invalid",n);var N=y=A=v=null,V=null,Q=null;for(p in d)if(d.hasOwnProperty(p)){var oe=d[p];if(oe!=null)switch(p){case"name":v=oe;break;case"type":A=oe;break;case"checked":V=oe;break;case"defaultChecked":Q=oe;break;case"value":y=oe;break;case"defaultValue":N=oe;break;case"children":case"dangerouslySetInnerHTML":if(oe!=null)throw Error(s(137,l));break;default:_t(n,l,p,oe,d,null)}}Bb(n,y,N,V,Q,A,v,!1);return;case"select":qe("invalid",n),p=A=y=null;for(v in d)if(d.hasOwnProperty(v)&&(N=d[v],N!=null))switch(v){case"value":y=N;break;case"defaultValue":A=N;break;case"multiple":p=N;default:_t(n,l,v,N,d,null)}l=y,d=A,n.multiple=!!p,l!=null?ql(n,!!p,l,!1):d!=null&&ql(n,!!p,d,!0);return;case"textarea":qe("invalid",n),y=v=p=null;for(A in d)if(d.hasOwnProperty(A)&&(N=d[A],N!=null))switch(A){case"value":p=N;break;case"defaultValue":v=N;break;case"children":y=N;break;case"dangerouslySetInnerHTML":if(N!=null)throw Error(s(91));break;default:_t(n,l,A,N,d,null)}zb(n,p,v,y);return;case"option":for(V in d)d.hasOwnProperty(V)&&(p=d[V],p!=null)&&(V==="selected"?n.selected=p&&typeof p!="function"&&typeof p!="symbol":_t(n,l,V,p,d,null));return;case"dialog":qe("beforetoggle",n),qe("toggle",n),qe("cancel",n),qe("close",n);break;case"iframe":case"object":qe("load",n);break;case"video":case"audio":for(p=0;p<Wu.length;p++)qe(Wu[p],n);break;case"image":qe("error",n),qe("load",n);break;case"details":qe("toggle",n);break;case"embed":case"source":case"link":qe("error",n),qe("load",n);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Q in d)if(d.hasOwnProperty(Q)&&(p=d[Q],p!=null))switch(Q){case"children":case"dangerouslySetInnerHTML":throw Error(s(137,l));default:_t(n,l,Q,p,d,null)}return;default:if(qv(l)){for(oe in d)d.hasOwnProperty(oe)&&(p=d[oe],p!==void 0&&Ly(n,l,oe,p,d,void 0));return}}for(N in d)d.hasOwnProperty(N)&&(p=d[N],p!=null&&_t(n,l,N,p,d,null))}function wO(n,l,d,p){switch(l){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var v=null,y=null,A=null,N=null,V=null,Q=null,oe=null;for(ie in d){var he=d[ie];if(d.hasOwnProperty(ie)&&he!=null)switch(ie){case"checked":break;case"value":break;case"defaultValue":V=he;default:p.hasOwnProperty(ie)||_t(n,l,ie,null,p,he)}}for(var te in p){var ie=p[te];if(he=d[te],p.hasOwnProperty(te)&&(ie!=null||he!=null))switch(te){case"type":y=ie;break;case"name":v=ie;break;case"checked":Q=ie;break;case"defaultChecked":oe=ie;break;case"value":A=ie;break;case"defaultValue":N=ie;break;case"children":case"dangerouslySetInnerHTML":if(ie!=null)throw Error(s(137,l));break;default:ie!==he&&_t(n,l,te,ie,p,he)}}Wv(n,A,N,V,Q,oe,y,v);return;case"select":ie=A=N=te=null;for(y in d)if(V=d[y],d.hasOwnProperty(y)&&V!=null)switch(y){case"value":break;case"multiple":ie=V;default:p.hasOwnProperty(y)||_t(n,l,y,null,p,V)}for(v in p)if(y=p[v],V=d[v],p.hasOwnProperty(v)&&(y!=null||V!=null))switch(v){case"value":te=y;break;case"defaultValue":N=y;break;case"multiple":A=y;default:y!==V&&_t(n,l,v,y,p,V)}l=N,d=A,p=ie,te!=null?ql(n,!!d,te,!1):!!p!=!!d&&(l!=null?ql(n,!!d,l,!0):ql(n,!!d,d?[]:"",!1));return;case"textarea":ie=te=null;for(N in d)if(v=d[N],d.hasOwnProperty(N)&&v!=null&&!p.hasOwnProperty(N))switch(N){case"value":break;case"children":break;default:_t(n,l,N,null,p,v)}for(A in p)if(v=p[A],y=d[A],p.hasOwnProperty(A)&&(v!=null||y!=null))switch(A){case"value":te=v;break;case"defaultValue":ie=v;break;case"children":break;case"dangerouslySetInnerHTML":if(v!=null)throw Error(s(91));break;default:v!==y&&_t(n,l,A,v,p,y)}Ub(n,te,ie);return;case"option":for(var Se in d)te=d[Se],d.hasOwnProperty(Se)&&te!=null&&!p.hasOwnProperty(Se)&&(Se==="selected"?n.selected=!1:_t(n,l,Se,null,p,te));for(V in p)te=p[V],ie=d[V],p.hasOwnProperty(V)&&te!==ie&&(te!=null||ie!=null)&&(V==="selected"?n.selected=te&&typeof te!="function"&&typeof te!="symbol":_t(n,l,V,te,p,ie));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Ce in d)te=d[Ce],d.hasOwnProperty(Ce)&&te!=null&&!p.hasOwnProperty(Ce)&&_t(n,l,Ce,null,p,te);for(Q in p)if(te=p[Q],ie=d[Q],p.hasOwnProperty(Q)&&te!==ie&&(te!=null||ie!=null))switch(Q){case"children":case"dangerouslySetInnerHTML":if(te!=null)throw Error(s(137,l));break;default:_t(n,l,Q,te,p,ie)}return;default:if(qv(l)){for(var gt in d)te=d[gt],d.hasOwnProperty(gt)&&te!==void 0&&!p.hasOwnProperty(gt)&&Ly(n,l,gt,void 0,p,te);for(oe in p)te=p[oe],ie=d[oe],!p.hasOwnProperty(oe)||te===ie||te===void 0&&ie===void 0||Ly(n,l,oe,te,p,ie);return}}for(var $ in d)te=d[$],d.hasOwnProperty($)&&te!=null&&!p.hasOwnProperty($)&&_t(n,l,$,null,p,te);for(he in p)te=p[he],ie=d[he],!p.hasOwnProperty(he)||te===ie||te==null&&ie==null||_t(n,l,he,te,p,ie)}function GC(n){switch(n){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function CO(){if(typeof performance.getEntriesByType=="function"){for(var n=0,l=0,d=performance.getEntriesByType("resource"),p=0;p<d.length;p++){var v=d[p],y=v.transferSize,A=v.initiatorType,N=v.duration;if(y&&N&&GC(A)){for(A=0,N=v.responseEnd,p+=1;p<d.length;p++){var V=d[p],Q=V.startTime;if(Q>N)break;var oe=V.transferSize,he=V.initiatorType;oe&&GC(he)&&(V=V.responseEnd,A+=oe*(V<N?1:(N-Q)/(V-Q)))}if(--p,l+=8*(y+A)/(v.duration/1e3),n++,10<n)break}}if(0<n)return l/n/1e6}return navigator.connection&&(n=navigator.connection.downlink,typeof n=="number")?n:5}var Iy=null,Oy=null;function up(n){return n.nodeType===9?n:n.ownerDocument}function HC(n){switch(n){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function WC(n,l){if(n===0)switch(l){case"svg":return 1;case"math":return 2;default:return 0}return n===1&&l==="foreignObject"?0:n}function Ny(n,l){return n==="textarea"||n==="noscript"||typeof l.children=="string"||typeof l.children=="number"||typeof l.children=="bigint"||typeof l.dangerouslySetInnerHTML=="object"&&l.dangerouslySetInnerHTML!==null&&l.dangerouslySetInnerHTML.__html!=null}var Fy=null;function DO(){var n=window.event;return n&&n.type==="popstate"?n===Fy?!1:(Fy=n,!0):(Fy=null,!1)}var XC=typeof setTimeout=="function"?setTimeout:void 0,PO=typeof clearTimeout=="function"?clearTimeout:void 0,qC=typeof Promise=="function"?Promise:void 0,RO=typeof queueMicrotask=="function"?queueMicrotask:typeof qC<"u"?function(n){return qC.resolve(null).then(n).catch(MO)}:XC;function MO(n){setTimeout(function(){throw n})}function Dn(n){return n==="head"}function YC(n,l){var d=l,p=0;do{var v=d.nextSibling;if(n.removeChild(d),v&&v.nodeType===8)if(d=v.data,d==="/$"||d==="/&"){if(p===0){n.removeChild(v),bc(l);return}p--}else if(d==="$"||d==="$?"||d==="$~"||d==="$!"||d==="&")p++;else if(d==="html")qu(n.ownerDocument.documentElement);else if(d==="head"){d=n.ownerDocument.head,qu(d);for(var y=d.firstChild;y;){var A=y.nextSibling,N=y.nodeName;y[hu]||N==="SCRIPT"||N==="STYLE"||N==="LINK"&&y.rel.toLowerCase()==="stylesheet"||d.removeChild(y),y=A}}else d==="body"&&qu(n.ownerDocument.body);d=v}while(d);bc(l)}function jC(n,l){var d=n;n=0;do{var p=d.nextSibling;if(d.nodeType===1?l?(d._stashedDisplay=d.style.display,d.style.display="none"):(d.style.display=d._stashedDisplay||"",d.getAttribute("style")===""&&d.removeAttribute("style")):d.nodeType===3&&(l?(d._stashedText=d.nodeValue,d.nodeValue=""):d.nodeValue=d._stashedText||""),p&&p.nodeType===8)if(d=p.data,d==="/$"){if(n===0)break;n--}else d!=="$"&&d!=="$?"&&d!=="$~"&&d!=="$!"||n++;d=p}while(d)}function By(n){var l=n.firstChild;for(l&&l.nodeType===10&&(l=l.nextSibling);l;){var d=l;switch(l=l.nextSibling,d.nodeName){case"HTML":case"HEAD":case"BODY":By(d),Gv(d);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(d.rel.toLowerCase()==="stylesheet")continue}n.removeChild(d)}}function LO(n,l,d,p){for(;n.nodeType===1;){var v=d;if(n.nodeName.toLowerCase()!==l.toLowerCase()){if(!p&&(n.nodeName!=="INPUT"||n.type!=="hidden"))break}else if(p){if(!n[hu])switch(l){case"meta":if(!n.hasAttribute("itemprop"))break;return n;case"link":if(y=n.getAttribute("rel"),y==="stylesheet"&&n.hasAttribute("data-precedence"))break;if(y!==v.rel||n.getAttribute("href")!==(v.href==null||v.href===""?null:v.href)||n.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin)||n.getAttribute("title")!==(v.title==null?null:v.title))break;return n;case"style":if(n.hasAttribute("data-precedence"))break;return n;case"script":if(y=n.getAttribute("src"),(y!==(v.src==null?null:v.src)||n.getAttribute("type")!==(v.type==null?null:v.type)||n.getAttribute("crossorigin")!==(v.crossOrigin==null?null:v.crossOrigin))&&y&&n.hasAttribute("async")&&!n.hasAttribute("itemprop"))break;return n;default:return n}}else if(l==="input"&&n.type==="hidden"){var y=v.name==null?null:""+v.name;if(v.type==="hidden"&&n.getAttribute("name")===y)return n}else return n;if(n=Ii(n.nextSibling),n===null)break}return null}function IO(n,l,d){if(l==="")return null;for(;n.nodeType!==3;)if((n.nodeType!==1||n.nodeName!=="INPUT"||n.type!=="hidden")&&!d||(n=Ii(n.nextSibling),n===null))return null;return n}function $C(n,l){for(;n.nodeType!==8;)if((n.nodeType!==1||n.nodeName!=="INPUT"||n.type!=="hidden")&&!l||(n=Ii(n.nextSibling),n===null))return null;return n}function Uy(n){return n.data==="$?"||n.data==="$~"}function zy(n){return n.data==="$!"||n.data==="$?"&&n.ownerDocument.readyState!=="loading"}function OO(n,l){var d=n.ownerDocument;if(n.data==="$~")n._reactRetry=l;else if(n.data!=="$?"||d.readyState!=="loading")l();else{var p=function(){l(),d.removeEventListener("DOMContentLoaded",p)};d.addEventListener("DOMContentLoaded",p),n._reactRetry=p}}function Ii(n){for(;n!=null;n=n.nextSibling){var l=n.nodeType;if(l===1||l===3)break;if(l===8){if(l=n.data,l==="$"||l==="$!"||l==="$?"||l==="$~"||l==="&"||l==="F!"||l==="F")break;if(l==="/$"||l==="/&")return null}}return n}var ky=null;function KC(n){n=n.nextSibling;for(var l=0;n;){if(n.nodeType===8){var d=n.data;if(d==="/$"||d==="/&"){if(l===0)return Ii(n.nextSibling);l--}else d!=="$"&&d!=="$!"&&d!=="$?"&&d!=="$~"&&d!=="&"||l++}n=n.nextSibling}return null}function ZC(n){n=n.previousSibling;for(var l=0;n;){if(n.nodeType===8){var d=n.data;if(d==="$"||d==="$!"||d==="$?"||d==="$~"||d==="&"){if(l===0)return n;l--}else d!=="/$"&&d!=="/&"||l++}n=n.previousSibling}return null}function QC(n,l,d){switch(l=up(d),n){case"html":if(n=l.documentElement,!n)throw Error(s(452));return n;case"head":if(n=l.head,!n)throw Error(s(453));return n;case"body":if(n=l.body,!n)throw Error(s(454));return n;default:throw Error(s(451))}}function qu(n){for(var l=n.attributes;l.length;)n.removeAttributeNode(l[0]);Gv(n)}var Oi=new Map,JC=new Set;function dp(n){return typeof n.getRootNode=="function"?n.getRootNode():n.nodeType===9?n:n.ownerDocument}var ma=O.d;O.d={f:NO,r:FO,D:BO,C:UO,L:zO,m:kO,X:GO,S:VO,M:HO};function NO(){var n=ma.f(),l=ip();return n||l}function FO(n){var l=Hl(n);l!==null&&l.tag===5&&l.type==="form"?_w(l):ma.r(n)}var xc=typeof document>"u"?null:document;function e1(n,l,d){var p=xc;if(p&&typeof l=="string"&&l){var v=wi(l);v='link[rel="'+n+'"][href="'+v+'"]',typeof d=="string"&&(v+='[crossorigin="'+d+'"]'),JC.has(v)||(JC.add(v),n={rel:n,crossOrigin:d,href:l},p.querySelector(v)===null&&(l=p.createElement("link"),bs(l,"link",n),ps(l),p.head.appendChild(l)))}}function BO(n){ma.D(n),e1("dns-prefetch",n,null)}function UO(n,l){ma.C(n,l),e1("preconnect",n,l)}function zO(n,l,d){ma.L(n,l,d);var p=xc;if(p&&n&&l){var v='link[rel="preload"][as="'+wi(l)+'"]';l==="image"&&d&&d.imageSrcSet?(v+='[imagesrcset="'+wi(d.imageSrcSet)+'"]',typeof d.imageSizes=="string"&&(v+='[imagesizes="'+wi(d.imageSizes)+'"]')):v+='[href="'+wi(n)+'"]';var y=v;switch(l){case"style":y=Tc(n);break;case"script":y=Ec(n)}Oi.has(y)||(n=m({rel:"preload",href:l==="image"&&d&&d.imageSrcSet?void 0:n,as:l},d),Oi.set(y,n),p.querySelector(v)!==null||l==="style"&&p.querySelector(Yu(y))||l==="script"&&p.querySelector(ju(y))||(l=p.createElement("link"),bs(l,"link",n),ps(l),p.head.appendChild(l)))}}function kO(n,l){ma.m(n,l);var d=xc;if(d&&n){var p=l&&typeof l.as=="string"?l.as:"script",v='link[rel="modulepreload"][as="'+wi(p)+'"][href="'+wi(n)+'"]',y=v;switch(p){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":y=Ec(n)}if(!Oi.has(y)&&(n=m({rel:"modulepreload",href:n},l),Oi.set(y,n),d.querySelector(v)===null)){switch(p){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(d.querySelector(ju(y)))return}p=d.createElement("link"),bs(p,"link",n),ps(p),d.head.appendChild(p)}}}function VO(n,l,d){ma.S(n,l,d);var p=xc;if(p&&n){var v=Wl(p).hoistableStyles,y=Tc(n);l=l||"default";var A=v.get(y);if(!A){var N={loading:0,preload:null};if(A=p.querySelector(Yu(y)))N.loading=5;else{n=m({rel:"stylesheet",href:n,"data-precedence":l},d),(d=Oi.get(y))&&Vy(n,d);var V=A=p.createElement("link");ps(V),bs(V,"link",n),V._p=new Promise(function(Q,oe){V.onload=Q,V.onerror=oe}),V.addEventListener("load",function(){N.loading|=1}),V.addEventListener("error",function(){N.loading|=2}),N.loading|=4,fp(A,l,p)}A={type:"stylesheet",instance:A,count:1,state:N},v.set(y,A)}}}function GO(n,l){ma.X(n,l);var d=xc;if(d&&n){var p=Wl(d).hoistableScripts,v=Ec(n),y=p.get(v);y||(y=d.querySelector(ju(v)),y||(n=m({src:n,async:!0},l),(l=Oi.get(v))&&Gy(n,l),y=d.createElement("script"),ps(y),bs(y,"link",n),d.head.appendChild(y)),y={type:"script",instance:y,count:1,state:null},p.set(v,y))}}function HO(n,l){ma.M(n,l);var d=xc;if(d&&n){var p=Wl(d).hoistableScripts,v=Ec(n),y=p.get(v);y||(y=d.querySelector(ju(v)),y||(n=m({src:n,async:!0,type:"module"},l),(l=Oi.get(v))&&Gy(n,l),y=d.createElement("script"),ps(y),bs(y,"link",n),d.head.appendChild(y)),y={type:"script",instance:y,count:1,state:null},p.set(v,y))}}function t1(n,l,d,p){var v=(v=re.current)?dp(v):null;if(!v)throw Error(s(446));switch(n){case"meta":case"title":return null;case"style":return typeof d.precedence=="string"&&typeof d.href=="string"?(l=Tc(d.href),d=Wl(v).hoistableStyles,p=d.get(l),p||(p={type:"style",instance:null,count:0,state:null},d.set(l,p)),p):{type:"void",instance:null,count:0,state:null};case"link":if(d.rel==="stylesheet"&&typeof d.href=="string"&&typeof d.precedence=="string"){n=Tc(d.href);var y=Wl(v).hoistableStyles,A=y.get(n);if(A||(v=v.ownerDocument||v,A={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},y.set(n,A),(y=v.querySelector(Yu(n)))&&!y._p&&(A.instance=y,A.state.loading=5),Oi.has(n)||(d={rel:"preload",as:"style",href:d.href,crossOrigin:d.crossOrigin,integrity:d.integrity,media:d.media,hrefLang:d.hrefLang,referrerPolicy:d.referrerPolicy},Oi.set(n,d),y||WO(v,n,d,A.state))),l&&p===null)throw Error(s(528,""));return A}if(l&&p!==null)throw Error(s(529,""));return null;case"script":return l=d.async,d=d.src,typeof d=="string"&&l&&typeof l!="function"&&typeof l!="symbol"?(l=Ec(d),d=Wl(v).hoistableScripts,p=d.get(l),p||(p={type:"script",instance:null,count:0,state:null},d.set(l,p)),p):{type:"void",instance:null,count:0,state:null};default:throw Error(s(444,n))}}function Tc(n){return'href="'+wi(n)+'"'}function Yu(n){return'link[rel="stylesheet"]['+n+"]"}function s1(n){return m({},n,{"data-precedence":n.precedence,precedence:null})}function WO(n,l,d,p){n.querySelector('link[rel="preload"][as="style"]['+l+"]")?p.loading=1:(l=n.createElement("link"),p.preload=l,l.addEventListener("load",function(){return p.loading|=1}),l.addEventListener("error",function(){return p.loading|=2}),bs(l,"link",d),ps(l),n.head.appendChild(l))}function Ec(n){return'[src="'+wi(n)+'"]'}function ju(n){return"script[async]"+n}function i1(n,l,d){if(l.count++,l.instance===null)switch(l.type){case"style":var p=n.querySelector('style[data-href~="'+wi(d.href)+'"]');if(p)return l.instance=p,ps(p),p;var v=m({},d,{"data-href":d.href,"data-precedence":d.precedence,href:null,precedence:null});return p=(n.ownerDocument||n).createElement("style"),ps(p),bs(p,"style",v),fp(p,d.precedence,n),l.instance=p;case"stylesheet":v=Tc(d.href);var y=n.querySelector(Yu(v));if(y)return l.state.loading|=4,l.instance=y,ps(y),y;p=s1(d),(v=Oi.get(v))&&Vy(p,v),y=(n.ownerDocument||n).createElement("link"),ps(y);var A=y;return A._p=new Promise(function(N,V){A.onload=N,A.onerror=V}),bs(y,"link",p),l.state.loading|=4,fp(y,d.precedence,n),l.instance=y;case"script":return y=Ec(d.src),(v=n.querySelector(ju(y)))?(l.instance=v,ps(v),v):(p=d,(v=Oi.get(y))&&(p=m({},d),Gy(p,v)),n=n.ownerDocument||n,v=n.createElement("script"),ps(v),bs(v,"link",p),n.head.appendChild(v),l.instance=v);case"void":return null;default:throw Error(s(443,l.type))}else l.type==="stylesheet"&&(l.state.loading&4)===0&&(p=l.instance,l.state.loading|=4,fp(p,d.precedence,n));return l.instance}function fp(n,l,d){for(var p=d.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),v=p.length?p[p.length-1]:null,y=v,A=0;A<p.length;A++){var N=p[A];if(N.dataset.precedence===l)y=N;else if(y!==v)break}y?y.parentNode.insertBefore(n,y.nextSibling):(l=d.nodeType===9?d.head:d,l.insertBefore(n,l.firstChild))}function Vy(n,l){n.crossOrigin==null&&(n.crossOrigin=l.crossOrigin),n.referrerPolicy==null&&(n.referrerPolicy=l.referrerPolicy),n.title==null&&(n.title=l.title)}function Gy(n,l){n.crossOrigin==null&&(n.crossOrigin=l.crossOrigin),n.referrerPolicy==null&&(n.referrerPolicy=l.referrerPolicy),n.integrity==null&&(n.integrity=l.integrity)}var mp=null;function r1(n,l,d){if(mp===null){var p=new Map,v=mp=new Map;v.set(d,p)}else v=mp,p=v.get(d),p||(p=new Map,v.set(d,p));if(p.has(n))return p;for(p.set(n,null),d=d.getElementsByTagName(n),v=0;v<d.length;v++){var y=d[v];if(!(y[hu]||y[ys]||n==="link"&&y.getAttribute("rel")==="stylesheet")&&y.namespaceURI!=="http://www.w3.org/2000/svg"){var A=y.getAttribute(l)||"";A=n+A;var N=p.get(A);N?N.push(y):p.set(A,[y])}}return p}function a1(n,l,d){n=n.ownerDocument||n,n.head.insertBefore(d,l==="title"?n.querySelector("head > title"):null)}function XO(n,l,d){if(d===1||l.itemProp!=null)return!1;switch(n){case"meta":case"title":return!0;case"style":if(typeof l.precedence!="string"||typeof l.href!="string"||l.href==="")break;return!0;case"link":if(typeof l.rel!="string"||typeof l.href!="string"||l.href===""||l.onLoad||l.onError)break;return l.rel==="stylesheet"?(n=l.disabled,typeof l.precedence=="string"&&n==null):!0;case"script":if(l.async&&typeof l.async!="function"&&typeof l.async!="symbol"&&!l.onLoad&&!l.onError&&l.src&&typeof l.src=="string")return!0}return!1}function n1(n){return!(n.type==="stylesheet"&&(n.state.loading&3)===0)}function qO(n,l,d,p){if(d.type==="stylesheet"&&(typeof p.media!="string"||matchMedia(p.media).matches!==!1)&&(d.state.loading&4)===0){if(d.instance===null){var v=Tc(p.href),y=l.querySelector(Yu(v));if(y){l=y._p,l!==null&&typeof l=="object"&&typeof l.then=="function"&&(n.count++,n=pp.bind(n),l.then(n,n)),d.state.loading|=4,d.instance=y,ps(y);return}y=l.ownerDocument||l,p=s1(p),(v=Oi.get(v))&&Vy(p,v),y=y.createElement("link"),ps(y);var A=y;A._p=new Promise(function(N,V){A.onload=N,A.onerror=V}),bs(y,"link",p),d.instance=y}n.stylesheets===null&&(n.stylesheets=new Map),n.stylesheets.set(d,l),(l=d.state.preload)&&(d.state.loading&3)===0&&(n.count++,d=pp.bind(n),l.addEventListener("load",d),l.addEventListener("error",d))}}var Hy=0;function YO(n,l){return n.stylesheets&&n.count===0&&gp(n,n.stylesheets),0<n.count||0<n.imgCount?function(d){var p=setTimeout(function(){if(n.stylesheets&&gp(n,n.stylesheets),n.unsuspend){var y=n.unsuspend;n.unsuspend=null,y()}},6e4+l);0<n.imgBytes&&Hy===0&&(Hy=62500*CO());var v=setTimeout(function(){if(n.waitingForImages=!1,n.count===0&&(n.stylesheets&&gp(n,n.stylesheets),n.unsuspend)){var y=n.unsuspend;n.unsuspend=null,y()}},(n.imgBytes>Hy?50:800)+l);return n.unsuspend=d,function(){n.unsuspend=null,clearTimeout(p),clearTimeout(v)}}:null}function pp(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)gp(this,this.stylesheets);else if(this.unsuspend){var n=this.unsuspend;this.unsuspend=null,n()}}}var _p=null;function gp(n,l){n.stylesheets=null,n.unsuspend!==null&&(n.count++,_p=new Map,l.forEach(jO,n),_p=null,pp.call(n))}function jO(n,l){if(!(l.state.loading&4)){var d=_p.get(n);if(d)var p=d.get(null);else{d=new Map,_p.set(n,d);for(var v=n.querySelectorAll("link[data-precedence],style[data-precedence]"),y=0;y<v.length;y++){var A=v[y];(A.nodeName==="LINK"||A.getAttribute("media")!=="not all")&&(d.set(A.dataset.precedence,A),p=A)}p&&d.set(null,p)}v=l.instance,A=v.getAttribute("data-precedence"),y=d.get(A)||p,y===p&&d.set(null,v),d.set(A,v),this.count++,p=pp.bind(this),v.addEventListener("load",p),v.addEventListener("error",p),y?y.parentNode.insertBefore(v,y.nextSibling):(n=n.nodeType===9?n.head:n,n.insertBefore(v,n.firstChild)),l.state.loading|=4}}var $u={$$typeof:C,Provider:null,Consumer:null,_currentValue:z,_currentValue2:z,_threadCount:0};function $O(n,l,d,p,v,y,A,N,V){this.tag=1,this.containerInfo=n,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Uv(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Uv(0),this.hiddenUpdates=Uv(null),this.identifierPrefix=p,this.onUncaughtError=v,this.onCaughtError=y,this.onRecoverableError=A,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=V,this.incompleteTransitions=new Map}function o1(n,l,d,p,v,y,A,N,V,Q,oe,he){return n=new $O(n,l,d,A,V,Q,oe,he,N),l=1,y===!0&&(l|=24),y=oi(3,null,null,l),n.current=y,y.stateNode=n,l=TS(),l.refCount++,n.pooledCache=l,l.refCount++,y.memoizedState={element:p,isDehydrated:d,cache:l},wS(y),n}function l1(n){return n?(n=ec,n):ec}function c1(n,l,d,p,v,y){v=l1(v),p.context===null?p.context=v:p.pendingContext=v,p=gn(l),p.payload={element:d},y=y===void 0?null:y,y!==null&&(p.callback=y),d=vn(n,p,l),d!==null&&(Ys(d,n,l),Cu(d,n,l))}function h1(n,l){if(n=n.memoizedState,n!==null&&n.dehydrated!==null){var d=n.retryLane;n.retryLane=d!==0&&d<l?d:l}}function Wy(n,l){h1(n,l),(n=n.alternate)&&h1(n,l)}function u1(n){if(n.tag===13||n.tag===31){var l=wo(n,67108864);l!==null&&Ys(l,n,67108864),Wy(n,67108864)}}function d1(n){if(n.tag===13||n.tag===31){var l=di();l=zv(l);var d=wo(n,l);d!==null&&Ys(d,n,l),Wy(n,l)}}var vp=!0;function KO(n,l,d,p){var v=k.T;k.T=null;var y=O.p;try{O.p=2,Xy(n,l,d,p)}finally{O.p=y,k.T=v}}function ZO(n,l,d,p){var v=k.T;k.T=null;var y=O.p;try{O.p=8,Xy(n,l,d,p)}finally{O.p=y,k.T=v}}function Xy(n,l,d,p){if(vp){var v=qy(p);if(v===null)My(n,l,p,Sp,d),m1(n,p);else if(JO(v,n,l,d,p))p.stopPropagation();else if(m1(n,p),l&4&&-1<QO.indexOf(n)){for(;v!==null;){var y=Hl(v);if(y!==null)switch(y.tag){case 3:if(y=y.stateNode,y.current.memoizedState.isDehydrated){var A=xo(y.pendingLanes);if(A!==0){var N=y;for(N.pendingLanes|=2,N.entangledLanes|=2;A;){var V=1<<31-ai(A);N.entanglements[1]|=V,A&=~V}wr(y),(at&6)===0&&(tp=Wt()+500,Hu(0))}}break;case 31:case 13:N=wo(y,2),N!==null&&Ys(N,y,2),ip(),Wy(y,2)}if(y=qy(p),y===null&&My(n,l,p,Sp,d),y===v)break;v=y}v!==null&&p.stopPropagation()}else My(n,l,p,null,d)}}function qy(n){return n=jv(n),Yy(n)}var Sp=null;function Yy(n){if(Sp=null,n=Gl(n),n!==null){var l=r(n);if(l===null)n=null;else{var d=l.tag;if(d===13){if(n=a(l),n!==null)return n;n=null}else if(d===31){if(n=o(l),n!==null)return n;n=null}else if(d===3){if(l.stateNode.current.memoizedState.isDehydrated)return l.tag===3?l.stateNode.containerInfo:null;n=null}else l!==n&&(n=null)}}return Sp=n,null}function f1(n){switch(n){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Tr()){case tt:return 2;case yo:return 8;case Kr:case nu:return 32;case nm:return 268435456;default:return 32}default:return 32}}var jy=!1,Pn=null,Rn=null,Mn=null,Ku=new Map,Zu=new Map,Ln=[],QO="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function m1(n,l){switch(n){case"focusin":case"focusout":Pn=null;break;case"dragenter":case"dragleave":Rn=null;break;case"mouseover":case"mouseout":Mn=null;break;case"pointerover":case"pointerout":Ku.delete(l.pointerId);break;case"gotpointercapture":case"lostpointercapture":Zu.delete(l.pointerId)}}function Qu(n,l,d,p,v,y){return n===null||n.nativeEvent!==y?(n={blockedOn:l,domEventName:d,eventSystemFlags:p,nativeEvent:y,targetContainers:[v]},l!==null&&(l=Hl(l),l!==null&&u1(l)),n):(n.eventSystemFlags|=p,l=n.targetContainers,v!==null&&l.indexOf(v)===-1&&l.push(v),n)}function JO(n,l,d,p,v){switch(l){case"focusin":return Pn=Qu(Pn,n,l,d,p,v),!0;case"dragenter":return Rn=Qu(Rn,n,l,d,p,v),!0;case"mouseover":return Mn=Qu(Mn,n,l,d,p,v),!0;case"pointerover":var y=v.pointerId;return Ku.set(y,Qu(Ku.get(y)||null,n,l,d,p,v)),!0;case"gotpointercapture":return y=v.pointerId,Zu.set(y,Qu(Zu.get(y)||null,n,l,d,p,v)),!0}return!1}function p1(n){var l=Gl(n.target);if(l!==null){var d=r(l);if(d!==null){if(l=d.tag,l===13){if(l=a(d),l!==null){n.blockedOn=l,Pb(n.priority,function(){d1(d)});return}}else if(l===31){if(l=o(d),l!==null){n.blockedOn=l,Pb(n.priority,function(){d1(d)});return}}else if(l===3&&d.stateNode.current.memoizedState.isDehydrated){n.blockedOn=d.tag===3?d.stateNode.containerInfo:null;return}}}n.blockedOn=null}function yp(n){if(n.blockedOn!==null)return!1;for(var l=n.targetContainers;0<l.length;){var d=qy(n.nativeEvent);if(d===null){d=n.nativeEvent;var p=new d.constructor(d.type,d);Yv=p,d.target.dispatchEvent(p),Yv=null}else return l=Hl(d),l!==null&&u1(l),n.blockedOn=d,!1;l.shift()}return!0}function _1(n,l,d){yp(n)&&d.delete(l)}function eN(){jy=!1,Pn!==null&&yp(Pn)&&(Pn=null),Rn!==null&&yp(Rn)&&(Rn=null),Mn!==null&&yp(Mn)&&(Mn=null),Ku.forEach(_1),Zu.forEach(_1)}function xp(n,l){n.blockedOn===l&&(n.blockedOn=null,jy||(jy=!0,c.unstable_scheduleCallback(c.unstable_NormalPriority,eN)))}var Tp=null;function g1(n){Tp!==n&&(Tp=n,c.unstable_scheduleCallback(c.unstable_NormalPriority,function(){Tp===n&&(Tp=null);for(var l=0;l<n.length;l+=3){var d=n[l],p=n[l+1],v=n[l+2];if(typeof p!="function"){if(Yy(p||d)===null)continue;break}var y=Hl(d);y!==null&&(n.splice(l,3),l-=3,qS(y,{pending:!0,data:v,method:d.method,action:p},p,v))}}))}function bc(n){function l(V){return xp(V,n)}Pn!==null&&xp(Pn,n),Rn!==null&&xp(Rn,n),Mn!==null&&xp(Mn,n),Ku.forEach(l),Zu.forEach(l);for(var d=0;d<Ln.length;d++){var p=Ln[d];p.blockedOn===n&&(p.blockedOn=null)}for(;0<Ln.length&&(d=Ln[0],d.blockedOn===null);)p1(d),d.blockedOn===null&&Ln.shift();if(d=(n.ownerDocument||n).$$reactFormReplay,d!=null)for(p=0;p<d.length;p+=3){var v=d[p],y=d[p+1],A=v[Vs]||null;if(typeof y=="function")A||g1(d);else if(A){var N=null;if(y&&y.hasAttribute("formAction")){if(v=y,A=y[Vs]||null)N=A.formAction;else if(Yy(v)!==null)continue}else N=A.action;typeof N=="function"?d[p+1]=N:(d.splice(p,3),p-=3),g1(d)}}}function v1(){function n(y){y.canIntercept&&y.info==="react-transition"&&y.intercept({handler:function(){return new Promise(function(A){return v=A})},focusReset:"manual",scroll:"manual"})}function l(){v!==null&&(v(),v=null),p||setTimeout(d,20)}function d(){if(!p&&!navigation.transition){var y=navigation.currentEntry;y&&y.url!=null&&navigation.navigate(y.url,{state:y.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var p=!1,v=null;return navigation.addEventListener("navigate",n),navigation.addEventListener("navigatesuccess",l),navigation.addEventListener("navigateerror",l),setTimeout(d,100),function(){p=!0,navigation.removeEventListener("navigate",n),navigation.removeEventListener("navigatesuccess",l),navigation.removeEventListener("navigateerror",l),v!==null&&(v(),v=null)}}}function $y(n){this._internalRoot=n}Ep.prototype.render=$y.prototype.render=function(n){var l=this._internalRoot;if(l===null)throw Error(s(409));var d=l.current,p=di();c1(d,p,n,l,null,null)},Ep.prototype.unmount=$y.prototype.unmount=function(){var n=this._internalRoot;if(n!==null){this._internalRoot=null;var l=n.containerInfo;c1(n.current,2,null,n,null,null),ip(),l[Vl]=null}};function Ep(n){this._internalRoot=n}Ep.prototype.unstable_scheduleHydration=function(n){if(n){var l=Db();n={blockedOn:null,target:n,priority:l};for(var d=0;d<Ln.length&&l!==0&&l<Ln[d].priority;d++);Ln.splice(d,0,n),d===0&&p1(n)}};var S1=e.version;if(S1!=="19.2.4")throw Error(s(527,S1,"19.2.4"));O.findDOMNode=function(n){var l=n._reactInternals;if(l===void 0)throw typeof n.render=="function"?Error(s(188)):(n=Object.keys(n).join(","),Error(s(268,n)));return n=u(l),n=n!==null?f(n):null,n=n===null?null:n.stateNode,n};var tN={bundleType:0,version:"19.2.4",rendererPackageName:"react-dom",currentDispatcherRef:k,reconcilerVersion:"19.2.4"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var bp=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!bp.isDisabled&&bp.supportsFiber)try{ou=bp.inject(tN),ri=bp}catch{}}return ed.createRoot=function(n,l){if(!i(n))throw Error(s(299));var d=!1,p="",v=ww,y=Cw,A=Dw;return l!=null&&(l.unstable_strictMode===!0&&(d=!0),l.identifierPrefix!==void 0&&(p=l.identifierPrefix),l.onUncaughtError!==void 0&&(v=l.onUncaughtError),l.onCaughtError!==void 0&&(y=l.onCaughtError),l.onRecoverableError!==void 0&&(A=l.onRecoverableError)),l=o1(n,1,!1,null,null,d,p,null,v,y,A,v1),n[Vl]=l.current,Ry(n),new $y(l)},ed.hydrateRoot=function(n,l,d){if(!i(n))throw Error(s(299));var p=!1,v="",y=ww,A=Cw,N=Dw,V=null;return d!=null&&(d.unstable_strictMode===!0&&(p=!0),d.identifierPrefix!==void 0&&(v=d.identifierPrefix),d.onUncaughtError!==void 0&&(y=d.onUncaughtError),d.onCaughtError!==void 0&&(A=d.onCaughtError),d.onRecoverableError!==void 0&&(N=d.onRecoverableError),d.formState!==void 0&&(V=d.formState)),l=o1(n,1,!0,l,d??null,p,v,V,y,A,N,v1),l.context=l1(null),d=l.current,p=di(),p=zv(p),v=gn(p),v.callback=null,vn(d,v,p),d=p,l.current.lanes=d,cu(l,d),wr(l),n[Vl]=l.current,Ry(n),new Ep(l)},ed.version="19.2.4",ed}var R1;function dN(){if(R1)return Qy.exports;R1=1;function c(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c)}catch(e){console.error(e)}}return c(),Qy.exports=uN(),Qy.exports}var fN=dN();var M1="popstate";function mN(c={}){function e(i,r){let{pathname:a="/",search:o="",hash:h=""}=Ll(i.location.hash.substring(1));return!a.startsWith("/")&&!a.startsWith(".")&&(a="/"+a),Mx("",{pathname:a,search:o,hash:h},r.state&&r.state.usr||null,r.state&&r.state.key||"default")}function t(i,r){let a=i.document.querySelector("base"),o="";if(a&&a.getAttribute("href")){let h=i.location.href,u=h.indexOf("#");o=u===-1?h:h.slice(0,u)}return o+"#"+(typeof r=="string"?r:Xd(r))}function s(i,r){ji(i.pathname.charAt(0)==="/",`relative pathnames are not supported in hash history.push(${JSON.stringify(r)})`)}return _N(e,t,s,c)}function Vt(c,e){if(c===!1||c===null||typeof c>"u")throw new Error(e)}function ji(c,e){if(!c){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function pN(){return Math.random().toString(36).substring(2,10)}function L1(c,e){return{usr:c.state,key:c.key,idx:e}}function Mx(c,e,t=null,s){return{pathname:typeof c=="string"?c:c.pathname,search:"",hash:"",...typeof e=="string"?Ll(e):e,state:t,key:e&&e.key||s||pN()}}function Xd({pathname:c="/",search:e="",hash:t=""}){return e&&e!=="?"&&(c+=e.charAt(0)==="?"?e:"?"+e),t&&t!=="#"&&(c+=t.charAt(0)==="#"?t:"#"+t),c}function Ll(c){let e={};if(c){let t=c.indexOf("#");t>=0&&(e.hash=c.substring(t),c=c.substring(0,t));let s=c.indexOf("?");s>=0&&(e.search=c.substring(s),c=c.substring(0,s)),c&&(e.pathname=c)}return e}function _N(c,e,t,s={}){let{window:i=document.defaultView,v5Compat:r=!1}=s,a=i.history,o="POP",h=null,u=f();u==null&&(u=0,a.replaceState({...a.state,idx:u},""));function f(){return(a.state||{idx:null}).idx}function m(){o="POP";let T=f(),E=T==null?null:T-u;u=T,h&&h({action:o,location:x.location,delta:E})}function _(T,E){o="PUSH";let b=Mx(x.location,T,E);t&&t(b,T),u=f()+1;let C=L1(b,u),w=x.createHref(b);try{a.pushState(C,"",w)}catch(P){if(P instanceof DOMException&&P.name==="DataCloneError")throw P;i.location.assign(w)}r&&h&&h({action:o,location:x.location,delta:1})}function g(T,E){o="REPLACE";let b=Mx(x.location,T,E);t&&t(b,T),u=f();let C=L1(b,u),w=x.createHref(b);a.replaceState(C,"",w),r&&h&&h({action:o,location:x.location,delta:0})}function S(T){return gN(T)}let x={get action(){return o},get location(){return c(i,a)},listen(T){if(h)throw new Error("A history only accepts one active listener");return i.addEventListener(M1,m),h=T,()=>{i.removeEventListener(M1,m),h=null}},createHref(T){return e(i,T)},createURL:S,encodeLocation(T){let E=S(T);return{pathname:E.pathname,search:E.search,hash:E.hash}},push:_,replace:g,go(T){return a.go(T)}};return x}function gN(c,e=!1){let t="http://localhost";typeof window<"u"&&(t=window.location.origin!=="null"?window.location.origin:window.location.href),Vt(t,"No window.location.(origin|href) available to create URL");let s=typeof c=="string"?c:Xd(c);return s=s.replace(/ $/,"%20"),!e&&s.startsWith("//")&&(s=t+s),new URL(s,t)}function pM(c,e,t="/"){return vN(c,e,t,!1)}function vN(c,e,t,s){let i=typeof e=="string"?Ll(e):e,r=ja(i.pathname||"/",t);if(r==null)return null;let a=_M(c);SN(a);let o=null;for(let h=0;o==null&&h<a.length;++h){let u=RN(r);o=DN(a[h],u,s)}return o}function _M(c,e=[],t=[],s="",i=!1){let r=(a,o,h=i,u)=>{let f={relativePath:u===void 0?a.path||"":u,caseSensitive:a.caseSensitive===!0,childrenIndex:o,route:a};if(f.relativePath.startsWith("/")){if(!f.relativePath.startsWith(s)&&h)return;Vt(f.relativePath.startsWith(s),`Absolute route path "${f.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),f.relativePath=f.relativePath.slice(s.length)}let m=za([s,f.relativePath]),_=t.concat(f);a.children&&a.children.length>0&&(Vt(a.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${m}".`),_M(a.children,e,_,m,h)),!(a.path==null&&!a.index)&&e.push({path:m,score:wN(m,a.index),routesMeta:_})};return c.forEach((a,o)=>{if(a.path===""||!a.path?.includes("?"))r(a,o);else for(let h of gM(a.path))r(a,o,!0,h)}),e}function gM(c){let e=c.split("/");if(e.length===0)return[];let[t,...s]=e,i=t.endsWith("?"),r=t.replace(/\?$/,"");if(s.length===0)return i?[r,""]:[r];let a=gM(s.join("/")),o=[];return o.push(...a.map(h=>h===""?r:[r,h].join("/"))),i&&o.push(...a),o.map(h=>c.startsWith("/")&&h===""?"/":h)}function SN(c){c.sort((e,t)=>e.score!==t.score?t.score-e.score:CN(e.routesMeta.map(s=>s.childrenIndex),t.routesMeta.map(s=>s.childrenIndex)))}var yN=/^:[\w-]+$/,xN=3,TN=2,EN=1,bN=10,AN=-2,I1=c=>c==="*";function wN(c,e){let t=c.split("/"),s=t.length;return t.some(I1)&&(s+=AN),e&&(s+=TN),t.filter(i=>!I1(i)).reduce((i,r)=>i+(yN.test(r)?xN:r===""?EN:bN),s)}function CN(c,e){return c.length===e.length&&c.slice(0,-1).every((s,i)=>s===e[i])?c[c.length-1]-e[e.length-1]:0}function DN(c,e,t=!1){let{routesMeta:s}=c,i={},r="/",a=[];for(let o=0;o<s.length;++o){let h=s[o],u=o===s.length-1,f=r==="/"?e:e.slice(r.length)||"/",m=k_({path:h.relativePath,caseSensitive:h.caseSensitive,end:u},f),_=h.route;if(!m&&u&&t&&!s[s.length-1].route.index&&(m=k_({path:h.relativePath,caseSensitive:h.caseSensitive,end:!1},f)),!m)return null;Object.assign(i,m.params),a.push({params:i,pathname:za([r,m.pathname]),pathnameBase:ON(za([r,m.pathnameBase])),route:_}),m.pathnameBase!=="/"&&(r=za([r,m.pathnameBase]))}return a}function k_(c,e){typeof c=="string"&&(c={path:c,caseSensitive:!1,end:!0});let[t,s]=PN(c.path,c.caseSensitive,c.end),i=e.match(t);if(!i)return null;let r=i[0],a=r.replace(/(.)\/+$/,"$1"),o=i.slice(1);return{params:s.reduce((u,{paramName:f,isOptional:m},_)=>{if(f==="*"){let S=o[_]||"";a=r.slice(0,r.length-S.length).replace(/(.)\/+$/,"$1")}const g=o[_];return m&&!g?u[f]=void 0:u[f]=(g||"").replace(/%2F/g,"/"),u},{}),pathname:r,pathnameBase:a,pattern:c}}function PN(c,e=!1,t=!0){ji(c==="*"||!c.endsWith("*")||c.endsWith("/*"),`Route path "${c}" will be treated as if it were "${c.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${c.replace(/\*$/,"/*")}".`);let s=[],i="^"+c.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(a,o,h)=>(s.push({paramName:o,isOptional:h!=null}),h?"/?([^\\/]+)?":"/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g,"(/$1)?$2");return c.endsWith("*")?(s.push({paramName:"*"}),i+=c==="*"||c==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?i+="\\/*$":c!==""&&c!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,e?void 0:"i"),s]}function RN(c){try{return c.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return ji(!1,`The URL path "${c}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),c}}function ja(c,e){if(e==="/")return c;if(!c.toLowerCase().startsWith(e.toLowerCase()))return null;let t=e.endsWith("/")?e.length-1:e.length,s=c.charAt(t);return s&&s!=="/"?null:c.slice(t)||"/"}var MN=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;function LN(c,e="/"){let{pathname:t,search:s="",hash:i=""}=typeof c=="string"?Ll(c):c,r;return t?(t=t.replace(/\/\/+/g,"/"),t.startsWith("/")?r=O1(t.substring(1),"/"):r=O1(t,e)):r=e,{pathname:r,search:NN(s),hash:FN(i)}}function O1(c,e){let t=e.replace(/\/+$/,"").split("/");return c.split("/").forEach(i=>{i===".."?t.length>1&&t.pop():i!=="."&&t.push(i)}),t.length>1?t.join("/"):"/"}function s0(c,e,t,s){return`Cannot include a '${c}' character in a manually specified \`to.${e}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function IN(c){return c.filter((e,t)=>t===0||e.route.path&&e.route.path.length>0)}function kT(c){let e=IN(c);return e.map((t,s)=>s===e.length-1?t.pathname:t.pathnameBase)}function VT(c,e,t,s=!1){let i;typeof c=="string"?i=Ll(c):(i={...c},Vt(!i.pathname||!i.pathname.includes("?"),s0("?","pathname","search",i)),Vt(!i.pathname||!i.pathname.includes("#"),s0("#","pathname","hash",i)),Vt(!i.search||!i.search.includes("#"),s0("#","search","hash",i)));let r=c===""||i.pathname==="",a=r?"/":i.pathname,o;if(a==null)o=t;else{let m=e.length-1;if(!s&&a.startsWith("..")){let _=a.split("/");for(;_[0]==="..";)_.shift(),m-=1;i.pathname=_.join("/")}o=m>=0?e[m]:"/"}let h=LN(i,o),u=a&&a!=="/"&&a.endsWith("/"),f=(r||a===".")&&t.endsWith("/");return!h.pathname.endsWith("/")&&(u||f)&&(h.pathname+="/"),h}var za=c=>c.join("/").replace(/\/\/+/g,"/"),ON=c=>c.replace(/\/+$/,"").replace(/^\/*/,"/"),NN=c=>!c||c==="?"?"":c.startsWith("?")?c:"?"+c,FN=c=>!c||c==="#"?"":c.startsWith("#")?c:"#"+c,BN=class{constructor(c,e,t,s=!1){this.status=c,this.statusText=e||"",this.internal=s,t instanceof Error?(this.data=t.toString(),this.error=t):this.data=t}};function UN(c){return c!=null&&typeof c.status=="number"&&typeof c.statusText=="string"&&typeof c.internal=="boolean"&&"data"in c}function zN(c){return c.map(e=>e.route.path).filter(Boolean).join("/").replace(/\/\/*/g,"/")||"/"}var vM=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";function SM(c,e){let t=c;if(typeof t!="string"||!MN.test(t))return{absoluteURL:void 0,isExternal:!1,to:t};let s=t,i=!1;if(vM)try{let r=new URL(window.location.href),a=t.startsWith("//")?new URL(r.protocol+t):new URL(t),o=ja(a.pathname,e);a.origin===r.origin&&o!=null?t=o+a.search+a.hash:i=!0}catch{ji(!1,`<Link to="${t}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}return{absoluteURL:s,isExternal:i,to:t}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var yM=["POST","PUT","PATCH","DELETE"];new Set(yM);var kN=["GET",...yM];new Set(kN);var Uh=q.createContext(null);Uh.displayName="DataRouter";var Rg=q.createContext(null);Rg.displayName="DataRouterState";var VN=q.createContext(!1),xM=q.createContext({isTransitioning:!1});xM.displayName="ViewTransition";var GN=q.createContext(new Map);GN.displayName="Fetchers";var HN=q.createContext(null);HN.displayName="Await";var Ei=q.createContext(null);Ei.displayName="Navigation";var Sf=q.createContext(null);Sf.displayName="Location";var Hr=q.createContext({outlet:null,matches:[],isDataRoute:!1});Hr.displayName="Route";var GT=q.createContext(null);GT.displayName="RouteError";var TM="REACT_ROUTER_ERROR",WN="REDIRECT",XN="ROUTE_ERROR_RESPONSE";function qN(c){if(c.startsWith(`${TM}:${WN}:{`))try{let e=JSON.parse(c.slice(28));if(typeof e=="object"&&e&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.location=="string"&&typeof e.reloadDocument=="boolean"&&typeof e.replace=="boolean")return e}catch{}}function YN(c){if(c.startsWith(`${TM}:${XN}:{`))try{let e=JSON.parse(c.slice(40));if(typeof e=="object"&&e&&typeof e.status=="number"&&typeof e.statusText=="string")return new BN(e.status,e.statusText,e.data)}catch{}}function jN(c,{relative:e}={}){Vt(zh(),"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:s}=q.useContext(Ei),{hash:i,pathname:r,search:a}=yf(c,{relative:e}),o=r;return t!=="/"&&(o=r==="/"?t:za([t,r])),s.createHref({pathname:o,search:a,hash:i})}function zh(){return q.useContext(Sf)!=null}function no(){return Vt(zh(),"useLocation() may be used only in the context of a <Router> component."),q.useContext(Sf).location}var EM="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function bM(c){q.useContext(Ei).static||q.useLayoutEffect(c)}function HT(){let{isDataRoute:c}=q.useContext(Hr);return c?oF():$N()}function $N(){Vt(zh(),"useNavigate() may be used only in the context of a <Router> component.");let c=q.useContext(Uh),{basename:e,navigator:t}=q.useContext(Ei),{matches:s}=q.useContext(Hr),{pathname:i}=no(),r=JSON.stringify(kT(s)),a=q.useRef(!1);return bM(()=>{a.current=!0}),q.useCallback((h,u={})=>{if(ji(a.current,EM),!a.current)return;if(typeof h=="number"){t.go(h);return}let f=VT(h,JSON.parse(r),i,u.relative==="path");c==null&&e!=="/"&&(f.pathname=f.pathname==="/"?e:za([e,f.pathname])),(u.replace?t.replace:t.push)(f,u.state,u)},[e,t,r,i,c])}q.createContext(null);function yf(c,{relative:e}={}){let{matches:t}=q.useContext(Hr),{pathname:s}=no(),i=JSON.stringify(kT(t));return q.useMemo(()=>VT(c,JSON.parse(i),s,e==="path"),[c,i,s,e])}function KN(c,e){return AM(c,e)}function AM(c,e,t,s,i){Vt(zh(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:r}=q.useContext(Ei),{matches:a}=q.useContext(Hr),o=a[a.length-1],h=o?o.params:{},u=o?o.pathname:"/",f=o?o.pathnameBase:"/",m=o&&o.route;{let b=m&&m.path||"";CM(u,!m||b.endsWith("*")||b.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${b}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${b}"> to <Route path="${b==="/"?"*":`${b}/*`}">.`)}let _=no(),g;if(e){let b=typeof e=="string"?Ll(e):e;Vt(f==="/"||b.pathname?.startsWith(f),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${f}" but pathname "${b.pathname}" was given in the \`location\` prop.`),g=b}else g=_;let S=g.pathname||"/",x=S;if(f!=="/"){let b=f.replace(/^\//,"").split("/");x="/"+S.replace(/^\//,"").split("/").slice(b.length).join("/")}let T=pM(c,{pathname:x});ji(m||T!=null,`No routes matched location "${g.pathname}${g.search}${g.hash}" `),ji(T==null||T[T.length-1].route.element!==void 0||T[T.length-1].route.Component!==void 0||T[T.length-1].route.lazy!==void 0,`Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let E=tF(T&&T.map(b=>Object.assign({},b,{params:Object.assign({},h,b.params),pathname:za([f,r.encodeLocation?r.encodeLocation(b.pathname.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:b.pathname]),pathnameBase:b.pathnameBase==="/"?f:za([f,r.encodeLocation?r.encodeLocation(b.pathnameBase.replace(/\?/g,"%3F").replace(/#/g,"%23")).pathname:b.pathnameBase])})),a,t,s,i);return e&&E?q.createElement(Sf.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...g},navigationType:"POP"}},E):E}function ZN(){let c=nF(),e=UN(c)?`${c.status} ${c.statusText}`:c instanceof Error?c.message:JSON.stringify(c),t=c instanceof Error?c.stack:null,s="rgba(200,200,200, 0.5)",i={padding:"0.5rem",backgroundColor:s},r={padding:"2px 4px",backgroundColor:s},a=null;return console.error("Error handled by React Router default ErrorBoundary:",c),a=q.createElement(q.Fragment,null,q.createElement("p",null," Hey developer "),q.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",q.createElement("code",{style:r},"ErrorBoundary")," or"," ",q.createElement("code",{style:r},"errorElement")," prop on your route.")),q.createElement(q.Fragment,null,q.createElement("h2",null,"Unexpected Application Error!"),q.createElement("h3",{style:{fontStyle:"italic"}},e),t?q.createElement("pre",{style:i},t):null,a)}var QN=q.createElement(ZN,null),wM=class extends q.Component{constructor(c){super(c),this.state={location:c.location,revalidation:c.revalidation,error:c.error}}static getDerivedStateFromError(c){return{error:c}}static getDerivedStateFromProps(c,e){return e.location!==c.location||e.revalidation!=="idle"&&c.revalidation==="idle"?{error:c.error,location:c.location,revalidation:c.revalidation}:{error:c.error!==void 0?c.error:e.error,location:e.location,revalidation:c.revalidation||e.revalidation}}componentDidCatch(c,e){this.props.onError?this.props.onError(c,e):console.error("React Router caught the following error during render",c)}render(){let c=this.state.error;if(this.context&&typeof c=="object"&&c&&"digest"in c&&typeof c.digest=="string"){const t=YN(c.digest);t&&(c=t)}let e=c!==void 0?q.createElement(Hr.Provider,{value:this.props.routeContext},q.createElement(GT.Provider,{value:c,children:this.props.component})):this.props.children;return this.context?q.createElement(JN,{error:c},e):e}};wM.contextType=VN;var i0=new WeakMap;function JN({children:c,error:e}){let{basename:t}=q.useContext(Ei);if(typeof e=="object"&&e&&"digest"in e&&typeof e.digest=="string"){let s=qN(e.digest);if(s){let i=i0.get(e);if(i)throw i;let r=SM(s.location,t);if(vM&&!i0.get(e))if(r.isExternal||s.reloadDocument)window.location.href=r.absoluteURL||r.to;else{const a=Promise.resolve().then(()=>window.__reactRouterDataRouter.navigate(r.to,{replace:s.replace}));throw i0.set(e,a),a}return q.createElement("meta",{httpEquiv:"refresh",content:`0;url=${r.absoluteURL||r.to}`})}}return c}function eF({routeContext:c,match:e,children:t}){let s=q.useContext(Uh);return s&&s.static&&s.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=e.route.id),q.createElement(Hr.Provider,{value:c},t)}function tF(c,e=[],t=null,s=null,i=null){if(c==null){if(!t)return null;if(t.errors)c=t.matches;else if(e.length===0&&!t.initialized&&t.matches.length>0)c=t.matches;else return null}let r=c,a=t?.errors;if(a!=null){let f=r.findIndex(m=>m.route.id&&a?.[m.route.id]!==void 0);Vt(f>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),r=r.slice(0,Math.min(r.length,f+1))}let o=!1,h=-1;if(t)for(let f=0;f<r.length;f++){let m=r[f];if((m.route.HydrateFallback||m.route.hydrateFallbackElement)&&(h=f),m.route.id){let{loaderData:_,errors:g}=t,S=m.route.loader&&!_.hasOwnProperty(m.route.id)&&(!g||g[m.route.id]===void 0);if(m.route.lazy||S){o=!0,h>=0?r=r.slice(0,h+1):r=[r[0]];break}}}let u=t&&s?(f,m)=>{s(f,{location:t.location,params:t.matches?.[0]?.params??{},unstable_pattern:zN(t.matches),errorInfo:m})}:void 0;return r.reduceRight((f,m,_)=>{let g,S=!1,x=null,T=null;t&&(g=a&&m.route.id?a[m.route.id]:void 0,x=m.route.errorElement||QN,o&&(h<0&&_===0?(CM("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),S=!0,T=null):h===_&&(S=!0,T=m.route.hydrateFallbackElement||null)));let E=e.concat(r.slice(0,_+1)),b=()=>{let C;return g?C=x:S?C=T:m.route.Component?C=q.createElement(m.route.Component,null):m.route.element?C=m.route.element:C=f,q.createElement(eF,{match:m,routeContext:{outlet:f,matches:E,isDataRoute:t!=null},children:C})};return t&&(m.route.ErrorBoundary||m.route.errorElement||_===0)?q.createElement(wM,{location:t.location,revalidation:t.revalidation,component:x,error:g,children:b(),routeContext:{outlet:null,matches:E,isDataRoute:!0},onError:u}):b()},null)}function WT(c){return`${c} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function sF(c){let e=q.useContext(Uh);return Vt(e,WT(c)),e}function iF(c){let e=q.useContext(Rg);return Vt(e,WT(c)),e}function rF(c){let e=q.useContext(Hr);return Vt(e,WT(c)),e}function XT(c){let e=rF(c),t=e.matches[e.matches.length-1];return Vt(t.route.id,`${c} can only be used on routes that contain a unique "id"`),t.route.id}function aF(){return XT("useRouteId")}function nF(){let c=q.useContext(GT),e=iF("useRouteError"),t=XT("useRouteError");return c!==void 0?c:e.errors?.[t]}function oF(){let{router:c}=sF("useNavigate"),e=XT("useNavigate"),t=q.useRef(!1);return bM(()=>{t.current=!0}),q.useCallback(async(i,r={})=>{ji(t.current,EM),t.current&&(typeof i=="number"?await c.navigate(i):await c.navigate(i,{fromRouteId:e,...r}))},[c,e])}var N1={};function CM(c,e,t){!e&&!N1[c]&&(N1[c]=!0,ji(!1,t))}q.memo(lF);function lF({routes:c,future:e,state:t,onError:s}){return AM(c,void 0,t,s,e)}function cF({to:c,replace:e,state:t,relative:s}){Vt(zh(),"<Navigate> may be used only in the context of a <Router> component.");let{static:i}=q.useContext(Ei);ji(!i,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");let{matches:r}=q.useContext(Hr),{pathname:a}=no(),o=HT(),h=VT(c,kT(r),a,s==="path"),u=JSON.stringify(h);return q.useEffect(()=>{o(JSON.parse(u),{replace:e,state:t,relative:s})},[o,u,s,e,t]),null}function S_(c){Vt(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function hF({basename:c="/",children:e=null,location:t,navigationType:s="POP",navigator:i,static:r=!1,unstable_useTransitions:a}){Vt(!zh(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let o=c.replace(/^\/*/,"/"),h=q.useMemo(()=>({basename:o,navigator:i,static:r,unstable_useTransitions:a,future:{}}),[o,i,r,a]);typeof t=="string"&&(t=Ll(t));let{pathname:u="/",search:f="",hash:m="",state:_=null,key:g="default"}=t,S=q.useMemo(()=>{let x=ja(u,o);return x==null?null:{location:{pathname:x,search:f,hash:m,state:_,key:g},navigationType:s}},[o,u,f,m,_,g,s]);return ji(S!=null,`<Router basename="${o}"> is not able to match the URL "${u}${f}${m}" because it does not start with the basename, so the <Router> won't render anything.`),S==null?null:q.createElement(Ei.Provider,{value:h},q.createElement(Sf.Provider,{children:e,value:S}))}function uF({children:c,location:e}){return KN(Lx(c),e)}function Lx(c,e=[]){let t=[];return q.Children.forEach(c,(s,i)=>{if(!q.isValidElement(s))return;let r=[...e,i];if(s.type===q.Fragment){t.push.apply(t,Lx(s.props.children,r));return}Vt(s.type===S_,`[${typeof s.type=="string"?s.type:s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),Vt(!s.props.index||!s.props.children,"An index route cannot have child routes.");let a={id:s.props.id||r.join("-"),caseSensitive:s.props.caseSensitive,element:s.props.element,Component:s.props.Component,index:s.props.index,path:s.props.path,middleware:s.props.middleware,loader:s.props.loader,action:s.props.action,hydrateFallbackElement:s.props.hydrateFallbackElement,HydrateFallback:s.props.HydrateFallback,errorElement:s.props.errorElement,ErrorBoundary:s.props.ErrorBoundary,hasErrorBoundary:s.props.hasErrorBoundary===!0||s.props.ErrorBoundary!=null||s.props.errorElement!=null,shouldRevalidate:s.props.shouldRevalidate,handle:s.props.handle,lazy:s.props.lazy};s.props.children&&(a.children=Lx(s.props.children,r)),t.push(a)}),t}var y_="get",x_="application/x-www-form-urlencoded";function Mg(c){return typeof HTMLElement<"u"&&c instanceof HTMLElement}function dF(c){return Mg(c)&&c.tagName.toLowerCase()==="button"}function fF(c){return Mg(c)&&c.tagName.toLowerCase()==="form"}function mF(c){return Mg(c)&&c.tagName.toLowerCase()==="input"}function pF(c){return!!(c.metaKey||c.altKey||c.ctrlKey||c.shiftKey)}function _F(c,e){return c.button===0&&(!e||e==="_self")&&!pF(c)}var Ap=null;function gF(){if(Ap===null)try{new FormData(document.createElement("form"),0),Ap=!1}catch{Ap=!0}return Ap}var vF=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function r0(c){return c!=null&&!vF.has(c)?(ji(!1,`"${c}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${x_}"`),null):c}function SF(c,e){let t,s,i,r,a;if(fF(c)){let o=c.getAttribute("action");s=o?ja(o,e):null,t=c.getAttribute("method")||y_,i=r0(c.getAttribute("enctype"))||x_,r=new FormData(c)}else if(dF(c)||mF(c)&&(c.type==="submit"||c.type==="image")){let o=c.form;if(o==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let h=c.getAttribute("formaction")||o.getAttribute("action");if(s=h?ja(h,e):null,t=c.getAttribute("formmethod")||o.getAttribute("method")||y_,i=r0(c.getAttribute("formenctype"))||r0(o.getAttribute("enctype"))||x_,r=new FormData(o,c),!gF()){let{name:u,type:f,value:m}=c;if(f==="image"){let _=u?`${u}.`:"";r.append(`${_}x`,"0"),r.append(`${_}y`,"0")}else u&&r.append(u,m)}}else{if(Mg(c))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');t=y_,s=null,i=x_,a=c}return r&&i==="text/plain"&&(a=r,r=void 0),{action:s,method:t.toLowerCase(),encType:i,formData:r,body:a}}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");function qT(c,e){if(c===!1||c===null||typeof c>"u")throw new Error(e)}function yF(c,e,t,s){let i=typeof c=="string"?new URL(c,typeof window>"u"?"server://singlefetch/":window.location.origin):c;return t?i.pathname.endsWith("/")?i.pathname=`${i.pathname}_.${s}`:i.pathname=`${i.pathname}.${s}`:i.pathname==="/"?i.pathname=`_root.${s}`:e&&ja(i.pathname,e)==="/"?i.pathname=`${e.replace(/\/$/,"")}/_root.${s}`:i.pathname=`${i.pathname.replace(/\/$/,"")}.${s}`,i}async function xF(c,e){if(c.id in e)return e[c.id];try{let t=await import(c.module);return e[c.id]=t,t}catch(t){return console.error(`Error loading route module \`${c.module}\`, reloading page...`),console.error(t),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function TF(c){return c==null?!1:c.href==null?c.rel==="preload"&&typeof c.imageSrcSet=="string"&&typeof c.imageSizes=="string":typeof c.rel=="string"&&typeof c.href=="string"}async function EF(c,e,t){let s=await Promise.all(c.map(async i=>{let r=e.routes[i.route.id];if(r){let a=await xF(r,t);return a.links?a.links():[]}return[]}));return CF(s.flat(1).filter(TF).filter(i=>i.rel==="stylesheet"||i.rel==="preload").map(i=>i.rel==="stylesheet"?{...i,rel:"prefetch",as:"style"}:{...i,rel:"prefetch"}))}function F1(c,e,t,s,i,r){let a=(h,u)=>t[u]?h.route.id!==t[u].route.id:!0,o=(h,u)=>t[u].pathname!==h.pathname||t[u].route.path?.endsWith("*")&&t[u].params["*"]!==h.params["*"];return r==="assets"?e.filter((h,u)=>a(h,u)||o(h,u)):r==="data"?e.filter((h,u)=>{let f=s.routes[h.route.id];if(!f||!f.hasLoader)return!1;if(a(h,u)||o(h,u))return!0;if(h.route.shouldRevalidate){let m=h.route.shouldRevalidate({currentUrl:new URL(i.pathname+i.search+i.hash,window.origin),currentParams:t[0]?.params||{},nextUrl:new URL(c,window.origin),nextParams:h.params,defaultShouldRevalidate:!0});if(typeof m=="boolean")return m}return!0}):[]}function bF(c,e,{includeHydrateFallback:t}={}){return AF(c.map(s=>{let i=e.routes[s.route.id];if(!i)return[];let r=[i.module];return i.clientActionModule&&(r=r.concat(i.clientActionModule)),i.clientLoaderModule&&(r=r.concat(i.clientLoaderModule)),t&&i.hydrateFallbackModule&&(r=r.concat(i.hydrateFallbackModule)),i.imports&&(r=r.concat(i.imports)),r}).flat(1))}function AF(c){return[...new Set(c)]}function wF(c){let e={},t=Object.keys(c).sort();for(let s of t)e[s]=c[s];return e}function CF(c,e){let t=new Set;return new Set(e),c.reduce((s,i)=>{let r=JSON.stringify(wF(i));return t.has(r)||(t.add(r),s.push({key:r,link:i})),s},[])}function DM(){let c=q.useContext(Uh);return qT(c,"You must render this element inside a <DataRouterContext.Provider> element"),c}function DF(){let c=q.useContext(Rg);return qT(c,"You must render this element inside a <DataRouterStateContext.Provider> element"),c}var YT=q.createContext(void 0);YT.displayName="FrameworkContext";function PM(){let c=q.useContext(YT);return qT(c,"You must render this element inside a <HydratedRouter> element"),c}function PF(c,e){let t=q.useContext(YT),[s,i]=q.useState(!1),[r,a]=q.useState(!1),{onFocus:o,onBlur:h,onMouseEnter:u,onMouseLeave:f,onTouchStart:m}=e,_=q.useRef(null);q.useEffect(()=>{if(c==="render"&&a(!0),c==="viewport"){let x=E=>{E.forEach(b=>{a(b.isIntersecting)})},T=new IntersectionObserver(x,{threshold:.5});return _.current&&T.observe(_.current),()=>{T.disconnect()}}},[c]),q.useEffect(()=>{if(s){let x=setTimeout(()=>{a(!0)},100);return()=>{clearTimeout(x)}}},[s]);let g=()=>{i(!0)},S=()=>{i(!1),a(!1)};return t?c!=="intent"?[r,_,{}]:[r,_,{onFocus:td(o,g),onBlur:td(h,S),onMouseEnter:td(u,g),onMouseLeave:td(f,S),onTouchStart:td(m,g)}]:[!1,_,{}]}function td(c,e){return t=>{c&&c(t),t.defaultPrevented||e(t)}}function RF({page:c,...e}){let{router:t}=DM(),s=q.useMemo(()=>pM(t.routes,c,t.basename),[t.routes,c,t.basename]);return s?q.createElement(LF,{page:c,matches:s,...e}):null}function MF(c){let{manifest:e,routeModules:t}=PM(),[s,i]=q.useState([]);return q.useEffect(()=>{let r=!1;return EF(c,e,t).then(a=>{r||i(a)}),()=>{r=!0}},[c,e,t]),s}function LF({page:c,matches:e,...t}){let s=no(),{future:i,manifest:r,routeModules:a}=PM(),{basename:o}=DM(),{loaderData:h,matches:u}=DF(),f=q.useMemo(()=>F1(c,e,u,r,s,"data"),[c,e,u,r,s]),m=q.useMemo(()=>F1(c,e,u,r,s,"assets"),[c,e,u,r,s]),_=q.useMemo(()=>{if(c===s.pathname+s.search+s.hash)return[];let x=new Set,T=!1;if(e.forEach(b=>{let C=r.routes[b.route.id];!C||!C.hasLoader||(!f.some(w=>w.route.id===b.route.id)&&b.route.id in h&&a[b.route.id]?.shouldRevalidate||C.hasClientLoader?T=!0:x.add(b.route.id))}),x.size===0)return[];let E=yF(c,o,i.unstable_trailingSlashAwareDataRequests,"data");return T&&x.size>0&&E.searchParams.set("_routes",e.filter(b=>x.has(b.route.id)).map(b=>b.route.id).join(",")),[E.pathname+E.search]},[o,i.unstable_trailingSlashAwareDataRequests,h,s,r,f,e,c,a]),g=q.useMemo(()=>bF(m,r),[m,r]),S=MF(m);return q.createElement(q.Fragment,null,_.map(x=>q.createElement("link",{key:x,rel:"prefetch",as:"fetch",href:x,...t})),g.map(x=>q.createElement("link",{key:x,rel:"modulepreload",href:x,...t})),S.map(({key:x,link:T})=>q.createElement("link",{key:x,nonce:t.nonce,...T,crossOrigin:T.crossOrigin??t.crossOrigin})))}function IF(...c){return e=>{c.forEach(t=>{typeof t=="function"?t(e):t!=null&&(t.current=e)})}}var OF=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{OF&&(window.__reactRouterVersion="7.13.0")}catch{}function NF({basename:c,children:e,unstable_useTransitions:t,window:s}){let i=q.useRef();i.current==null&&(i.current=mN({window:s,v5Compat:!0}));let r=i.current,[a,o]=q.useState({action:r.action,location:r.location}),h=q.useCallback(u=>{t===!1?o(u):q.startTransition(()=>o(u))},[t]);return q.useLayoutEffect(()=>r.listen(h),[r,h]),q.createElement(hF,{basename:c,children:e,location:a.location,navigationType:a.action,navigator:r,unstable_useTransitions:t})}var RM=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,jT=q.forwardRef(function({onClick:e,discover:t="render",prefetch:s="none",relative:i,reloadDocument:r,replace:a,state:o,target:h,to:u,preventScrollReset:f,viewTransition:m,unstable_defaultShouldRevalidate:_,...g},S){let{basename:x,unstable_useTransitions:T}=q.useContext(Ei),E=typeof u=="string"&&RM.test(u),b=SM(u,x);u=b.to;let C=jN(u,{relative:i}),[w,P,I]=PF(s,g),M=zF(u,{replace:a,state:o,target:h,preventScrollReset:f,relative:i,viewTransition:m,unstable_defaultShouldRevalidate:_,unstable_useTransitions:T});function R(B){e&&e(B),B.defaultPrevented||M(B)}let L=q.createElement("a",{...g,...I,href:b.absoluteURL||C,onClick:b.isExternal||r?e:R,ref:IF(S,P),target:h,"data-discover":!E&&t==="render"?"true":void 0});return w&&!E?q.createElement(q.Fragment,null,L,q.createElement(RF,{page:C})):L});jT.displayName="Link";var FF=q.forwardRef(function({"aria-current":e="page",caseSensitive:t=!1,className:s="",end:i=!1,style:r,to:a,viewTransition:o,children:h,...u},f){let m=yf(a,{relative:u.relative}),_=no(),g=q.useContext(Rg),{navigator:S,basename:x}=q.useContext(Ei),T=g!=null&&WF(m)&&o===!0,E=S.encodeLocation?S.encodeLocation(m).pathname:m.pathname,b=_.pathname,C=g&&g.navigation&&g.navigation.location?g.navigation.location.pathname:null;t||(b=b.toLowerCase(),C=C?C.toLowerCase():null,E=E.toLowerCase()),C&&x&&(C=ja(C,x)||C);const w=E!=="/"&&E.endsWith("/")?E.length-1:E.length;let P=b===E||!i&&b.startsWith(E)&&b.charAt(w)==="/",I=C!=null&&(C===E||!i&&C.startsWith(E)&&C.charAt(E.length)==="/"),M={isActive:P,isPending:I,isTransitioning:T},R=P?e:void 0,L;typeof s=="function"?L=s(M):L=[s,P?"active":null,I?"pending":null,T?"transitioning":null].filter(Boolean).join(" ");let B=typeof r=="function"?r(M):r;return q.createElement(jT,{...u,"aria-current":R,className:L,ref:f,style:B,to:a,viewTransition:o},typeof h=="function"?h(M):h)});FF.displayName="NavLink";var BF=q.forwardRef(({discover:c="render",fetcherKey:e,navigate:t,reloadDocument:s,replace:i,state:r,method:a=y_,action:o,onSubmit:h,relative:u,preventScrollReset:f,viewTransition:m,unstable_defaultShouldRevalidate:_,...g},S)=>{let{unstable_useTransitions:x}=q.useContext(Ei),T=GF(),E=HF(o,{relative:u}),b=a.toLowerCase()==="get"?"get":"post",C=typeof o=="string"&&RM.test(o),w=P=>{if(h&&h(P),P.defaultPrevented)return;P.preventDefault();let I=P.nativeEvent.submitter,M=I?.getAttribute("formmethod")||a,R=()=>T(I||P.currentTarget,{fetcherKey:e,method:M,navigate:t,replace:i,state:r,relative:u,preventScrollReset:f,viewTransition:m,unstable_defaultShouldRevalidate:_});x&&t!==!1?q.startTransition(()=>R()):R()};return q.createElement("form",{ref:S,method:b,action:E,onSubmit:s?h:w,...g,"data-discover":!C&&c==="render"?"true":void 0})});BF.displayName="Form";function UF(c){return`${c} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function MM(c){let e=q.useContext(Uh);return Vt(e,UF(c)),e}function zF(c,{target:e,replace:t,state:s,preventScrollReset:i,relative:r,viewTransition:a,unstable_defaultShouldRevalidate:o,unstable_useTransitions:h}={}){let u=HT(),f=no(),m=yf(c,{relative:r});return q.useCallback(_=>{if(_F(_,e)){_.preventDefault();let g=t!==void 0?t:Xd(f)===Xd(m),S=()=>u(c,{replace:g,state:s,preventScrollReset:i,relative:r,viewTransition:a,unstable_defaultShouldRevalidate:o});h?q.startTransition(()=>S()):S()}},[f,u,m,t,s,e,c,i,r,a,o,h])}var kF=0,VF=()=>`__${String(++kF)}__`;function GF(){let{router:c}=MM("useSubmit"),{basename:e}=q.useContext(Ei),t=aF(),s=c.fetch,i=c.navigate;return q.useCallback(async(r,a={})=>{let{action:o,method:h,encType:u,formData:f,body:m}=SF(r,e);if(a.navigate===!1){let _=a.fetcherKey||VF();await s(_,t,a.action||o,{unstable_defaultShouldRevalidate:a.unstable_defaultShouldRevalidate,preventScrollReset:a.preventScrollReset,formData:f,body:m,formMethod:a.method||h,formEncType:a.encType||u,flushSync:a.flushSync})}else await i(a.action||o,{unstable_defaultShouldRevalidate:a.unstable_defaultShouldRevalidate,preventScrollReset:a.preventScrollReset,formData:f,body:m,formMethod:a.method||h,formEncType:a.encType||u,replace:a.replace,state:a.state,fromRouteId:t,flushSync:a.flushSync,viewTransition:a.viewTransition})},[s,i,e,t])}function HF(c,{relative:e}={}){let{basename:t}=q.useContext(Ei),s=q.useContext(Hr);Vt(s,"useFormAction must be used inside a RouteContext");let[i]=s.matches.slice(-1),r={...yf(c||".",{relative:e})},a=no();if(c==null){r.search=a.search;let o=new URLSearchParams(r.search),h=o.getAll("index");if(h.some(f=>f==="")){o.delete("index"),h.filter(m=>m).forEach(m=>o.append("index",m));let f=o.toString();r.search=f?`?${f}`:""}}return(!c||c===".")&&i.route.index&&(r.search=r.search?r.search.replace(/^\?/,"?index&"):"?index"),t!=="/"&&(r.pathname=r.pathname==="/"?t:za([t,r.pathname])),Xd(r)}function WF(c,{relative:e}={}){let t=q.useContext(xM);Vt(t!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:s}=MM("useViewTransitionState"),i=yf(c,{relative:e});if(!t.isTransitioning)return!1;let r=ja(t.currentLocation.pathname,s)||t.currentLocation.pathname,a=ja(t.nextLocation.pathname,s)||t.nextLocation.pathname;return k_(i.pathname,a)!=null||k_(i.pathname,r)!=null}function XF(){return ge.jsx("div",{style:{minHeight:"100vh",display:"grid",placeItems:"center"},children:ge.jsxs("div",{style:{textAlign:"center",padding:24,maxWidth:720},children:[ge.jsx("div",{className:"profile-image",children:ge.jsx("img",{src:"/my-3d-gallery_2/icons/image14.png",alt:"Profile Icon",className:"profile-icon"})}),ge.jsx("h1",{style:{marginBottom:8},children:"My 3D Gallery"}),ge.jsx("p",{style:{opacity:.8,marginBottom:24},children:"Yu-chan(@yu_chan141)3D Gaussian Splatting 3D"}),ge.jsx(jT,{to:"/gallery",style:{textDecoration:"none"},children:ge.jsx("button",{style:{padding:"12px 18px",borderRadius:10,border:"1px solid rgba(255,255,255,0.2)",cursor:"pointer"},children:" "})}),ge.jsx("div",{className:"social-links",children:ge.jsx("a",{href:"https://x.com/yu_chan141",target:"_blank",rel:"noreferrer",className:"twitter-link",children:ge.jsx("img",{src:"/my-3d-gallery_2/icons/x-logo-black.png",alt:"X (Twitter)",className:"social-icon"})})})]})})}const qF="GpuTimings",LM="2.15.3",YF="8051ab4";function V_(c,e){for(const t in e){const s=e[t];Array.isArray(s)?c[t]=V_([],s):s&&typeof s=="object"?c[t]=V_({},s):c[t]=s}return c}const jF={create(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,c=>{const e=Math.random()*16|0;return(c==="x"?e:e&3|8).toString(16)})}},Re={delimiter:"/",join(...c){let e=c[0];for(let t=0;t<c.length-1;t++){const s=c[t],i=c[t+1];if(i[0]===Re.delimiter){e=i;continue}s&&i&&s[s.length-1]!==Re.delimiter&&i[0]!==Re.delimiter?e+=Re.delimiter+i:e+=i}return e},normalize(c){const e=c.startsWith(Re.delimiter),t=c.endsWith(Re.delimiter),s=c.split("/");let i="",r=[];for(let a=0;a<s.length;a++)if(s[a]!==""&&s[a]!=="."){if(s[a]===".."&&r.length>0){r=r.slice(0,r.length-2);continue}a>0&&r.push(Re.delimiter),r.push(s[a])}return i=r.join(""),!e&&i[0]===Re.delimiter&&(i=i.slice(1)),t&&i[i.length-1]!==Re.delimiter&&(i+=Re.delimiter),i},split(c){const e=c.lastIndexOf(Re.delimiter);return e!==-1?[c.substring(0,e),c.substring(e+1)]:["",c]},getBasename(c){return Re.split(c)[1]},getDirectory(c){return Re.split(c)[0]},getExtension(c){const e=c.split("?")[0].split(".").pop();return e!==c?`.${e}`:""},isRelativePath(c){return c.charAt(0)!=="/"&&c.match(/:\/\//)===null},extractPath(c){let e="";const t=c.split("/");let s=0;if(t.length>1)if(Re.isRelativePath(c))if(t[0]===".")for(s=0;s<t.length-1;++s)e+=s===0?t[s]:`/${t[s]}`;else if(t[0]==="..")for(s=0;s<t.length-1;++s)e+=s===0?t[s]:`/${t[s]}`;else for(e=".",s=0;s<t.length-1;++s)e+=`/${t[s]}`;else for(s=0;s<t.length-1;++s)e+=s===0?t[s]:`/${t[s]}`;return e}},$F=()=>{let c=!1;try{const e=Object.defineProperty({},"passive",{get:function(){return c=!0,!1}});window.addEventListener("testpassive",null,e),window.removeEventListener("testpassive",null,e)}catch{}return c},Pa=typeof navigator<"u"?navigator.userAgent:"",Nd=typeof window<"u"?"browser":typeof global<"u"?"node":"worker",sd=/android/i.test(Pa)?"android":/ip(?:[ao]d|hone)/i.test(Pa)?"ios":/windows/i.test(Pa)?"windows":/mac os/i.test(Pa)?"osx":/linux/i.test(Pa)?"linux":/cros/i.test(Pa)?"cros":null,KF=Nd!=="browser"?null:/Chrome\/|Chromium\/|Edg.*\//.test(Pa)?"chrome":/Safari\//.test(Pa)?"safari":/Firefox\//.test(Pa)?"firefox":"other",ZF=Nd==="browser"&&("ontouchstart"in window||"maxTouchPoints"in navigator&&navigator.maxTouchPoints>0),QF=$F(),Ve={name:sd,environment:Nd,browser:Nd==="browser",worker:Nd==="worker",desktop:["windows","osx","linux","cros"].includes(sd),mobile:["android","ios"].includes(sd),ios:sd==="ios",android:sd==="android",touch:ZF,passiveEvents:QF,browserName:KF},IM="abcdefghijklmnopqrstuvwxyz",OM="ABCDEFGHIJKLMNOPQRSTUVWXYZ",JF=IM+OM,Ix=55296,NM=56319,B1=56320,eB=57343,tB=8205,U1=127462,z1=127487,sB=127995,iB=127999,rB=8400,aB=8447,Ox=65024,Nx=65039;function Fx(c,e=0){const t=c.length;if(e<0||e>=t)return null;const s=c.charCodeAt(e);if(t>1&&s>=Ix&&s<=NM){const i=c.charCodeAt(e+1);if(i>=B1&&i<=eB)return{code:(s-Ix)*1024+i-B1+65536,long:!0}}return{code:s,long:!1}}function Gn(c,e,t){if(!c)return!1;const s=Fx(c);if(s){const i=s.code;return i>=e&&i<=t}return!1}function nB(c,e){if(e===c.length-1)return 1;if(Gn(c[e],Ix,NM)){const t=c.substring(e,e+2),s=c.substring(e+2,e+4);return Gn(s,sB,iB)||Gn(t,U1,z1)&&Gn(s,U1,z1)?4:Gn(s,Ox,Nx)?3:2}return Gn(c[e+1],Ox,Nx)?2:1}const T_={ASCII_LOWERCASE:IM,ASCII_UPPERCASE:OM,ASCII_LETTERS:JF,format(c,...e){for(let t=0;t<e.length;t++)c=c.replace(`{${t}}`,e[t]);return c},getCodePoint(c,e){const t=Fx(c,e);return t&&t.code},getCodePoints(c){if(typeof c!="string")throw new TypeError("Not a string");let e=0;const t=[];let s;for(;s=Fx(c,e);)t.push(s.code),e+=s.long?2:1;return t},getSymbols(c){if(typeof c!="string")throw new TypeError("Not a string");let e=0;const t=c.length,s=[];let i=0,r;for(;e<t;){if(i+=nB(c,e+i),r=c[e+i],Gn(r,rB,aB)&&(r=c[e+i++]),Gn(r,Ox,Nx)&&(r=c[e+i++]),r&&r.charCodeAt(0)===tB){r=c[e+i++];continue}const a=c.substring(e,e+i);s.push(a),e+=i,i=0}return s},fromCodePoint(...c){return c.map(e=>e>65535?(e-=65536,String.fromCharCode((e>>10)+55296,e%1024+56320)):String.fromCharCode(e)).join("")}};class oB{off(){this._removed||this.handler.offByHandle(this)}on(e,t,s=this){return this.handler._addCallback(e,t,s,!1)}once(e,t,s=this){return this.handler._addCallback(e,t,s,!0)}set removed(e){e&&(this._removed=!0)}get removed(){return this._removed}toJSON(e){}constructor(e,t,s,i,r=!1){this._removed=!1,this.handler=e,this.name=t,this.callback=s,this.scope=i,this._once=r}}class Pe{initEventHandler(){this._callbacks=new Map,this._callbackActive=new Map}_addCallback(e,t,s,i){if(this._callbacks.has(e)||this._callbacks.set(e,[]),this._callbackActive.has(e)){const a=this._callbackActive.get(e);a&&a===this._callbacks.get(e)&&this._callbackActive.set(e,a.slice())}const r=new oB(this,e,t,s,i);return this._callbacks.get(e).push(r),r}on(e,t,s=this){return this._addCallback(e,t,s,!1)}once(e,t,s=this){return this._addCallback(e,t,s,!0)}off(e,t,s){if(e)this._callbackActive.has(e)&&this._callbackActive.get(e)===this._callbacks.get(e)&&this._callbackActive.set(e,this._callbackActive.get(e).slice());else for(const[i,r]of this._callbackActive)this._callbacks.has(i)&&this._callbacks.get(i)===r&&this._callbackActive.set(i,r.slice());if(e)if(t){const i=this._callbacks.get(e);if(!i)return this;for(let r=0;r<i.length;r++)i[r].callback===t&&(s&&i[r].scope!==s||(i[r].removed=!0,i.splice(r,1),r--));i.length===0&&this._callbacks.delete(e)}else{const i=this._callbacks.get(e);if(i){for(let r=0;r<i.length;r++)i[r].removed=!0;this._callbacks.delete(e)}}else{for(const i of this._callbacks.values())for(let r=0;r<i.length;r++)i[r].removed=!0;this._callbacks.clear()}return this}offByHandle(e){const t=e.name;e.removed=!0,this._callbackActive.has(t)&&this._callbackActive.get(t)===this._callbacks.get(t)&&this._callbackActive.set(t,this._callbackActive.get(t).slice());const s=this._callbacks.get(t);if(!s)return this;const i=s.indexOf(e);return i!==-1&&(s.splice(i,1),s.length===0&&this._callbacks.delete(t)),this}fire(e,t,s,i,r,a,o,h,u){if(!e)return this;const f=this._callbacks.get(e);if(!f)return this;let m;this._callbackActive.has(e)?this._callbackActive.get(e)!==f&&(m=f.slice()):this._callbackActive.set(e,f);for(let _=0;(m||this._callbackActive.get(e))&&_<(m||this._callbackActive.get(e)).length;_++){const g=(m||this._callbackActive.get(e))[_];if(g.callback&&(g.callback.call(g.scope,t,s,i,r,a,o,h,u),g._once)){const S=this._callbacks.get(e),x=S?S.indexOf(g):-1;if(x!==-1){this._callbackActive.get(e)===S&&this._callbackActive.set(e,this._callbackActive.get(e).slice());const T=this._callbacks.get(e);if(!T)continue;T[x].removed=!0,T.splice(x,1),T.length===0&&this._callbacks.delete(e)}}}return m||this._callbackActive.delete(e),this}hasEvent(e){return!!this._callbacks.get(e)?.length}constructor(){this._callbacks=new Map,this._callbackActive=new Map}}class lB{push(e,t){if(this._index[e])throw Error(`Key already in index ${e}`);const s=this._list.push(t)-1;this._index[e]=s}has(e){return this._index[e]!==void 0}get(e){const t=this._index[e];return t!==void 0?this._list[t]:null}remove(e){const t=this._index[e];if(t!==void 0){this._list.splice(t,1),delete this._index[e];for(e in this._index){const s=this._index[e];s>t&&(this._index[e]=s-1)}return!0}return!1}list(){return this._list}clear(){this._list.length=0;for(const e in this._index)delete this._index[e]}constructor(){this._list=[],this._index={}}}const cB=c=>{const e={};let t=e;return()=>(t===e&&(t=c()),t)};class Zs{static loadScript(e,t){const s=document.createElement("script");s.setAttribute("src",e),s.onload=()=>{t(null)},s.onerror=()=>{t(`Failed to load script='${e}'`)},document.body.appendChild(s)}static loadWasm(e,t,s){const i=Zs.wasmSupported()&&t.glueUrl&&t.wasmUrl?t.glueUrl:t.fallbackUrl;i?Zs.loadScript(i,r=>{if(r)s(r,null);else{const a=window[e];window[e]=void 0,a({locateFile:()=>t.wasmUrl,onAbort:()=>{s("wasm module aborted.")}}).then(o=>{s(null,o)})}}):s("No supported wasm modules found.",null)}static getModule(e){return Zs.modules.hasOwnProperty(e)||(Zs.modules[e]={config:null,initializing:!1,instance:null,callbacks:[]}),Zs.modules[e]}static initialize(e,t){if(t.initializing)return;const s=t.config;(s.glueUrl||s.wasmUrl||s.fallbackUrl)&&(t.initializing=!0,Zs.loadWasm(e,s,(i,r)=>{i?s.errorHandler?s.errorHandler(i):console.error(`failed to initialize module=${e} error=${i}`):(t.instance=r,t.callbacks.forEach(a=>{a(r)}))}))}}Zs.modules={};Zs.wasmSupported=cB(()=>{try{if(typeof WebAssembly=="object"&&typeof WebAssembly.instantiate=="function"){const c=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(c instanceof WebAssembly.Module)return new WebAssembly.Instance(c)instanceof WebAssembly.Instance}}catch{}return!1});class FM{static setConfig(e,t){const s=Zs.getModule(e);s.config=t,s.callbacks.length>0&&Zs.initialize(e,s)}static getConfig(e){return Zs.modules?.[e]?.config}static getInstance(e,t){const s=Zs.getModule(e);s.instance?t(s.instance):(s.callbacks.push(t),s.config&&Zs.initialize(e,s))}}class BM{get remainingBytes(){return this.dataView.byteLength-this.offset}reset(e=0){this.offset=e}skip(e){this.offset+=e}align(e){this.offset=this.offset+e-1&~(e-1)}_inc(e){return this.offset+=e,this.offset-e}readChar(){return String.fromCharCode(this.dataView.getUint8(this.offset++))}readChars(e){let t="";for(let s=0;s<e;++s)t+=this.readChar();return t}readU8(){return this.dataView.getUint8(this.offset++)}readU16(){return this.dataView.getUint16(this._inc(2),!0)}readU32(){return this.dataView.getUint32(this._inc(4),!0)}readU64(){return this.readU32()+2**32*this.readU32()}readU32be(){return this.dataView.getUint32(this._inc(4),!1)}readArray(e){for(let t=0;t<e.length;++t)e[t]=this.readU8()}readLine(){const e=this.dataView;let t="";for(;!(this.offset>=e.byteLength);){const s=String.fromCharCode(this.readU8());if(s===`
`)break;t+=s}return t}constructor(e){this.offset=0,this.arraybuffer=e,this.dataView=new DataView(e)}}class G_{_binarySearch(e){let t=0,s=this.items.length-1;const i=e[this._sortBy];let r,a;for(;t<=s;)r=Math.floor((t+s)/2),a=this.items[r][this._sortBy],a<=i?t=r+1:a>i&&(s=r-1);return t}_doSort(e,t){const s=this._sortBy;return e[s]-t[s]}insert(e){const t=this._binarySearch(e);this.items.splice(t,0,e),this.length++,this.loopIndex>=t&&this.loopIndex++}append(e){this.items.push(e),this.length++}remove(e){const t=this.items.indexOf(e);t<0||(this.items.splice(t,1),this.length--,this.loopIndex>=t&&this.loopIndex--)}sort(){const e=this.loopIndex>=0?this.items[this.loopIndex]:null;this.items.sort(this._sortHandler),e!==null&&(this.loopIndex=this.items.indexOf(e))}constructor(e){this.items=[],this.length=0,this.loopIndex=-1,this._sortBy=e.sortBy,this._sortHandler=this._doSort.bind(this)}}class xf extends Pe{add(...e){let t=!1;const s=this._processArguments(e,!0);if(!s.length)return t;for(let i=0;i<s.length;i++)this._index[s[i]]||(t=!0,this._index[s[i]]=!0,this._list.push(s[i]),this.fire("add",s[i],this._parent));return t&&this.fire("change",this._parent),t}remove(...e){let t=!1;if(!this._list.length)return t;const s=this._processArguments(e,!0);if(!s.length)return t;for(let i=0;i<s.length;i++)this._index[s[i]]&&(t=!0,delete this._index[s[i]],this._list.splice(this._list.indexOf(s[i]),1),this.fire("remove",s[i],this._parent));return t&&this.fire("change",this._parent),t}clear(){if(!this._list.length)return;const e=this._list.slice(0);this._list=[],this._index={};for(let t=0;t<e.length;t++)this.fire("remove",e[t],this._parent);this.fire("change",this._parent)}has(...e){return this._list.length?this._has(this._processArguments(e)):!1}_has(e){if(!this._list.length||!e.length)return!1;for(let t=0;t<e.length;t++)if(e[t].length===1){if(this._index[e[t][0]])return!0}else{let s=!0;for(let i=0;i<e[t].length;i++)if(!this._index[e[t][i]]){s=!1;break}if(s)return!0}return!1}list(){return this._list.slice(0)}_processArguments(e,t){const s=[];let i=[];if(!e||!e.length)return s;for(let r=0;r<e.length;r++)if(e[r]instanceof Array){t||(i=[]);for(let a=0;a<e[r].length;a++)typeof e[r][a]=="string"&&(t?s.push(e[r][a]):i.push(e[r][a]));!t&&i.length&&s.push(i)}else typeof e[r]=="string"&&(t?s.push(e[r]):s.push([e[r]]));return s}get size(){return this._list.length}constructor(e){super(),this._index={},this._list=[],this._parent=e}}xf.EVENT_ADD="add";xf.EVENT_REMOVE="remove";xf.EVENT_CHANGE="change";const vs=typeof window<"u"&&window.performance&&window.performance.now?performance.now.bind(performance):Date.now,hB=/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class a0{toString(){let e="";return this.scheme&&(e+=`${this.scheme}:`),this.authority&&(e+=`//${this.authority}`),e+=this.path,this.query&&(e+=`?${this.query}`),this.fragment&&(e+=`#${this.fragment}`),e}getQuery(){const e={};if(this.query){const t=decodeURIComponent(this.query).split("&");for(const s of t){const i=s.split("=");e[i[0]]=i[1]}}return e}setQuery(e){let t="";for(const s in e)e.hasOwnProperty(s)&&(t!==""&&(t+="&"),t+=`${encodeURIComponent(s)}=${encodeURIComponent(e[s])}`);this.query=t}constructor(e){const t=e.match(hB);this.scheme=t[2],this.authority=t[4],this.path=t[5],this.query=t[7],this.fragment=t[9]}}class Tf{static set(e,t=!0){}static get(e){return Tf._traceChannels.has(e)}}Tf._traceChannels=new Set;Tf.stack=!1;const uB=0,$T=1,k1=4,dB=5,J={DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,clamp(c,e,t){return c>=t?t:c<=e?e:c},intToBytes24(c){const e=c>>16&255,t=c>>8&255,s=c&255;return[e,t,s]},intToBytes32(c){const e=c>>24&255,t=c>>16&255,s=c>>8&255,i=c&255;return[e,t,s,i]},bytesToInt24(c,e,t){return c.length&&(t=c[2],e=c[1],c=c[0]),c<<16|e<<8|t},bytesToInt32(c,e,t,s){return c.length&&(s=c[3],t=c[2],e=c[1],c=c[0]),(c<<24|e<<16|t<<8|s)>>>0},lerp(c,e,t){return c+(e-c)*J.clamp(t,0,1)},lerpAngle(c,e,t){return e-c>180&&(e-=360),e-c<-180&&(e+=360),J.lerp(c,e,J.clamp(t,0,1))},powerOfTwo(c){return c!==0&&!(c&c-1)},nextPowerOfTwo(c){return c--,c|=c>>1,c|=c>>2,c|=c>>4,c|=c>>8,c|=c>>16,c++,c},nearestPowerOfTwo(c){return Math.pow(2,Math.round(Math.log2(c)))},random(c,e){const t=e-c;return Math.random()*t+c},smoothstep(c,e,t){return t<=c?0:t>=e?1:(t=(t-c)/(e-c),t*t*(3-2*t))},smootherstep(c,e,t){return t<=c?0:t>=e?1:(t=(t-c)/(e-c),t*t*t*(t*(t*6-15)+10))},roundUp(c,e){return e===0?c:Math.ceil(c/e)*e},between(c,e,t,s){const i=Math.min(e,t),r=Math.max(e,t);return s?c>=i&&c<=r:c>i&&c<r}};class ue{clone(){const e=this.constructor;return new e(this.r,this.g,this.b,this.a)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this.a=e.a,this}equals(e){return this.r===e.r&&this.g===e.g&&this.b===e.b&&this.a===e.a}set(e,t,s,i=1){return this.r=e,this.g=t,this.b=s,this.a=i,this}lerp(e,t,s){return this.r=e.r+s*(t.r-e.r),this.g=e.g+s*(t.g-e.g),this.b=e.b+s*(t.b-e.b),this.a=e.a+s*(t.a-e.a),this}linear(e=this){return this.r=Math.pow(e.r,2.2),this.g=Math.pow(e.g,2.2),this.b=Math.pow(e.b,2.2),this.a=e.a,this}gamma(e=this){return this.r=Math.pow(e.r,1/2.2),this.g=Math.pow(e.g,1/2.2),this.b=Math.pow(e.b,1/2.2),this.a=e.a,this}mulScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}fromString(e){const t=parseInt(e.replace("#","0x"),16);let s;return e.length>7?s=J.intToBytes32(t):(s=J.intToBytes24(t),s[3]=255),this.set(s[0]/255,s[1]/255,s[2]/255,s[3]/255),this}fromArray(e,t=0){return this.r=e[t]??this.r,this.g=e[t+1]??this.g,this.b=e[t+2]??this.b,this.a=e[t+3]??this.a,this}toString(e,t){const{r:s,g:i,b:r,a}=this;if(t||s>1||i>1||r>1)return`${s.toFixed(3)}, ${i.toFixed(3)}, ${r.toFixed(3)}, ${a.toFixed(3)}`;let o=`#${((1<<24)+(Math.round(s*255)<<16)+(Math.round(i*255)<<8)+Math.round(r*255)).toString(16).slice(1)}`;if(e===!0){const h=Math.round(a*255).toString(16);this.a<16/255?o+=`0${h}`:o+=h}return o}toArray(e=[],t=0,s=!0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,s&&(e[t+3]=this.a),e}constructor(e=0,t=0,s=0,i=1){const r=e.length;r===3||r===4?(this.r=e[0],this.g=e[1],this.b=e[2],this.a=e[3]??1):(this.r=e,this.g=t,this.b=s,this.a=i)}}ue.BLACK=Object.freeze(new ue(0,0,0,1));ue.BLUE=Object.freeze(new ue(0,0,1,1));ue.CYAN=Object.freeze(new ue(0,1,1,1));ue.GRAY=Object.freeze(new ue(.5,.5,.5,1));ue.GREEN=Object.freeze(new ue(0,1,0,1));ue.MAGENTA=Object.freeze(new ue(1,0,1,1));ue.RED=Object.freeze(new ue(1,0,0,1));ue.WHITE=Object.freeze(new ue(1,1,1,1));ue.YELLOW=Object.freeze(new ue(1,1,0,1));class UM{evaluate(e,t=!1){(t||e<this._left||e>=this._right)&&this._reset(e);let s;const i=this._curve.type;if(i===dB)s=this._p0;else{const r=this._recip===0?0:(e-this._left)*this._recip;i===uB?s=J.lerp(this._p0,this._p1,r):i===$T?s=J.lerp(this._p0,this._p1,r*r*(3-2*r)):s=this._evaluateHermite(this._p0,this._p1,this._m0,this._m1,r)}return s}_reset(e){const t=this._curve.keys,s=t.length;if(!s)this._left=-1/0,this._right=1/0,this._recip=0,this._p0=this._p1=this._m0=this._m1=0;else if(e<t[0][0])this._left=-1/0,this._right=t[0][0],this._recip=0,this._p0=this._p1=t[0][1],this._m0=this._m1=0;else if(e>=t[s-1][0])this._left=t[s-1][0],this._right=1/0,this._recip=0,this._p0=this._p1=t[s-1][1],this._m0=this._m1=0;else{let i=0;for(;e>=t[i+1][0];)i++;this._left=t[i][0],this._right=t[i+1][0];const r=1/(this._right-this._left);this._recip=isFinite(r)?r:0,this._p0=t[i][1],this._p1=t[i+1][1],this._curve.type===k1&&this._calcTangents(t,i)}}_calcTangents(e,t){let s;const i=e[t],r=e[t+1];let a;if(t===0?s=[e[0][0]+(e[0][0]-e[1][0]),e[0][1]+(e[0][1]-e[1][1])]:s=e[t-1],t===e.length-2?a=[e[t+1][0]+(e[t+1][0]-e[t][0]),e[t+1][1]+(e[t+1][1]-e[t][1])]:a=e[t+2],this._curve.type===k1){const o=2*(r[0]-i[0])/(r[0]-s[0]),h=2*(r[0]-i[0])/(a[0]-i[0]);this._m0=this._curve.tension*(isFinite(o)?o:0)*(r[1]-s[1]),this._m1=this._curve.tension*(isFinite(h)?h:0)*(a[1]-i[1])}else{const o=(r[0]-i[0])/(i[0]-s[0]),h=(r[0]-i[0])/(a[0]-r[0]),u=i[1]+(s[1]-i[1])*(isFinite(o)?o:0),f=r[1]+(a[1]-r[1])*(isFinite(h)?h:0),m=this._curve.tension;this._m0=m*(r[1]-u),this._m1=m*(f-i[1])}}_evaluateHermite(e,t,s,i,r){const a=r*r,o=r+r,h=1-r,u=h*h;return e*((1+o)*u)+s*(r*u)+t*(a*(3-o))+i*(a*(r-1))}constructor(e,t=0){this._left=-1/0,this._right=1/0,this._recip=0,this._p0=0,this._p1=0,this._m0=0,this._m1=0,this._curve=e,this._reset(t)}}class fr{get length(){return this.keys.length}add(e,t){const s=this.keys,i=s.length;let r=0;for(;r<i&&!(s[r][0]>e);r++);const a=[e,t];return this.keys.splice(r,0,a),a}get(e){return this.keys[e]}sort(){this.keys.sort((e,t)=>e[0]-t[0])}value(e){return this._eval.evaluate(e,!0)}closest(e){const t=this.keys,s=t.length;let i=2,r=null;for(let a=0;a<s;a++){const o=Math.abs(e-t[a][0]);if(i>=o)i=o,r=t[a];else break}return r}clone(){const e=new this.constructor;return e.keys=this.keys.map(t=>[...t]),e.type=this.type,e.tension=this.tension,e}quantize(e){e=Math.max(e,2);const t=new Float32Array(e),s=1/(e-1);t[0]=this._eval.evaluate(0,!0);for(let i=1;i<e;i++)t[i]=this._eval.evaluate(s*i);return t}quantizeClamped(e,t,s){const i=this.quantize(e);for(let r=0;r<i.length;++r)i[r]=Math.min(s,Math.max(t,i[r]));return i}constructor(e){if(this.keys=[],this.type=$T,this.tension=.5,this._eval=new UM(this),e)for(let t=0;t<e.length-1;t+=2)this.keys.push([e[t],e[t+1]]);this.sort()}}class ol{get length(){return this.curves.length}set type(e){this._type=e;for(let t=0;t<this.curves.length;t++)this.curves[t].type=e}get type(){return this._type}get(e){return this.curves[e]}value(e,t=[]){const s=this.curves.length;t.length=s;for(let i=0;i<s;i++)t[i]=this.curves[i].value(e);return t}clone(){const e=new this.constructor;e.curves=[];for(let t=0;t<this.curves.length;t++)e.curves.push(this.curves[t].clone());return e._type=this._type,e}quantize(e){e=Math.max(e,2);const t=this.curves.length,s=new Float32Array(e*t),i=1/(e-1);for(let r=0;r<t;r++){const a=new UM(this.curves[r]);for(let o=0;o<e;o++)s[o*t+r]=a.evaluate(i*o)}return s}quantizeClamped(e,t,s){const i=this.quantize(e);for(let r=0;r<i.length;++r)i[r]=Math.min(s,Math.max(t,i[r]));return i}constructor(...e){if(this.curves=[],this._type=$T,e.length>1)for(let t=0;t<e.length;t++)this.curves.push(new fr(e[t]));else if(e.length===0)this.curves.push(new fr);else{const t=e[0];if(typeof t=="number")for(let s=0;s<t;s++)this.curves.push(new fr);else for(let s=0;s<t.length;s++)this.curves.push(new fr(t[s]))}}}const Bx=new Float32Array(1),V1=new Int32Array(Bx.buffer);class pl{static float2Half(e){Bx[0]=e;const t=V1[0];let s=t>>16&32768,i=t>>12&2047;const r=t>>23&255;return r<103?s:r>142?(s|=31744,s|=(r===255?0:1)&&t&8388607,s):r<113?(i|=2048,s|=(i>>114-r)+(i>>113-r&1),s):(s|=r-112<<10|i>>1,s+=i&1,s)}static float2RGBA8(e,t){Bx[0]=e;const s=V1[0];t.r=(s>>24&255)/255,t.g=(s>>16&255)/255,t.b=(s>>8&255)/255,t.a=(s&255)/255}}class D{add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}add2(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addScaled(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}clone(){const e=this.constructor;return new e(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}cross(e,t){const s=e.x,i=e.y,r=e.z,a=t.x,o=t.y,h=t.z;return this.x=i*h-o*r,this.y=r*a-h*s,this.z=s*o-a*i,this}distance(e){const t=this.x-e.x,s=this.y-e.y,i=this.z-e.z;return Math.sqrt(t*t+s*s+i*i)}div(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}div2(e,t){return this.x=e.x/t.x,this.y=e.y/t.y,this.z=e.z/t.z,this}divScalar(e){return this.x/=e,this.y/=e,this.z/=e,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z}equalsApprox(e,t=1e-6){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}lerp(e,t,s){return this.x=e.x+s*(t.x-e.x),this.y=e.y+s*(t.y-e.y),this.z=e.z+s*(t.z-e.z),this}mul(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}mul2(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}mulScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}normalize(e=this){const t=e.x*e.x+e.y*e.y+e.z*e.z;if(t>0){const s=1/Math.sqrt(t);this.x=e.x*s,this.y=e.y*s,this.z=e.z*s}return this}floor(e=this){return this.x=Math.floor(e.x),this.y=Math.floor(e.y),this.z=Math.floor(e.z),this}ceil(e=this){return this.x=Math.ceil(e.x),this.y=Math.ceil(e.y),this.z=Math.ceil(e.z),this}round(e=this){return this.x=Math.round(e.x),this.y=Math.round(e.y),this.z=Math.round(e.z),this}min(e){return e.x<this.x&&(this.x=e.x),e.y<this.y&&(this.y=e.y),e.z<this.z&&(this.z=e.z),this}max(e){return e.x>this.x&&(this.x=e.x),e.y>this.y&&(this.y=e.y),e.z>this.z&&(this.z=e.z),this}project(e){const t=this.x*e.x+this.y*e.y+this.z*e.z,s=e.x*e.x+e.y*e.y+e.z*e.z,i=t/s;return this.x=e.x*i,this.y=e.y*i,this.z=e.z*i,this}set(e,t,s){return this.x=e,this.y=t,this.z=s,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}sub2(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}fromArray(e,t=0){return this.x=e[t]??this.x,this.y=e[t+1]??this.y,this.z=e[t+2]??this.z,this}toString(){return`[${this.x}, ${this.y}, ${this.z}]`}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}constructor(e=0,t=0,s=0){e.length===3?(this.x=e[0],this.y=e[1],this.z=e[2]):(this.x=e,this.y=t,this.z=s)}}D.ZERO=Object.freeze(new D(0,0,0));D.HALF=Object.freeze(new D(.5,.5,.5));D.ONE=Object.freeze(new D(1,1,1));D.UP=Object.freeze(new D(0,1,0));D.DOWN=Object.freeze(new D(0,-1,0));D.RIGHT=Object.freeze(new D(1,0,0));D.LEFT=Object.freeze(new D(-1,0,0));D.FORWARD=Object.freeze(new D(0,0,-1));D.BACK=Object.freeze(new D(0,0,1));class $i{clone(){const e=this.constructor;return new e().copy(this)}copy(e){const t=e.data,s=this.data;return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[8]=t[8],this}set(e){const t=this.data;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],this}getX(e=new D){return e.set(this.data[0],this.data[1],this.data[2])}getY(e=new D){return e.set(this.data[3],this.data[4],this.data[5])}getZ(e=new D){return e.set(this.data[6],this.data[7],this.data[8])}equals(e){const t=this.data,s=e.data;return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]}isIdentity(){const e=this.data;return e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===1&&e[5]===0&&e[6]===0&&e[7]===0&&e[8]===1}setIdentity(){const e=this.data;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,this}toString(){return`[${this.data.join(", ")}]`}transpose(e=this){const t=e.data,s=this.data;if(t===s){let i;i=t[1],s[1]=t[3],s[3]=i,i=t[2],s[2]=t[6],s[6]=i,i=t[5],s[5]=t[7],s[7]=i}else s[0]=t[0],s[1]=t[3],s[2]=t[6],s[3]=t[1],s[4]=t[4],s[5]=t[7],s[6]=t[2],s[7]=t[5],s[8]=t[8];return this}setFromMat4(e){const t=e.data,s=this.data;return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[4],s[4]=t[5],s[5]=t[6],s[6]=t[8],s[7]=t[9],s[8]=t[10],this}setFromQuat(e){const t=e.x,s=e.y,i=e.z,r=e.w,a=t+t,o=s+s,h=i+i,u=t*a,f=t*o,m=t*h,_=s*o,g=s*h,S=i*h,x=r*a,T=r*o,E=r*h,b=this.data;return b[0]=1-(_+S),b[1]=f+E,b[2]=m-T,b[3]=f-E,b[4]=1-(u+S),b[5]=g+x,b[6]=m+T,b[7]=g-x,b[8]=1-(u+_),this}invertMat4(e){const t=e.data,s=t[0],i=t[1],r=t[2],a=t[4],o=t[5],h=t[6],u=t[8],f=t[9],m=t[10],_=m*o-h*f,g=-m*i+r*f,S=h*i-r*o,x=-m*a+h*u,T=m*s-r*u,E=-h*s+r*a,b=f*a-o*u,C=-f*s+i*u,w=o*s-i*a,P=s*_+i*x+r*b;if(P===0)this.setIdentity();else{const I=1/P,M=this.data;M[0]=_*I,M[1]=g*I,M[2]=S*I,M[3]=x*I,M[4]=T*I,M[5]=E*I,M[6]=b*I,M[7]=C*I,M[8]=w*I}return this}transformVector(e,t=new D){const s=this.data,{x:i,y:r,z:a}=e;return t.x=i*s[0]+r*s[3]+a*s[6],t.y=i*s[1]+r*s[4]+a*s[7],t.z=i*s[2]+r*s[5]+a*s[8],t}constructor(){this.data=new Float32Array(9),this.data[0]=this.data[4]=this.data[8]=1}}$i.IDENTITY=Object.freeze(new $i);$i.ZERO=Object.freeze(new $i().set([0,0,0,0,0,0,0,0,0]));class ne{add(e){return this.x+=e.x,this.y+=e.y,this}add2(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addScaled(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}clone(){const e=this.constructor;return new e(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}cross(e){return this.x*e.y-this.y*e.x}distance(e){const t=this.x-e.x,s=this.y-e.y;return Math.sqrt(t*t+s*s)}div(e){return this.x/=e.x,this.y/=e.y,this}div2(e,t){return this.x=e.x/t.x,this.y=e.y/t.y,this}divScalar(e){return this.x/=e,this.y/=e,this}dot(e){return this.x*e.x+this.y*e.y}equals(e){return this.x===e.x&&this.y===e.y}equalsApprox(e,t=1e-6){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSq(){return this.x*this.x+this.y*this.y}lerp(e,t,s){return this.x=e.x+s*(t.x-e.x),this.y=e.y+s*(t.y-e.y),this}mul(e){return this.x*=e.x,this.y*=e.y,this}mul2(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this}mulScalar(e){return this.x*=e,this.y*=e,this}normalize(e=this){const t=e.x*e.x+e.y*e.y;if(t>0){const s=1/Math.sqrt(t);this.x=e.x*s,this.y=e.y*s}return this}rotate(e){const t=Math.atan2(this.x,this.y)+e*J.DEG_TO_RAD,s=Math.sqrt(this.x*this.x+this.y*this.y);return this.x=Math.sin(t)*s,this.y=Math.cos(t)*s,this}angle(){return Math.atan2(this.x,this.y)*J.RAD_TO_DEG}angleTo(e){return Math.atan2(this.x*e.y+this.y*e.x,this.x*e.x+this.y*e.y)*J.RAD_TO_DEG}floor(e=this){return this.x=Math.floor(e.x),this.y=Math.floor(e.y),this}ceil(e=this){return this.x=Math.ceil(e.x),this.y=Math.ceil(e.y),this}round(e=this){return this.x=Math.round(e.x),this.y=Math.round(e.y),this}min(e){return e.x<this.x&&(this.x=e.x),e.y<this.y&&(this.y=e.y),this}max(e){return e.x>this.x&&(this.x=e.x),e.y>this.y&&(this.y=e.y),this}set(e,t){return this.x=e,this.y=t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}sub2(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}subScalar(e){return this.x-=e,this.y-=e,this}fromArray(e,t=0){return this.x=e[t]??this.x,this.y=e[t+1]??this.y,this}toString(){return`[${this.x}, ${this.y}]`}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}static angleRad(e,t){return Math.atan2(e.x*t.y-e.y*t.x,e.x*t.x+e.y*t.y)}constructor(e=0,t=0){e.length===2?(this.x=e[0],this.y=e[1]):(this.x=e,this.y=t)}}ne.ZERO=Object.freeze(new ne(0,0));ne.HALF=Object.freeze(new ne(.5,.5));ne.ONE=Object.freeze(new ne(1,1));ne.UP=Object.freeze(new ne(0,1));ne.DOWN=Object.freeze(new ne(0,-1));ne.RIGHT=Object.freeze(new ne(1,0));ne.LEFT=Object.freeze(new ne(-1,0));class me{add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}add2(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addScaled(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}clone(){const e=this.constructor;return new e(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}div(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}div2(e,t){return this.x=e.x/t.x,this.y=e.y/t.y,this.z=e.z/t.z,this.w=e.w/t.w,this}divScalar(e){return this.x/=e,this.y/=e,this.z/=e,this.w/=e,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w}equalsApprox(e,t=1e-6){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t&&Math.abs(this.w-e.w)<t}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}lerp(e,t,s){return this.x=e.x+s*(t.x-e.x),this.y=e.y+s*(t.y-e.y),this.z=e.z+s*(t.z-e.z),this.w=e.w+s*(t.w-e.w),this}mul(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}mul2(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this.w=e.w*t.w,this}mulScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}normalize(e=this){const t=e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w;if(t>0){const s=1/Math.sqrt(t);this.x=e.x*s,this.y=e.y*s,this.z=e.z*s,this.w=e.w*s}return this}floor(e=this){return this.x=Math.floor(e.x),this.y=Math.floor(e.y),this.z=Math.floor(e.z),this.w=Math.floor(e.w),this}ceil(e=this){return this.x=Math.ceil(e.x),this.y=Math.ceil(e.y),this.z=Math.ceil(e.z),this.w=Math.ceil(e.w),this}round(e=this){return this.x=Math.round(e.x),this.y=Math.round(e.y),this.z=Math.round(e.z),this.w=Math.round(e.w),this}min(e){return e.x<this.x&&(this.x=e.x),e.y<this.y&&(this.y=e.y),e.z<this.z&&(this.z=e.z),e.w<this.w&&(this.w=e.w),this}max(e){return e.x>this.x&&(this.x=e.x),e.y>this.y&&(this.y=e.y),e.z>this.z&&(this.z=e.z),e.w>this.w&&(this.w=e.w),this}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}sub2(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}fromArray(e,t=0){return this.x=e[t]??this.x,this.y=e[t+1]??this.y,this.z=e[t+2]??this.z,this.w=e[t+3]??this.w,this}toString(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}constructor(e=0,t=0,s=0,i=0){e.length===4?(this.x=e[0],this.y=e[1],this.z=e[2],this.w=e[3]):(this.x=e,this.y=t,this.z=s,this.w=i)}}me.ZERO=Object.freeze(new me(0,0,0,0));me.HALF=Object.freeze(new me(.5,.5,.5,.5));me.ONE=Object.freeze(new me(1,1,1,1));const id=new ne,sr=new D,Cr=new D,Dr=new D,wp=new D;class fe{static _getPerspectiveHalfSize(e,t,s,i,r){r?(e.x=i*Math.tan(t*Math.PI/360),e.y=e.x/s):(e.y=i*Math.tan(t*Math.PI/360),e.x=e.y*s)}add2(e,t){const s=e.data,i=t.data,r=this.data;return r[0]=s[0]+i[0],r[1]=s[1]+i[1],r[2]=s[2]+i[2],r[3]=s[3]+i[3],r[4]=s[4]+i[4],r[5]=s[5]+i[5],r[6]=s[6]+i[6],r[7]=s[7]+i[7],r[8]=s[8]+i[8],r[9]=s[9]+i[9],r[10]=s[10]+i[10],r[11]=s[11]+i[11],r[12]=s[12]+i[12],r[13]=s[13]+i[13],r[14]=s[14]+i[14],r[15]=s[15]+i[15],this}add(e){return this.add2(this,e)}clone(){const e=this.constructor;return new e().copy(this)}copy(e){const t=e.data,s=this.data;return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[8]=t[8],s[9]=t[9],s[10]=t[10],s[11]=t[11],s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15],this}equals(e){const t=this.data,s=e.data;return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]&&t[9]===s[9]&&t[10]===s[10]&&t[11]===s[11]&&t[12]===s[12]&&t[13]===s[13]&&t[14]===s[14]&&t[15]===s[15]}isIdentity(){const e=this.data;return e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===0&&e[5]===1&&e[6]===0&&e[7]===0&&e[8]===0&&e[9]===0&&e[10]===1&&e[11]===0&&e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1}mul2(e,t){const s=e.data,i=t.data,r=this.data,a=s[0],o=s[1],h=s[2],u=s[3],f=s[4],m=s[5],_=s[6],g=s[7],S=s[8],x=s[9],T=s[10],E=s[11],b=s[12],C=s[13],w=s[14],P=s[15];let I,M,R,L;return I=i[0],M=i[1],R=i[2],L=i[3],r[0]=a*I+f*M+S*R+b*L,r[1]=o*I+m*M+x*R+C*L,r[2]=h*I+_*M+T*R+w*L,r[3]=u*I+g*M+E*R+P*L,I=i[4],M=i[5],R=i[6],L=i[7],r[4]=a*I+f*M+S*R+b*L,r[5]=o*I+m*M+x*R+C*L,r[6]=h*I+_*M+T*R+w*L,r[7]=u*I+g*M+E*R+P*L,I=i[8],M=i[9],R=i[10],L=i[11],r[8]=a*I+f*M+S*R+b*L,r[9]=o*I+m*M+x*R+C*L,r[10]=h*I+_*M+T*R+w*L,r[11]=u*I+g*M+E*R+P*L,I=i[12],M=i[13],R=i[14],L=i[15],r[12]=a*I+f*M+S*R+b*L,r[13]=o*I+m*M+x*R+C*L,r[14]=h*I+_*M+T*R+w*L,r[15]=u*I+g*M+E*R+P*L,this}mulAffine2(e,t){const s=e.data,i=t.data,r=this.data,a=s[0],o=s[1],h=s[2],u=s[4],f=s[5],m=s[6],_=s[8],g=s[9],S=s[10],x=s[12],T=s[13],E=s[14];let b,C,w;return b=i[0],C=i[1],w=i[2],r[0]=a*b+u*C+_*w,r[1]=o*b+f*C+g*w,r[2]=h*b+m*C+S*w,r[3]=0,b=i[4],C=i[5],w=i[6],r[4]=a*b+u*C+_*w,r[5]=o*b+f*C+g*w,r[6]=h*b+m*C+S*w,r[7]=0,b=i[8],C=i[9],w=i[10],r[8]=a*b+u*C+_*w,r[9]=o*b+f*C+g*w,r[10]=h*b+m*C+S*w,r[11]=0,b=i[12],C=i[13],w=i[14],r[12]=a*b+u*C+_*w+x,r[13]=o*b+f*C+g*w+T,r[14]=h*b+m*C+S*w+E,r[15]=1,this}mul(e){return this.mul2(this,e)}transformPoint(e,t=new D){const s=this.data,{x:i,y:r,z:a}=e;return t.x=i*s[0]+r*s[4]+a*s[8]+s[12],t.y=i*s[1]+r*s[5]+a*s[9]+s[13],t.z=i*s[2]+r*s[6]+a*s[10]+s[14],t}transformVector(e,t=new D){const s=this.data,{x:i,y:r,z:a}=e;return t.x=i*s[0]+r*s[4]+a*s[8],t.y=i*s[1]+r*s[5]+a*s[9],t.z=i*s[2]+r*s[6]+a*s[10],t}transformVec4(e,t=new me){const s=this.data,{x:i,y:r,z:a,w:o}=e;return t.x=i*s[0]+r*s[4]+a*s[8]+o*s[12],t.y=i*s[1]+r*s[5]+a*s[9]+o*s[13],t.z=i*s[2]+r*s[6]+a*s[10]+o*s[14],t.w=i*s[3]+r*s[7]+a*s[11]+o*s[15],t}setLookAt(e,t,s){Dr.sub2(e,t).normalize(),Cr.copy(s).normalize(),sr.cross(Cr,Dr).normalize(),Cr.cross(Dr,sr);const i=this.data;return i[0]=sr.x,i[1]=sr.y,i[2]=sr.z,i[3]=0,i[4]=Cr.x,i[5]=Cr.y,i[6]=Cr.z,i[7]=0,i[8]=Dr.x,i[9]=Dr.y,i[10]=Dr.z,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}setFrustum(e,t,s,i,r,a){const o=2*r,h=t-e,u=i-s,f=a-r,m=this.data;return m[0]=o/h,m[1]=0,m[2]=0,m[3]=0,m[4]=0,m[5]=o/u,m[6]=0,m[7]=0,m[8]=(t+e)/h,m[9]=(i+s)/u,m[10]=(-a-r)/f,m[11]=-1,m[12]=0,m[13]=0,m[14]=-o*a/f,m[15]=0,this}setPerspective(e,t,s,i,r){return fe._getPerspectiveHalfSize(id,e,t,s,r),this.setFrustum(-id.x,id.x,-id.y,id.y,s,i)}setOrtho(e,t,s,i,r,a){const o=this.data;return o[0]=2/(t-e),o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[5]=2/(i-s),o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[10]=-2/(a-r),o[11]=0,o[12]=-(t+e)/(t-e),o[13]=-(i+s)/(i-s),o[14]=-(a+r)/(a-r),o[15]=1,this}setFromAxisAngle(e,t){t*=J.DEG_TO_RAD;const{x:s,y:i,z:r}=e,a=Math.cos(t),o=Math.sin(t),h=1-a,u=h*s,f=h*i,m=this.data;return m[0]=u*s+a,m[1]=u*i+o*r,m[2]=u*r-o*i,m[3]=0,m[4]=u*i-o*r,m[5]=f*i+a,m[6]=f*r+o*s,m[7]=0,m[8]=u*r+o*i,m[9]=f*r-s*o,m[10]=h*r*r+a,m[11]=0,m[12]=0,m[13]=0,m[14]=0,m[15]=1,this}setTranslate(e,t,s){const i=this.data;return i[0]=1,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=1,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=1,i[11]=0,i[12]=e,i[13]=t,i[14]=s,i[15]=1,this}setScale(e,t,s){const i=this.data;return i[0]=e,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=t,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=s,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setViewport(e,t,s,i){const r=this.data;return r[0]=s*.5,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=i*.5,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=.5,r[11]=0,r[12]=e+s*.5,r[13]=t+i*.5,r[14]=.5,r[15]=1,this}setReflection(e,t){const s=e.x,i=e.y,r=e.z,a=this.data;return a[0]=1-2*s*s,a[1]=-2*s*i,a[2]=-2*s*r,a[3]=0,a[4]=-2*s*i,a[5]=1-2*i*i,a[6]=-2*i*r,a[7]=0,a[8]=-2*s*r,a[9]=-2*i*r,a[10]=1-2*r*r,a[11]=0,a[12]=-2*s*t,a[13]=-2*i*t,a[14]=-2*r*t,a[15]=1,this}invert(e=this){const t=e.data,s=t[0],i=t[1],r=t[2],a=t[3],o=t[4],h=t[5],u=t[6],f=t[7],m=t[8],_=t[9],g=t[10],S=t[11],x=t[12],T=t[13],E=t[14],b=t[15],C=s*h-i*o,w=s*u-r*o,P=s*f-a*o,I=i*u-r*h,M=i*f-a*h,R=r*f-a*u,L=m*T-_*x,B=m*E-g*x,G=m*b-S*x,H=_*E-g*T,ee=_*b-S*T,j=g*b-S*E,ae=C*j-w*ee+P*H+I*G-M*B+R*L;if(ae===0)this.setIdentity();else{const k=1/ae,O=this.data;O[0]=(h*j-u*ee+f*H)*k,O[1]=(-i*j+r*ee-a*H)*k,O[2]=(T*R-E*M+b*I)*k,O[3]=(-_*R+g*M-S*I)*k,O[4]=(-o*j+u*G-f*B)*k,O[5]=(s*j-r*G+a*B)*k,O[6]=(-x*R+E*P-b*w)*k,O[7]=(m*R-g*P+S*w)*k,O[8]=(o*ee-h*G+f*L)*k,O[9]=(-s*ee+i*G-a*L)*k,O[10]=(x*M-T*P+b*C)*k,O[11]=(-m*M+_*P-S*C)*k,O[12]=(-o*H+h*B-u*L)*k,O[13]=(s*H-i*B+r*L)*k,O[14]=(-x*I+T*w-E*C)*k,O[15]=(m*I-_*w+g*C)*k}return this}set(e){const t=this.data;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],this}setIdentity(){const e=this.data;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}setTRS(e,t,s){const i=t.x,r=t.y,a=t.z,o=t.w,h=s.x,u=s.y,f=s.z,m=i+i,_=r+r,g=a+a,S=i*m,x=i*_,T=i*g,E=r*_,b=r*g,C=a*g,w=o*m,P=o*_,I=o*g,M=this.data;return M[0]=(1-(E+C))*h,M[1]=(x+I)*h,M[2]=(T-P)*h,M[3]=0,M[4]=(x-I)*u,M[5]=(1-(S+C))*u,M[6]=(b+w)*u,M[7]=0,M[8]=(T+P)*f,M[9]=(b-w)*f,M[10]=(1-(S+E))*f,M[11]=0,M[12]=e.x,M[13]=e.y,M[14]=e.z,M[15]=1,this}transpose(e=this){const t=e.data,s=this.data;if(t===s){let i;i=t[1],s[1]=t[4],s[4]=i,i=t[2],s[2]=t[8],s[8]=i,i=t[3],s[3]=t[12],s[12]=i,i=t[6],s[6]=t[9],s[9]=i,i=t[7],s[7]=t[13],s[13]=i,i=t[11],s[11]=t[14],s[14]=i}else s[0]=t[0],s[1]=t[4],s[2]=t[8],s[3]=t[12],s[4]=t[1],s[5]=t[5],s[6]=t[9],s[7]=t[13],s[8]=t[2],s[9]=t[6],s[10]=t[10],s[11]=t[14],s[12]=t[3],s[13]=t[7],s[14]=t[11],s[15]=t[15];return this}getTranslation(e=new D){return e.set(this.data[12],this.data[13],this.data[14])}getX(e=new D){return e.set(this.data[0],this.data[1],this.data[2])}getY(e=new D){return e.set(this.data[4],this.data[5],this.data[6])}getZ(e=new D){return e.set(this.data[8],this.data[9],this.data[10])}getScale(e=new D){return this.getX(sr),this.getY(Cr),this.getZ(Dr),e.set(sr.length(),Cr.length(),Dr.length()),e}get scaleSign(){return this.getX(sr),this.getY(Cr),this.getZ(Dr),sr.cross(sr,Cr),sr.dot(Dr)<0?-1:1}setFromEulerAngles(e,t,s){e*=J.DEG_TO_RAD,t*=J.DEG_TO_RAD,s*=J.DEG_TO_RAD;const i=Math.sin(-e),r=Math.cos(-e),a=Math.sin(-t),o=Math.cos(-t),h=Math.sin(-s),u=Math.cos(-s),f=this.data;return f[0]=o*u,f[1]=-o*h,f[2]=a,f[3]=0,f[4]=r*h+u*i*a,f[5]=r*u-i*a*h,f[6]=-o*i,f[7]=0,f[8]=i*h-r*u*a,f[9]=u*i+r*a*h,f[10]=r*o,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,this}getEulerAngles(e=new D){this.getScale(wp);const t=wp.x,s=wp.y,i=wp.z;if(t===0||s===0||i===0)return e.set(0,0,0);const r=this.data,a=Math.asin(-r[2]/t),o=Math.PI*.5;let h,u;return a<o?a>-o?(h=Math.atan2(r[6]/s,r[10]/i),u=Math.atan2(r[1]/t,r[0]/t)):(u=0,h=-Math.atan2(r[4]/s,r[5]/s)):(u=0,h=Math.atan2(r[4]/s,r[5]/s)),e.set(h,a,u).mulScalar(J.RAD_TO_DEG)}toString(){return`[${this.data.join(", ")}]`}constructor(){this.data=new Float32Array(16),this.data[0]=this.data[5]=this.data[10]=this.data[15]=1}}fe.IDENTITY=Object.freeze(new fe);fe.ZERO=Object.freeze(new fe().set([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]));class pe{clone(){const e=this.constructor;return new e(this.x,this.y,this.z,this.w)}conjugate(e=this){return this.x=e.x*-1,this.y=e.y*-1,this.z=e.z*-1,this.w=e.w,this}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}equals(e){return this.x===e.x&&this.y===e.y&&this.z===e.z&&this.w===e.w}equalsApprox(e,t=1e-6){return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t&&Math.abs(this.w-e.w)<t}getAxisAngle(e){let t=Math.acos(this.w)*2;const s=Math.sin(t/2);return s!==0?(e.x=this.x/s,e.y=this.y/s,e.z=this.z/s,(e.x<0||e.y<0||e.z<0)&&(e.x*=-1,e.y*=-1,e.z*=-1,t*=-1)):(e.x=1,e.y=0,e.z=0),t*J.RAD_TO_DEG}getEulerAngles(e=new D){let t,s,i;const r=this.x,a=this.y,o=this.z,h=this.w,u=2*(h*a-r*o);return u<=-.99999?(t=2*Math.atan2(r,h),s=-Math.PI/2,i=0):u>=.99999?(t=2*Math.atan2(r,h),s=Math.PI/2,i=0):(t=Math.atan2(2*(h*r+a*o),1-2*(r*r+a*a)),s=Math.asin(u),i=Math.atan2(2*(h*o+r*a),1-2*(a*a+o*o))),e.set(t,s,i).mulScalar(J.RAD_TO_DEG)}invert(e=this){return this.conjugate(e).normalize()}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}lerp(e,t,s){const i=(1-s)*(e.dot(t)<0?-1:1);return this.x=e.x*i+t.x*s,this.y=e.y*i+t.y*s,this.z=e.z*i+t.z*s,this.w=e.w*i+t.w*s,this.normalize()}mul(e){const t=this.x,s=this.y,i=this.z,r=this.w,a=e.x,o=e.y,h=e.z,u=e.w;return this.x=r*a+t*u+s*h-i*o,this.y=r*o+s*u+i*a-t*h,this.z=r*h+i*u+t*o-s*a,this.w=r*u-t*a-s*o-i*h,this}mulScalar(e,t=this){return this.x=t.x*e,this.y=t.y*e,this.z=t.z*e,this.w=t.w*e,this}mul2(e,t){const s=e.x,i=e.y,r=e.z,a=e.w,o=t.x,h=t.y,u=t.z,f=t.w;return this.x=a*o+s*f+i*u-r*h,this.y=a*h+i*f+r*o-s*u,this.z=a*u+r*f+s*h-i*o,this.w=a*f-s*o-i*h-r*u,this}normalize(e=this){let t=e.length();return t===0?(this.x=this.y=this.z=0,this.w=1):(t=1/t,this.x=e.x*t,this.y=e.y*t,this.z=e.z*t,this.w=e.w*t),this}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}setFromAxisAngle(e,t){t*=.5*J.DEG_TO_RAD;const s=Math.sin(t),i=Math.cos(t);return this.x=s*e.x,this.y=s*e.y,this.z=s*e.z,this.w=i,this}setFromEulerAngles(e,t,s){if(e instanceof D){const m=e;e=m.x,t=m.y,s=m.z}const i=.5*J.DEG_TO_RAD;e*=i,t*=i,s*=i;const r=Math.sin(e),a=Math.cos(e),o=Math.sin(t),h=Math.cos(t),u=Math.sin(s),f=Math.cos(s);return this.x=r*h*f-a*o*u,this.y=a*o*f+r*h*u,this.z=a*h*u-r*o*f,this.w=a*h*f+r*o*u,this}setFromMat4(e){const t=e.data;let s=t[0],i=t[1],r=t[2],a=t[4],o=t[5],h=t[6],u=t[8],f=t[9],m=t[10];s*(o*m-h*f)-i*(a*m-h*u)+r*(a*f-o*u)<0&&(s=-s,i=-i,r=-r);let g;return g=s*s+i*i+r*r,g===0?this.set(0,0,0,1):(g=1/Math.sqrt(g),s*=g,i*=g,r*=g,g=a*a+o*o+h*h,g===0?this.set(0,0,0,1):(g=1/Math.sqrt(g),a*=g,o*=g,h*=g,g=u*u+f*f+m*m,g===0?this.set(0,0,0,1):(g=1/Math.sqrt(g),u*=g,f*=g,m*=g,m<0?s>o?this.set(1+s-o-m,i+a,u+r,h-f):this.set(i+a,1-s+o-m,h+f,u-r):s<-o?this.set(u+r,h+f,1-s-o+m,i-a):this.set(h-f,u-r,i-a,1+s+o+m),this.mulScalar(1/this.length()))))}setFromDirections(e,t){const s=1+e.dot(t);return s<Number.EPSILON?Math.abs(e.x)>Math.abs(e.y)?(this.x=-e.z,this.y=0,this.z=e.x,this.w=0):(this.x=0,this.y=-e.z,this.z=e.y,this.w=0):(this.x=e.y*t.z-e.z*t.y,this.y=e.z*t.x-e.x*t.z,this.z=e.x*t.y-e.y*t.x,this.w=s),this.normalize()}slerp(e,t,s){const i=e.x,r=e.y,a=e.z,o=e.w;let h=t.x,u=t.y,f=t.z,m=t.w,_=o*m+i*h+r*u+a*f;if(_<0&&(m=-m,h=-h,u=-u,f=-f,_=-_),Math.abs(_)>=1)return this.w=o,this.x=i,this.y=r,this.z=a,this;const g=Math.acos(_),S=Math.sqrt(1-_*_);if(Math.abs(S)<.001)return this.w=o*.5+m*.5,this.x=i*.5+h*.5,this.y=r*.5+u*.5,this.z=a*.5+f*.5,this;const x=Math.sin((1-s)*g)/S,T=Math.sin(s*g)/S;return this.w=o*x+m*T,this.x=i*x+h*T,this.y=r*x+u*T,this.z=a*x+f*T,this}transformVector(e,t=new D){const s=e.x,i=e.y,r=e.z,a=this.x,o=this.y,h=this.z,u=this.w,f=u*s+o*r-h*i,m=u*i+h*s-a*r,_=u*r+a*i-o*s,g=-a*s-o*i-h*r;return t.x=f*u+g*-a+m*-h-_*-o,t.y=m*u+g*-o+_*-a-f*-h,t.z=_*u+g*-h+f*-o-m*-a,t}fromArray(e,t=0){return this.x=e[t]??this.x,this.y=e[t+1]??this.y,this.z=e[t+2]??this.z,this.w=e[t+3]??this.w,this}toString(){return`[${this.x}, ${this.y}, ${this.z}, ${this.w}]`}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}constructor(e=0,t=0,s=0,i=1){e.length===4?(this.x=e[0],this.y=e[1],this.z=e[2],this.w=e[3]):(this.x=e,this.y=t,this.z=s,this.w=i)}}pe.IDENTITY=Object.freeze(new pe(0,0,0,1));pe.ZERO=Object.freeze(new pe(0,0,0,0));const Ac=new D,wc=new D,G1=new D,H1=new D,fB=new D;class Ge{add(e){const t=this.center,s=t.x,i=t.y,r=t.z,a=this.halfExtents,o=a.x,h=a.y,u=a.z;let f=s-o,m=s+o,_=i-h,g=i+h,S=r-u,x=r+u;const T=e.center,E=T.x,b=T.y,C=T.z,w=e.halfExtents,P=w.x,I=w.y,M=w.z,R=E-P,L=E+P,B=b-I,G=b+I,H=C-M,ee=C+M;R<f&&(f=R),L>m&&(m=L),B<_&&(_=B),G>g&&(g=G),H<S&&(S=H),ee>x&&(x=ee),t.x=(f+m)*.5,t.y=(_+g)*.5,t.z=(S+x)*.5,a.x=(m-f)*.5,a.y=(g-_)*.5,a.z=(x-S)*.5}copy(e){this.center.copy(e.center),this.halfExtents.copy(e.halfExtents)}clone(){return new Ge(this.center,this.halfExtents)}intersects(e){const t=this.getMax(),s=this.getMin(),i=e.getMax(),r=e.getMin();return s.x<=i.x&&t.x>=r.x&&s.y<=i.y&&t.y>=r.y&&s.z<=i.z&&t.z>=r.z}_intersectsRay(e,t){const s=Ac.copy(this.getMin()).sub(e.origin),i=wc.copy(this.getMax()).sub(e.origin),r=e.direction;r.x===0?(s.x=s.x<0?-Number.MAX_VALUE:Number.MAX_VALUE,i.x=i.x<0?-Number.MAX_VALUE:Number.MAX_VALUE):(s.x/=r.x,i.x/=r.x),r.y===0?(s.y=s.y<0?-Number.MAX_VALUE:Number.MAX_VALUE,i.y=i.y<0?-Number.MAX_VALUE:Number.MAX_VALUE):(s.y/=r.y,i.y/=r.y),r.z===0?(s.z=s.z<0?-Number.MAX_VALUE:Number.MAX_VALUE,i.z=i.z<0?-Number.MAX_VALUE:Number.MAX_VALUE):(s.z/=r.z,i.z/=r.z);const a=G1.set(Math.min(s.x,i.x),Math.min(s.y,i.y),Math.min(s.z,i.z)),o=H1.set(Math.max(s.x,i.x),Math.max(s.y,i.y),Math.max(s.z,i.z)),h=Math.min(Math.min(o.x,o.y),o.z),u=Math.max(Math.max(a.x,a.y),a.z),f=h>=u&&u>=0;return f&&t.copy(e.direction).mulScalar(u).add(e.origin),f}_fastIntersectsRay(e){const t=Ac,s=wc,i=G1,r=H1,a=fB,o=e.direction;return t.sub2(e.origin,this.center),r.set(Math.abs(t.x),Math.abs(t.y),Math.abs(t.z)),i.mul2(t,o),!(r.x>this.halfExtents.x&&i.x>=0||r.y>this.halfExtents.y&&i.y>=0||r.z>this.halfExtents.z&&i.z>=0||(a.set(Math.abs(o.x),Math.abs(o.y),Math.abs(o.z)),s.cross(o,t),s.set(Math.abs(s.x),Math.abs(s.y),Math.abs(s.z)),s.x>this.halfExtents.y*a.z+this.halfExtents.z*a.y)||s.y>this.halfExtents.x*a.z+this.halfExtents.z*a.x||s.z>this.halfExtents.x*a.y+this.halfExtents.y*a.x)}intersectsRay(e,t){return t?this._intersectsRay(e,t):this._fastIntersectsRay(e)}setMinMax(e,t){this.center.add2(t,e).mulScalar(.5),this.halfExtents.sub2(t,e).mulScalar(.5)}getMin(){return this._min.copy(this.center).sub(this.halfExtents)}getMax(){return this._max.copy(this.center).add(this.halfExtents)}containsPoint(e){const t=this.center,s=this.halfExtents;return!(e.x<t.x-s.x||e.x>t.x+s.x||e.y<t.y-s.y||e.y>t.y+s.y||e.z<t.z-s.z||e.z>t.z+s.z)}closestPoint(e,t=new D){const s=this.center,i=this.halfExtents;return t.set(Math.max(s.x-i.x,Math.min(e.x,s.x+i.x)),Math.max(s.y-i.y,Math.min(e.y,s.y+i.y)),Math.max(s.z-i.z,Math.min(e.z,s.z+i.z)))}setFromTransformedAabb(e,t,s=!1){const i=e.center,r=e.halfExtents,a=t.data;let o=a[0],h=a[4],u=a[8],f=a[1],m=a[5],_=a[9],g=a[2],S=a[6],x=a[10];if(s){let T=o*o+h*h+u*u;if(T>0){const E=1/Math.sqrt(T);o*=E,h*=E,u*=E}if(T=f*f+m*m+_*_,T>0){const E=1/Math.sqrt(T);f*=E,m*=E,_*=E}if(T=g*g+S*S+x*x,T>0){const E=1/Math.sqrt(T);g*=E,S*=E,x*=E}}this.center.set(a[12]+o*i.x+h*i.y+u*i.z,a[13]+f*i.x+m*i.y+_*i.z,a[14]+g*i.x+S*i.y+x*i.z),this.halfExtents.set(Math.abs(o)*r.x+Math.abs(h)*r.y+Math.abs(u)*r.z,Math.abs(f)*r.x+Math.abs(m)*r.y+Math.abs(_)*r.z,Math.abs(g)*r.x+Math.abs(S)*r.y+Math.abs(x)*r.z)}static computeMinMax(e,t,s,i=e.length/3){if(i>0){let r=e[0],a=e[1],o=e[2],h=r,u=a,f=o;const m=i*3;for(let _=3;_<m;_+=3){const g=e[_],S=e[_+1],x=e[_+2];g<r&&(r=g),S<a&&(a=S),x<o&&(o=x),g>h&&(h=g),S>u&&(u=S),x>f&&(f=x)}t.set(r,a,o),s.set(h,u,f)}}compute(e,t){Ge.computeMinMax(e,Ac,wc,t),this.setMinMax(Ac,wc)}intersectsBoundingSphere(e){return this._distanceToBoundingSphereSq(e)<=e.radius*e.radius}_distanceToBoundingSphereSq(e){const t=this.getMin(),s=this.getMax();let i=0;const r=["x","y","z"];for(let a=0;a<3;++a){let o=0;const h=e.center[r[a]],u=t[r[a]],f=s[r[a]];let m=0;h<u&&(m=u-h,o+=m*m),h>f&&(m=h-f,o+=m*m),i+=o}return i}_expand(e,t){Ac.add2(this.getMin(),e),wc.add2(this.getMax(),t),this.setMinMax(Ac,wc)}constructor(e,t){this.center=new D,this.halfExtents=new D(.5,.5,.5),this._min=new D,this._max=new D,e&&this.center.copy(e),t&&this.halfExtents.copy(t)}}const Cp=new D,mB=new D;class KT{containsPoint(e){const t=Cp.sub2(e,this.center).lengthSq(),s=this.radius;return t<s*s}intersectsRay(e,t){const s=Cp.copy(e.origin).sub(this.center),i=s.dot(mB.copy(e.direction).normalize()),r=s.dot(s)-this.radius*this.radius;if(r>0&&i>0)return!1;const a=i*i-r;if(a<0)return!1;const o=Math.abs(-i-Math.sqrt(a));return t&&t.copy(e.direction).mulScalar(o).add(e.origin),!0}intersectsBoundingSphere(e){Cp.sub2(e.center,this.center);const t=e.radius+this.radius;return Cp.lengthSq()<=t*t}constructor(e=new D,t=.5){this.center=e,this.radius=t}}class zM{clone(){const e=this.constructor;return new e().copy(this)}copy(e){return this.normal.copy(e.normal),this.distance=e.distance,this}intersectsLine(e,t,s){const i=this.distance,r=this.normal.dot(e)+i,a=this.normal.dot(t)+i,o=r/(r-a),h=o>=0&&o<=1;return h&&s&&s.lerp(e,t,o),h}intersectsRay(e,t){const s=this.normal.dot(e.direction);if(s===0)return!1;const i=-(this.normal.dot(e.origin)+this.distance)/s;return i>=0&&t&&t.copy(e.direction).mulScalar(i).add(e.origin),i>=0}normalize(){const e=1/this.normal.length();return this.normal.mulScalar(e),this.distance*=e,this}set(e,t,s,i){return this.normal.set(e,t,s),this.distance=i,this}setFromPointNormal(e,t){return this.normal.copy(t),this.distance=-this.normal.dot(e),this}constructor(e=D.UP,t=0){this.normal=new D,this.normal.copy(e),this.distance=t}}class kM{clone(){const e=this.constructor;return new e().copy(this)}copy(e){for(let t=0;t<6;t++)this.planes[t].copy(e.planes[t]);return this}setFromMat4(e){const[t,s,i,r,a,o,h,u,f,m,_,g,S,x,T,E]=e.data,b=this.planes;b[0].set(r-t,u-a,g-f,E-S).normalize(),b[1].set(r+t,u+a,g+f,E+S).normalize(),b[2].set(r+s,u+o,g+m,E+x).normalize(),b[3].set(r-s,u-o,g-m,E-x).normalize(),b[4].set(r-i,u-h,g-_,E-T).normalize(),b[5].set(r+i,u+h,g+_,E+T).normalize()}containsPoint(e){for(let t=0;t<6;t++){const{normal:s,distance:i}=this.planes[t];if(s.dot(e)+i<=0)return!1}return!0}add(e){const t=this.planes,s=e.planes;for(let i=0;i<6;i++)s[i].distance>t[i].distance&&t[i].copy(s[i]);return this}containsSphere(e){const{center:t,radius:s}=e;let i=0;for(let r=0;r<6;r++){const{normal:a,distance:o}=this.planes[r],h=a.dot(t)+o;if(h<=-s)return 0;h>s&&i++}return i===6?2:1}constructor(){this.planes=[];for(let e=0;e<6;e++)this.planes[e]=new zM}}class Ux{set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.set(e.origin,e.direction)}clone(){return new this.constructor(this.origin,this.direction)}constructor(e,t){this.origin=new D,this.direction=D.FORWARD.clone(),e&&this.origin.copy(e),t&&this.direction.copy(t)}}const as=0,Te=1,Lg=2,ZT=0,Ms=1,pB=2,VM=4,_B=5,QT=6,JT=8,Sr=0,gB=2,vB=3,SB=4,GM=1,wa=4,Ns=8,yB=16,xB=32,TB=64,eE=128,zx=256,Hi=0,H_=1,EB=2,bB=3,qd=1,Yd=2,W_=4,Ft=0,_l=1,Fd=2,AB=3,ze=0,$t=1,Ef=2,bf=3,Af=4,Jn=5,wB=0,X_=1,q_=2,kx=3,CB=4,DB=5,PB=6,$a=7,Vx=0,Ka=1,eo=2,RB=[1,2,4],tE=0,sE=1,Ig=2,wf=3,Og=4,Cf=5,Ja=6,Ze=7,Df=8,Ng=9,kh=10,Pf=11,kt=12,Fg=13,fs=14,Wr=15,Br=16,gl=17,vl=18,Bg=19,Us=20,Rf=21,Ug=22,zg=23,Vh=24,Gh=25,Mf=26,Lf=27,iE=28,rE=29,aE=30,kg=31,Vg=32,Gg=33,Hg=34,Wg=35,Xg=36,oo=37,qg=38,nE=39,Yg=40,jg=41,$g=42,Hh=43,Kg=44,oE=45,Zg=46,lo=47,Qg=48,Ps=49,If=50,Jg=51,lE=52,ev=53,Y_=54,j_=55,$_=56,K_=61,Z_=62,Q_=63,tv=64,cE=65,hE=66,uE=67,J_=68,ll=69,sv=70,iv=71,rv=72,av=73,nv=74,ov=75,Ki=new Map([[tE,{name:"A8",size:1,ldr:!0}],[lE,{name:"R8",size:1,ldr:!0}],[sE,{name:"L8",size:1,ldr:!0}],[Ig,{name:"LA8",size:2,ldr:!0}],[ev,{name:"RG8",size:2,ldr:!0}],[wf,{name:"RGB565",size:2,ldr:!0}],[Og,{name:"RGBA5551",size:2,ldr:!0}],[Cf,{name:"RGBA4",size:2,ldr:!0}],[Ja,{name:"RGB8",size:4,ldr:!0}],[Ze,{name:"RGBA8",size:4,ldr:!0,srgbFormat:Us}],[If,{name:"R16F",size:2}],[Jg,{name:"RG16F",size:4}],[Pf,{name:"RGB16F",size:8}],[kt,{name:"RGBA16F",size:8}],[Fg,{name:"RGB32F",size:16}],[fs,{name:"RGBA32F",size:16}],[Wr,{name:"R32F",size:4}],[sv,{name:"RG32F",size:8}],[iv,{name:"RGB9E5",size:4}],[rv,{name:"RG8S",size:2}],[av,{name:"RGBA8S",size:4}],[nv,{name:"RGB10A2",size:4}],[ov,{name:"RGB10A2U",size:4,isInt:!0}],[Br,{name:"DEPTH",size:4}],[ll,{name:"DEPTH16",size:2}],[gl,{name:"DEPTHSTENCIL",size:4}],[vl,{name:"111110F",size:4}],[Bg,{name:"SRGB8",size:4,ldr:!0,srgb:!0}],[Us,{name:"SRGBA8",size:4,ldr:!0,srgb:!0}],[kg,{name:"BGRA8",size:4,ldr:!0}],[tv,{name:"SBGRA8",size:4,ldr:!0,srgb:!0}],[Df,{name:"DXT1",blockSize:8,ldr:!0,srgbFormat:Y_}],[Ng,{name:"DXT3",blockSize:16,ldr:!0,srgbFormat:j_}],[kh,{name:"DXT5",blockSize:16,ldr:!0,srgbFormat:$_}],[Rf,{name:"ETC1",blockSize:8,ldr:!0}],[Ug,{name:"ETC2_RGB",blockSize:8,ldr:!0,srgbFormat:K_}],[zg,{name:"ETC2_RGBA",blockSize:16,ldr:!0,srgbFormat:Z_}],[Vh,{name:"PVRTC_2BPP_RGB_1",ldr:!0,blockSize:8}],[Gh,{name:"PVRTC_2BPP_RGBA_1",ldr:!0,blockSize:8}],[Mf,{name:"PVRTC_4BPP_RGB_1",ldr:!0,blockSize:8}],[Lf,{name:"PVRTC_4BPP_RGBA_1",ldr:!0,blockSize:8}],[iE,{name:"ASTC_4x4",blockSize:16,ldr:!0,srgbFormat:Q_}],[rE,{name:"ATC_RGB",blockSize:8,ldr:!0}],[aE,{name:"ATC_RGBA",blockSize:16,ldr:!0}],[cE,{name:"BC6H_RGBF",blockSize:16}],[hE,{name:"BC6H_RGBUF",blockSize:16}],[uE,{name:"BC7_RGBA",blockSize:16,ldr:!0,srgbFormat:J_}],[Y_,{name:"DXT1_SRGB",blockSize:8,ldr:!0,srgb:!0}],[j_,{name:"DXT3_SRGBA",blockSize:16,ldr:!0,srgb:!0}],[$_,{name:"DXT5_SRGBA",blockSize:16,ldr:!0,srgb:!0}],[K_,{name:"ETC2_SRGB",blockSize:8,ldr:!0,srgb:!0}],[Z_,{name:"ETC2_SRGBA",blockSize:16,ldr:!0,srgb:!0}],[Q_,{name:"ASTC_4x4_SRGB",blockSize:16,ldr:!0,srgb:!0}],[J_,{name:"BC7_SRGBA",blockSize:16,ldr:!0,srgb:!0}],[Vg,{name:"R8I",size:1,isInt:!0}],[Gg,{name:"R8U",size:1,isInt:!0}],[Hg,{name:"R16I",size:2,isInt:!0}],[Wg,{name:"R16U",size:2,isInt:!0}],[Xg,{name:"R32I",size:4,isInt:!0}],[oo,{name:"R32U",size:4,isInt:!0}],[qg,{name:"RG8I",size:2,isInt:!0}],[nE,{name:"RG8U",size:2,isInt:!0}],[Yg,{name:"RG16I",size:4,isInt:!0}],[jg,{name:"RG16U",size:4,isInt:!0}],[$g,{name:"RG32I",size:8,isInt:!0}],[Hh,{name:"RG32U",size:8,isInt:!0}],[Kg,{name:"RGBA8I",size:4,isInt:!0}],[oE,{name:"RGBA8U",size:4,isInt:!0}],[Zg,{name:"RGBA16I",size:8,isInt:!0}],[lo,{name:"RGBA16U",size:8,isInt:!0}],[Qg,{name:"RGBA32I",size:16,isInt:!0}],[Ps,{name:"RGBA32U",size:16,isInt:!0}]]),Gx=c=>Ki.get(c)?.blockSize!==void 0,eg=c=>Ki.get(c)?.srgb===!0,qn=c=>Ki.get(c)?.isInt===!0,lv=c=>Ki.get(c)?.srgbFormat||c,MB=c=>{for(const[e,t]of Ki)if(t.srgbFormat===c)return e;return c},LB=c=>{const e=Ki.get(c);return!!(e?.ldr&&!e?.srgb)},dE=c=>{switch(c){case Wr:case sv:case Fg:case fs:return Float32Array;case Xg:case $g:case Qg:return Int32Array;case oo:case Hh:case Ps:case iv:case nv:case ov:return Uint32Array;case Hg:case Yg:case Zg:return Int16Array;case ev:case Wg:case jg:case lo:case wf:case Og:case Cf:case If:case Jg:case Pf:case kt:return Uint16Array;case Vg:case qg:case Kg:case rv:case av:return Int8Array;default:return Uint8Array}},cv=0,hv=1,HM=2,fE=3,ka=4,zr=5,cl=6,He="POSITION",si="NORMAL",Xr="TANGENT",kr="BLENDWEIGHT",yi="BLENDINDICES",Rs="COLOR",W1="TEXCOORD",Zi="TEXCOORD0",Il="TEXCOORD1",Of="TEXCOORD2",Nf="TEXCOORD3",Ff="TEXCOORD4",Bf="TEXCOORD5",Uf="TEXCOORD6",zf="TEXCOORD7",Hx="ATTR0",tg="ATTR1",mE="ATTR2",pE="ATTR3",_E="ATTR4",IB="ATTR5",OB="ATTR6",NB="ATTR7",jd="ATTR8",$d="ATTR9",FB="ATTR10",gE="ATTR11",vE="ATTR12",uv="ATTR13",SE="ATTR14",Eh="ATTR15",BB=1,fh=0,UB=2,zB=3,kB=5,n0=0,WM=1,X1=2,qr="default",Sl="rgbm",sg="rgbe",bh="rgbp",yE="swizzleGGGR",XM="1d",Si="2d",Na="2d-array",Fa="cube",ig="cube-array",mh="3d",Ks=0,Ol=1,mr=2,yl=3,to=4,VB="none",Wx="cube",q1="equirect",GB="octahedral",ot="glsl",Je="wgsl",co=0,Va=1,ho=2,Nl=3,Wh=4,Xh=5,ct=6,dv=7,ph=0,Ga=1,Bs=2,xl=3,Gi=4,so=5,hl=6,Ha=7,ul=8,Kd=9,Zd=10,Qd=11,rg=12,Ah=13,Or=14,HB=15,WB=16,fv=17,XB=18,qB=19,YB=20,mv=21,pv=22,xE=23,qM=24,jB=25,Qs=26,wh=27,Ch=28,Dh=29,Ph=30,_v=31,gv=32,Rh=33,vv=34,Sv=35,Mh=36,yv=37,xv=38,ag=39,TE=40,EE=41,$B=42,KB=43,ZB=44,QB=45,JB=46,eU=47,tU=48,sU=49,Y1=["bool","int","float","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","mat2","mat3","mat4","sampler2D","samplerCube","","sampler2DShadow","samplerCubeShadow","sampler3D","","","","","sampler2DArray","uint","uvec2","uvec3","uvec4","","","","","","","","","","","","","isampler2D","usampler2D","isamplerCube","usamplerCube","isampler3D","usampler3D","isampler2DArray","usampler2DArray"],YM=[["bool"],["i32"],["f32"],["vec2f","vec2<f32>"],["vec3f","vec3<f32>"],["vec4f","vec4<f32>"],["vec2i","vec2<i32>"],["vec3i","vec3<i32>"],["vec4i","vec4<i32>"],["vec2<bool>"],["vec3<bool>"],["vec4<bool>"],["mat2x2f","mat2x2<f32>"],["mat3x3f","mat3x3<f32>"],["mat4x4f","mat4x4<f32>"],["texture_2d<f32>"],["texture_cube<f32>"],["array<f32>"],["texture_depth_2d"],["texture_depth_cube"],["texture_3d<f32>"],["array<vec2<f32>>"],["array<vec3<f32>>"],["array<vec4<f32>>"],["array<mat4x4<f32>>"],["texture_2d_array<f32>"],["u32"],["vec2u","vec2<u32>"],["vec3u","vec3<u32>"],["vec4u","vec4<u32>"],["array<i32>"],["array<u32>"],["array<bool>"],["array<vec2i>","array<vec2<i32>>"],["array<vec2u>","array<vec2<u32>>"],["array<vec2b>","array<vec2<bool>>"],["array<vec3i>","array<vec3<i32>>"],["array<vec3u>","array<vec3<u32>>"],["array<vec3b>","array<vec3<bool>>"],["array<vec4i>","array<vec4<i32>>"],["array<vec4u>","array<vec4<u32>>"],["array<vec4b>","array<vec4<bool>>"],["texture_2d<i32>"],["texture_2d<u32>"],["texture_cube<i32>"],["texture_cube<u32>"],["texture_3d<i32>"],["texture_3d<u32>"],["texture_2d_array<i32>"],["texture_2d_array<u32>"]],jM=new Map;YM.forEach((c,e)=>{c.forEach(t=>jM.set(t,e))});const _h="webgl2",ng="webgpu",og="null",Tl=1,El=2,rs=4,iU="ldr",Dp="ldr_srgb",rU="hdr",$M=1,KM=2,ZM=4,QM=8,JM=16,e2=32,t2=64,s2=128,aU=255,Jd=0,kf=1,Lh=2,i2=["view","mesh","mesh_ub"],Tv="default",bE="_unused_float_uniform",gh=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Uint16Array],Bd=[1,1,2,2,4,4,4,2],AE=[Uint8Array,Uint16Array,Uint32Array],nU=[1,2,4],r2=new Map([["float","f32"],["vec2","vec2f"],["vec3","vec3f"],["vec4","vec4f"],["int","i32"],["ivec2","vec2i"],["ivec3","vec3i"],["ivec4","vec4i"],["uint","u32"],["uvec2","vec2u"],["uvec3","vec3u"],["uvec4","vec4u"]]),$e={};$e[He]=0;$e[si]=1;$e[kr]=2;$e[yi]=3;$e[Rs]=4;$e[Zi]=5;$e[Il]=6;$e[Of]=7;$e[Nf]=8;$e[Ff]=9;$e[Bf]=10;$e[Uf]=11;$e[zf]=12;$e[Xr]=13;$e[Hx]=0;$e[tg]=1;$e[mE]=2;$e[pE]=3;$e[_E]=4;$e[IB]=5;$e[OB]=6;$e[NB]=7;$e[jd]=8;$e[$d]=9;$e[FB]=10;$e[gE]=11;$e[vE]=12;$e[uv]=13;$e[SE]=14;$e[Eh]=15;const oU="modulepreload",lU=function(c){return"/my-3d-gallery_2/"+c},j1={},Xx=function(e,t,s){let i=Promise.resolve();if(t&&t.length>0){let h=function(u){return Promise.all(u.map(f=>Promise.resolve(f).then(m=>({status:"fulfilled",value:m}),m=>({status:"rejected",reason:m}))))};document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),o=a?.nonce||a?.getAttribute("nonce");i=h(t.map(u=>{if(u=lU(u),u in j1)return;j1[u]=!0;const f=u.endsWith(".css"),m=f?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${u}"]${m}`))return;const _=document.createElement("link");if(_.rel=f?"stylesheet":oU,f||(_.as="script"),_.crossOrigin="",_.href=u,o&&_.setAttribute("nonce",o),document.head.appendChild(_),f)return new Promise((g,S)=>{_.addEventListener("load",g),_.addEventListener("error",()=>S(new Error(`Unable to preload CSS for ${u}`)))})}))}function r(a){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=a,window.dispatchEvent(o),!o.defaultPrevented)throw a}return i.then(a=>{for(const o of a||[])o.status==="rejected"&&r(o.reason);return e().catch(r)})};let cU=0;class Ev{constructor(e,t){this.slot=-1,this.scopeId=null,this.name=e,this.visibility=t}}class io extends Ev{}class Is extends Ev{constructor(e,t,s=!1){super(e,t),this.format="",this.readOnly=s}}class ef extends Ev{constructor(e,t,s=Si,i=Ks,r=!0,a=null){super(e,t),this.textureDimension=s,this.sampleType=i,this.hasSampler=r,this.samplerName=a??`${e}_sampler`}}class hU extends Ev{constructor(e,t=Ze,s=Si,i=!0,r=!1){super(e,rs),this.format=t,this.textureDimension=s,this.write=i,this.read=r}}class Vr{destroy(){this.impl.destroy()}getTexture(e){const t=this.textureFormatsMap.get(e);return t!==void 0?this.textureFormats[t]:null}getStorageTexture(e){const t=this.storageTextureFormatsMap.get(e);return t!==void 0?this.storageTextureFormats[t]:null}loseContext(){}constructor(e,t){this.uniformBufferFormats=[],this.textureFormats=[],this.storageTextureFormats=[],this.storageBufferFormats=[],this.id=cU++;let s=0;t.forEach(r=>{r.slot=s++,r instanceof ef&&r.hasSampler&&s++,r instanceof io?this.uniformBufferFormats.push(r):r instanceof ef?this.textureFormats.push(r):r instanceof hU?this.storageTextureFormats.push(r):r instanceof Is&&this.storageBufferFormats.push(r)}),this.device=e;const i=e.scope;this.bufferFormatsMap=new Map,this.uniformBufferFormats.forEach((r,a)=>this.bufferFormatsMap.set(r.name,a)),this.textureFormatsMap=new Map,this.textureFormats.forEach((r,a)=>{this.textureFormatsMap.set(r.name,a),r.scopeId=i.resolve(r.name)}),this.storageTextureFormatsMap=new Map,this.storageTextureFormats.forEach((r,a)=>{this.storageTextureFormatsMap.set(r.name,a),r.scopeId=i.resolve(r.name)}),this.storageBufferFormatsMap=new Map,this.storageBufferFormats.forEach((r,a)=>{this.storageBufferFormatsMap.set(r.name,a),r.scopeId=i.resolve(r.name)}),this.impl=e.createBindGroupFormatImpl(this)}}class ks{get(e,t){return this._cache.has(e)||(this._cache.set(e,t()),e.on("destroy",()=>{this.remove(e)}),e.on("devicelost",()=>{this._cache.get(e)?.loseContext?.(e)})),this._cache.get(e)}remove(e){this._cache.get(e)?.destroy?.(e),this._cache.delete(e)}constructor(){this._cache=new Map}}class Wi{static calcLevelDimension(e,t){return Math.max(e>>t,1)}static calcMipLevelsCount(e,t,s=1){return 1+Math.floor(Math.log2(Math.max(e,t,s)))}static calcLevelGpuSize(e,t,s,i){const r=Ki.get(i),a=Ki.get(i)?.size??0;if(a>0)return e*t*s*a;const o=r.blockSize??0;let h=Math.floor((e+3)/4);const u=Math.floor((t+3)/4),f=Math.floor((s+3)/4);return(i===Vh||i===Gh)&&(h=Math.max(Math.floor(h/2),1)),h*u*f*o}static calcGpuSize(e,t,s,i,r,a){let o=0;for(;o+=Wi.calcLevelGpuSize(e,t,s,i),!(!r||e===1&&t===1&&s===1);)e=Math.max(e>>1,1),t=Math.max(t>>1,1),s=Math.max(s>>1,1);return o*(a?6:1)}}class Fl{get(e){let t=this.map.get(e);return t===void 0&&(t=this.id++,this.map.set(e,t)),t}constructor(){this.map=new Map,this.id=0}}const uU=new Fl;class tf{constructor(e,t=0,s=1,i=0,r=1){this.texture=e,this.baseMipLevel=t,this.mipLevelCount=s,this.baseArrayLayer=i,this.arrayLayerCount=r,this.key=uU.get(`${t}:${s}:${i}:${r}`)}}let dU=0;class De{destroy(){const e=this.device;e&&(e.onTextureDestroyed(this),this.impl.destroy(e),this.adjustVramSizeTracking(e._vram,-this._gpuSize),this._levels=null,this.device=null)}recreateImpl(e=!0){const{device:t}=this;this.impl?.destroy(t),this.impl=null,this.impl=t.createTextureImpl(this),this.dirtyAll(),e&&this.upload()}_clearLevels(){this._levels=this._cubemap?[[null,null,null,null,null,null]]:[null]}resize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){const i=this.device;this.adjustVramSizeTracking(i._vram,-this._gpuSize),this._gpuSize=0,this.impl.destroy(i),this._clearLevels(),this._width=Math.floor(e),this._height=Math.floor(t),this._depth=Math.floor(s),this._updateNumLevel(),this.impl=i.createTextureImpl(this),this.dirtyAll()}}loseContext(){this.impl.loseContext(),this.dirtyAll()}adjustVramSizeTracking(e,t){e.tex+=t}propertyChanged(e){this.impl.propertyChanged(e),this.renderVersionDirty=this.device.renderVersion}_updateNumLevel(){const e=this.mipmaps?Wi.calcMipLevelsCount(this.width,this.height):1,t=this._numLevelsRequested;this._numLevels=Math.min(t??e,e),this._mipmaps=this._numLevels>1}get lockedMode(){return this._lockedMode}set minFilter(e){this._minFilter!==e&&(qn(this._format)||(this._minFilter=e,this.propertyChanged($M)))}get minFilter(){return this._minFilter}set magFilter(e){this._magFilter!==e&&(qn(this._format)||(this._magFilter=e,this.propertyChanged(KM)))}get magFilter(){return this._magFilter}set addressU(e){this._addressU!==e&&(this._addressU=e,this.propertyChanged(ZM))}get addressU(){return this._addressU}set addressV(e){this._addressV!==e&&(this._addressV=e,this.propertyChanged(QM))}get addressV(){return this._addressV}set addressW(e){this._volume&&e!==this._addressW&&(this._addressW=e,this.propertyChanged(JM))}get addressW(){return this._addressW}set compareOnRead(e){this._compareOnRead!==e&&(this._compareOnRead=e,this.propertyChanged(e2))}get compareOnRead(){return this._compareOnRead}set compareFunc(e){this._compareFunc!==e&&(this._compareFunc=e,this.propertyChanged(t2))}get compareFunc(){return this._compareFunc}set anisotropy(e){this._anisotropy!==e&&(this._anisotropy=e,this.propertyChanged(s2))}get anisotropy(){return this._anisotropy}set mipmaps(e){this._mipmaps!==e&&(this.device.isWebGPU||qn(this._format)||(this._mipmaps=e),e&&(this._needsMipmapsUpload=!0,this.device?.texturesToUpload?.add(this)))}get mipmaps(){return this._mipmaps}get numLevels(){return this._numLevels}get storage(){return this._storage}get width(){return this._width}get height(){return this._height}get depth(){return this._depth}get format(){return this._format}get cubemap(){return this._cubemap}get gpuSize(){const e=this.pot&&this._mipmaps&&!(this._compressed&&this._levels.length===1);return Wi.calcGpuSize(this._width,this._height,this._depth,this._format,e,this._cubemap)}get array(){return this._arrayLength>0}get arrayLength(){return this._arrayLength}get volume(){return this._volume}set type(e){this._type!==e&&(this._type=e,this.device._shadersDirty=!0)}get type(){return this._type}set srgb(e){const t=eg(this.format);if(e!==t)if(e){const s=lv(this.format);this._format!==s&&(this._format=s,this.recreateImpl(),this.device._shadersDirty=!0)}else{const s=MB(this.format);this._format!==s&&(this._format=s,this.recreateImpl(),this.device._shadersDirty=!0)}}get srgb(){return eg(this.format)}set flipY(e){this._flipY!==e&&(this._flipY=e,this.markForUpload())}get flipY(){return this._flipY}set premultiplyAlpha(e){this._premultiplyAlpha!==e&&(this._premultiplyAlpha=e,this.markForUpload())}get premultiplyAlpha(){return this._premultiplyAlpha}get pot(){return J.powerOfTwo(this._width)&&J.powerOfTwo(this._height)}get encoding(){switch(this.type){case Sl:return"rgbm";case sg:return"rgbe";case bh:return"rgbp"}return LB(this.format)?"srgb":"linear"}dirtyAll(){this._levelsUpdated=this._cubemap?[[!0,!0,!0,!0,!0,!0]]:[!0],this.markForUpload(),this._needsMipmapsUpload=this._mipmaps,this._mipmapsUploaded=!1,this.propertyChanged(aU)}lock(e={}){var t,s,i;(t=e).level??(t.level=0),(s=e).face??(s.face=0),(i=e).mode??(i.mode=X1),this._lockedMode=e.mode,this._lockedLevel=e.level;const r=this.cubemap?this._levels[e.face]:this._levels;if(r[e.level]===null){const a=Math.max(1,this._width>>e.level),o=Math.max(1,this._height>>e.level),h=Math.max(1,this._depth>>e.level),u=new ArrayBuffer(Wi.calcLevelGpuSize(a,o,h,this._format));r[e.level]=new(dE(this._format))(u)}return r[e.level]}setSource(e,t=0){let s=!1,i,r;if(this._cubemap){if(e[0]){i=e[0].width||0,r=e[0].height||0;for(let a=0;a<6;a++){const o=e[a];if(!o||o.width!==i||o.height!==r||!this.device._isBrowserInterface(o)){s=!0;break}}}else s=!0;if(!s)for(let a=0;a<6;a++)this._levels[t][a]!==e[a]&&(this._levelsUpdated[t][a]=!0)}else this.device._isBrowserInterface(e)||(s=!0),s||(e!==this._levels[t]&&(this._levelsUpdated[t]=!0),e instanceof HTMLVideoElement?(i=e.videoWidth,r=e.videoHeight):(i=e.width,r=e.height));if(s)if(this._width=4,this._height=4,this._cubemap)for(let a=0;a<6;a++)this._levels[t][a]=null,this._levelsUpdated[t][a]=!0;else this._levels[t]=null,this._levelsUpdated[t]=!0;else t===0&&(this._width=i,this._height=r),this._levels[t]=e;(this._invalid!==s||!s)&&(this._invalid=s,this.upload())}getSource(e=0){return this._levels[e]}unlock(){this._lockedMode,this._lockedMode===X1&&this.upload(),this._lockedLevel=-1,this._lockedMode=n0}markForUpload(){this._needsUpload=!0,this.device?.texturesToUpload?.add(this)}upload(){this.markForUpload(),this._needsMipmapsUpload=this._mipmaps,this.impl.uploadImmediate?.(this.device,this)}read(e,t,s,i,r={}){return this.impl.read?.(e,t,s,i,r)}write(e,t,s,i,r){return this.impl.write?.(e,t,s,i,r)}getView(e=0,t=1,s=0,i=1){return new tf(this,e,t,s,i)}constructor(e,t={}){this._gpuSize=0,this.id=dU++,this._invalid=!1,this._lockedLevel=-1,this._lockedMode=n0,this.renderVersionDirty=0,this._storage=!1,this._numLevels=0,this.device=e,this.name=t.name??"",this._width=Math.floor(t.width??4),this._height=Math.floor(t.height??4),this._format=t.format??Ze,this._compressed=Gx(this._format),this._integerFormat=qn(this._format),this._integerFormat&&(t.minFilter=ze,t.magFilter=ze),this._volume=t.volume??!1,this._depth=Math.floor(t.depth??1),this._arrayLength=Math.floor(t.arrayLength??0),this._storage=t.storage??!1,this._cubemap=t.cubemap??!1,this._flipY=t.flipY??!1,this._premultiplyAlpha=t.premultiplyAlpha??!1,this._mipmaps=t.mipmaps??!0,this._numLevelsRequested=t.numLevels,t.numLevels!==void 0&&(this._numLevels=t.numLevels),this._updateNumLevel(),this._minFilter=t.minFilter??Jn,this._magFilter=t.magFilter??$t,this._anisotropy=t.anisotropy??1,this._addressU=t.addressU??as,this._addressV=t.addressV??as,this._addressW=t.addressW??as,this._compareOnRead=t.compareOnRead??!1,this._compareFunc=t.compareFunc??X_,this._type=t.type??qr,this.projection=VB,this._cubemap?this.projection=Wx:t.projection&&t.projection!==Wx&&(this.projection=t.projection),this._levels=t.levels;const s=!!t.levels;this._levels||this._clearLevels(),this.recreateImpl(s)}}const fU={white:[255,255,255,255],gray:[128,128,128,255],black:[0,0,0,255],normal:[128,128,255,255],pink:[255,128,255,255]};class mU{destroy(){this.map.forEach(e=>{e.destroy()})}constructor(){this.map=new Map}}const pU=new ks,dl=(c,e)=>{const t=pU.get(c,()=>new mU);if(!t.map.has(e)){const s=new De(c,{name:`built-in-texture-${e}`,width:1,height:1,format:Ze}),i=s.lock(),r=fU[e];i.set(r),s.unlock(),t.map.set(e,s)}return t.map.get(e)};let _U=0;class wE{constructor(){this.offsets=[]}}class qh{destroy(){this.impl.destroy(),this.impl=null,this.format=null,this.defaultUniformBuffer=null}setUniformBuffer(e,t){const s=this.format.bufferFormatsMap.get(e);this.uniformBuffers[s]!==t&&(this.uniformBuffers[s]=t,this.dirty=!0)}setStorageBuffer(e,t){const s=this.format.storageBufferFormatsMap.get(e);this.storageBuffers[s]!==t&&(this.storageBuffers[s]=t,this.dirty=!0)}setTexture(e,t){const s=this.format.textureFormatsMap.get(e),i=t instanceof tf?t.texture:t;this.textures[s]!==t?(this.textures[s]=t,this.dirty=!0):this.renderVersionUpdated<i.renderVersionDirty&&(this.dirty=!0)}setStorageTexture(e,t){const s=this.format.storageTextureFormatsMap.get(e),i=t instanceof tf?t.texture:t;this.storageTextures[s]!==t?(this.storageTextures[s]=t,this.dirty=!0):this.renderVersionUpdated<i.renderVersionDirty&&(this.dirty=!0)}updateUniformBuffers(){for(let e=0;e<this.uniformBuffers.length;e++)this.uniformBuffers[e].update()}update(){const{textureFormats:e,storageTextureFormats:t,storageBufferFormats:s}=this.format;for(let i=0;i<e.length;i++){const r=e[i];let a=r.scopeId.value;a||(r.name==="uSceneDepthMap"&&(a=dl(this.device,"white")),r.name==="uSceneColorMap"&&(a=dl(this.device,"pink")),a||(a=dl(this.device,"pink"))),this.setTexture(r.name,a)}for(let i=0;i<t.length;i++){const r=t[i],a=r.scopeId.value;this.setStorageTexture(r.name,a)}for(let i=0;i<s.length;i++){const r=s[i],a=r.scopeId.value;this.setStorageBuffer(r.name,a)}this.uniformBufferOffsets.length=this.uniformBuffers.length;for(let i=0;i<this.uniformBuffers.length;i++){const r=this.uniformBuffers[i];this.uniformBufferOffsets[i]=r.offset,this.renderVersionUpdated<r.renderVersionDirty&&(this.dirty=!0)}this.dirty&&(this.dirty=!1,this.renderVersionUpdated=this.device.renderVersion,this.impl.update(this))}constructor(e,t,s){this.renderVersionUpdated=-1,this.uniformBufferOffsets=[],this.id=_U++,this.device=e,this.format=t,this.dirty=!0,this.impl=e.createBindGroupImpl(this),this.textures=[],this.storageTextures=[],this.storageBuffers=[],this.uniformBuffers=[],this.defaultUniformBuffer=s,s&&this.setUniformBuffer(Tv,s)}}const xt={set(c,e,t,s=1){return c&~(s<<t)|e<<t},get(c,e,t=1){return c>>e&t},all(c,e,t=1){const s=t<<e;return(c&s)===s},any(c,e,t=1){return(c&t<<e)!==0}},Pp=7,On=15,$1=0,K1=3,Z1=7,Q1=11,J1=14,eD=18,qx=22,tD=23,sD=24,iD=25,rD=26,gU=15,vU=qx;class ht{set blend(e){this.target0=xt.set(this.target0,e?1:0,rD)}get blend(){return xt.all(this.target0,rD)}setColorBlend(e,t,s){this.target0=xt.set(this.target0,e,$1,Pp),this.target0=xt.set(this.target0,t,K1,On),this.target0=xt.set(this.target0,s,Z1,On)}setAlphaBlend(e,t,s){this.target0=xt.set(this.target0,e,Q1,Pp),this.target0=xt.set(this.target0,t,J1,On),this.target0=xt.set(this.target0,s,eD,On)}setColorWrite(e,t,s,i){this.redWrite=e,this.greenWrite=t,this.blueWrite=s,this.alphaWrite=i}get colorOp(){return xt.get(this.target0,$1,Pp)}get colorSrcFactor(){return xt.get(this.target0,K1,On)}get colorDstFactor(){return xt.get(this.target0,Z1,On)}get alphaOp(){return xt.get(this.target0,Q1,Pp)}get alphaSrcFactor(){return xt.get(this.target0,J1,On)}get alphaDstFactor(){return xt.get(this.target0,eD,On)}set redWrite(e){this.target0=xt.set(this.target0,e?1:0,qx)}get redWrite(){return xt.all(this.target0,qx)}set greenWrite(e){this.target0=xt.set(this.target0,e?1:0,tD)}get greenWrite(){return xt.all(this.target0,tD)}set blueWrite(e){this.target0=xt.set(this.target0,e?1:0,sD)}get blueWrite(){return xt.all(this.target0,sD)}set alphaWrite(e){this.target0=xt.set(this.target0,e?1:0,iD)}get alphaWrite(){return xt.all(this.target0,iD)}get allWrite(){return xt.get(this.target0,vU,gU)}copy(e){return this.target0=e.target0,this}clone(){return new this.constructor().copy(this)}get key(){return this.target0}equals(e){return this.target0===e.target0}constructor(e=!1,t=Sr,s=Ms,i=ZT,r,a,o,h=!0,u=!0,f=!0,m=!0){this.target0=0,this.setColorBlend(t,s,i),this.setAlphaBlend(r??t,a??s,o??i),this.setColorWrite(h,u,f,m),this.blend=e}}ht.NOBLEND=Object.freeze(new ht);ht.NOWRITE=Object.freeze(new ht(void 0,void 0,void 0,void 0,void 0,void 0,void 0,!1,!1,!1,!1));ht.ALPHABLEND=Object.freeze(new ht(!0,Sr,QT,JT));ht.ADDBLEND=Object.freeze(new ht(!0,Sr,Ms,Ms));const SU=new Fl,aD=7,nD=0,oD=3;class Gt{set test(e){this.func=e?kx:$a,this.updateKey()}get test(){return this.func!==$a}set write(e){this.data=xt.set(this.data,e?1:0,oD),this.updateKey()}get write(){return xt.all(this.data,oD)}set func(e){this.data=xt.set(this.data,e,nD,aD),this.updateKey()}get func(){return xt.get(this.data,nD,aD)}set depthBias(e){this._depthBias=e,this.updateKey()}get depthBias(){return this._depthBias}set depthBiasSlope(e){this._depthBiasSlope=e,this.updateKey()}get depthBiasSlope(){return this._depthBiasSlope}copy(e){return this.data=e.data,this._depthBias=e._depthBias,this._depthBiasSlope=e._depthBiasSlope,this.key=e.key,this}clone(){return new this.constructor().copy(this)}updateKey(){const{data:e,_depthBias:t,_depthBiasSlope:s}=this,i=`${e}-${t}-${s}`;this.key=SU.get(i)}equals(e){return this.key===e.key}constructor(e=kx,t=!0){this.data=0,this._depthBias=0,this._depthBiasSlope=0,this.key=0,this.func=e,this.write=t}}Gt.DEFAULT=Object.freeze(new Gt);Gt.NODEPTH=Object.freeze(new Gt($a,!1));Gt.WRITEDEPTH=Object.freeze(new Gt($a,!0));class a2{equals(e){return this.globalId===e.globalId&&this.revision===e.revision}copy(e){this.globalId=e.globalId,this.revision=e.revision}reset(){this.globalId=0,this.revision=0}constructor(){this.globalId=0,this.revision=0}}let lD=0;class yU{increment(){this.version.revision++}constructor(){lD++,this.version=new a2,this.version.globalId=lD}}class xU{toJSON(e){}setValue(e){this.value=e,this.versionObject.increment()}getValue(){return this.value}constructor(e){this.name=e,this.value=null,this.versionObject=new yU}}class TU{resolve(e){return this.variables.has(e)||this.variables.set(e,new xU(e)),this.variables.get(e)}removeValue(e){for(const t of this.variables.values())t.value===e&&(t.value=null)}constructor(e){this.name=e,this.variables=new Map}}let EU=0;class Yr{destroy(){const e=this.device;e.buffers.delete(this),this.impl.initialized&&(this.impl.destroy(e),this.adjustVramSizeTracking(e._vram,-this.storage.byteLength))}adjustVramSizeTracking(e,t){e.vb+=t}loseContext(){this.impl.loseContext()}getFormat(){return this.format}getUsage(){return this.usage}getNumVertices(){return this.numVertices}lock(){return this.storage}unlock(){this.impl.unlock(this)}setData(e){return e.byteLength!==this.numBytes?!1:(this.storage=e,this.unlock(),!0)}constructor(e,t,s,i){this.usage=Hi,this.usage=i?.usage??Hi,this.device=e,this.format=t,this.numVertices=s,this.id=EU++,this.impl=e.createVertexBufferImpl(this,t,i),this.numBytes=t.verticesByteSize?t.verticesByteSize:t.size*s,this.adjustVramSizeTracking(e._vram,this.numBytes);const r=i?.data;r?this.setData(r):this.storage=new ArrayBuffer(this.numBytes),this.device.buffers.add(this)}}function Fr(c){if(c==null)return 0;let e=0;for(let t=0,s=c.length;t<s;t++)e=(e<<5)-e+c.charCodeAt(t),e|=0;return e}function bv(c){let t=2166136261;for(let s=0;s<c.length;s++)t^=c[s],t*=16777619;return t>>>0}const bU=new Fl,AU=[2,4,8,12,16],wU=new ks;class Ti{get elements(){return this._elements}static getDefaultInstancingFormat(e){return wU.get(e,()=>new Ti(e,[{semantic:gE,components:4,type:ct},{semantic:vE,components:4,type:ct},{semantic:SE,components:4,type:ct},{semantic:Eh,components:4,type:ct}]))}static isElementValid(e,t){const s=t.components*Bd[t.type];return!(e.isWebGPU&&!AU.includes(s))}update(){this._evaluateHash()}_evaluateHash(){const e=[],t=[],s=this._elements.length;for(let r=0;r<s;r++){const{name:a,dataType:o,numComponents:h,normalize:u,offset:f,stride:m,size:_,asInt:g}=this._elements[r],S=a+o+h+u+g;e.push(S);const x=S+f+m+_;t.push(x)}e.sort();const i=e.join();this.batchingHash=Fr(i),this.shaderProcessingHashString=i,this.renderingHashString=t.join("_"),this.renderingHash=bU.get(this.renderingHashString)}constructor(e,t,s){this.device=e,this._elements=[],this.hasUv0=!1,this.hasUv1=!1,this.hasColor=!1,this.hasTangents=!1,this.verticesByteSize=0,this.vertexCount=s,this.interleaved=s===void 0,this.instancing=!1,this.size=t.reduce((a,o)=>a+Math.ceil(o.components*Bd[o.type]/4)*4,0);let i=0,r;for(let a=0,o=t.length;a<o;a++){const h=t[a];r=h.components*Bd[h.type],s&&(i=J.roundUp(i,r));const u=h.asInt??!1,f=u?!1:h.normalize??!1,m={name:h.semantic,offset:s?i:h.hasOwnProperty("offset")?h.offset:i,stride:s?r:h.hasOwnProperty("stride")?h.stride:this.size,dataType:h.type,numComponents:h.components,normalize:f,size:r,asInt:u};this._elements.push(m),s?i+=r*s:i+=Math.ceil(r/4)*4,h.semantic===Zi?this.hasUv0=!0:h.semantic===Il?this.hasUv1=!0:h.semantic===Rs?this.hasColor=!0:h.semantic===Xr&&(this.hasTangents=!0)}s&&(this.verticesByteSize=i),this._evaluateHash()}}const CU=new Fl;class Xi{set func(e){this._func=e,this._dirty=!0}get func(){return this._func}set ref(e){this._ref=e,this._dirty=!0}get ref(){return this._ref}set fail(e){this._fail=e,this._dirty=!0}get fail(){return this._fail}set zfail(e){this._zfail=e,this._dirty=!0}get zfail(){return this._zfail}set zpass(e){this._zpass=e,this._dirty=!0}get zpass(){return this._zpass}set readMask(e){this._readMask=e,this._dirty=!0}get readMask(){return this._readMask}set writeMask(e){this._writeMask=e,this._dirty=!0}get writeMask(){return this._writeMask}_evalKey(){const{_func:e,_ref:t,_fail:s,_zfail:i,_zpass:r,_readMask:a,_writeMask:o}=this,h=`${e},${t},${s},${i},${r},${a},${o}`;this._key=CU.get(h),this._dirty=!1}get key(){return this._dirty&&this._evalKey(),this._key}copy(e){return this._func=e._func,this._ref=e._ref,this._readMask=e._readMask,this._writeMask=e._writeMask,this._fail=e._fail,this._zfail=e._zfail,this._zpass=e._zpass,this._dirty=e._dirty,this._key=e._key,this}clone(){return new this.constructor().copy(this)}constructor(e={}){this._dirty=!0,this._func=e.func??$a,this._ref=e.ref??0,this._readMask=e.readMask??255,this._writeMask=e.writeMask??255,this._fail=e.fail??fh,this._zfail=e.zfail??fh,this._zpass=e.zpass??fh,this._evalKey()}}Xi.DEFAULT=Object.freeze(new Xi);class Yh extends Pe{postInit(){const e=new Ti(this,[{semantic:He,components:2,type:ct}]),t=new Float32Array([-1,-1,1,-1,-1,1,1,1]);this.quadVertexBuffer=new Yr(this,e,4,{data:t})}initCapsDefines(){const{capsDefines:e}=this;e.clear(),this.textureFloatFilterable&&e.set("CAPS_TEXTURE_FLOAT_FILTERABLE",""),this.textureFloatRenderable&&e.set("CAPS_TEXTURE_FLOAT_RENDERABLE",""),this.supportsMultiDraw&&e.set("CAPS_MULTI_DRAW",""),this.supportsPrimitiveIndex&&e.set("CAPS_PRIMITIVE_INDEX",""),Ve.desktop&&e.set("PLATFORM_DESKTOP",""),Ve.mobile&&e.set("PLATFORM_MOBILE",""),Ve.android&&e.set("PLATFORM_ANDROID",""),Ve.ios&&e.set("PLATFORM_IOS","")}destroy(){this.fire("destroy"),this.quadVertexBuffer?.destroy(),this.quadVertexBuffer=null,this.dynamicBuffers?.destroy(),this.dynamicBuffers=null,this.gpuProfiler?.destroy(),this.gpuProfiler=null,this._destroyed=!0}onDestroyShader(e){this.fire("destroy:shader",e);const t=this.shaders.indexOf(e);t!==-1&&this.shaders.splice(t,1)}onTextureDestroyed(e){this.textures.delete(e),this.texturesToUpload.delete(e),this.scope.removeValue(e)}postDestroy(){this.scope=null,this.canvas=null}loseContext(){this.contextLost=!0,this.backBufferSize.set(-1,-1);for(const e of this.textures)e.loseContext();for(const e of this.buffers)e.loseContext();for(const e of this.targets)e.loseContext();this.gpuProfiler?.loseContext()}restoreContext(){this.contextLost=!1,this.initializeRenderState(),this.initializeContextCaches();for(const e of this.buffers)e.unlock();this.gpuProfiler?.restoreContext?.()}toJSON(e){}initializeContextCaches(){this.vertexBuffers=[],this.shader=null,this.shaderValid=void 0,this.shaderAsyncCompile=!1,this.renderTarget=null}initializeRenderState(){this.blendState=new ht,this.depthState=new Gt,this.cullMode=_l,this.vx=this.vy=this.vw=this.vh=0,this.sx=this.sy=this.sw=this.sh=0,this.blendColor=new ue(0,0,0,0)}setStencilState(e,t){}setBlendState(e){}setBlendColor(e,t,s,i){}setDepthState(e){}setCullMode(e){}setRenderTarget(e){this.renderTarget=e}setVertexBuffer(e){e&&this.vertexBuffers.push(e)}clearVertexBuffer(){this.vertexBuffers.length=0}getIndirectDrawSlot(e=1){return 0}get indirectDrawBuffer(){return null}getIndirectDispatchSlot(e=1){return 0}get indirectDispatchBuffer(){return null}getRenderTarget(){return this.renderTarget}initRenderTarget(e){e.initialized||(e.init(),this.targets.add(e))}draw(e,t,s,i,r=!0,a=!0){}_isBrowserInterface(e){return this._isImageBrowserInterface(e)||this._isImageCanvasInterface(e)||this._isImageVideoInterface(e)}_isImageBrowserInterface(e){return typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement}_isImageCanvasInterface(e){return typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement}_isImageVideoInterface(e){return typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement}resizeCanvas(e,t){const s=Math.min(this._maxPixelRatio,Ve.browser?window.devicePixelRatio:1),i=Math.floor(e*s),r=Math.floor(t*s);(i!==this.canvas.width||r!==this.canvas.height)&&this.setResolution(i,r)}setResolution(e,t){this.canvas.width=e,this.canvas.height=t,this.fire(Yh.EVENT_RESIZE,e,t)}update(){this.updateClientRect()}updateClientRect(){if(Ve.worker)this.clientRect.width=this.canvas.width,this.clientRect.height=this.canvas.height;else{const e=this.canvas.getBoundingClientRect();this.clientRect.width=e.width,this.clientRect.height=e.height}}get width(){return this.canvas.width}get height(){return this.canvas.height}set fullscreen(e){}get fullscreen(){return!1}set maxPixelRatio(e){this._maxPixelRatio=e}get maxPixelRatio(){return this._maxPixelRatio}get deviceType(){return this._deviceType}startRenderPass(e){}endRenderPass(e){}startComputePass(e){}endComputePass(){}frameStart(){this.renderPassIndex=0,this.renderVersion++}frameEnd(){this.mapsToClear.forEach(e=>e.clear()),this.mapsToClear.clear()}computeDispatch(e,t="Unnamed"){}getRenderableHdrFormat(e=[vl,kt,fs],t=!0,s=1){for(let i=0;i<e.length;i++){const r=e[i];switch(r){case vl:{if(this.textureRG11B10Renderable)return r;break}case kt:if(this.textureHalfFloatRenderable)return r;break;case fs:if(this.isWebGPU&&s>1)continue;if(this.textureFloatRenderable&&(!t||this.textureFloatFilterable))return r;break}}}validateAttributes(e,t,s){}constructor(e,t){var s,i,r,a,o,h;super(),this.backBuffer=null,this.backBufferSize=new ne,this.backBufferAntialias=!1,this.isWebGPU=!1,this.isWebGL2=!1,this.isNull=!1,this.isHdr=!1,this.maxIndirectDrawCount=1024,this.maxIndirectDispatchCount=256,this.maxColorAttachments=1,this.maxSamples=1,this.supportsMultiDraw=!0,this.supportsCompute=!1,this.supportsStorageTextureRead=!1,this.renderTarget=null,this.shaders=[],this.textures=new Set,this.texturesToUpload=new Set,this.targets=new Set,this.renderVersion=0,this.insideRenderPass=!1,this.supportsUniformBuffers=!1,this.supportsClipDistances=!1,this.supportsPrimitiveIndex=!1,this.textureRG11B10Renderable=!1,this.textureFloatFilterable=!1,this.blendState=new ht,this.depthState=new Gt,this.stencilEnabled=!1,this.stencilFront=new Xi,this.stencilBack=new Xi,this._destroyed=!1,this.defaultClearOptions={color:[0,0,0,1],depth:1,stencil:0,flags:qd|Yd},this.clientRect={width:0,height:0},this._shadersDirty=!1,this.capsDefines=new Map,this.mapsToClear=new Set,this.canvas=e,"setAttribute"in e&&e.setAttribute("data-engine",`PlayCanvas ${LM}`),this.initOptions={...t},(s=this.initOptions).alpha??(s.alpha=!0),(i=this.initOptions).depth??(i.depth=!0),(r=this.initOptions).stencil??(r.stencil=!0),(a=this.initOptions).antialias??(a.antialias=!0),(o=this.initOptions).powerPreference??(o.powerPreference="high-performance"),(h=this.initOptions).displayFormat??(h.displayFormat=iU),this._maxPixelRatio=Ve.browser?Math.min(1,window.devicePixelRatio):1,this.buffers=new Set,this._vram={tex:0,vb:0,ib:0,ub:0,sb:0},this._shaderStats={vsCompiled:0,fsCompiled:0,linked:0,materialShaders:0,compileTime:0},this.initializeContextCaches(),this._drawCallsPerFrame=0,this._shaderSwitchesPerFrame=0,this._primsPerFrame=[];for(let u=cv;u<=cl;u++)this._primsPerFrame[u]=0;this._renderTargetCreationTime=0,this.scope=new TU("Device"),this.textureBias=this.scope.resolve("textureBias"),this.textureBias.setValue(0)}}Yh.EVENT_RESIZE="resizecanvas";let DU=0;class At{destroy(){const e=this._device;e&&(e.targets.delete(this),e.renderTarget===this&&e.setRenderTarget(null),this.destroyFrameBuffers())}destroyFrameBuffers(){const e=this._device;e&&this.impl.destroy(e)}destroyTextureBuffers(){this._depthBuffer?.destroy(),this._depthBuffer=null,this._colorBuffers?.forEach(e=>{e.destroy()}),this._colorBuffers=null,this._colorBuffer=null}resize(e,t){if(!(this.mipLevel>0)&&(this._depthBuffer?.resize(e,t),this._colorBuffers?.forEach(s=>{s.resize(e,t)}),this._width!==e||this._height!==t)){this.destroyFrameBuffers();const s=this._device;s.renderTarget===this&&s.setRenderTarget(null),this.evaluateDimensions(),this.validateMrt(),this.impl=s.createRenderTargetImpl(this)}}validateMrt(){}evaluateDimensions(){const e=this._colorBuffer??this._depthBuffer;e&&(this._width=e.width,this._height=e.height,this._mipLevel>0&&(this._width=Wi.calcLevelDimension(this._width,this._mipLevel),this._height=Wi.calcLevelDimension(this._height,this._mipLevel)))}init(){this.impl.init(this._device,this)}get initialized(){return this.impl.initialized}get device(){return this._device}loseContext(){this.impl.loseContext()}resolve(e=!0,t=!!this._depthBuffer){this._device&&this._samples>1&&this.impl.resolve(this._device,this,e,t)}copy(e,t,s){if(!this._device)if(e._device)this._device=e._device;else return!1;return this._device.copyRenderTarget(e,this,t,s)}get samples(){return this._samples}get depth(){return this._depth}get stencil(){return this._stencil}get colorBuffer(){return this._colorBuffer}getColorBuffer(e){return this._colorBuffers?.[e]}get depthBuffer(){return this._depthBuffer}get face(){return this._face}get mipLevel(){return this._mipLevel}get mipmaps(){return this._mipmaps}get width(){return this._width??this._device.width}get height(){return this._height??this._device.height}isColorBufferSrgb(e=0){if(this.device.backBuffer===this)return eg(this.device.backBufferFormat);const t=this.getColorBuffer(e);return t?eg(t.format):!1}constructor(e={}){this.id=DU++;const t=e.colorBuffer?.device??e.colorBuffers?.[0].device??e.depthBuffer?.device??e.graphicsDevice;this._device=t;const{maxSamples:s}=this._device;if(this._samples=Math.min(e.samples??1,s),t.isWebGPU&&(this._samples=this._samples>1?s:1),this._colorBuffer=e.colorBuffer,e.colorBuffer&&(this._colorBuffers=[e.colorBuffer]),this._depthBuffer=e.depthBuffer,this._face=e.face??0,this._depthBuffer){const i=this._depthBuffer._format;i===Br||i===ll?(this._depth=!0,this._stencil=!1):i===gl?(this._depth=!0,this._stencil=!0):i===Wr&&this._depthBuffer.device.isWebGPU&&this._samples>1?(this._depth=!0,this._stencil=!1):(this._depth=!1,this._stencil=!1)}else this._depth=e.depth??!0,this._stencil=e.stencil??!1;e.colorBuffers&&(this._colorBuffers||(this._colorBuffers=[...e.colorBuffers],this._colorBuffer=e.colorBuffers[0])),this.autoResolve=e.autoResolve??!0,this.name=e.name,this.name||(this.name=this._colorBuffer?.name),this.name||(this.name=this._depthBuffer?.name),this.name||(this.name="Untitled"),this.flipY=e.flipY??!1,this._mipLevel=e.mipLevel??0,this._mipLevel>0&&this._depth&&(this._mipLevel=0),this._mipmaps=e.mipLevel===void 0,this.evaluateDimensions(),this.validateMrt(),this.impl=t.createRenderTargetImpl(this)}}class PU{update(e){this.destroy();const t=e.device,s=this.createDescriptor(t,e);this.bindGroup=t.wgpu.createBindGroup(s)}destroy(){this.bindGroup=null}createDescriptor(e,t){const s=[],i=t.format,r=t.format.uniformBufferFormats;t.uniformBuffers.forEach((f,m)=>{const _=r[m].slot,g=f.persistent?f.impl.buffer:f.allocation.gpuBuffer.buffer;s.push({binding:_,resource:{buffer:g,offset:0,size:f.format.byteSize}})});const a=t.format.textureFormats;t.textures.forEach((f,m)=>{const _=f instanceof tf,S=(_?f.texture:f).impl,x=i.textureFormats[m],T=a[m].slot,E=S.getView(e,_?f:void 0);if(s.push({binding:T,resource:E}),x.hasSampler){const b=S.getSampler(e,x.sampleType);s.push({binding:T+1,resource:b})}});const o=t.format.storageTextureFormats;t.storageTextures.forEach((f,m)=>{const _=f instanceof tf,S=(_?f.texture:f).impl,x=o[m].slot,T=S.getView(e,_?f:void 0);s.push({binding:x,resource:T})});const h=t.format.storageBufferFormats;return t.storageBuffers.forEach((f,m)=>{const _=f.impl.buffer,g=h[m].slot;s.push({binding:g,resource:{buffer:_}})}),{layout:t.format.impl.bindGroupLayout,entries:s}}}class o0{static shaderStage(e){let t=0;return e&Tl&&(t|=GPUShaderStage.VERTEX),e&El&&(t|=GPUShaderStage.FRAGMENT),e&rs&&(t|=GPUShaderStage.COMPUTE),t}}const _e=[];_e[tE]="";_e[sE]="";_e[Ig]="";_e[lE]="r8unorm";_e[ev]="rg8unorm";_e[wf]="";_e[Og]="";_e[Cf]="";_e[Ja]="rgba8unorm";_e[Ze]="rgba8unorm";_e[Df]="bc1-rgba-unorm";_e[Ng]="bc2-rgba-unorm";_e[kh]="bc3-rgba-unorm";_e[Pf]="";_e[kt]="rgba16float";_e[If]="r16float";_e[Jg]="rg16float";_e[Fg]="";_e[fs]="rgba32float";_e[Wr]="r32float";_e[sv]="rg32float";_e[Br]="depth32float";_e[ll]="depth16unorm";_e[gl]="depth24plus-stencil8";_e[vl]="rg11b10ufloat";_e[Bg]="";_e[Us]="rgba8unorm-srgb";_e[Rf]="";_e[Ug]="etc2-rgb8unorm";_e[zg]="etc2-rgba8unorm";_e[Vh]="";_e[Gh]="";_e[Mf]="";_e[Lf]="";_e[iE]="astc-4x4-unorm";_e[rE]="";_e[aE]="";_e[kg]="bgra8unorm";_e[tv]="bgra8unorm-srgb";_e[Vg]="r8sint";_e[Gg]="r8uint";_e[Hg]="r16sint";_e[Wg]="r16uint";_e[Xg]="r32sint";_e[oo]="r32uint";_e[qg]="rg8sint";_e[nE]="rg8uint";_e[Yg]="rg16sint";_e[jg]="rg16uint";_e[$g]="rg32sint";_e[Hh]="rg32uint";_e[Kg]="rgba8sint";_e[oE]="rgba8uint";_e[Zg]="rgba16sint";_e[lo]="rgba16uint";_e[Qg]="rgba32sint";_e[Ps]="rgba32uint";_e[cE]="bc6h-rgb-float";_e[hE]="bc6h-rgb-ufloat";_e[uE]="bc7-rgba-unorm";_e[iv]="rgb9e5ufloat";_e[rv]="rg8snorm";_e[av]="rgba8snorm";_e[nv]="rgb10a2unorm";_e[ov]="rgb10a2uint";_e[Y_]="bc1-rgba-unorm-srgb";_e[j_]="bc2-rgba-unorm-srgb";_e[$_]="bc3-rgba-unorm-srgb";_e[K_]="etc2-rgb8unorm-srgb";_e[Z_]="etc2-rgba8unorm-srgb";_e[J_]="bc7-rgba-unorm-srgb";_e[Q_]="astc-4x4-unorm-srgb";const jh=[];jh[Ks]="filtering";jh[Ol]="non-filtering";jh[mr]="comparison";jh[yl]="comparison";jh[to]="comparison";const $h=[];$h[Ks]="float";$h[Ol]="unfilterable-float";$h[mr]="depth";$h[yl]="sint";$h[to]="uint";const RU=new Fl;class MU{destroy(){this.bindGroupLayout=null}loseContext(){}createDescriptor(e){const t=[];let s="";return e.uniformBufferFormats.forEach(r=>{const a=o0.shaderStage(r.visibility);s+=`#${r.slot}U:${a}`,t.push({binding:r.slot,visibility:a,buffer:{type:"uniform",hasDynamicOffset:!0}})}),e.textureFormats.forEach(r=>{const a=o0.shaderStage(r.visibility),o=r.sampleType,h=r.textureDimension,u=!1,f=$h[o];if(s+=`#${r.slot}T:${a}-${f}-${h}-${u}`,t.push({binding:r.slot,visibility:a,texture:{sampleType:f,viewDimension:h,multisampled:u}}),r.hasSampler){const m=jh[o];s+=`#${r.slot+1}S:${a}-${m}`,t.push({binding:r.slot+1,visibility:a,sampler:{type:m}})}}),e.storageTextureFormats.forEach(r=>{const{format:a,textureDimension:o}=r,{read:h,write:u}=r;s+=`#${r.slot}ST:${a}-${o}-${h?"r1":"r0"}-${u?"w1":"w0"}`,t.push({binding:r.slot,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:h?u?"read-write":"read-only":"write-only",format:_e[a],viewDimension:o}})}),e.storageBufferFormats.forEach(r=>{const a=r.readOnly,o=o0.shaderStage(r.visibility);s+=`#${r.slot}SB:${o}-${a?"ro":"rw"}`,t.push({binding:r.slot,visibility:o,buffer:{type:a?"read-only-storage":"storage"}})}),{key:s,desc:{entries:t}}}constructor(e){const t=e.device,{key:s,desc:i}=this.createDescriptor(e);this.key=RU.get(s),this.bindGroupLayout=t.wgpu.createBindGroupLayout(i)}}class Av{destroy(e){this.buffer&&(this.buffer.destroy(),this.buffer=null)}get initialized(){return!!this.buffer}loseContext(){}allocate(e,t){this.buffer=e.wgpu.createBuffer({size:t,usage:this.usageFlags})}unlock(e,t){const s=e.wgpu;if(!this.buffer){const o=t.byteLength+3&-4;this.usageFlags|=GPUBufferUsage.COPY_DST,this.allocate(e,o)}const i=t.byteOffset??0,r=new Uint8Array(t.buffer??t,i,t.byteLength),a=new Uint8Array(this.buffer.size);a.set(r),s.queue.writeBuffer(this.buffer,0,a,0,a.length)}read(e,t,s,i,r){return e.readStorageBuffer(this,t,s,i,r)}write(e,t,s,i,r){e.writeStorageBuffer(this,t,s,i,r)}clear(e,t,s){e.clearStorageBuffer(this,t,s)}constructor(e=0){this.buffer=null,this.usageFlags=0,this.usageFlags=e}}class LU extends Av{unlock(e){const t=e.device;super.unlock(t,e.storage)}constructor(e,t){super(yB|(t?.storage?eE:0)),this.format=null,this.format=e.format===Ka?"uint16":"uint32"}}const n2={equals(c,e){if(c.length!==e.length)return!1;for(let t=0;t<c.length;t++)if(c[t]!==e[t])return!1;return!0}},en=[];en[co]="sint8";en[Va]="uint8";en[ho]="sint16";en[Nl]="uint16";en[Wh]="sint32";en[Xh]="uint32";en[ct]="float32";en[dv]="float16";const tn=[];tn[co]="snorm8";tn[Va]="unorm8";tn[ho]="snorm16";tn[Nl]="unorm16";tn[Wh]="sint32";tn[Xh]="uint32";tn[ct]="float32";tn[dv]="float16";class IU{get(e,t=null){const s=this.getKey(e,t);let i=this.cache.get(s);return i||(i=this.create(e,t),this.cache.set(s,i)),i}getKey(e,t=null){return`${e?.renderingHashString}-${t?.renderingHashString}`}create(e,t){const s=[],i=r=>{const a=r.interleaved,o=r.instancing?"instance":"vertex";let h=[];const u=r.elements.length;for(let f=0;f<u;f++){const m=r.elements[f],_=$e[m.name],g=m.normalize?tn:en;h.push({shaderLocation:_,offset:a?m.offset:0,format:`${g[m.dataType]}${m.numComponents>1?`x${m.numComponents}`:""}`}),(!a||f===u-1)&&(s.push({attributes:h,arrayStride:m.stride,stepMode:o}),h=[])}};return e&&i(e),t&&i(t),s}constructor(){this.cache=new Map}}class o2{getPipelineLayout(e){const t=[];e.forEach(r=>{t.push(r.bindGroupLayout)});const s={bindGroupLayouts:t};return this.device.wgpu.createPipelineLayout(s)}constructor(e){this.device=e}}const OU=["point-list","line-list",void 0,"line-strip","triangle-list","triangle-strip",void 0],cD=["add","subtract","reverse-subtract","min","max"],Rp=["zero","one","src","one-minus-src","dst","one-minus-dst","src-alpha","src-alpha-saturated","one-minus-src-alpha","dst-alpha","one-minus-dst-alpha","constant","one-minus-constant"],l0=["never","less","equal","less-equal","greater","not-equal","greater-equal","always"],NU=["none","back","front"],Cc=["keep","zero","replace","increment-clamp","increment-wrap","decrement-clamp","decrement-wrap","invert"],FU=["","uint16","uint32"];let BU=class{};class UU extends o2{get(e,t,s,i,r,a,o,h,u,f,m,_,g){const S=e.type;i&&S!==fE&&S!==zr&&(i=void 0);const x=this.lookupHashes;x[0]=S,x[1]=r.id,x[2]=f,x[3]=u.key,x[4]=h.key,x[5]=t?.renderingHash??0,x[6]=s?.renderingHash??0,x[7]=a.impl.key,x[8]=o[0]?.key??0,x[9]=o[1]?.key??0,x[10]=o[2]?.key??0,x[11]=m?_.key:0,x[12]=m?g.key:0,x[13]=i??0;const T=bv(x);let E=this.cache.get(T);if(E)for(let I=0;I<E.length;I++){const M=E[I];if(n2.equals(M.hashes,x))return M.pipeline}const b=OU[S],C=this.getPipelineLayout(o),w=this.vertexBufferLayout.get(t,s),P=new BU;return P.hashes=new Uint32Array(x),P.pipeline=this.create(b,i,r,a,C,h,u,w,f,m,_,g),E?E.push(P):E=[P],this.cache.set(T,E),P.pipeline}getBlend(e){let t;return e.blend&&(t={color:{operation:cD[e.colorOp],srcFactor:Rp[e.colorSrcFactor],dstFactor:Rp[e.colorDstFactor]},alpha:{operation:cD[e.alphaOp],srcFactor:Rp[e.alphaSrcFactor],dstFactor:Rp[e.alphaDstFactor]}}),t}getDepthStencil(e,t,s,i,r,a){let o;const{depth:h,stencil:u}=t;if(h||u){if(o={format:t.impl.depthAttachment.format},h){o.depthWriteEnabled=e.write,o.depthCompare=l0[e.func];const f=a==="triangle-list"||a==="triangle-strip";o.depthBias=f?e.depthBias:0,o.depthBiasSlopeScale=f?e.depthBiasSlope:0}else o.depthWriteEnabled=!1,o.depthCompare="always";u&&s&&(o.stencilReadMas=i.readMask,o.stencilWriteMask=i.writeMask,o.stencilFront={compare:l0[i.func],failOp:Cc[i.fail],passOp:Cc[i.zpass],depthFailOp:Cc[i.zfail]},o.stencilBack={compare:l0[r.func],failOp:Cc[r.fail],passOp:Cc[r.zpass],depthFailOp:Cc[r.zfail]})}return o}create(e,t,s,i,r,a,o,h,u,f,m,_){const g=this.device.wgpu,S=s.impl,x={vertex:{module:S.getVertexShaderModule(),entryPoint:S.vertexEntryPoint,buffers:h},primitive:{topology:e,frontFace:"ccw",cullMode:NU[u]},depthStencil:this.getDepthStencil(o,i,f,m,_,e),multisample:{count:i.samples},layout:r};t&&(x.primitive.stripIndexFormat=FU[t]),x.fragment={module:S.getFragmentShaderModule(),entryPoint:S.fragmentEntryPoint,targets:[]};const T=i.impl.colorAttachments;if(T.length>0){let b=0;a.redWrite&&(b|=GPUColorWrite.RED),a.greenWrite&&(b|=GPUColorWrite.GREEN),a.blueWrite&&(b|=GPUColorWrite.BLUE),a.alphaWrite&&(b|=GPUColorWrite.ALPHA);const C=this.getBlend(a);T.forEach(w=>{x.fragment.targets.push({format:w.format,writeMask:b,blend:C})})}return g.createRenderPipeline(x)}constructor(e){super(e),this.lookupHashes=new Uint32Array(14),this.vertexBufferLayout=new IU,this.cache=new Map}}class zU{constructor(){this.pipeline=null,this.hashes=null}}class kU extends o2{get(e,t){const s=this.lookupHashes;s[0]=e.impl.computeKey,s[1]=t.impl.key;const i=bv(s);let r=this.cache.get(i);if(r)for(let h=0;h<r.length;h++){const u=r[h];if(n2.equals(u.hashes,s))return u.pipeline}const a=this.getPipelineLayout([t.impl]),o=new zU;return o.hashes=new Uint32Array(s),o.pipeline=this.create(e,a),r?r.push(o):r=[o],this.cache.set(i,r),o.pipeline}create(e,t){const s=this.device.wgpu,i=e.impl,r={compute:{module:i.getComputeShaderModule(),entryPoint:i.computeEntryPoint},layout:t};return s.createComputePipeline(r)}constructor(...e){super(...e),this.lookupHashes=new Uint32Array(2),this.cache=new Map}}class wv{incRefCount(){this._refCount++}decRefCount(){this._refCount--}get refCount(){return this._refCount}constructor(){this._refCount=0}}class VU extends wv{constructor(e){super(),this.object=e,this.incRefCount()}}class GU{destroy(){this.cache.forEach(e=>{e.object?.destroy()}),this.cache.clear()}clear(){this.cache.clear()}get(e){const t=this.cache.get(e);return t?(t.incRefCount(),t.object):null}set(e,t){this.cache.set(e,new VU(t))}release(e){const t=this.cache.get(e);t&&(t.decRefCount(),t.refCount===0&&(this.cache.delete(e),t.object?.destroy()))}constructor(){this.cache=new Map}}class HU extends GU{loseContext(e){this.clear()}}const WU=new ks,Ud=c=>WU.get(c,()=>new HU),XU=new Fl;class qU{destroy(){this.multisampledBuffer?.destroy(),this.multisampledBuffer=null}}class hD{destroy(e){this.depthTextureInternal&&(this.depthTexture?.destroy(),this.depthTexture=null),this.multisampledDepthBuffer&&(this.multisampledDepthBuffer=null,Ud(e).release(this.multisampledDepthBufferKey))}constructor(e){this.depthTexture=null,this.depthTextureInternal=!1,this.multisampledDepthBuffer=null,this.format=e,this.hasStencil=e==="depth24plus-stencil8"}}class YU{destroy(e){this.initialized=!1,this.assignedColorTexture=null,this.colorAttachments.forEach(t=>{t.destroy()}),this.colorAttachments.length=0,this.depthAttachment?.destroy(e),this.depthAttachment=null}updateKey(){let t=`${this.renderTarget.samples}:${this.depthAttachment?this.depthAttachment.format:"nodepth"}`;this.colorAttachments.forEach(s=>{t+=`:${s.format}`}),this.key=XU.get(t)}assignColorTexture(e,t){this.assignedColorTexture=t;const s=t.createView({format:e.backBufferViewFormat}),i=this.renderPassDescriptor.colorAttachments[0];this.renderTarget.samples>1?i.resolveTarget=s:i.view=s,this.setColorAttachment(0,void 0,e.backBufferViewFormat),this.updateKey()}setColorAttachment(e,t,s){this.colorAttachments[e]||(this.colorAttachments[e]=new qU),t&&(this.colorAttachments[e].multisampledBuffer=t),s&&(this.colorAttachments[e].format=s)}init(e,t){const s=e.wgpu;this.initDepthStencil(e,s,t),t._colorBuffers&&t._colorBuffers.forEach((r,a)=>{this.setColorAttachment(a,void 0,r.impl.format)}),this.renderPassDescriptor.colorAttachments=[];const i=this.isBackbuffer?1:t._colorBuffers?.length??0;for(let r=0;r<i;++r){const a=this.initColor(e,s,t,r),o=r===0&&this.colorAttachments[0]?.format;(a.view||o)&&this.renderPassDescriptor.colorAttachments.push(a)}this.updateKey(),this.initialized=!0}initDepthStencil(e,t,s){const{samples:i,width:r,height:a,depth:o,depthBuffer:h}=s;if(o||h){let u;if(h)if(this.depthAttachment=new hD(h.impl.format),i>1){const f="depth24plus-stencil8";this.depthAttachment.format=f,this.depthAttachment.hasStencil=f==="depth24plus-stencil8";const m=`${h.id}:${r}:${a}:${i}:${f}`,_=Ud(e);let g=_.get(m);if(!g){const S={size:[r,a,1],dimension:"2d",sampleCount:i,format:f,usage:GPUTextureUsage.RENDER_ATTACHMENT|(f!==h.impl.format?GPUTextureUsage.TEXTURE_BINDING:0)};g=t.createTexture(S),_.set(m,g)}this.depthAttachment.multisampledDepthBuffer=g,this.depthAttachment.multisampledDepthBufferKey=m,u=g.createView()}else{const f=h.impl.gpuTexture;this.depthAttachment.depthTexture=f,u=f.createView()}else{this.depthAttachment=new hD("depth24plus-stencil8");const f={size:[r,a,1],dimension:"2d",sampleCount:i,format:this.depthAttachment.format,usage:GPUTextureUsage.RENDER_ATTACHMENT};i>1?f.usage|=GPUTextureUsage.TEXTURE_BINDING:f.usage|=GPUTextureUsage.COPY_SRC;const m=t.createTexture(f);this.depthAttachment.depthTexture=m,this.depthAttachment.depthTextureInternal=!0,u=m.createView()}this.renderPassDescriptor.depthStencilAttachment={view:u}}}initColor(e,t,s,i){const r={},{samples:a,width:o,height:h,mipLevel:u}=s,f=s.getColorBuffer(i);let m=null;if(f&&(f.cubemap?m=f.impl.createView({dimension:"2d",baseArrayLayer:s.face,arrayLayerCount:1,mipLevelCount:1,baseMipLevel:u}):m=f.impl.createView({mipLevelCount:1,baseMipLevel:u})),a>1){const _=this.isBackbuffer?e.backBufferViewFormat:f.impl.format,g={size:[o,h,1],dimension:"2d",sampleCount:a,format:_,usage:GPUTextureUsage.RENDER_ATTACHMENT},S=t.createTexture(g);this.setColorAttachment(i,S,g.format),r.view=S.createView(),r.resolveTarget=m}else r.view=m;return r}setupForRenderPass(e,t){const s=this.renderPassDescriptor.colorAttachments?.length??0;for(let r=0;r<s;++r){const a=this.renderPassDescriptor.colorAttachments[r],o=e.colorArrayOps[r],h=t.isColorBufferSrgb(r);a.clearValue=h?o.clearValueLinear:o.clearValue,a.loadOp=o.clear?"clear":"load",a.storeOp=o.store?"store":"discard"}const i=this.renderPassDescriptor.depthStencilAttachment;i&&(i.depthClearValue=e.depthStencilOps.clearDepthValue,i.depthLoadOp=e.depthStencilOps.clearDepth?"clear":"load",i.depthStoreOp=e.depthStencilOps.storeDepth?"store":"discard",i.depthReadOnly=!1,this.depthAttachment.hasStencil&&(i.stencilClearValue=e.depthStencilOps.clearStencilValue,i.stencilLoadOp=e.depthStencilOps.clearStencil?"clear":"load",i.stencilStoreOp=e.depthStencilOps.storeStencil?"store":"discard",i.stencilReadOnly=!1))}loseContext(){this.initialized=!1}resolve(e,t,s,i){}constructor(e){this.initialized=!1,this.colorAttachments=[],this.depthAttachment=null,this.assignedColorTexture=null,this.renderPassDescriptor={},this.isBackbuffer=!1,this.renderTarget=e}}const os=[];os[Bs]=1;os[xl]=2;os[Gi]=3;os[so]=4;os[Ga]=1;os[hl]=2;os[Ha]=3;os[ul]=4;os[ph]=1;os[Kd]=2;os[Zd]=3;os[Qd]=4;os[rg]=8;os[Ah]=12;os[Or]=16;os[Qs]=1;os[wh]=2;os[Ch]=3;os[Dh]=4;class Be{get isArrayType(){return this.count>0}calculateOffset(e){let t=this.byteSize<=8?this.byteSize:16;this.count&&(t=16),e=J.roundUp(e,t),this.offset=e/4}constructor(e,t,s=0){if(this.shortName=e,this.name=s?`${e}[0]`:e,this.type=t,this.numComponents=os[t],this.updateType=t,s>0)switch(t){case Bs:this.updateType=fv;break;case Ga:this.updateType=Ph;break;case Qs:this.updateType=_v;break;case ph:this.updateType=gv;break;case xl:this.updateType=mv;break;case hl:this.updateType=Rh;break;case wh:this.updateType=vv;break;case Kd:this.updateType=Sv;break;case Gi:this.updateType=pv;break;case Ha:this.updateType=Mh;break;case Ch:this.updateType=yv;break;case Zd:this.updateType=xv;break;case so:this.updateType=xE;break;case ul:this.updateType=ag;break;case Dh:this.updateType=TE;break;case Qd:this.updateType=EE;break;case Or:this.updateType=qM;break}this.count=s;let i=this.numComponents;s&&(i=J.roundUp(i,4)),this.byteSize=i*4,s&&(this.byteSize*=s)}}class uo{get(e){return this.map.get(e)}constructor(e,t){this.byteSize=0,this.map=new Map,this.scope=e.scope,this.uniforms=t;let s=0;for(let i=0;i<t.length;i++){const r=t[i];r.calculateOffset(s),s=r.offset*4+r.byteSize,r.scopeId=this.scope.resolve(r.name),this.map.set(r.name,r)}this.byteSize=J.roundUp(s,16)}}const uD=/[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g,c0=/(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)(;+)/g,h0="@@@",jU=/([\w-]+)\[(.*?)\]/,$U=new Set(["highp","mediump","lowp"]),KU=new Set(["sampler2DShadow","samplerCubeShadow","sampler2DArrayShadow"]),ZU={sampler2D:Si,sampler3D:mh,samplerCube:Fa,samplerCubeShadow:Fa,sampler2DShadow:Si,sampler2DArray:Na,sampler2DArrayShadow:Na,isampler2D:Si,usampler2D:Si,isampler3D:mh,usampler3D:mh,isamplerCube:Fa,usamplerCube:Fa,isampler2DArray:Na,usampler2DArray:Na},QU={[Si]:"texture2D",[Fa]:"textureCube",[mh]:"texture3D",[Na]:"texture2DArray"};let JU=class{constructor(e,t){this.line=e;const s=e.trim().split(/\s+/);if($U.has(s[0])&&(this.precision=s.shift()),this.type=s.shift(),e.includes(","),e.includes("[")){const i=s.join(" "),r=jU.exec(i);this.name=r[1],this.arraySize=Number(r[2]),isNaN(this.arraySize)&&(t.failed=!0)}else this.name=s.shift(),this.arraySize=0;this.isSampler=this.type.indexOf("sampler")!==-1,this.isSignedInt=this.type.indexOf("isampler")!==-1,this.isUnsignedInt=this.type.indexOf("usampler")!==-1}};class As{static run(e,t,s){const i=new Map,r=As.extract(t.vshader),a=As.extract(t.fshader),o=new Map,h=As.processAttributes(r.attributes,t.attributes,o,t.processingOptions),u=As.processVaryings(r.varyings,i,!0),f=As.processVaryings(a.varyings,i,!1),m=As.processOuts(a.outs),_=r.uniforms.concat(a.uniforms),S=Array.from(new Set(_)).map(w=>new JU(w,s)),x=As.processUniforms(e,S,t.processingOptions,s),T=`${h}
${u}
${x.code}`,E=r.src.replace(h0,T),b=`${f}
${m}
${x.code}`,C=a.src.replace(h0,b);return{vshader:E,fshader:C,attributes:o,meshUniformBufferFormat:x.meshUniformBufferFormat,meshBindGroupFormat:x.meshBindGroupFormat}}static extract(e){const t=[],s=[],i=[],r=[];let a=`${h0}
`,o;for(;(o=uD.exec(e))!==null;){const h=o[1];switch(h){case"attribute":case"varying":case"uniform":case"out":{c0.lastIndex=o.index;const u=c0.exec(e);h==="attribute"?t.push(u[2]):h==="varying"?s.push(u[2]):h==="out"?i.push(u[2]):h==="uniform"&&r.push(u[2]),e=As.cutOut(e,o.index,c0.lastIndex,a),uD.lastIndex=o.index+a.length,a="";break}}}return{src:e,attributes:t,varyings:s,outs:i,uniforms:r}}static processUniforms(e,t,s,i){const r=[],a=[];t.forEach(_=>{_.isSampler?r.push(_):a.push(_)});const o=[];a.forEach(_=>{if(!s.hasUniform(_.name)){const g=Y1.indexOf(_.type),S=new Be(_.name,g,_.arraySize);o.push(S)}}),o.length===0&&o.push(new Be(bE,Bs));const h=o.length?new uo(e,o):null,u=[];r.forEach(_=>{if(!s.hasTexture(_.name)){let g=Ks;_.isSignedInt?g=yl:_.isUnsignedInt?g=to:(_.precision==="highp"&&(g=Ol),KU.has(_.type)&&(g=mr));const S=ZU[_.type];u.push(new ef(_.name,Tl|El,S,g))}});const f=new Vr(e,u);let m="";return s.uniformFormats.forEach((_,g)=>{_&&(m+=As.getUniformShaderDeclaration(_,g,0))}),h&&(m+=As.getUniformShaderDeclaration(h,Lh,0)),s.bindGroupFormats.forEach((_,g)=>{_&&(m+=As.getTexturesShaderDeclaration(_,g))}),m+=As.getTexturesShaderDeclaration(f,kf),{code:m,meshUniformBufferFormat:h,meshBindGroupFormat:f}}static processVaryings(e,t,s){let i="";const r=s?"out":"in";return e.forEach((a,o)=>{const h=As.splitToWords(a),u=h.slice(0,-1).join(" "),f=h[h.length-1];s?t.set(f,o):o=t.get(f),i+=`layout(location = ${o}) ${r} ${u} ${f};
`}),i}static processOuts(e){let t="";return e.forEach((s,i)=>{t+=`layout(location = ${i}) out ${s};
`}),t}static getTypeCount(e){const t=e.substring(e.length-1),s=parseInt(t,10);return isNaN(s)?1:s}static processAttributes(e,t,s,i){let r="";return e.forEach(a=>{const o=As.splitToWords(a);let h=o[0],u=o[1];if(t.hasOwnProperty(u)){const f=t[u],m=$e[f];s.set(m,u);let _;const g=i.getVertexElement(f);if(g){const S=g.dataType;if(S!==ct&&S!==dv&&!g.normalize&&!g.asInt){const x=As.getTypeCount(h),T=`_private_${u}`;_=`vec${x} ${u} = vec${x}(${T});
`,u=T;const E=S===co||S===ho||S===Wh;x===1?h=E?"int":"uint":h=E?`ivec${x}`:`uvec${x}`}}r+=`layout(location = ${m}) in ${h} ${u};
`,_&&(r+=_)}}),r}static splitToWords(e){return e=e.replace(/\s+/g," ").trim(),e.split(" ")}static cutOut(e,t,s,i){return e.substring(0,t)+i+e.substring(s)}static getUniformShaderDeclaration(e,t,s){const i=i2[t];let r=`layout(set = ${t}, binding = ${s}, std140) uniform ub_${i} {
`;return e.uniforms.forEach(a=>{const o=Y1[a.type];r+=`    ${o} ${a.shortName}${a.count?`[${a.count}]`:""};
`}),`${r}};
`}static getTexturesShaderDeclaration(e,t){let s="";return e.textureFormats.forEach(i=>{let r=QU[i.textureDimension];const a=r==="texture2DArray",o=i.sampleType===to?"u":i.sampleType===yl?"i":"";r=`${o}${r}`;let h="",u="";a&&(h="_texture",u=`#define ${i.name} ${o}sampler2DArray(${i.name}${h}, ${i.name}_sampler)
`),s+=`layout(set = ${t}, binding = ${i.slot}) uniform ${r} ${i.name}${h};
`,i.hasSampler&&(s+=`layout(set = ${t}, binding = ${i.slot+1}) uniform sampler ${i.name}_sampler;
`),s+=u}),s}}const dD=/^[ \t]*(attribute|varying|uniform)[\t ]+/gm,u0=/^[ \t]*(attribute|varying|uniform)[ \t]*([^;]+)(;+)/gm,d0=/^[ \t]*var\s*(?:(<storage,[^>]*>)\s*([\w\d_]+)\s*:\s*(.*?)\s*;|(<(?!storage,)[^>]*>)?\s*([\w\d_]+)\s*:\s*(texture_.*|storage_texture_.*|storage\w.*|external_texture|sampler(?:_comparison)?)\s*;)\s*$/gm,ez=/(?:@interpolate\([^)]*\)\s*)?([\w]+)\s*:\s*([\w<>]+)/,f0="@@@",tz=/(@vertex|@fragment)\s*fn\s+\w+\s*\(\s*(\w+)\s*:[\s\S]*?\{/,sz={texture_1d:{viewDimension:XM,baseSampleType:Ks},texture_2d:{viewDimension:Si,baseSampleType:Ks},texture_2d_array:{viewDimension:Na,baseSampleType:Ks},texture_3d:{viewDimension:mh,baseSampleType:Ks},texture_cube:{viewDimension:Fa,baseSampleType:Ks},texture_cube_array:{viewDimension:ig,baseSampleType:Ks},texture_multisampled_2d:{viewDimension:Si,baseSampleType:Ks},texture_depth_2d:{viewDimension:Si,baseSampleType:mr},texture_depth_2d_array:{viewDimension:Na,baseSampleType:mr},texture_depth_cube:{viewDimension:Fa,baseSampleType:mr},texture_depth_cube_array:{viewDimension:ig,baseSampleType:mr},texture_external:{viewDimension:Si,baseSampleType:Ol}},iz=(c,e)=>{const t=sz[c];let s=t.baseSampleType;if(t.baseSampleType===Ks&&c!=="texture_multisampled_2d")switch(e){case"u32":s=to;break;case"i32":s=yl;break;case"f32":s=Ks;break;case"uff":s=Ol;break}return{viewDimension:t.viewDimension,sampleType:s}},rz=(c,e)=>{if(e===mr)switch(c){case Si:return"texture_depth_2d";case Na:return"texture_depth_2d_array";case Fa:return"texture_depth_cube";case ig:return"texture_depth_cube_array"}let t;switch(c){case XM:t="texture_1d";break;case Si:t="texture_2d";break;case Na:t="texture_2d_array";break;case mh:t="texture_3d";break;case Fa:t="texture_cube";break;case ig:t="texture_cube_array";break}let s;switch(e){case Ks:case Ol:s="f32";break;case to:s="u32";break;case yl:s="i32";break}return`${t}<${s}>`},fD={f32:"WrappedF32",i32:"WrappedI32",u32:"WrappedU32",vec2f:"WrappedVec2F",vec2i:"WrappedVec2I",vec2u:"WrappedVec2U"},l2=c=>(c=c.replace(/\s+/g," ").trim(),c.split(/[\s:]+/)),az=/array<([^,]+),\s*([^>]+)>/;class nz{constructor(e,t){this.ubName=null,this.arraySize=0,this.line=e;const s=l2(e);if(s.length<2){t.failed=!0;return}if(this.name=s[0],this.type=s.slice(1).join(" "),this.type.includes("array<")){const i=az.exec(this.type);this.type=i[1].trim(),this.arraySize=Number(i[2]),isNaN(this.arraySize)&&(t.failed=!0)}}}const oz=/^\s*var\s+(\w+)\s*:\s*(texture_\w+)(?:<(\w+)>)?;\s*$/,lz=/^\s*var\s+([\w\d_]+)\s*:\s*(texture_storage_2d|texture_storage_2d_array)<([\w\d_]+),\s*(\w+)>\s*;\s*$/,cz=/^\s*var\s*<storage,\s*(read|write)?>\s*([\w\d_]+)\s*:\s*(.*)\s*;\s*$/,hz=/^\s*var\s+([\w\d_]+)\s*:\s*texture_external;\s*$/,uz=/^\s*var\s+([\w\d_]+)\s*:\s*(sampler|sampler_comparison)\s*;\s*$/;class mD{equals(e){return!(this.name!==e.name||this.type!==e.type||this.isTexture!==e.isTexture||this.isSampler!==e.isSampler||this.isStorageTexture!==e.isStorageTexture||this.isStorageBuffer!==e.isStorageBuffer||this.isExternalTexture!==e.isExternalTexture||this.textureFormat!==e.textureFormat||this.textureDimension!==e.textureDimension||this.sampleType!==e.sampleType||this.textureType!==e.textureType||this.format!==e.format||this.access!==e.access||this.accessMode!==e.accessMode||this.samplerType!==e.samplerType)}constructor(e,t){this.originalLine=e,this.line=e,this.isTexture=!1,this.isSampler=!1,this.isStorageTexture=!1,this.isStorageBuffer=!1,this.isExternalTexture=!1,this.type="",this.matchedElements=[];const s=this.line.match(oz);if(s){this.name=s[1],this.type=s[2],this.textureFormat=s[3],this.isTexture=!0,this.matchedElements.push(...s);const h=iz(this.type,this.textureFormat);this.textureDimension=h.viewDimension,this.sampleType=h.sampleType}const i=this.line.match(lz);i&&(this.isStorageTexture=!0,this.name=i[1],this.textureType=i[2],this.format=i[3],this.access=i[4],this.matchedElements.push(...i));const r=this.line.match(cz);r&&(this.isStorageBuffer=!0,this.accessMode=r[1]||"none",this.name=r[2],this.type=r[3],this.matchedElements.push(...r));const a=this.line.match(hz);a&&(this.name=a[1],this.isExternalTexture=!0,this.matchedElements.push(...r));const o=this.line.match(uz);o&&(this.name=o[1],this.samplerType=o[2],this.isSampler=!0,this.matchedElements.push(...o)),this.matchedElements.length===0&&(t.failed=!0)}}class Yt{static run(e,t,s){const i=new Map,r=Yt.extract(t.vshader),a=Yt.extract(t.fshader),o=new Map,h=Yt.processAttributes(r.attributes,t.attributes,o,t.processingOptions,s),u=Yt.processVaryings(r.varyings,i,!0,e),f=Yt.processVaryings(a.varyings,i,!1,e),m=r.uniforms.concat(a.uniforms),g=Array.from(new Set(m)).map(I=>new nz(I,s)),S=Yt.processUniforms(e,g,t.processingOptions,s);r.src=Yt.renameUniformAccess(r.src,g),a.src=Yt.renameUniformAccess(a.src,g);const x=Yt.mergeResources(r.resources,a.resources,s),T=Yt.processResources(e,x,t.processingOptions,s),E=Yt.generateFragmentOutputStruct(a.src,e.maxColorAttachments);r.src=Yt.copyInputs(r.src,s),a.src=Yt.copyInputs(a.src,s);const b=`${h}
${u}
${S.code}
${T.code}
`,C=r.src.replace(f0,b),w=`${f}
${E}
${S.code}
${T.code}
`,P=a.src.replace(f0,w);return{vshader:C,fshader:P,attributes:o,meshUniformBufferFormat:S.meshUniformBufferFormat,meshBindGroupFormat:T.meshBindGroupFormat}}static extract(e){const t=[],s=[],i=[],r=[];let a=`${f0}
`,o;for(;(o=dD.exec(e))!==null;){const h=o[1];u0.lastIndex=o.index;const u=u0.exec(e);h==="attribute"?t.push(u[2]):h==="varying"?s.push(u[2]):h==="uniform"&&i.push(u[2]),e=Yt.cutOut(e,o.index,u0.lastIndex,a),dD.lastIndex=o.index+a.length,a=""}for(;(o=d0.exec(e))!==null;)r.push(o[0]),e=Yt.cutOut(e,o.index,d0.lastIndex,a),d0.lastIndex=o.index+a.length,a="";return{src:e,attributes:t,varyings:s,uniforms:i,resources:r}}static processUniforms(e,t,s,i){const r=[];t.forEach(h=>{if(s.hasUniform(h.name))h.ubName="ub_view";else{h.ubName="ub_mesh_ub";const u=jM.get(h.type),f=new Be(h.name,u,h.arraySize);r.push(f)}}),r.length===0&&r.push(new Be(bE,Bs));const a=new uo(e,r);let o="";return s.uniformFormats.forEach((h,u)=>{h&&(o+=Yt.getUniformShaderDeclaration(h,u,0))}),a&&(o+=Yt.getUniformShaderDeclaration(a,Lh,0)),{code:o,meshUniformBufferFormat:a}}static renameUniformAccess(e,t){return t.forEach(s=>{const i=`uniform.${s.name}`,r=`${s.ubName}.${s.name}`,a=new RegExp(`\\b${i}\\b`,"g");e=e.replace(a,r)}),e}static mergeResources(e,t,s){const i=e.map(a=>new mD(a,s));return t.map(a=>new mD(a,s)).forEach(a=>{const o=i.find(h=>h.name===a.name);o?o.equals(a)||(s.failed=!0):i.push(a)}),i}static processResources(e,t,s,i){const r=[];for(let h=0;h<t.length;h++){const u=t[h];if(u.isTexture){const f=t[h+1],m=f?.isSampler,_=u.sampleType,g=u.textureDimension;r.push(new ef(u.name,Tl|El,g,_,m,m?f.name:null)),m&&h++}if(u.isStorageBuffer){const f=u.accessMode!=="read_write",m=new Is(u.name,Tl|El,f);m.format=u.type,r.push(m)}}const a=new Vr(e,r);let o="";return s.bindGroupFormats.forEach((h,u)=>{h&&(o+=Yt.getTextureShaderDeclaration(h,u))}),o+=Yt.getTextureShaderDeclaration(a,kf),{code:o,meshBindGroupFormat:a}}static getUniformShaderDeclaration(e,t,s){const i=i2[t],r=`struct_ub_${i}`;let a=`struct ${r} {
`;return e.uniforms.forEach(o=>{let h=YM[o.type][0];o.count>0?(fD.hasOwnProperty(h)&&(h=fD[h]),a+=`    ${o.shortName}: array<${h}, ${o.count}>,
`):a+=`    ${o.shortName}: ${h},
`}),a+=`};
`,a+=`@group(${t}) @binding(${s}) var<uniform> ub_${i} : ${r};

`,a}static getTextureShaderDeclaration(e,t){let s="";return e.textureFormats.forEach(i=>{const r=rz(i.textureDimension,i.sampleType);if(s+=`@group(${t}) @binding(${i.slot}) var ${i.name}: ${r};
`,i.hasSampler){const a=i.sampleType===mr?"sampler_comparison":"sampler";s+=`@group(${t}) @binding(${i.slot+1}) var ${i.samplerName}: ${a};
`}}),e.storageBufferFormats.forEach(i=>{const r=i.readOnly?"read":"read_write";s+=`@group(${t}) @binding(${i.slot}) var<storage, ${r}> ${i.name} : ${i.format};
`}),s}static processVaryings(e,t,s,i){let r="",a="",o="";e.forEach((_,g)=>{const S=_.match(ez);if(S){const x=S[1],T=S[2];s?t.set(x,g):g=t.get(x),r+=`    @location(${g}) ${_},
`,s||(a+=`    var<private> ${x}: ${T};
`,o+=`    ${x} = input.${x};
`)}}),s?r+=`    @builtin(position) position : vec4f,
`:(r+=`    @builtin(position) position : vec4f,
`,r+=`    @builtin(front_facing) frontFacing : bool,
`,r+=`    @builtin(sample_index) sampleIndex : u32,
`,i.supportsPrimitiveIndex&&(r+=`    @builtin(primitive_index) primitiveIndex : u32,
`));const h=i.supportsPrimitiveIndex?`
						var<private> pcPrimitiveIndex: u32;
				`:"",u=i.supportsPrimitiveIndex?`
								pcPrimitiveIndex = input.primitiveIndex;
				`:"",f=s?"":`
						var<private> pcPosition: vec4f;
						var<private> pcFrontFacing: bool;
						var<private> pcSampleIndex: u32;
						${h}
						${a}
						
						// function to copy inputs (varyings) to private global variables
						fn _pcCopyInputs(input: FragmentInput) {
								${o}
								pcPosition = input.position;
								pcFrontFacing = input.frontFacing;
								pcSampleIndex = input.sampleIndex;
								${u}
						}
				`;return`
						struct ${s?"VertexOutput":"FragmentInput"} {
								${r}
						};
						${f}
				`}static generateFragmentOutputStruct(e,t){let s=`struct FragmentOutput {
`;for(let r=0;r<t;r++)s+=`    @location(${r}) color${r>0?r:""} : pcOutType${r},
`;return e.search(/\.fragDepth\s*=/)!==-1&&(s+=`    @builtin(frag_depth) fragDepth : f32
`),`${s}};
`}static floatAttributeToInt(e,t){const i={f32:"f32","vec2<f32>":"vec2f","vec3<f32>":"vec3f","vec4<f32>":"vec4f"}[e]||e;return{f32:t?"i32":"u32",vec2f:t?"vec2i":"vec2u",vec3f:t?"vec3i":"vec3u",vec4f:t?"vec4i":"vec4u"}[i]||null}static processAttributes(e,t={},s,i,r){let a="",o="",h="";return e.forEach(u=>{const f=l2(u),m=f[0];let _=f[1];const g=_;if(t.hasOwnProperty(m)){const S=t[m],x=$e[S];s.set(x,m);const T=i.getVertexElement(S);if(T){const E=T.dataType;if(E!==ct&&E!==dv&&!T.normalize&&!T.asInt){const b=E===co||E===ho||E===Wh;_=Yt.floatAttributeToInt(_,b)}}a+=`    @location(${x}) ${m}: ${_},
`,o+=`    var<private> ${u};
`,h+=`    ${m} = ${g}(input.${m});
`}}),`
						struct VertexInput {
								${a}
								@builtin(vertex_index) vertexIndex : u32,       // built-in vertex index
								@builtin(instance_index) instanceIndex : u32    // built-in instance index
						};

						${o}
						var<private> pcVertexIndex: u32;
						var<private> pcInstanceIndex: u32;

						fn _pcCopyInputs(input: VertexInput) {
								${h}
								pcVertexIndex = input.vertexIndex;
								pcInstanceIndex = input.instanceIndex;
						}
				`}static copyInputs(e,t){const s=e.match(tz);if(!s||!s[2])return e;const i=s[2],r=s.index+s[0].length-1,a=e.slice(0,r+1),o=e.slice(r+1),h=`
    _pcCopyInputs(${i});`;return a+h+o}static cutOut(e,t,s,i){return e.substring(0,t)+i+e.substring(s)}}const dz=new Fl;class fz{destroy(e){this._vertexCode=null,this._fragmentCode=null}createShaderModule(e,t){return this.shader.device.wgpu.createShaderModule({code:e})}getVertexShaderModule(){return this.createShaderModule(this._vertexCode,"Vertex")}getFragmentShaderModule(){return this.createShaderModule(this._fragmentCode,"Fragment")}getComputeShaderModule(){return this.createShaderModule(this._computeCode,"Compute")}processGLSL(){const e=this.shader,t=As.run(e.device,e.definition,e);this._vertexCode=this.transpile(t.vshader,"vertex",e.definition.vshader),this._fragmentCode=this.transpile(t.fshader,"fragment",e.definition.fshader),this._vertexCode&&this._fragmentCode?e.ready=!0:e.failed=!0,e.meshUniformBufferFormat=t.meshUniformBufferFormat,e.meshBindGroupFormat=t.meshBindGroupFormat,e.attributes=t.attributes}processWGSL(){const e=this.shader,t=Yt.run(e.device,e.definition,e);this._vertexCode=t.vshader,this._fragmentCode=t.fshader,e.meshUniformBufferFormat=t.meshUniformBufferFormat,e.meshBindGroupFormat=t.meshBindGroupFormat,e.attributes=t.attributes}transpile(e,t,s){const i=this.shader.device;if(!i.glslang||!i.twgsl)return console.error(`Cannot transpile shader [${this.shader.label}] - shader transpilers (glslang/twgsl) are not available. Make sure to provide glslangUrl and twgslUrl when creating the device.`,{shader:this.shader}),null;try{const r=i.glslang.compileGLSL(e,t);return i.twgsl.convertSpirV2WGSL(r)}catch(r){console.error(`Failed to transpile webgl ${t} shader [${this.shader.label}] to WebGPU while rendering undefined, error:
 [${r.stack}]`,{processed:e,original:s,shader:this.shader,error:r,stack:r.stack})}}get vertexCode(){return this._vertexCode}get fragmentCode(){return this._fragmentCode}get computeKey(){if(this._computeKey===void 0){const e=`${this._computeCode}|${this.computeEntryPoint}`;this._computeKey=dz.get(e)}return this._computeKey}loseContext(){}restoreContext(e,t){}constructor(e){this._vertexCode=null,this._fragmentCode=null,this._computeCode=null,this.vertexEntryPoint="main",this.fragmentEntryPoint="main",this.computeEntryPoint="main",this.shader=e;const t=e.definition;t.shaderLanguage===Je?(t.cshader?(this._computeCode=t.cshader??null,this.computeUniformBufferFormats=t.computeUniformBufferFormats,this.computeBindGroupFormat=t.computeBindGroupFormat,t.computeEntryPoint&&(this.computeEntryPoint=t.computeEntryPoint)):(this.vertexEntryPoint="vertexMain",this.fragmentEntryPoint="fragmentMain",t.processingOptions?this.processWGSL():(this._vertexCode=t.vshader??null,this._fragmentCode=t.fshader??null,e.meshUniformBufferFormat=t.meshUniformBufferFormat,e.meshBindGroupFormat=t.meshBindGroupFormat)),e.ready=!0):t.processingOptions&&this.processGLSL()}}const vh=[];vh[as]="repeat";vh[Te]="clamp-to-edge";vh[Lg]="mirror-repeat";const Wa=[];Wa[ze]={level:"nearest",mip:"nearest"};Wa[$t]={level:"linear",mip:"nearest"};Wa[Ef]={level:"nearest",mip:"nearest"};Wa[bf]={level:"nearest",mip:"linear"};Wa[Af]={level:"linear",mip:"nearest"};Wa[Jn]={level:"linear",mip:"linear"};const mz=c=>{};class pz{create(e){const t=this.texture,s=e.wgpu,i=t.numLevels;this.desc={size:{width:t.width,height:t.height,depthOrArrayLayers:t.cubemap?6:t.array?t.arrayLength:1},format:this.format,mipLevelCount:i,sampleCount:1,dimension:t.volume?"3d":"2d",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|(Gx(t.format)?0:GPUTextureUsage.RENDER_ATTACHMENT)|(t.storage?GPUTextureUsage.STORAGE_BINDING:0)},this.gpuTexture=s.createTexture(this.desc);let r;this.texture.format===gl&&(r={format:"depth24plus",aspect:"depth-only"}),this.view=this.createView(r),this.viewCache.clear()}destroy(e){}propertyChanged(e){this.samplers.length=0}getView(e,t){if(this.uploadImmediate(e,this.texture),t){let s=this.viewCache.get(t.key);return s||(s=this.createView({baseMipLevel:t.baseMipLevel,mipLevelCount:t.mipLevelCount,baseArrayLayer:t.baseArrayLayer,arrayLayerCount:t.arrayLayerCount}),this.viewCache.set(t.key,s)),s}return this.view}createView(e){const t=e??{},s=this.desc,i=this.texture,r=()=>i.cubemap?"cube":i.volume?"3d":i.array?"2d-array":"2d",a={format:t.format??s.format,dimension:t.dimension??r(),aspect:t.aspect??"all",baseMipLevel:t.baseMipLevel??0,mipLevelCount:t.mipLevelCount??s.mipLevelCount,baseArrayLayer:t.baseArrayLayer??0,arrayLayerCount:t.arrayLayerCount??s.depthOrArrayLayers};return this.gpuTexture.createView(a)}getSampler(e,t){let s=this.samplers[t];if(!s){const i=this.texture,r={addressModeU:vh[i.addressU],addressModeV:vh[i.addressV],addressModeW:vh[i.addressW]};!t&&i.compareOnRead&&(t=mr),t===mr||t===yl||t===to?(r.compare="less",r.magFilter="linear",r.minFilter="linear"):t===Ol||!e.textureFloatFilterable&&(i.format===fs||i.format===kt)||this.texture.format===gl||qn(this.texture.format)?(r.magFilter="nearest",r.minFilter="nearest",r.mipmapFilter="nearest"):(r.magFilter=Wa[i.magFilter].level,r.minFilter=Wa[i.minFilter].level,r.mipmapFilter=Wa[i.minFilter].mip);const a=r.minFilter==="linear"&&r.magFilter==="linear"&&r.mipmapFilter==="linear";r.maxAnisotropy=a?J.clamp(Math.round(i._anisotropy),1,e.maxTextureAnisotropy):1,s=e.wgpu.createSampler(r),this.samplers[t]=s}return s}loseContext(){}uploadImmediate(e,t){(t._needsUpload||t._needsMipmapsUpload)&&(this.uploadData(e),t._needsUpload=!1,t._needsMipmapsUpload=!1)}uploadData(e){const t=this.texture;if(this.desc&&(this.desc.size.width!==t.width||this.desc.size.height!==t.height)&&(this.gpuTexture.destroy(),this.create(e),t.renderVersionDirty=e.renderVersion),t._levels){let s=!1,i=!1;const r=t.numLevels;for(let a=0;a<r;a++){const o=t._levels[a];if(o){if(t.cubemap)for(let h=0;h<6;h++){const u=o[h];u?this.isExternalImage(u)?(this.uploadExternalImage(e,u,a,h),s=!0):ArrayBuffer.isView(u)&&(this.uploadTypedArrayData(e,u,a,h),s=!0):i=!0}else if(!t._volume)if(t.array)if(t.arrayLength===o.length)for(let h=0;h<t._arrayLength;h++){const u=o[h];this.isExternalImage(u)?(this.uploadExternalImage(e,u,a,h),s=!0):ArrayBuffer.isView(u)&&(this.uploadTypedArrayData(e,u,a,h),s=!0)}else i=!0;else this.isExternalImage(o)?(this.uploadExternalImage(e,o,a,0),s=!0):ArrayBuffer.isView(o)&&(this.uploadTypedArrayData(e,o,a,0),s=!0)}else i=!0}s&&i&&t.mipmaps&&!Gx(t.format)&&!qn(t.format)&&e.mipmapRenderer.generate(this),t._gpuSize&&t.adjustVramSizeTracking(e._vram,-t._gpuSize),t._gpuSize=t.gpuSize,t.adjustVramSizeTracking(e._vram,t._gpuSize)}}isExternalImage(e){return typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas}uploadExternalImage(e,t,s,i){const r={source:t,origin:[0,0],flipY:!1},a={texture:this.gpuTexture,mipLevel:s,origin:[0,0,i],aspect:"all",premultipliedAlpha:this.texture._premultiplyAlpha},o={width:this.desc.size.width,height:this.desc.size.height,depthOrArrayLayers:1};e.submit(),mz(t instanceof HTMLCanvasElement&&t.getContext("2d")),e.wgpu.queue.copyExternalImageToTexture(r,a,o)}uploadTypedArrayData(e,t,s,i){const r=this.texture,a=e.wgpu,o={texture:this.gpuTexture,origin:[0,0,i],mipLevel:s},h=Wi.calcLevelDimension(r.width,s),u=Wi.calcLevelDimension(r.height,s);Wi.calcLevelGpuSize(h,u,1,r.format);const f=Ki.get(r.format);let m,_;if(f.size)m={offset:0,bytesPerRow:f.size*h,rowsPerImage:u},_={width:h,height:u};else if(f.blockSize){const g=S=>Math.floor((S+3)/4);m={offset:0,bytesPerRow:f.blockSize*g(h),rowsPerImage:g(u)},_={width:Math.max(4,h),height:Math.max(4,u)}}e.submit(),a.queue.writeTexture(o,t,m,_)}read(e,t,s,i,r){const a=r.mipLevel??0,o=r.face??0,h=r.data??null,u=r.immediate??!1,f=this.texture,m=Ki.get(f.format),_=s*m.size,g=J.roundUp(_,256),S=g*i,x=f.device,T=x.createBufferImpl(GM|Ns);T.allocate(x,S);const E={texture:this.gpuTexture,mipLevel:a,origin:[e,t,o]},b={buffer:T.buffer,offset:0,bytesPerRow:g},C={width:s,height:i,depthOrArrayLayers:1};return x.getCommandEncoder().copyTextureToBuffer(E,b,C),x.readBuffer(T,S,null,u).then(P=>{const I=dE(f.format),M=h?.buffer??new ArrayBuffer(i*_),R=new Uint8Array(M,h?.byteOffset??0,i*_);for(let L=0;L<i;L++){const B=L*g,G=L*_;R.set(P.subarray(B,B+_),G)}return h??new I(M)})}constructor(e){this.samplers=[],this.viewCache=new Map,this.texture=e,this.format=_e[e.format],this.create(e.device)}}class _z extends Av{unlock(e){const t=e.device;super.unlock(t,e.storageInt32.buffer)}constructor(e){super(TB)}}class gz extends Av{unlock(e){const t=e.device;super.unlock(t,e.storage)}constructor(e,t,s){super(xB|(s?.storage?eE:0))}}const ir=/[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g,m0=/define[ \t]+([^\n]+)\r?(?:\n|$)/g,pD=/extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g,p0=/undef[ \t]+([^\n]+)\r?(?:\n|$)/g,_0=/(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g,g0=/(endif|else|elif)(?:[ \t]+([^\r\n]*))?\r?\n?/g,_D=/\{?[\w-]+\}?/,vz=/(!|\s)?defined\(([\w-]+)\)/,Sz=/!?defined\s*\([^)]*\)/g,yz=/!?defined\s*$/,xz=/([a-z_]\w*)\s*(==|!=|<|<=|>|>=)\s*([\w"']+)/i,Tz=/[+\-]/g,v0=/include[ \t]+"([\w-]+)(?:\s*,\s*([\w-]+))?"/g,Ez=/\{i\}/g,gD=/(pcFragColor[1-8])\b/g;class gs{static run(e,t=new Map,s={}){gs.sourceName=s.sourceName,e=this.stripComments(e),e=e.split(/\r?\n/).map(o=>o.trimEnd()).join(`
`);const i=new Map,r=new Map;if(e=this._preprocess(e,i,r,t,s.stripDefines),e===null)return null;const a=new Map;return i.forEach((o,h)=>{Number.isInteger(parseFloat(o))&&!o.includes(".")&&a.set(h,o)}),e=this.stripComments(e),e=this.stripUnusedColorAttachments(e,s),e=this.RemoveEmptyLines(e),e=this.processArraySize(e,a),e=this.injectDefines(e,r),e}static stripUnusedColorAttachments(e,t){if(t.stripUnusedColorAttachments){const s=new Map;if(e.match(gD)?.forEach(a=>{const o=parseInt(a.charAt(a.length-1),10);s.set(o,(s.get(o)??0)+1)}),Array.from(s.values()).some(a=>a===1)){const a=e.split(`
`),o=[];for(let h=0;h<a.length;h++){const u=a[h].match(gD);if(u){const f=parseInt(u[0].charAt(u[0].length-1),10);if(f>0&&s.get(f)===1)continue}o.push(a[h])}e=o.join(`
`)}}return e}static stripComments(e){return e.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,"$1")}static processArraySize(e,t){return e!==null&&t.forEach((s,i)=>{e=e.replace(new RegExp(`\\[${i}\\]`,"g"),`[${s}]`)}),e}static injectDefines(e,t){if(e!==null&&t.size>0){const s=e.split(`
`);t.forEach((i,r)=>{const a=new RegExp(r,"g");for(let o=0;o<s.length;o++)s[o].includes("#")||(s[o]=s[o].replace(a,i))}),e=s.join(`
`)}return e}static RemoveEmptyLines(e){return e!==null&&(e=e.split(/\r?\n/).map(t=>t.trim()===""?"":t).join(`
`),e=e.replace(/(\n\n){3,}/g,`

`)),e}static _preprocess(e,t=new Map,s,i,r){const a=e,o=[];let h=!1,u;for(;(u=ir.exec(e))!==null&&!h;){const f=u[1];switch(f){case"define":{m0.lastIndex=u.index;const m=m0.exec(e);h||(h=m===null);const _=m[1];_D.lastIndex=m.index;const S=_D.exec(_)[0];let x=_.substring(S.length).trim();x===""&&(x="true");const T=gs._keep(o);let E=r;if(T){const b=S.startsWith("{")&&S.endsWith("}");b&&(E=!0),b?s.set(S,x):t.set(S,x),E&&(e=e.substring(0,m.index-1)+e.substring(m0.lastIndex),ir.lastIndex=m.index-1)}E||(ir.lastIndex=m.index+m[0].length);break}case"undef":{p0.lastIndex=u.index;const m=p0.exec(e),_=m[1].trim();gs._keep(o)&&(t.delete(_),r&&(e=e.substring(0,m.index-1)+e.substring(p0.lastIndex),ir.lastIndex=m.index-1)),r||(ir.lastIndex=m.index+m[0].length);break}case"extension":{pD.lastIndex=u.index;const m=pD.exec(e);if(h||(h=m===null),m){const _=m[1];gs._keep(o)&&t.set(_,"true")}ir.lastIndex=m.index+m[0].length;break}case"ifdef":case"ifndef":case"if":{_0.lastIndex=u.index;const m=_0.exec(e),_=m[2],g=gs.evaluate(_,t);h||(h=g.error);let S=g.result;f==="ifndef"&&(S=!S),o.push({anyKeep:S,keep:S,start:u.index,end:_0.lastIndex}),ir.lastIndex=m.index+m[0].length;break}case"endif":case"else":case"elif":{g0.lastIndex=u.index;const m=g0.exec(e),_=o.pop();if(!_){console.error(`Shader preprocessing encountered "#${m[1]}" without a preceding #if #ifdef #ifndef while preprocessing ${gs.sourceName} on line:
 ${e.substring(u.index,u.index+100)}...`,{source:a}),h=!0;continue}const g=_.keep?e.substring(_.end,u.index):"";e=e.substring(0,_.start)+g+e.substring(g0.lastIndex),ir.lastIndex=_.start+g.length;const S=m[1];if(S==="else"||S==="elif"){let x=!1;if(!_.anyKeep)if(S==="else")x=!_.keep;else{const T=gs.evaluate(m[2],t);x=T.result,h||(h=T.error)}o.push({anyKeep:_.anyKeep||x,keep:x,start:ir.lastIndex,end:ir.lastIndex})}break}case"include":{v0.lastIndex=u.index;const m=v0.exec(e);if(h||(h=m===null),!m){h=!0;continue}const _=m[1].trim(),g=m[2]?.trim();if(gs._keep(o)){let x=i?.get(_);if(x!==void 0){if(x=this.stripComments(x),g){const T=t.get(g),E=parseFloat(T);if(Number.isInteger(E)){let b="";for(let C=0;C<E;C++)b+=x.replace(Ez,String(C));x=b}else console.error(`Include Count identifier "${g}" not resolved while preprocessing ${gs.sourceName} on line:
 ${e.substring(u.index,u.index+100)}...`,{originalSource:a,source:e}),h=!0}e=e.substring(0,m.index-1)+x+e.substring(v0.lastIndex),ir.lastIndex=m.index-1}else{console.error(`Include "${_}" not resolved while preprocessing ${gs.sourceName}`,{originalSource:a,source:e}),h=!0;continue}}break}}}return o.length>0&&(console.error(`Shader preprocessing reached the end of the file without encountering the necessary #endif to close a preceding #if, #ifdef, or #ifndef block. ${gs.sourceName}`),h=!0),h?(console.error("Failed to preprocess shader: ",{source:a}),null):e}static _keep(e){for(let t=0;t<e.length;t++)if(!e[t].keep)return!1;return!0}static evaluateAtomicExpression(e,t){let s=!1;e=e.trim();let i=!1;if(e==="true")return{result:!0,error:s};if(e==="false")return{result:!1,error:s};const r=vz.exec(e);if(r){i=r[1]==="!",e=r[2].trim();const h=t.has(e);return{result:i?!h:h,error:s}}const a=xz.exec(e);if(a){const h=t.get(a[1].trim())??a[1].trim(),u=t.get(a[3].trim())??a[3].trim(),f=a[2].trim();let m=!1;switch(f){case"==":m=h===u;break;case"!=":m=h!==u;break;case"<":m=h<u;break;case"<=":m=h<=u;break;case">":m=h>u;break;case">=":m=h>=u;break;default:s=!0}return{result:m,error:s}}return{result:t.has(e),error:s}}static processParentheses(e,t){let s=!1,i=e.trim();for(;i.startsWith("(")&&i.endsWith(")");){let r=0,a=!0;for(let o=0;o<i.length-1;o++)if(i[o]==="(")r++;else if(i[o]===")"&&(r--,r===0)){a=!1;break}if(a)i=i.slice(1,-1).trim();else break}for(;;){let r=!1,a=0,o=0,h=-1,u=-1,f=0;for(let S=0;S<i.length;S++)if(i[S]==="("){const x=i.substring(0,S);yz.test(x)?f++:f===0&&(a++,a>o&&(o=a,h=S),r=!0)}else i[S]===")"&&(f>0?f--:a>0&&(a===o&&h!==-1&&(u=S),a--));if(!r||h===-1||u===-1)break;const m=i.substring(h+1,u),{result:_,error:g}=gs.evaluate(m,t);s=s||g,i=i.substring(0,h)+(_?"true":"false")+i.substring(u+1)}return{expression:i,error:s}}static evaluate(e,t){const s=Tz.exec(e)===null;let i=e,r=!1;if(e.replace(Sz,"").indexOf("(")!==-1){const h=gs.processParentheses(e,t);i=h.expression,r=h.error}if(r)return{result:!1,error:!0};const o=i.split("||");for(const h of o){const u=h.split("&&");let f=!0;for(const m of u){const{result:_,error:g}=gs.evaluateAtomicExpression(m.trim(),t);if(!_||g){f=!1;break}}if(f)return{result:!0,error:!s}}return{result:!1,error:!s}}}var c2=`
#ifndef outType_0
#define outType_0 vec4
#endif
layout(location = 0) out highp outType_0 pcFragColor0;
#if COLOR_ATTACHMENT_1
layout(location = 1) out highp outType_1 pcFragColor1;
#endif
#if COLOR_ATTACHMENT_2
layout(location = 2) out highp outType_2 pcFragColor2;
#endif
#if COLOR_ATTACHMENT_3
layout(location = 3) out highp outType_3 pcFragColor3;
#endif
#if COLOR_ATTACHMENT_4
layout(location = 4) out highp outType_4 pcFragColor4;
#endif
#if COLOR_ATTACHMENT_5
layout(location = 5) out highp outType_5 pcFragColor5;
#endif
#if COLOR_ATTACHMENT_6
layout(location = 6) out highp outType_6 pcFragColor6;
#endif
#if COLOR_ATTACHMENT_7
layout(location = 7) out highp outType_7 pcFragColor7;
#endif
#define gl_FragColor pcFragColor0
#define varying in
#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLod textureLod
#define texture2DProjLod textureProjLod
#define textureCubeLod textureLod
#define texture2DGrad textureGrad
#define texture2DProjGrad textureProjGrad
#define textureCubeGrad textureGrad
#define utexture2D texture
#define itexture2D texture
#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead
#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod
#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead
#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead
#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead
#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
#define GL2
`,h2=`
#extension GL_ANGLE_multi_draw : enable
#define attribute in
#define varying out
#define texture2D texture
#define utexture2D texture
#define itexture2D texture
#define GL2
#define VERTEXSHADER
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name
#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name
`,u2=`
#extension GL_EXT_samplerless_texture_functions : require
#ifndef outType_0
#define outType_0 vec4
#endif
#ifndef outType_1
#define outType_1 vec4
#endif
#ifndef outType_2
#define outType_2 vec4
#endif
#ifndef outType_3
#define outType_3 vec4
#endif
#ifndef outType_4
#define outType_4 vec4
#endif
#ifndef outType_5
#define outType_5 vec4
#endif
#ifndef outType_6
#define outType_6 vec4
#endif
#ifndef outType_7
#define outType_7 vec4
#endif
layout(location = 0) out highp outType_0 pcFragColor0;
layout(location = 1) out highp outType_1 pcFragColor1;
layout(location = 2) out highp outType_2 pcFragColor2;
layout(location = 3) out highp outType_3 pcFragColor3;
layout(location = 4) out highp outType_4 pcFragColor4;
layout(location = 5) out highp outType_5 pcFragColor5;
layout(location = 6) out highp outType_6 pcFragColor6;
layout(location = 7) out highp outType_7 pcFragColor7;
#define gl_FragColor pcFragColor0
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLod(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLod(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead
#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod
#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead
#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead
#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead
#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT
#define GL2
#define WEBGPU
`,d2=`
#extension GL_EXT_samplerless_texture_functions : require
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)
#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT
#define GL2
#define WEBGPU
#define VERTEXSHADER
#define gl_VertexID gl_VertexIndex
#define gl_InstanceID gl_InstanceIndex
`,f2=`
`,m2=`
#define VERTEXSHADER
`,vD=`
vec2 getGrabScreenPos(vec4 clipPos) {
	vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
vec2 getImageEffectUV(vec2 uv) {
	#ifdef WEBGPU
		uv.y = 1.0 - uv.y;
	#endif
	return uv;
}
`,SD=`
#define WEBGPU
fn getGrabScreenPos(clipPos: vec4<f32>) -> vec2<f32> {
	var uv: vec2<f32> = (clipPos.xy / clipPos.w) * 0.5 + vec2<f32>(0.5);
	uv.y = 1.0 - uv.y;
	return uv;
}
fn getImageEffectUV(uv: vec2<f32>) -> vec2<f32> {
	var modifiedUV: vec2<f32> = uv;
	modifiedUV.y = 1.0 - modifiedUV.y;
	return modifiedUV;
}
struct WrappedF32 { @size(16) element: f32 }
struct WrappedI32 { @size(16) element: i32 }
struct WrappedU32 { @size(16) element: u32 }
struct WrappedVec2F { @size(16) element: vec2f }
struct WrappedVec2I { @size(16) element: vec2i }
struct WrappedVec2U { @size(16) element: vec2u }
`;const bz={vertex_position:He,vertex_normal:si,vertex_tangent:Xr,vertex_texCoord0:Zi,vertex_texCoord1:Il,vertex_texCoord2:Of,vertex_texCoord3:Nf,vertex_texCoord4:Ff,vertex_texCoord5:Bf,vertex_texCoord6:Uf,vertex_texCoord7:zf,vertex_color:Rs,vertex_boneIndices:yi,vertex_boneWeights:kr};class Os{static createDefinition(e,t){const s=_=>{let g=_.fragmentOutputTypes??"vec4";return Array.isArray(g)||(g=[g]),g},i=(_,g,S,x)=>{const T=e.isWebGPU?_:g;let E="";if(!S){const b=s(x);for(let C=0;C<e.maxColorAttachments;C++){E+=`#define COLOR_ATTACHMENT_${C}
`;const w=b[C]??"vec4";E+=`#define outType_${C} ${w}
`}}return E+T},r=(_,g)=>{let S="";if(!_&&e.supportsPrimitiveIndex&&(S+=`enable primitive_index;
`),!_){const x=s(g);for(let T=0;T<e.maxColorAttachments;T++){const E=x[T]??"vec4",b=r2.get(E);S+=`alias pcOutType${T} = ${b};
`}}return S},a=t.name??"Untitled";let o,h;const u=Os.getDefinesCode(e,t.vertexDefines),f=Os.getDefinesCode(e,t.fragmentDefines);return t.shaderLanguage===Je?(o=`
								${r(!0,t)}
								${u}
								${m2}
								${SD}
								${t.vertexCode}
						`,h=`
								${r(!1,t)}
								${f}
								${f2}
								${SD}
								${t.fragmentCode}
						`):(o=`${Os.versionCode(e)+i(d2,h2,!0,t)+u+Os.precisionCode(e)}
								${vD}
								${Os.getShaderNameCode(a)}
								${t.vertexCode}`,h=`${(t.fragmentPreamble||"")+Os.versionCode(e)+i(u2,c2,!1,t)+f+Os.precisionCode(e)}
								${vD}
								${Os.getShaderNameCode(a)}
								${t.fragmentCode}`),{name:a,shaderLanguage:t.shaderLanguage??ot,attributes:t.attributes,vshader:o,vincludes:t.vertexIncludes,fincludes:t.fragmentIncludes,fshader:h,feedbackVaryings:t.feedbackVaryings,useTransformFeedback:t.useTransformFeedback,meshUniformBufferFormat:t.meshUniformBufferFormat,meshBindGroupFormat:t.meshBindGroupFormat}}static getDefinesCode(e,t){let s="";return e.capsDefines.forEach((i,r)=>{s+=`#define ${r} ${i}
`}),s+=`
`,t?.forEach((i,r)=>{s+=`#define ${r} ${i}
`}),s+=`
`,s}static getShaderNameCode(e){return`#define SHADER_NAME ${e}
`}static versionCode(e){return e.isWebGPU?`#version 450
`:`#version 300 es
`}static precisionCode(e,t){t&&t!=="highp"&&t!=="mediump"&&t!=="lowp"&&(t=null),t&&(t==="highp"&&e.maxPrecision!=="highp"&&(t="mediump"),t==="mediump"&&e.maxPrecision==="lowp"&&(t="lowp"));const s=t||e.precision;return`
						precision ${s} float;
						precision ${s} int;
						precision ${s} usampler2D;
						precision ${s} isampler2D;
						precision ${s} sampler2DShadow;
						precision ${s} samplerCubeShadow;
						precision ${s} sampler2DArray;
				`}static collectAttributes(e){const t={};let s=0,i=e.indexOf("attribute");for(;i>=0&&!(i>0&&e[i-1]==="/");){let r=!1;if(i>0){let a=e.lastIndexOf(`
`,i);a=a!==-1?a+1:0,e.substring(a,i).includes("#")&&(r=!0)}if(!r){const a=e.indexOf(";",i),o=e.lastIndexOf(" ",a),h=e.substring(o+1,a);if(!t[h]){const u=bz[h];u!==void 0?t[h]=u:(t[h]=`ATTR${s}`,s++)}}i=e.indexOf("attribute",i+1)}return t}}let Az=0;class fo{init(){this.ready=!1,this.failed=!1}get label(){return`Shader Id ${this.id} (${this.definition.shaderLanguage===Je?"WGSL":"GLSL"}) ${this.name}`}destroy(){this.device.onDestroyShader(this),this.impl.destroy(this)}loseContext(){this.init(),this.impl.loseContext()}restoreContext(){this.impl.restoreContext(this.device,this)}constructor(e,t){if(this.attributes=new Map,this.id=Az++,this.device=e,this.definition=t,this.name=t.name||"Untitled",this.init(),t.cshader){const r=Os.getDefinesCode(e,t.cdefines)+t.cshader;t.cshader=gs.run(r,t.cincludes,{sourceName:`compute shader for ${this.label}`,stripDefines:!0})}else{const i=t.shaderLanguage===Je;if(t.vshader=gs.run(t.vshader,t.vincludes,{sourceName:`vertex shader for ${this.label}`,stripDefines:i}),t.shaderLanguage===ot){var s;(s=t).attributes??(s.attributes=Os.collectAttributes(t.vshader))}const r=e.isWebGL2&&(Ve.name==="osx"||Ve.name==="ios");if(t.fshader=gs.run(t.fshader,t.fincludes,{stripUnusedColorAttachments:r,stripDefines:i,sourceName:`fragment shader for ${this.label}`}),!t.vshader||!t.fshader){this.failed=!0;return}}this.impl=e.createShaderImpl(this)}}class wz{}class Cz{}class Dz{destroy(){this.gpuBuffers.forEach(e=>{e.destroy(this.device)}),this.gpuBuffers=null,this.stagingBuffers.forEach(e=>{e.destroy(this.device)}),this.stagingBuffers=null,this.usedBuffers=null,this.activeBuffer=null}alloc(e,t){if(this.activeBuffer){const r=J.roundUp(this.activeBuffer.size,this.bufferAlignment);this.bufferSize-r<t&&this.scheduleSubmit()}if(!this.activeBuffer){let r=this.gpuBuffers.pop();r||(r=this.createBuffer(this.device,this.bufferSize,!1));let a=this.stagingBuffers.pop();a||(a=this.createBuffer(this.device,this.bufferSize,!0)),this.activeBuffer=new wz,this.activeBuffer.stagingBuffer=a,this.activeBuffer.gpuBuffer=r,this.activeBuffer.offset=0,this.activeBuffer.size=0}const s=this.activeBuffer,i=J.roundUp(s.size,this.bufferAlignment);e.gpuBuffer=s.gpuBuffer,e.offset=i,e.storage=s.stagingBuffer.alloc(i,t),s.size=i+t}scheduleSubmit(){this.activeBuffer&&(this.usedBuffers.push(this.activeBuffer),this.activeBuffer=null)}submit(){this.scheduleSubmit()}constructor(e,t,s){this.gpuBuffers=[],this.stagingBuffers=[],this.usedBuffers=[],this.activeBuffer=null,this.device=e,this.bufferSize=t,this.bufferAlignment=s}}const ut=[];ut[Bs]=function(c,e,t){const s=c.storageFloat32;s[t]=e};ut[xl]=(c,e,t)=>{const s=c.storageFloat32;s[t]=e[0],s[t+1]=e[1]};ut[Gi]=(c,e,t)=>{const s=c.storageFloat32;s[t]=e[0],s[t+1]=e[1],s[t+2]=e[2]};ut[so]=(c,e,t)=>{const s=c.storageFloat32;s[t]=e[0],s[t+1]=e[1],s[t+2]=e[2],s[t+3]=e[3]};ut[Ga]=function(c,e,t){const s=c.storageInt32;s[t]=e};ut[hl]=function(c,e,t){const s=c.storageInt32;s[t]=e[0],s[t+1]=e[1]};ut[Ha]=function(c,e,t){const s=c.storageInt32;s[t]=e[0],s[t+1]=e[1],s[t+2]=e[2]};ut[ul]=function(c,e,t){const s=c.storageInt32;s[t]=e[0],s[t+1]=e[1],s[t+2]=e[2],s[t+3]=e[3]};ut[rg]=(c,e,t)=>{const s=c.storageFloat32;s[t]=e[0],s[t+1]=e[1],s[t+4]=e[2],s[t+5]=e[3],s[t+8]=e[4],s[t+9]=e[5]};ut[Ah]=(c,e,t)=>{const s=c.storageFloat32;s[t]=e[0],s[t+1]=e[1],s[t+2]=e[2],s[t+4]=e[3],s[t+5]=e[4],s[t+6]=e[5],s[t+8]=e[6],s[t+9]=e[7],s[t+10]=e[8]};ut[fv]=function(c,e,t,s){const i=c.storageFloat32;for(let r=0;r<s;r++)i[t+r*4]=e[r]};ut[mv]=(c,e,t,s)=>{const i=c.storageFloat32;for(let r=0;r<s;r++)i[t+r*4]=e[r*2],i[t+r*4+1]=e[r*2+1]};ut[pv]=(c,e,t,s)=>{const i=c.storageFloat32;for(let r=0;r<s;r++)i[t+r*4]=e[r*3],i[t+r*4+1]=e[r*3+1],i[t+r*4+2]=e[r*3+2]};ut[Qs]=(c,e,t,s)=>{const i=c.storageUint32;i[t]=e};ut[wh]=(c,e,t,s)=>{const i=c.storageUint32;i[t]=e[0],i[t+1]=e[1]};ut[Ch]=(c,e,t,s)=>{const i=c.storageUint32;i[t]=e[0],i[t+1]=e[1],i[t+2]=e[2]};ut[Dh]=(c,e,t,s)=>{const i=c.storageUint32;i[t]=e[0],i[t+1]=e[1],i[t+2]=e[2],i[t+3]=e[3]};ut[Ph]=function(c,e,t,s){const i=c.storageInt32;for(let r=0;r<s;r++)i[t+r*4]=e[r]};ut[gv]=ut[Ph];ut[_v]=function(c,e,t,s){const i=c.storageUint32;for(let r=0;r<s;r++)i[t+r*4]=e[r]};ut[Rh]=(c,e,t,s)=>{const i=c.storageInt32;for(let r=0;r<s;r++)i[t+r*4]=e[r*2],i[t+r*4+1]=e[r*2+1]};ut[Sv]=ut[Rh];ut[vv]=(c,e,t,s)=>{const i=c.storageUint32;for(let r=0;r<s;r++)i[t+r*4]=e[r*2],i[t+r*4+1]=e[r*2+1]};ut[Mh]=(c,e,t,s)=>{const i=c.storageInt32;for(let r=0;r<s;r++)i[t+r*4]=e[r*3],i[t+r*4+1]=e[r*3+1],i[t+r*4+2]=e[r*3+2]};ut[xv]=ut[Mh];ut[yv]=(c,e,t,s)=>{const i=c.storageUint32;for(let r=0;r<s;r++)i[t+r*4]=e[r*3],i[t+r*4+1]=e[r*3+1],i[t+r*4+2]=e[r*3+2]};class Vf{destroy(){if(this.persistent){const e=this.device;this.impl.destroy(e),e._vram.ub-=this.format.byteSize}}get offset(){return this.persistent?0:this.allocation.offset}assignStorage(e){this.storageInt32=e,this.storageUint32=new Uint32Array(e.buffer,e.byteOffset,e.byteLength/4),this.storageFloat32=new Float32Array(e.buffer,e.byteOffset,e.byteLength/4)}loseContext(){this.impl?.loseContext()}setUniform(e,t){const s=e.offset;if(t!=null){const i=ut[e.updateType];i?i(this,t,s,e.count):this.storageFloat32.set(t,s)}}set(e,t){const s=this.format.map.get(e);s&&this.setUniform(s,t)}startUpdate(e){if(!this.persistent){const t=this.allocation,s=t.gpuBuffer;this.device.dynamicBuffers.alloc(t,this.format.byteSize),this.assignStorage(t.storage),e&&(e.bindGroup=t.gpuBuffer.getBindGroup(this),e.offsets[0]=t.offset),s!==t.gpuBuffer&&(this.renderVersionDirty=this.device.renderVersion)}}endUpdate(){this.persistent?this.impl.unlock(this):(this.storageFloat32=null,this.storageInt32=null)}update(e){this.startUpdate(e);const t=this.format.uniforms;for(let s=0;s<t.length;s++){const i=t[s].scopeId.value;this.setUniform(t[s],i)}this.endUpdate()}constructor(e,t,s=!0){if(this.renderVersionDirty=0,this.device=e,this.format=t,this.persistent=s,s){this.impl=e.createUniformBufferImpl(this);const i=new ArrayBuffer(t.byteSize);this.assignStorage(new Int32Array(i)),e._vram.ub+=this.format.byteSize}else this.allocation=new Cz}}const Pz={type:zr,base:0,baseVertex:0,count:4,indexed:!1};class Rz{destroy(){this.shader.destroy(),this.shader=null,this.uniformBuffer.destroy(),this.uniformBuffer=null}clear(e,t,s,i){s=s||i;const r=s.flags??i.flags;if(r!==0){const{uniformBuffer:a,dynamicBindGroup:o}=this;if(a.startUpdate(o),e.setBindGroup(Lh,o.bindGroup,o.offsets),e.setBindGroup(kf,e.emptyBindGroup),r&qd&&(t.colorBuffer||t.impl.assignedColorTexture)){const h=s.color??i.color;this.colorData.set(h),e.setBlendState(ht.NOBLEND)}else e.setBlendState(ht.NOWRITE);if(a.set("color",this.colorData),r&Yd&&t.depth){const h=s.depth??i.depth;a.set("depth",h),e.setDepthState(Gt.WRITEDEPTH)}else a.set("depth",1),e.setDepthState(Gt.NODEPTH);r&W_&&t.stencil,a.endUpdate(),e.setCullMode(Ft),e.setShader(this.shader),e.draw(Pz)}}constructor(e){const t=`

						struct ub_mesh {
								color : vec4f,
								depth: f32
						}

						@group(2) @binding(0) var<uniform> ubMesh : ub_mesh;

						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f
						}

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
								var output : VertexOutput;
								output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
								return output;
						}

						@fragment
						fn fragmentMain() -> @location(0) vec4f {
								return ubMesh.color;
						}
				`;this.shader=new fo(e,{name:"WebGPUClearRendererShader",shaderLanguage:Je,vshader:t,fshader:t}),this.uniformBuffer=new Vf(e,new uo(e,[new Be("color",so),new Be("depth",Bs)]),!1),this.dynamicBindGroup=new wE,this.colorData=new Float32Array(4)}}class Mz{destroy(){this.shader.destroy(),this.shader=null,this.pipelineCache.clear()}generate(e){const t=e.desc;if(t.mipLevelCount<=1||e.texture.volume)return;const s=this.device,i=s.wgpu,r=t.format;let a=this.pipelineCache.get(r);if(!a){const m=this.shader.impl;a=i.createRenderPipeline({layout:"auto",vertex:{module:m.getVertexShaderModule(),entryPoint:m.vertexEntryPoint},fragment:{module:m.getFragmentShaderModule(),entryPoint:m.fragmentEntryPoint,targets:[{format:r}]},primitive:{topology:"triangle-strip"}}),this.pipelineCache.set(r,a)}const o=e.texture,h=o.cubemap?6:o.array?o.arrayLength:1,u=[];for(let m=0;m<h;m++)u.push(e.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:m}));const f=s.getCommandEncoder();for(let m=1;m<t.mipLevelCount;m++)for(let _=0;_<h;_++){const g=e.createView({dimension:"2d",baseMipLevel:m,mipLevelCount:1,baseArrayLayer:_}),S=f.beginRenderPass({colorAttachments:[{view:g,loadOp:"clear",storeOp:"store"}]}),x=i.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:this.minSampler},{binding:1,resource:u[_]}]});S.setPipeline(a),S.setBindGroup(0,x),S.draw(4),S.end(),u[_]=g}s.pipeline=null}constructor(e){this.pipelineCache=new Map,this.device=e;const t=`
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
								@location(0) texCoord : vec2f
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var imgSampler : sampler;
						@group(0) @binding(1) var img : texture_2d<f32>;

						@fragment
						fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
							return textureSample(img, imgSampler, texCoord);
						}
				`;this.shader=new fo(e,{name:"WebGPUMipmapRendererShader",shaderLanguage:Je,vshader:t,fshader:t}),this.minSampler=e.wgpu.createSampler({minFilter:"linear"})}}class Lz{getBindGroup(e){const t=e.format.byteSize;let s=this.bindGroupCache.get(t);return s||(s=new qh(this.device,this.bindGroupFormat,e),s.update(),this.bindGroupCache.set(t,s)),s}constructor(e){this.bindGroupCache=new Map,this.device=e,this.bindGroupFormat=new Vr(this.device,[new io(Tv,Tl|El)])}}class Iz extends Lz{destroy(e){e._vram.ub-=this.buffer.size,this.buffer.destroy(),this.buffer=null}onAvailable(){this.mappedRange=this.buffer.getMappedRange()}alloc(e,t){return new Int32Array(this.mappedRange,e,t/4)}constructor(e,t,s){super(e),this.buffer=null,this.mappedRange=null,this.buffer=e.wgpu.createBuffer({size:t,usage:s?GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:s}),s&&this.onAvailable(),e._vram.ub+=t}}class Oz extends Dz{createBuffer(e,t,s){return new Iz(e,t,s)}submit(){super.submit();const e=this.usedBuffers.length;if(e){const t=this.device,s=this.gpuBuffers,i=t.wgpu.createCommandEncoder();for(let a=e-1;a>=0;a--){const o=this.usedBuffers[a],{stagingBuffer:h,gpuBuffer:u,offset:f,size:m}=o,_=h.buffer;_.unmap(),i.copyBufferToBuffer(_,f,u.buffer,f,m),s.push(u)}const r=i.finish();t.addCommandBuffer(r,!0);for(let a=0;a<e;a++){const o=this.usedBuffers[a].stagingBuffer;this.pendingStagingBuffers.push(o)}this.usedBuffers.length=0}}onCommandBuffersSubmitted(){const e=this.pendingStagingBuffers.length;if(e){for(let t=0;t<e;t++){const s=this.pendingStagingBuffers[t];s.buffer.mapAsync(GPUMapMode.WRITE).then(()=>{this.stagingBuffers&&(s.onAvailable(),this.stagingBuffers.push(s))})}this.pendingStagingBuffers.length=0}}constructor(...e){super(...e),this.pendingStagingBuffers=[]}}class p2{loseContext(){this.pastFrameAllocations.clear()}set enabled(e){this._enableRequest=e}get enabled(){return this._enableRequest}get passTimings(){return this._passTimings}processEnableRequest(){this._enableRequest!==this._enabled&&(this._enabled=this._enableRequest,this._enabled||(this._frameTime=0))}request(e){this.pastFrameAllocations.set(e,this.frameAllocations),this.frameAllocations=[]}_parsePassName(e){let t=this._nameCache.get(e);return t===void 0&&(e.startsWith("RenderPass")?t=e.substring(10):t=e,this._nameCache.set(e,t)),t}report(e,t){if(t){const s=this.pastFrameAllocations.get(e);if(!s)return;t.length>0&&(this._frameTime=t.reduce((i,r)=>i+r,0)),this._passTimings.clear();for(let i=0;i<s.length;++i){const r=s[i],a=t[i],o=this._parsePassName(r);this._passTimings.set(o,(this._passTimings.get(o)||0)+a)}if(Tf.get(qF)){let i=0;for(let r=0;r<s.length;++r)s[r],i+=t[r]}}this.pastFrameAllocations.delete(e)}getSlot(e){if(this.frameAllocations.length>=this.maxCount)return-1;const t=this.frameAllocations.length;return this.frameAllocations.push(e),t}get slotCount(){return this.frameAllocations.length}constructor(){this.frameAllocations=[],this.pastFrameAllocations=new Map,this._enabled=!1,this._enableRequest=!1,this._frameTime=0,this._passTimings=new Map,this._nameCache=new Map,this.maxCount=9999}}class Nz{destroy(){this.querySet?.destroy(),this.querySet=null,this.queryBuffer?.destroy(),this.queryBuffer=null,this.activeStagingBuffer=null,this.stagingBuffers.forEach(e=>{e.destroy()}),this.stagingBuffers=null}getStagingBuffer(){let e=this.stagingBuffers.pop();return e||(e=this.device.wgpu.createBuffer({size:this.queryBuffer.size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})),e}resolve(e){const s=this.device.getCommandEncoder();s.resolveQuerySet(this.querySet,0,e,this.queryBuffer,0);const i=this.getStagingBuffer();this.activeStagingBuffer=i,s.copyBufferToBuffer(this.queryBuffer,0,i,0,this.bytesPerSlot*e)}request(e,t){const s=this.activeStagingBuffer;return this.activeStagingBuffer=null,s.mapAsync(GPUMapMode.READ).then(()=>{const i=new BigInt64Array(s.getMappedRange()),r=[];for(let a=0;a<e;a++)r.push(Number(i[a*2+1]-i[a*2])*1e-6);return s.unmap(),this.stagingBuffers?.push(s),{renderVersion:t,timings:r}})}constructor(e,t,s){this.stagingBuffers=[],this.activeStagingBuffer=null,this.device=e,this.capacity=s,this.bytesPerSlot=t?8:4;const i=e.wgpu;this.querySet=i.createQuerySet({type:t?"timestamp":"occlusion",count:s}),this.queryBuffer=i.createBuffer({size:this.bytesPerSlot*s,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST})}}class Fz extends p2{destroy(){this.timestampQueriesSet?.destroy(),this.timestampQueriesSet=null}frameStart(){this.processEnableRequest()}frameEnd(){this._enabled&&this.timestampQueriesSet?.resolve(this.slotCount*2)}request(){if(this._enabled){const e=this.device.renderVersion;this.timestampQueriesSet?.request(this.slotCount,e).then(t=>{this.report(t.renderVersion,t.timings)}),super.request(e)}}constructor(e){super(),this.device=e,this.maxCount=1024,this.timestampQueriesSet=e.supportsTimestampQuery?new Nz(e,!0,2*this.maxCount):null}}class Bz{destroy(){this.shader.destroy(),this.shader=null,this.pipelineCache=null}getPipeline(e){let t=this.pipelineCache.get(e);return t||(t=this.createPipeline(e),this.pipelineCache.set(e,t)),t}createPipeline(e){const t=this.shader.impl;return this.device.wgpu.createRenderPipeline({layout:"auto",vertex:{module:t.getVertexShaderModule(),entryPoint:t.vertexEntryPoint},fragment:{module:t.getFragmentShaderModule(),entryPoint:t.fragmentEntryPoint,targets:[{format:e}]},primitive:{topology:"triangle-strip"}})}resolveDepth(e,t,s){const i=this.device,r=i.wgpu,a=this.getPipeline(s.format),o=t.depthOrArrayLayers;for(let h=0;h<o;h++){const u=t.createView({dimension:"2d",aspect:"depth-only",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:h}),f=s.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:h}),m=e.beginRenderPass({colorAttachments:[{view:f,loadOp:"clear",storeOp:"store"}]}),_=r.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:u}]});m.setPipeline(a),m.setBindGroup(0,_),m.draw(4),m.end()}i.pipeline=null}constructor(e){this.pipelineCache=new Map,this.device=e;const t=`
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var img : texture_depth_multisampled_2d;

						@fragment
						fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {
								// load th depth value from sample index 0
								var depth = textureLoad(img, vec2i(fragColor.xy), 0u);
								return vec4f(depth, 0.0, 0.0, 0.0);
						}
				`;this.shader=new fo(e,{name:"WebGPUResolverDepthShader",shaderLanguage:Je,vshader:t,fshader:t})}}const Uz=12;class zz{destroy(){this.uniformBuffers.forEach(e=>e.destroy()),this.uniformBuffers.length=0,this.bindGroup.destroy(),this.bindGroup=null}updateBindGroup(){const{bindGroup:e}=this;e.updateUniformBuffers(),e.update()}dispatch(e,t,s){const i=this.compute.device;i.setBindGroup(0,this.bindGroup);const r=i.passEncoder;r.setPipeline(this.pipeline);const{indirectSlotIndex:a,indirectBuffer:o,indirectFrameStamp:h}=this.compute;if(a>=0){let u;o?u=o.impl.buffer:u=i.indirectDispatchBuffer.impl.buffer;const f=a*Uz;r.dispatchWorkgroupsIndirect(u,f)}else r.dispatchWorkgroups(e,t,s)}constructor(e){this.uniformBuffers=[],this.bindGroup=null,this.compute=e;const{device:t,shader:s}=e,{computeBindGroupFormat:i,computeUniformBufferFormats:r}=s.impl;if(this.bindGroup=new qh(t,i),r){for(const a in r)if(r.hasOwnProperty(a)){const o=new Vf(t,r[a],!0);this.uniformBuffers.push(o),this.bindGroup.setUniformBuffer(a,o)}}this.pipeline=t.computePipeline.get(s,i)}}let kz=0;class Fs{destroy(){const e=this.device;e.buffers.delete(this),this.adjustVramSizeTracking(e._vram,-this.byteSize),this.impl.destroy(e)}adjustVramSizeTracking(e,t){e.sb+=t}read(e=0,t=this.byteSize,s=null,i=!1){return this.impl.read(this.device,e,t,s,i)}write(e=0,t,s=0,i){this.impl.write(this.device,e,t,s,i)}clear(e=0,t=this.byteSize){this.impl.clear(this.device,e,t)}copy(e,t=0,s=0,i=e.byteSize-t){this.device.getCommandEncoder().copyBufferToBuffer(e.impl.buffer,t,this.impl.buffer,s,i)}constructor(e,t,s=0,i=!0){this.id=kz++,this.device=e,this.byteSize=t,this.bufferUsage=s;const r=i?eE|s:s;this.impl=e.createBufferImpl(r),this.impl.allocate(e,t),this.device.buffers.add(this),this.adjustVramSizeTracking(e._vram,this.byteSize)}}class Vz{allocate(e){this.gpuIndirect&&this.gpuIndirect.length===5*e||(this.storage?.destroy(),this.gpuIndirect=new Uint32Array(5*e),this.gpuIndirectSigned=new Int32Array(this.gpuIndirect.buffer),this.storage=new Fs(this.device,this.gpuIndirect.byteLength,zx|Ns))}add(e,t,s,i,r=0,a=0){const o=e*5;this.gpuIndirect[o+0]=t,this.gpuIndirect[o+1]=s,this.gpuIndirect[o+2]=i,this.gpuIndirectSigned[o+3]=r,this.gpuIndirect[o+4]=a}update(e){if(this.storage&&e>0){const s=e*5;this.storage.write(0,this.gpuIndirect,0,s)}return 0}destroy(){this.storage?.destroy(),this.storage=null}constructor(e){this.gpuIndirect=null,this.gpuIndirectSigned=null,this.storage=null,this.device=e}}class Gz{_onDeviceLost(){}destroy(){this._destroyed=!0,this.availableStagingBuffers.forEach(e=>e.destroy()),this.pendingStagingBuffers.forEach(e=>e.destroy())}update(e){const t=this.pendingStagingBuffers;for(let i=0;i<t.length;i++){const r=t[i];r.mapAsync(GPUMapMode.WRITE).then(()=>{this._destroyed?r.destroy():this.availableStagingBuffers.push(r)})}t.length=0;const s=this.availableStagingBuffers;for(let i=s.length-1;i>=0;i--)s[i].size<e&&(s[i].destroy(),s.splice(i,1))}upload(e,t,s,i){this.useSingleBuffer?this.uploadDirect(e,t,s,i):this.uploadStaging(e,t,s,i)}uploadDirect(e,t,s,i){const r=s*e.BYTES_PER_ELEMENT;i*e.BYTES_PER_ELEMENT,t.write(r,e,0,i)}uploadStaging(e,t,s,i){const r=this.uploadStream.device,a=s*e.BYTES_PER_ELEMENT,o=i*e.BYTES_PER_ELEMENT;this.update(o);const h=this.availableStagingBuffers.pop()??this.uploadStream.device.wgpu.createBuffer({size:o,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),u=h.getMappedRange();new Uint8Array(u).set(new Uint8Array(e.buffer,e.byteOffset,o)),h.unmap(),r.getCommandEncoder().copyBufferToBuffer(h,0,t.impl.buffer,a,o),this.pendingStagingBuffers.push(h)}constructor(e){this.availableStagingBuffers=[],this.pendingStagingBuffers=[],this._destroyed=!1,this.uploadStream=e,this.useSingleBuffer=e.useSingleBuffer}}const S0=new Map,yD=20,Hz=12;class Wz extends Yh{destroy(){this.clearRenderer.destroy(),this.clearRenderer=null,this.mipmapRenderer.destroy(),this.mipmapRenderer=null,this.resolver.destroy(),this.resolver=null,super.destroy()}initDeviceCaps(){const e=this.wgpu?.limits;this.limits=e,this.precision="highp",this.maxPrecision="highp",this.maxSamples=4,this.maxTextures=16,this.maxTextureSize=e.maxTextureDimension2D,this.maxCubeMapSize=e.maxTextureDimension2D,this.maxVolumeSize=e.maxTextureDimension3D,this.maxColorAttachments=e.maxColorAttachments,this.maxPixelRatio=1,this.maxAnisotropy=16,this.fragmentUniformsCount=e.maxUniformBufferBindingSize/16,this.vertexUniformsCount=e.maxUniformBufferBindingSize/16,this.supportsUniformBuffers=!0,this.supportsAreaLights=!0,this.supportsGpuParticles=!0,this.supportsCompute=!0,this.textureFloatRenderable=!0,this.textureHalfFloatRenderable=!0,this.supportsImageBitmap=!0,this.samples=this.backBufferAntialias?4:1;const t=window.navigator.gpu.wgslLanguageFeatures;this.supportsStorageTextureRead=t?.has("readonly_and_readwrite_storage_textures"),this.initCapsDefines()}async initWebGpu(e,t){if(!window.navigator.gpu)throw new Error("Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering.");if(e&&t){const s=r=>new URL(r,window.location.href).toString(),i=await Promise.all([Xx(()=>import(`${s(t)}`),[]).then(r=>twgsl(t.replace(".js",".wasm"))),Xx(()=>import(`${s(e)}`),[]).then(r=>r.default())]);this.twgsl=i[0],this.glslang=i[1]}return this.createDevice()}async createDevice(){const e={powerPreference:this.initOptions.powerPreference!=="default"?this.initOptions.powerPreference:void 0,xrCompatible:this.initOptions.xrCompatible};this.gpuAdapter=await window.navigator.gpu.requestAdapter(e);const t=[],s=f=>{const m=this.gpuAdapter.features.has(f);return m&&t.push(f),m};this.textureFloatFilterable=s("float32-filterable"),this.textureFloatBlendable=s("float32-blendable"),this.extCompressedTextureS3TC=s("texture-compression-bc"),this.extCompressedTextureS3TCSliced3D=s("texture-compression-bc-sliced-3d"),this.extCompressedTextureETC=s("texture-compression-etc2"),this.extCompressedTextureASTC=s("texture-compression-astc"),this.extCompressedTextureASTCSliced3D=s("texture-compression-astc-sliced-3d"),this.supportsTimestampQuery=s("timestamp-query"),this.supportsDepthClip=s("depth-clip-control"),this.supportsDepth32Stencil=s("depth32float-stencil8"),this.supportsIndirectFirstInstance=s("indirect-first-instance"),this.supportsShaderF16=s("shader-f16"),this.supportsStorageRGBA8=s("bgra8unorm-storage"),this.textureRG11B10Renderable=s("rg11b10ufloat-renderable"),this.supportsClipDistances=s("clip-distances"),this.supportsTextureFormatTier1=s("texture-format-tier1"),this.supportsTextureFormatTier2=s("texture-format-tier2"),this.supportsPrimitiveIndex=s("primitive-index");const i=this.gpuAdapter?.limits,r={};if(i)for(const f in i)f==="minSubgroupSize"||f==="maxSubgroupSize"||(r[f]=i[f]);const a={requiredFeatures:t,requiredLimits:r,defaultQueue:{label:"Default Queue"}};this.wgpu=await this.gpuAdapter.requestDevice(a),this.wgpu.lost?.then(this.handleDeviceLost.bind(this)),this.initDeviceCaps(),this.gpuContext=this.canvas.getContext("webgpu");let o="standard",h=window.navigator.gpu.getPreferredCanvasFormat();const u=this.initOptions.displayFormat;return this.backBufferFormat=h==="rgba8unorm"?u===Dp?Us:Ze:u===Dp?tv:kg,this.backBufferViewFormat=u===Dp?`${h}-srgb`:h,u===rU&&this.textureFloatFilterable&&window.matchMedia("(dynamic-range: high)")?.matches&&(this.backBufferFormat=kt,this.backBufferViewFormat="rgba16float",h="rgba16float",this.isHdr=!0,o="extended"),this.canvasConfig={device:this.wgpu,colorSpace:"srgb",alphaMode:this.initOptions.alpha?"premultiplied":"opaque",format:h,toneMapping:{mode:o},usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,viewFormats:u===Dp?[this.backBufferViewFormat]:[]},this.gpuContext?.configure(this.canvasConfig),this.createBackbuffer(),this.clearRenderer=new Rz(this),this.mipmapRenderer=new Mz(this),this.resolver=new Bz(this),this.postInit(),this}async handleDeviceLost(e){e.reason!=="destroyed"&&(super.loseContext(),await this.createDevice(),super.restoreContext())}postInit(){super.postInit(),this.initializeRenderState(),this.setupPassEncoderDefaults(),this.gpuProfiler=new Fz(this),this.dynamicBuffers=new Oz(this,100*1024,this.limits.minUniformBufferOffsetAlignment),this.emptyBindGroup=new qh(this,new Vr(this,[])),this.emptyBindGroup.update()}createBackbuffer(){this.supportsStencil=this.initOptions.stencil,this.backBuffer=new At({name:"WebgpuFramebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples}),this.backBuffer.impl.isBackbuffer=!0}frameStart(){super.frameStart(),this.gpuProfiler.frameStart(),this.submit();const e=this.gpuContext?.getCurrentTexture?.()??this.externalBackbuffer?.impl.gpuTexture;(this.backBufferSize.x!==e.width||this.backBufferSize.y!==e.height)&&(this.backBufferSize.set(e.width,e.height),this.backBuffer.destroy(),this.backBuffer=null,this.createBackbuffer());const t=this.backBuffer,s=t.impl;s.setColorAttachment(0,void 0,this.backBufferViewFormat),this.initRenderTarget(t),s.assignColorTexture(this,e)}frameEnd(){super.frameEnd(),this.gpuProfiler.frameEnd(),this.submit(),this.contextLost||this.gpuProfiler.request(),this._indirectDrawNextIndex=0,this._indirectDispatchNextIndex=0}createBufferImpl(e){return new Av(e)}createUniformBufferImpl(e){return new _z(e)}createVertexBufferImpl(e,t,s){return new gz(e,t,s)}createIndexBufferImpl(e,t){return new LU(e,t)}createShaderImpl(e){return new fz(e)}createDrawCommandImpl(e){return new Vz(this)}createTextureImpl(e){return this.textures.add(e),new pz(e)}createRenderTargetImpl(e){return new YU(e)}createUploadStreamImpl(e){return new Gz(e)}createBindGroupFormatImpl(e){return new MU(e)}createBindGroupImpl(e){return new PU}createComputeImpl(e){return new zz(e)}get indirectDrawBuffer(){return this.allocateIndirectDrawBuffer(),this._indirectDrawBuffer}allocateIndirectDrawBuffer(){this._indirectDrawNextIndex===0&&this._indirectDrawBufferCount<this.maxIndirectDrawCount&&(this._indirectDrawBuffer?.destroy(),this._indirectDrawBuffer=null),this._indirectDrawBuffer===null&&(this._indirectDrawBuffer=new Fs(this,this.maxIndirectDrawCount*yD,zx|Ns),this._indirectDrawBufferCount=this.maxIndirectDrawCount)}getIndirectDrawSlot(e=1){this.allocateIndirectDrawBuffer();const t=this._indirectDrawNextIndex,s=this._indirectDrawNextIndex+e;return this._indirectDrawNextIndex=s,t}get indirectDispatchBuffer(){return this.allocateIndirectDispatchBuffer(),this._indirectDispatchBuffer}allocateIndirectDispatchBuffer(){this._indirectDispatchNextIndex===0&&this._indirectDispatchBufferCount<this.maxIndirectDispatchCount&&(this._indirectDispatchBuffer?.destroy(),this._indirectDispatchBuffer=null),this._indirectDispatchBuffer===null&&(this._indirectDispatchBuffer=new Fs(this,this.maxIndirectDispatchCount*Hz,zx|Ns),this._indirectDispatchBufferCount=this.maxIndirectDispatchCount)}getIndirectDispatchSlot(e=1){this.allocateIndirectDispatchBuffer();const t=this._indirectDispatchNextIndex,s=this._indirectDispatchNextIndex+e;return this._indirectDispatchNextIndex=s,t}setBindGroup(e,t,s){this.passEncoder&&(this.passEncoder.setBindGroup(e,t.impl.bindGroup,s??t.uniformBufferOffsets),this.bindGroupFormats[e]=t.format.impl)}submitVertexBuffer(e,t){const s=e.format,{interleaved:i,elements:r}=s,a=r.length,o=e.impl.buffer;if(i)return this.passEncoder.setVertexBuffer(t,o),1;for(let h=0;h<a;h++)this.passEncoder.setVertexBuffer(t+h,o,r[h].offset);return a}validateVBLocations(e,t){const s=i=>{const{elements:r}=i.format;for(let a=0;a<r.length;a++){const o=r[a].name,h=$e[o];S0.has(h),S0.set(h,o)}};s(e),s(t),S0.clear()}draw(e,t,s=1,i,r=!0,a=!0){if(this.shader.ready&&!this.shader.failed){const o=this.passEncoder;let h=this.pipeline;const u=this.vertexBuffers[0],f=this.vertexBuffers[1];if(r){if(u){const m=this.submitVertexBuffer(u,0);f&&this.submitVertexBuffer(f,m)}h=this.renderPipeline.get(e,u?.format,f?.format,t?.format,this.shader,this.renderTarget,this.bindGroupFormats,this.blendState,this.depthState,this.cullMode,this.stencilEnabled,this.stencilFront,this.stencilBack),this.pipeline!==h&&(this.pipeline=h,o.setPipeline(h))}if(t&&o.setIndexBuffer(t.impl.buffer,t.impl.format),i){const _=(i.impl?.storage??this.indirectDrawBuffer).impl.buffer,g=i.count;for(let S=0;S<g;S++){const x=(i.slotIndex+S)*yD;t?o.drawIndexedIndirect(_,x):o.drawIndirect(_,x)}}else t?o.drawIndexed(e.count,s,e.base,e.baseVertex??0,0):o.draw(e.count,s,e.base,0);this._drawCallsPerFrame++}a&&(this.clearVertexBuffer(),this.pipeline=null)}setShader(e,t=!1){e!==this.shader&&(this.shader=e)}setBlendState(e){this.blendState.copy(e)}setDepthState(e){this.depthState.copy(e)}setStencilState(e,t){if(e||t){this.stencilEnabled=!0,this.stencilFront.copy(e??Xi.DEFAULT),this.stencilBack.copy(t??Xi.DEFAULT);const s=this.stencilFront.ref;this.stencilRef!==s&&(this.stencilRef=s,this.passEncoder.setStencilReference(s))}else this.stencilEnabled=!1}setBlendColor(e,t,s,i){const r=this.blendColor;(e!==r.r||t!==r.g||s!==r.b||i!==r.a)&&(r.set(e,t,s,i),this.passEncoder.setBlendConstant(r))}setCullMode(e){this.cullMode=e}setAlphaToCoverage(e){}initializeContextCaches(){super.initializeContextCaches()}setupPassEncoderDefaults(){this.pipeline=null,this.stencilRef=0,this.blendColor.set(0,0,0,0)}_uploadDirtyTextures(){this.texturesToUpload.forEach(e=>{(e._needsUpload||e._needsMipmapsUpload)&&e.upload()}),this.texturesToUpload.clear()}setupTimeStampWrites(e,t){if(this.gpuProfiler._enabled&&this.gpuProfiler.timestampQueriesSet){const s=this.gpuProfiler.getSlot(t);s===-1||(e=e??{},e.timestampWrites={querySet:this.gpuProfiler.timestampQueriesSet.querySet,beginningOfPassWriteIndex:s*2,endOfPassWriteIndex:s*2+1})}return e}startRenderPass(e){this._uploadDirtyTextures();const t=e.renderTarget||this.backBuffer;this.renderTarget=t;const s=t.impl;t!==this.backBuffer&&this.initRenderTarget(t),s.setupForRenderPass(e,t);const i=s.renderPassDescriptor;this.setupTimeStampWrites(i,e.name);const r=this.getCommandEncoder();this.passEncoder=r.beginRenderPass(i),this.passEncoder.label=`${e.name}-PassEncoder RT:${t.name}`,this.setupPassEncoderDefaults();const{width:a,height:o}=t;this.setViewport(0,0,a,o),this.setScissor(0,0,a,o),this.insideRenderPass=!0}endRenderPass(e){this.passEncoder.end(),this.passEncoder=null,this.insideRenderPass=!1,this.bindGroupFormats.length=0;const t=this.renderTarget;if(t&&t.depthBuffer&&e.depthStencilOps.resolveDepth&&e.samples>1&&t.autoResolve){const s=t.impl.depthAttachment,i=t.depthBuffer.impl.gpuTexture;s&&i&&this.resolver.resolveDepth(this.commandEncoder,s.multisampledDepthBuffer,i)}for(let s=0;s<e.colorArrayOps.length;s++)e.colorArrayOps[s].genMipmaps&&this.mipmapRenderer.generate(e.renderTarget._colorBuffers[s].impl)}startComputePass(e){this._uploadDirtyTextures(),this.pipeline=null;const t=this.setupTimeStampWrites(void 0,e),s=this.getCommandEncoder();this.passEncoder=s.beginComputePass(t),this.insideRenderPass=!0}endComputePass(){this.passEncoder.end(),this.passEncoder=null,this.insideRenderPass=!1,this.bindGroupFormats.length=0}computeDispatch(e,t="Unnamed"){this.startComputePass(t);for(let s=0;s<e.length;s++){const i=e[s];i.applyParameters(),i.impl.updateBindGroup()}for(let s=0;s<e.length;s++){const i=e[s];i.impl.dispatch(i.countX,i.countY,i.countZ)}this.endComputePass()}getCommandEncoder(){let e=this.commandEncoder;return e||(e=this.wgpu.createCommandEncoder(),this.commandEncoder=e),e}endCommandEncoder(){const{commandEncoder:e}=this;if(e){const t=e.finish();this.addCommandBuffer(t),this.commandEncoder=null}}addCommandBuffer(e,t=!1){t?this.commandBuffers.unshift(e):this.commandBuffers.push(e)}submit(){this.endCommandEncoder(),this.commandBuffers.length>0&&(this.dynamicBuffers.submit(),this.wgpu.queue.submit(this.commandBuffers),this.commandBuffers.length=0,this.dynamicBuffers.onCommandBuffersSubmitted())}clear(e){e.flags&&this.clearRenderer.clear(this,this.renderTarget,e,this.defaultClearOptions)}setViewport(e,t,s,i){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-i),this.vx=e,this.vy=t,this.vw=s,this.vh=i,this.passEncoder.setViewport(e,t,s,i,0,1))}setScissor(e,t,s,i){this.passEncoder&&(this.renderTarget.flipY||(t=this.renderTarget.height-t-i),this.sx=e,this.sy=t,this.sw=s,this.sh=i,this.passEncoder.setScissorRect(e,t,s,i))}clearStorageBuffer(e,t=0,s=e.byteSize){this.getCommandEncoder().clearBuffer(e.buffer,t,s)}readStorageBuffer(e,t=0,s=e.byteSize-t,i=null,r=!1){const a=this.createBufferImpl(GM|Ns);a.allocate(this,s);const o=a.buffer;return this.getCommandEncoder().copyBufferToBuffer(e.buffer,t,o,0,s),this.readBuffer(a,s,i,r)}readBuffer(e,t,s=null,i=!1){const r=e.buffer;return new Promise((a,o)=>{const h=()=>{r?.mapAsync(GPUMapMode.READ).then(()=>{s??(s=new Uint8Array(t));const u=r.getMappedRange(0,t),f=s.constructor;s.set(new f(u)),r.unmap(),e.destroy(this),a(s)})};i?(this.submit(),h()):setTimeout(()=>{h()})})}writeStorageBuffer(e,t=0,s,i=0,r){this.wgpu.queue.writeBuffer(e.buffer,t,s,i,r)}copyRenderTarget(e,t,s,i){const r={width:e?e.width:t.width,height:e?e.height:t.height,depthOrArrayLayers:1},a=this.getCommandEncoder();if(s){const o={texture:e?e.colorBuffer.impl.gpuTexture:this.backBuffer.impl.assignedColorTexture,mipLevel:e?e.mipLevel:0},h={texture:t?t.colorBuffer.impl.gpuTexture:this.backBuffer.impl.assignedColorTexture,mipLevel:t?t.mipLevel:0};a.copyTextureToTexture(o,h,r)}if(i){const o=e||this.renderTarget,h=o.impl.depthAttachment.depthTexture,u=o.mipLevel;if(e.samples>1){const f=t.colorBuffer.impl.gpuTexture;this.resolver.resolveDepth(a,h,f)}else{const f=t?t.depthBuffer.impl.gpuTexture:this.renderTarget.impl.depthAttachment.depthTexture,m=t?t.mipLevel:this.renderTarget.mipLevel,_={texture:h,mipLevel:u},g={texture:f,mipLevel:m};a.copyTextureToTexture(_,g,r)}}return!0}get hasTranspilers(){return this.glslang&&this.twgsl}constructor(e,t={}){super(e,t),this.renderPipeline=new UU(this),this.computePipeline=new kU(this),this._indirectDrawBuffer=null,this._indirectDrawBufferCount=0,this._indirectDrawNextIndex=0,this._indirectDispatchBuffer=null,this._indirectDispatchBufferCount=0,this._indirectDispatchNextIndex=0,this.pipeline=null,this.bindGroupFormats=[],this.commandEncoder=null,this.commandBuffers=[],this.glslang=null,this.twgsl=null,t=this.initOptions,t.alpha=t.alpha??!0,this.backBufferAntialias=t.antialias??!1,this.isWebGPU=!0,this._deviceType=ng,this.scope.resolve(bE).setValue(0)}}class _2{destroy(e){this.bufferId&&(e.gl.deleteBuffer(this.bufferId),this.bufferId=null)}get initialized(){return!!this.bufferId}loseContext(){this.bufferId=null}unlock(e,t,s,i){const r=e.gl;if(this.bufferId)r.bindBuffer(s,this.bufferId),r.bufferSubData(s,0,i);else{let a;switch(t){case Hi:a=r.STATIC_DRAW;break;case H_:a=r.DYNAMIC_DRAW;break;case EB:a=r.STREAM_DRAW;break;case bB:a=r.DYNAMIC_COPY;break}this.bufferId=r.createBuffer(),r.bindBuffer(s,this.bufferId),r.bufferData(s,i,a)}}constructor(){this.bufferId=null}}class Xz extends _2{destroy(e){super.destroy(e),e.unbindVertexArray()}loseContext(){super.loseContext(),this.vao=null}unlock(e){const t=e.device;super.unlock(t,e.usage,t.gl.ARRAY_BUFFER,e.storage)}constructor(...e){super(...e),this.vao=null}}class qz extends _2{unlock(e){const t=e.device;super.unlock(t,e.usage,t.gl.ELEMENT_ARRAY_BUFFER,e.storage)}constructor(e){super();const t=e.device.gl,s=e.format;s===Vx?this.glFormat=t.UNSIGNED_BYTE:s===Ka?this.glFormat=t.UNSIGNED_SHORT:s===eo&&(this.glFormat=t.UNSIGNED_INT)}}class Yz{constructor(e,t,s,i){if(this.locationId=i,this.scopeId=e.scope.resolve(t),this.version=new a2,t.substring(t.length-3)==="[0]")switch(s){case Bs:s=fv;break;case Ga:s=Ph;break;case Qs:s=_v;break;case ph:s=gv;break;case xl:s=mv;break;case hl:s=Rh;break;case wh:s=vv;break;case Kd:s=Sv;break;case Gi:s=pv;break;case Ha:s=Mh;break;case Ch:s=yv;break;case Zd:s=xv;break;case so:s=xE;break;case ul:s=ag;break;case Dh:s=TE;break;case Qd:s=EE;break}this.dataType=s,this.value=[null,null,null,null],this.array=[]}}const xD=new Set(["gl_VertexID","gl_InstanceID","gl_DrawID","gl_BaseVertex","gl_BaseInstance"]);class jz{destroy(e){this.map.forEach(t=>{e.gl.deleteShader(t)})}loseContext(e){this.map.clear()}constructor(){this.map=new Map}}const $z=new ks,Kz=new ks;class Zz{destroy(e){this.glProgram&&(e.device.gl.deleteProgram(this.glProgram),this.glProgram=null)}init(){this.uniforms=[],this.samplers=[],this.attributes=[],this.glProgram=null,this.glVertexShader=null,this.glFragmentShader=null}loseContext(){this.init()}restoreContext(e,t){this.compile(e,t),this.link(e,t)}compile(e,t){const s=t.definition;this.glVertexShader=this._compileShaderSource(e,s.vshader,!0),this.glFragmentShader=this._compileShaderSource(e,s.fshader,!1)}link(e,t){if(this.glProgram)return;const s=e.gl;if(s.isContextLost())return;const i=s.createProgram();this.glProgram=i,s.attachShader(i,this.glVertexShader),s.attachShader(i,this.glFragmentShader);const r=t.definition,a=r.attributes;if(r.useTransformFeedback){let o=r.feedbackVaryings;if(!o){o=[];for(const h in a)a.hasOwnProperty(h)&&o.push(`out_${h}`)}s.transformFeedbackVaryings(i,o,s.INTERLEAVED_ATTRIBS)}for(const o in a)if(a.hasOwnProperty(o)){const h=a[o],u=$e[h];s.bindAttribLocation(i,u,o)}s.linkProgram(i)}_compileShaderSource(e,t,s){const i=e.gl;if(i.isContextLost())return null;const a=(s?$z:Kz).get(e,()=>new jz);let o=a.map.get(t);return o||(o=i.createShader(s?i.VERTEX_SHADER:i.FRAGMENT_SHADER),i.shaderSource(o,t),i.compileShader(o),a.map.set(t,o)),o}finalize(e,t){const s=e.gl;if(s.isContextLost())return!0;const i=this.glProgram,r=t.definition;if(!s.getProgramParameter(i,s.LINK_STATUS)){if(!this._isCompiled(e,t,this.glVertexShader,r.vshader,"vertex")||!this._isCompiled(e,t,this.glFragmentShader,r.fshader,"fragment"))return!1;const f=`Failed to link shader program. Error: ${s.getProgramInfoLog(i)}`;return console.error(f),!1}const o=s.getProgramParameter(i,s.ACTIVE_ATTRIBUTES);t.attributes.clear();for(let f=0;f<o;f++){const m=s.getActiveAttrib(i,f),_=s.getAttribLocation(i,m.name);xD.has(m.name)||(r.attributes[m.name]===void 0?(console.error(`Vertex shader attribute "${m.name}" is not mapped to a semantic in shader definition, shader [${t.label}]`,t),t.failed=!0):t.attributes.set(_,m.name))}const h=e._samplerTypes,u=s.getProgramParameter(i,s.ACTIVE_UNIFORMS);for(let f=0;f<u;f++){const m=s.getActiveUniform(i,f),_=s.getUniformLocation(i,m.name);if(xD.has(m.name))continue;const g=new Yz(e,m.name,e.pcUniformType[m.type],_);h.has(m.type)?this.samplers.push(g):this.uniforms.push(g)}return t.ready=!0,!0}_isCompiled(e,t,s,i,r){const a=e.gl;if(!a.getShaderParameter(s,a.COMPILE_STATUS)){const o=a.getShaderInfoLog(s),[h,u]=this._processError(i,o),f=`Failed to compile ${r} shader:

${o}
${h} while rendering undefined`;return console.error(f),!1}return!0}isLinked(e){const{extParallelShaderCompile:t}=e;return t?e.gl.getProgramParameter(this.glProgram,t.COMPLETION_STATUS_KHR):!0}_processError(e,t){const s={};let i="";if(e){const r=e.split(`
`);let a=0,o=r.length;if(t&&t.startsWith("ERROR:")){const h=t.match(/^ERROR:\s(\d+):(\d+):\s*(.+)/);h&&(s.message=h[3],s.line=parseInt(h[2],10),a=Math.max(0,s.line-6),o=Math.min(r.length,s.line+5))}for(let h=a;h<o;h++){const u=h+1===s.line?"> ":"  ";i+=`${u}${h+1}:	${r[h]}
`}s.source=e}return[i,s]}constructor(e){this.compileDuration=0,this.init(),this.compile(e.device,e),this.link(e.device,e),e.device.shaders.push(e)}}class Qz{allocate(e){this.glCounts&&this.glCounts.length===e||(this.glCounts=new Int32Array(e),this.glOffsetsBytes=new Int32Array(e),this.glInstanceCounts=new Int32Array(e))}add(e,t,s,i){this.glCounts[e]=t,this.glOffsetsBytes[e]=i*this.indexSizeBytes,this.glInstanceCounts[e]=s}update(e){return 0}constructor(e){this.glCounts=null,this.glOffsetsBytes=null,this.glInstanceCounts=null,this.indexSizeBytes=e}}function TD(c,e){const t=c.width,s=c.height;if(t>e||s>e){const i=e/Math.max(t,s),r=Math.floor(t*i),a=Math.floor(s*i),o=document.createElement("canvas");return o.width=r,o.height=a,o.getContext("2d").drawImage(c,0,0,t,s,0,0,r,a),o}return c}class Jz{destroy(e){if(this._glTexture){for(let t=0;t<e.textureUnits.length;t++){const s=e.textureUnits[t];for(let i=0;i<s.length;i++)s[i]===this._glTexture&&(s[i]=null)}e.gl.deleteTexture(this._glTexture),this._glTexture=null}}loseContext(){this._glTexture=null}propertyChanged(e){this.dirtyParameterFlags|=e}initialize(e,t){const s=e.gl;switch(this._glTexture=s.createTexture(),this._glTarget=t._cubemap?s.TEXTURE_CUBE_MAP:t._volume?s.TEXTURE_3D:t.array?s.TEXTURE_2D_ARRAY:s.TEXTURE_2D,t._format){case tE:this._glFormat=s.ALPHA,this._glInternalFormat=s.ALPHA,this._glPixelType=s.UNSIGNED_BYTE;break;case sE:this._glFormat=s.LUMINANCE,this._glInternalFormat=s.LUMINANCE,this._glPixelType=s.UNSIGNED_BYTE;break;case Ig:this._glFormat=s.LUMINANCE_ALPHA,this._glInternalFormat=s.LUMINANCE_ALPHA,this._glPixelType=s.UNSIGNED_BYTE;break;case lE:this._glFormat=s.RED,this._glInternalFormat=s.R8,this._glPixelType=s.UNSIGNED_BYTE;break;case ev:this._glFormat=s.RG,this._glInternalFormat=s.RG8,this._glPixelType=s.UNSIGNED_BYTE;break;case wf:this._glFormat=s.RGB,this._glInternalFormat=s.RGB565,this._glPixelType=s.UNSIGNED_SHORT_5_6_5;break;case Og:this._glFormat=s.RGBA,this._glInternalFormat=s.RGB5_A1,this._glPixelType=s.UNSIGNED_SHORT_5_5_5_1;break;case Cf:this._glFormat=s.RGBA,this._glInternalFormat=s.RGBA4,this._glPixelType=s.UNSIGNED_SHORT_4_4_4_4;break;case Ja:this._glFormat=s.RGB,this._glInternalFormat=s.RGB8,this._glPixelType=s.UNSIGNED_BYTE;break;case Ze:this._glFormat=s.RGBA,this._glInternalFormat=s.RGBA8,this._glPixelType=s.UNSIGNED_BYTE;break;case kg:case tv:break;case sv:break;case iv:this._glFormat=s.RGB,this._glInternalFormat=s.RGB9_E5,this._glPixelType=s.UNSIGNED_INT_5_9_9_9_REV;break;case rv:this._glFormat=s.RG,this._glInternalFormat=s.RG8_SNORM,this._glPixelType=s.BYTE;break;case av:this._glFormat=s.RGBA,this._glInternalFormat=s.RGBA8_SNORM,this._glPixelType=s.BYTE;break;case nv:this._glFormat=s.RGBA,this._glInternalFormat=s.RGB10_A2,this._glPixelType=s.UNSIGNED_INT_2_10_10_10_REV;break;case ov:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGB10_A2UI,this._glPixelType=s.UNSIGNED_INT_2_10_10_10_REV;break;case Df:this._glFormat=s.RGB,this._glInternalFormat=e.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;break;case Ng:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case kh:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;break;case Rf:this._glFormat=s.RGB,this._glInternalFormat=e.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;break;case Vh:this._glFormat=s.RGB,this._glInternalFormat=e.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;break;case Gh:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;break;case Mf:this._glFormat=s.RGB,this._glInternalFormat=e.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;break;case Lf:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;break;case Ug:this._glFormat=s.RGB,this._glInternalFormat=e.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;break;case zg:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;break;case iE:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;break;case rE:this._glFormat=s.RGB,this._glInternalFormat=e.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;break;case aE:this._glFormat=s.RGBA,this._glInternalFormat=e.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;break;case cE:this._glFormat=s.RGB,this._glInternalFormat=e.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;break;case hE:this._glFormat=s.RGB,this._glInternalFormat=e.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;break;case uE:this._glFormat=s.RGBA,this._glInternalFormat=e.extTextureCompressionBPTC.COMPRESSED_RGBA_BPTC_UNORM_EXT;break;case Y_:this._glFormat=s.SRGB,this._glInternalFormat=e.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_S3TC_DXT1_EXT;break;case j_:this._glFormat=s.SRGB_ALPHA,this._glInternalFormat=e.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;break;case $_:this._glFormat=s.SRGB_ALPHA,this._glInternalFormat=e.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;break;case K_:this._glFormat=s.SRGB,this._glInternalFormat=e.extCompressedTextureETC.COMPRESSED_SRGB8_ETC2;break;case Z_:this._glFormat=s.SRGB_ALPHA,this._glInternalFormat=e.extCompressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;break;case Q_:this._glFormat=s.SRGB_ALPHA,this._glInternalFormat=e.extCompressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;break;case J_:this._glFormat=s.RGBA,this._glInternalFormat=e.extTextureCompressionBPTC.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;break;case If:this._glFormat=s.RED,this._glInternalFormat=s.R16F,this._glPixelType=s.HALF_FLOAT;break;case Jg:this._glFormat=s.RG,this._glInternalFormat=s.RG16F,this._glPixelType=s.HALF_FLOAT;break;case Pf:this._glFormat=s.RGB,this._glInternalFormat=s.RGB16F,this._glPixelType=s.HALF_FLOAT;break;case kt:this._glFormat=s.RGBA,this._glInternalFormat=s.RGBA16F,this._glPixelType=s.HALF_FLOAT;break;case Fg:this._glFormat=s.RGB,this._glInternalFormat=s.RGB32F,this._glPixelType=s.FLOAT;break;case fs:this._glFormat=s.RGBA,this._glInternalFormat=s.RGBA32F,this._glPixelType=s.FLOAT;break;case Wr:this._glFormat=s.RED,this._glInternalFormat=s.R32F,this._glPixelType=s.FLOAT;break;case Br:this._glFormat=s.DEPTH_COMPONENT,this._glInternalFormat=s.DEPTH_COMPONENT32F,this._glPixelType=s.FLOAT;break;case ll:this._glFormat=s.DEPTH_COMPONENT,this._glInternalFormat=s.DEPTH_COMPONENT16,this._glPixelType=s.UNSIGNED_SHORT;break;case gl:this._glFormat=s.DEPTH_STENCIL,this._glInternalFormat=s.DEPTH24_STENCIL8,this._glPixelType=s.UNSIGNED_INT_24_8;break;case vl:this._glFormat=s.RGB,this._glInternalFormat=s.R11F_G11F_B10F,this._glPixelType=s.UNSIGNED_INT_10F_11F_11F_REV;break;case Bg:this._glFormat=s.RGB,this._glInternalFormat=s.SRGB8,this._glPixelType=s.UNSIGNED_BYTE;break;case Us:this._glFormat=s.RGBA,this._glInternalFormat=s.SRGB8_ALPHA8,this._glPixelType=s.UNSIGNED_BYTE;break;case Vg:this._glFormat=s.RED_INTEGER,this._glInternalFormat=s.R8I,this._glPixelType=s.BYTE;break;case Gg:this._glFormat=s.RED_INTEGER,this._glInternalFormat=s.R8UI,this._glPixelType=s.UNSIGNED_BYTE;break;case Hg:this._glFormat=s.RED_INTEGER,this._glInternalFormat=s.R16I,this._glPixelType=s.SHORT;break;case Wg:this._glFormat=s.RED_INTEGER,this._glInternalFormat=s.R16UI,this._glPixelType=s.UNSIGNED_SHORT;break;case Xg:this._glFormat=s.RED_INTEGER,this._glInternalFormat=s.R32I,this._glPixelType=s.INT;break;case oo:this._glFormat=s.RED_INTEGER,this._glInternalFormat=s.R32UI,this._glPixelType=s.UNSIGNED_INT;break;case qg:this._glFormat=s.RG_INTEGER,this._glInternalFormat=s.RG8I,this._glPixelType=s.BYTE;break;case nE:this._glFormat=s.RG_INTEGER,this._glInternalFormat=s.RG8UI,this._glPixelType=s.UNSIGNED_BYTE;break;case Yg:this._glFormat=s.RG_INTEGER,this._glInternalFormat=s.RG16I,this._glPixelType=s.SHORT;break;case jg:this._glFormat=s.RG_INTEGER,this._glInternalFormat=s.RG16UI,this._glPixelType=s.UNSIGNED_SHORT;break;case $g:this._glFormat=s.RG_INTEGER,this._glInternalFormat=s.RG32I,this._glPixelType=s.INT;break;case Hh:this._glFormat=s.RG_INTEGER,this._glInternalFormat=s.RG32UI,this._glPixelType=s.UNSIGNED_INT;break;case Kg:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGBA8I,this._glPixelType=s.BYTE;break;case oE:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGBA8UI,this._glPixelType=s.UNSIGNED_BYTE;break;case Zg:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGBA16I,this._glPixelType=s.SHORT;break;case lo:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGBA16UI,this._glPixelType=s.UNSIGNED_SHORT;break;case Qg:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGBA32I,this._glPixelType=s.INT;break;case Ps:this._glFormat=s.RGBA_INTEGER,this._glInternalFormat=s.RGBA32UI,this._glPixelType=s.UNSIGNED_INT;break}this._glCreated=!1}upload(e,t){const s=e.gl;if(!t._needsUpload&&(t._needsMipmapsUpload&&t._mipmapsUploaded||!t.pot))return;let i=0,r,a;const o=t.numLevels;for(t.array&&!this._glCreated&&s.texStorage3D(s.TEXTURE_2D_ARRAY,o,this._glInternalFormat,t._width,t._height,t._arrayLength);t._levels[i]||i===0;){if(!t._needsUpload&&i===0){i++;continue}else if(i&&(!t._needsMipmapsUpload||!t._mipmaps))break;if(r=t._levels[i],a=1/Math.pow(2,i),i===1&&!t._compressed&&!t._integerFormat&&t._levels.length<o&&(s.generateMipmap(this._glTarget),t._mipmapsUploaded=!0),t._cubemap){let h;if(e._isBrowserInterface(r[0]))for(h=0;h<6;h++){if(!t._levelsUpdated[0][h])continue;let u=r[h];e._isImageBrowserInterface(u)&&(u.width>e.maxCubeMapSize||u.height>e.maxCubeMapSize)&&(u=TD(u,e.maxCubeMapSize),i===0&&(t._width=u.width,t._height=u.height)),e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),this._glCreated?s.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,i,0,0,this._glFormat,this._glPixelType,u):s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,i,this._glInternalFormat,this._glFormat,this._glPixelType,u)}else for(a=1/Math.pow(2,i),h=0;h<6;h++){if(!t._levelsUpdated[0][h])continue;const u=r[h];t._compressed?this._glCreated&&u?s.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,i,0,0,Math.max(t._width*a,1),Math.max(t._height*a,1),this._glInternalFormat,u):s.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,i,this._glInternalFormat,Math.max(t._width*a,1),Math.max(t._height*a,1),0,u):(e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),this._glCreated&&u?s.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,i,0,0,Math.max(t._width*a,1),Math.max(t._height*a,1),this._glFormat,this._glPixelType,u):s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X+h,i,this._glInternalFormat,Math.max(t._width*a,1),Math.max(t._height*a,1),0,this._glFormat,this._glPixelType,u))}}else if(t._volume)t._compressed?s.compressedTexImage3D(s.TEXTURE_3D,i,this._glInternalFormat,Math.max(t._width*a,1),Math.max(t._height*a,1),Math.max(t._depth*a,1),0,r):(e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),s.texImage3D(s.TEXTURE_3D,i,this._glInternalFormat,Math.max(t._width*a,1),Math.max(t._height*a,1),Math.max(t._depth*a,1),0,this._glFormat,this._glPixelType,r));else if(t.array){if(Array.isArray(r)&&t._arrayLength===r.length)if(t._compressed)for(let h=0;h<t._arrayLength;h++)s.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY,i,0,0,h,Math.max(Math.floor(t._width*a),1),Math.max(Math.floor(t._height*a),1),1,this._glInternalFormat,r[h]);else for(let h=0;h<t._arrayLength;h++)s.texSubImage3D(s.TEXTURE_2D_ARRAY,i,0,0,h,Math.max(Math.floor(t._width*a),1),Math.max(Math.floor(t._height*a),1),1,this._glFormat,this._glPixelType,r[h])}else{if(e._isBrowserInterface(r)){e._isImageBrowserInterface(r)&&(r.width>e.maxTextureSize||r.height>e.maxTextureSize)&&(r=TD(r,e.maxTextureSize),i===0&&(t._width=r.width,t._height=r.height));const h=r.width||r.videoWidth,u=r.height||r.videoHeight;e.setUnpackFlipY(t._flipY),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),this._glCreated&&t._width===h&&t._height===u&&!e._isImageVideoInterface(r)?s.texSubImage2D(s.TEXTURE_2D,i,0,0,this._glFormat,this._glPixelType,r):(s.texImage2D(s.TEXTURE_2D,i,this._glInternalFormat,this._glFormat,this._glPixelType,r),i===0&&(t._width=h,t._height=u))}else a=1/Math.pow(2,i),t._compressed?this._glCreated&&r?s.compressedTexSubImage2D(s.TEXTURE_2D,i,0,0,Math.max(Math.floor(t._width*a),1),Math.max(Math.floor(t._height*a),1),this._glInternalFormat,r):s.compressedTexImage2D(s.TEXTURE_2D,i,this._glInternalFormat,Math.max(Math.floor(t._width*a),1),Math.max(Math.floor(t._height*a),1),0,r):(e.setUnpackFlipY(!1),e.setUnpackPremultiplyAlpha(t._premultiplyAlpha),this._glCreated&&r?s.texSubImage2D(s.TEXTURE_2D,i,0,0,Math.max(t._width*a,1),Math.max(t._height*a,1),this._glFormat,this._glPixelType,r):s.texImage2D(s.TEXTURE_2D,i,this._glInternalFormat,Math.max(t._width*a,1),Math.max(t._height*a,1),0,this._glFormat,this._glPixelType,r));i===0?t._mipmapsUploaded=!1:t._mipmapsUploaded=!0}i++}if(t._needsUpload)if(t._cubemap)for(let h=0;h<6;h++)t._levelsUpdated[0][h]=!1;else t._levelsUpdated[0]=!1;!t._compressed&&!t._integerFormat&&t._mipmaps&&t._needsMipmapsUpload&&t._levels.length===1&&(s.generateMipmap(this._glTarget),t._mipmapsUploaded=!0),t._gpuSize&&t.adjustVramSizeTracking(e._vram,-t._gpuSize),t._gpuSize=t.gpuSize,t.adjustVramSizeTracking(e._vram,t._gpuSize),this._glCreated=!0}uploadImmediate(e,t){(t._needsUpload||t._needsMipmapsUpload)&&(e.setTexture(t,0),t._needsUpload=!1,t._needsMipmapsUpload=!1)}read(e,t,s,i,r){const a=this.texture;return a.device.readTextureAsync(a,e,t,s,i,r)}write(e,t,s,i,r){const{texture:a}=this,{device:o}=a;return o.setTexture(a,0),o.writeTextureAsync(a,e,t,s,i,r)}constructor(e){this._glTexture=null,this.dirtyParameterFlags=0,this.texture=e}}class ek{destroy(e){this.msaaFB&&(e.deleteRenderbuffer(this.msaaFB),this.msaaFB=null),this.resolveFB&&(e.deleteRenderbuffer(this.resolveFB),this.resolveFB=null)}constructor(e,t){this.msaaFB=e,this.resolveFB=t}}class tk{destroy(e){const t=e.gl;this._isInitialized=!1,this._glFrameBuffer&&(this._glFrameBuffer!==this.suppliedColorFramebuffer&&t.deleteFramebuffer(this._glFrameBuffer),this._glFrameBuffer=null),this._glDepthBuffer&&(t.deleteRenderbuffer(this._glDepthBuffer),this._glDepthBuffer=null),this._glResolveFrameBuffer&&(this._glResolveFrameBuffer!==this.suppliedColorFramebuffer&&t.deleteFramebuffer(this._glResolveFrameBuffer),this._glResolveFrameBuffer=null),this._glMsaaColorBuffers.forEach(s=>{t.deleteRenderbuffer(s)}),this._glMsaaColorBuffers.length=0,this.colorMrtFramebuffers?.forEach(s=>{s.destroy(t)}),this.colorMrtFramebuffers=null,this._glMsaaDepthBuffer&&(this._glMsaaDepthBuffer=null,this.msaaDepthBufferKey&&Ud(e).release(this.msaaDepthBufferKey)),this.suppliedColorFramebuffer=void 0}get initialized(){return this._isInitialized}init(e,t){const s=e.gl;this._isInitialized=!0;const i=[];if(this.suppliedColorFramebuffer!==void 0)this._glFrameBuffer=this.suppliedColorFramebuffer;else{this._glFrameBuffer=s.createFramebuffer(),e.setFramebuffer(this._glFrameBuffer);const r=t._colorBuffers?.length??0,a=s.COLOR_ATTACHMENT0;for(let h=0;h<r;++h){const u=t.getColorBuffer(h);u&&(u.impl._glTexture||(u._width=Math.min(u.width,e.maxRenderBufferSize),u._height=Math.min(u.height,e.maxRenderBufferSize),e.setTexture(u,0)),s.framebufferTexture2D(s.FRAMEBUFFER,a+h,u._cubemap?s.TEXTURE_CUBE_MAP_POSITIVE_X+t._face:s.TEXTURE_2D,u.impl._glTexture,t.mipLevel),i.push(a+h))}s.drawBuffers(i);const o=t._depthBuffer;if(o||t._depth){const h=t._stencil?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT;if(o)o.impl._glTexture||(o._width=Math.min(o.width,e.maxRenderBufferSize),o._height=Math.min(o.height,e.maxRenderBufferSize),e.setTexture(o,0)),s.framebufferTexture2D(s.FRAMEBUFFER,h,o._cubemap?s.TEXTURE_CUBE_MAP_POSITIVE_X+t._face:s.TEXTURE_2D,t._depthBuffer.impl._glTexture,t.mipLevel);else if(!(t._samples>1)){this._glDepthBuffer||(this._glDepthBuffer=s.createRenderbuffer());const f=t._stencil?s.DEPTH24_STENCIL8:s.DEPTH_COMPONENT32F;s.bindRenderbuffer(s.RENDERBUFFER,this._glDepthBuffer),s.renderbufferStorage(s.RENDERBUFFER,f,t.width,t.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,h,s.RENDERBUFFER,this._glDepthBuffer),s.bindRenderbuffer(s.RENDERBUFFER,null)}}}if(t._samples>1){this._glResolveFrameBuffer=this._glFrameBuffer,this._glFrameBuffer=s.createFramebuffer(),e.setFramebuffer(this._glFrameBuffer);const r=t._colorBuffers?.length??0;if(this.suppliedColorFramebuffer!==void 0){const a=s.createRenderbuffer();this._glMsaaColorBuffers.push(a);const o=e.backBufferFormat===Ze?s.RGBA8:s.RGB8;s.bindRenderbuffer(s.RENDERBUFFER,a),s.renderbufferStorageMultisample(s.RENDERBUFFER,t._samples,o,t.width,t.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.RENDERBUFFER,a)}else for(let a=0;a<r;++a){const o=t.getColorBuffer(a);if(o){const h=s.createRenderbuffer();this._glMsaaColorBuffers.push(h),s.bindRenderbuffer(s.RENDERBUFFER,h),s.renderbufferStorageMultisample(s.RENDERBUFFER,t._samples,o.impl._glInternalFormat,t.width,t.height),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0+a,s.RENDERBUFFER,h)}}if(t._depth){const a=t._stencil?s.DEPTH24_STENCIL8:s.DEPTH_COMPONENT32F,o=t._stencil?s.DEPTH_STENCIL_ATTACHMENT:s.DEPTH_ATTACHMENT;let h;const u=t._depthBuffer;u&&(h=`${u.id}:${t.width}:${t.height}:${t._samples}:${a}:${o}`,this._glMsaaDepthBuffer=Ud(e).get(h)),this._glMsaaDepthBuffer||(this._glMsaaDepthBuffer=s.createRenderbuffer(),s.bindRenderbuffer(s.RENDERBUFFER,this._glMsaaDepthBuffer),s.renderbufferStorageMultisample(s.RENDERBUFFER,t._samples,a,t.width,t.height),this._glMsaaDepthBuffer.destroy=function(){s.deleteRenderbuffer(this)},u&&Ud(e).set(h,this._glMsaaDepthBuffer)),this.msaaDepthBufferKey=h,s.framebufferRenderbuffer(s.FRAMEBUFFER,o,s.RENDERBUFFER,this._glMsaaDepthBuffer)}r>1&&(this._createMsaaMrtFramebuffers(e,t,r),e.setFramebuffer(this._glFrameBuffer),s.drawBuffers(i))}}_createMsaaMrtFramebuffers(e,t,s){const i=e.gl;this.colorMrtFramebuffers=[];for(let r=0;r<s;++r){const a=t.getColorBuffer(r),o=i.createFramebuffer();e.setFramebuffer(o);const h=this._glMsaaColorBuffers[r];i.bindRenderbuffer(i.RENDERBUFFER,h),i.renderbufferStorageMultisample(i.RENDERBUFFER,t._samples,a.impl._glInternalFormat,t.width,t.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,h),i.drawBuffers([i.COLOR_ATTACHMENT0]);const u=i.createFramebuffer();e.setFramebuffer(u),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,a._cubemap?i.TEXTURE_CUBE_MAP_POSITIVE_X+t._face:i.TEXTURE_2D,a.impl._glTexture,0),this.colorMrtFramebuffers[r]=new ek(o,u)}}_checkFbo(e,t,s=""){const i=e.gl;switch(i.checkFramebufferStatus(i.FRAMEBUFFER)){case i.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:break;case i.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:break;case i.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:break;case i.FRAMEBUFFER_UNSUPPORTED:break}}loseContext(){this._glFrameBuffer=null,this._glDepthBuffer=null,this._glResolveFrameBuffer=null,this._glMsaaColorBuffers.length=0,this._glMsaaDepthBuffer=null,this.msaaDepthBufferKey=void 0,this.colorMrtFramebuffers=null,this.suppliedColorFramebuffer=void 0,this._isInitialized=!1}internalResolve(e,t,s,i,r){e.setScissor(0,0,i.width,i.height);const a=e.gl;a.bindFramebuffer(a.READ_FRAMEBUFFER,t),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,s),a.blitFramebuffer(0,0,i.width,i.height,0,0,i.width,i.height,r,a.NEAREST)}resolve(e,t,s,i){const r=e.gl;if(this.colorMrtFramebuffers){if(s)for(let a=0;a<this.colorMrtFramebuffers.length;a++){const o=this.colorMrtFramebuffers[a];this.internalResolve(e,o.msaaFB,o.resolveFB,t,r.COLOR_BUFFER_BIT)}i&&this.internalResolve(e,this._glFrameBuffer,this._glResolveFrameBuffer,t,r.DEPTH_BUFFER_BIT)}else this.internalResolve(e,this._glFrameBuffer,this._glResolveFrameBuffer,t,(s?r.COLOR_BUFFER_BIT:0)|(i?r.DEPTH_BUFFER_BIT:0));r.bindFramebuffer(r.FRAMEBUFFER,this._glFrameBuffer)}constructor(){this._glFrameBuffer=null,this._glDepthBuffer=null,this._glResolveFrameBuffer=null,this.colorMrtFramebuffers=null,this._glMsaaColorBuffers=[],this._glMsaaDepthBuffer=null,this._isInitialized=!1}}class sk{destroy(){const e=this.uploadStream.device.gl;this.availablePBOs.forEach(t=>e.deleteBuffer(t.pbo)),this.pendingPBOs.forEach(t=>{t.sync&&e.deleteSync(t.sync),e.deleteBuffer(t.pbo)})}_onDeviceLost(){this.availablePBOs.length=0,this.pendingPBOs.length=0}update(e){const t=this.uploadStream.device.gl,s=this.pendingPBOs;for(let r=s.length-1;r>=0;r--){const a=s[r],o=t.clientWaitSync(a.sync,0,0);(o===t.CONDITION_SATISFIED||o===t.ALREADY_SIGNALED)&&(t.deleteSync(a.sync),this.availablePBOs.push({pbo:a.pbo,size:a.size}),s.splice(r,1))}const i=this.availablePBOs;for(let r=i.length-1;r>=0;r--)i[r].size<e&&(t.deleteBuffer(i[r].pbo),i.splice(r,1))}upload(e,t,s,i){this.useSingleBuffer?this.uploadDirect(e,t,s,i):this.uploadPBO(e,t,s,i)}uploadDirect(e,t,s,i){t._levels[0]=e,t.upload()}uploadPBO(e,t,s,i){const r=this.uploadStream.device,a=r.gl,o=t.width,h=i*e.BYTES_PER_ELEMENT;this.update(h);const u=s/o,f=i/o,m=this.availablePBOs.pop()??{pbo:a.createBuffer(),size:h};a.bindBuffer(a.PIXEL_UNPACK_BUFFER,m.pbo),a.bufferData(a.PIXEL_UNPACK_BUFFER,h,a.STREAM_DRAW),a.bufferSubData(a.PIXEL_UNPACK_BUFFER,0,new Uint8Array(e.buffer,e.byteOffset,h)),a.bindBuffer(a.PIXEL_UNPACK_BUFFER,null),r.setTexture(t,0),r.activeTexture(0),r.bindTexture(t),a.bindBuffer(a.PIXEL_UNPACK_BUFFER,m.pbo),r.setUnpackFlipY(!1),r.setUnpackPremultiplyAlpha(!1),a.pixelStorei(a.UNPACK_ALIGNMENT,e.BYTES_PER_ELEMENT),a.pixelStorei(a.UNPACK_ROW_LENGTH,0),a.pixelStorei(a.UNPACK_SKIP_ROWS,0),a.pixelStorei(a.UNPACK_SKIP_PIXELS,0);const _=t.impl;a.texSubImage2D(a.TEXTURE_2D,0,0,u,o,f,_._glFormat,_._glPixelType,0),a.bindBuffer(a.PIXEL_UNPACK_BUFFER,null);const g=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);this.pendingPBOs.push({pbo:m.pbo,size:h,sync:g}),a.flush()}constructor(e){this.availablePBOs=[],this.pendingPBOs=[],this.uploadStream=e,this.useSingleBuffer=e.useSingleBuffer}}class ik{destroy(e){this.queries.forEach(t=>e.deleteQuery(t)),this.queries=null}constructor(){this.queries=[]}}class rk extends p2{destroy(){this.freeQueries.forEach(e=>this.device.gl.deleteQuery(e)),this.frameQueries.forEach(e=>this.device.gl.deleteQuery(e)),this.previousFrameQueries.forEach(e=>e.destroy(this.device.gl)),this.freeQueries=null,this.frameQueries=null,this.previousFrameQueries=null}loseContext(){super.loseContext(),this.freeQueries=[],this.frameQueries=[],this.previousFrameQueries=[]}restoreContext(){this.ext=this.device.extDisjointTimerQuery}getQuery(){return this.freeQueries.pop()??this.device.gl.createQuery()}start(e){if(this.ext){const t=this.getSlot(e),s=this.getQuery();return this.frameQueries[t]=s,this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,s),t}}end(e){e!==void 0&&this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT)}frameStart(){this.processEnableRequest(),this._enabled&&(this.frameGPUMarkerSlot=this.start("GpuFrame"))}frameEnd(){this._enabled&&this.end(this.frameGPUMarkerSlot)}request(){if(this._enabled){const e=this.ext,t=this.device.gl,s=this.device.renderVersion,i=this.frameQueries;if(i.length>0){this.frameQueries=[];const r=new ik;r.queries=i,r.renderVersion=s,this.previousFrameQueries.push(r)}if(this.previousFrameQueries.length>0){const r=this.previousFrameQueries[0],a=r.queries,o=a[a.length-1],h=t.getQueryParameter(o,t.QUERY_RESULT_AVAILABLE),u=t.getParameter(e.GPU_DISJOINT_EXT);if(h&&!u){this.previousFrameQueries.shift();const f=this.timings;f.length=0;for(let m=0;m<a.length;m++){const _=a[m],g=t.getQueryParameter(_,t.QUERY_RESULT);f[m]=g*1e-6,this.freeQueries.push(_)}this.report(r.renderVersion,f)}u&&(this.previousFrameQueries.forEach(f=>{this.report(f.renderVersion,null),f.destroy(t)}),this.previousFrameQueries.length=0)}super.request(s)}}constructor(e){super(),this.freeQueries=[],this.frameQueries=[],this.previousFrameQueries=[],this.timings=[],this.device=e,this.ext=e.extDisjointTimerQuery}}const Dc=[];class g2 extends Yh{postInit(){super.postInit(),this.gpuProfiler=new rk(this)}destroy(){super.destroy();const e=this.gl;this.feedback&&e.deleteTransformFeedback(this.feedback),this.clearVertexArrayObjectCache(),this.canvas.removeEventListener("webglcontextlost",this._contextLostHandler,!1),this.canvas.removeEventListener("webglcontextrestored",this._contextRestoredHandler,!1),this._contextLostHandler=null,this._contextRestoredHandler=null,this.gl=null,super.postDestroy()}createBackbuffer(e){this.supportsStencil=this.initOptions.stencil,this.backBuffer=new At({name:"WebglFramebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples}),this.backBuffer.impl.suppliedColorFramebuffer=e}updateBackbufferFormat(e){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e);const s=this.gl.getParameter(this.gl.ALPHA_BITS);this.backBufferFormat=s?Ze:Ja}updateBackbuffer(){const e=this.canvas.width!==this.backBufferSize.x||this.canvas.height!==this.backBufferSize.y;(this._defaultFramebufferChanged||e)&&(this._defaultFramebufferChanged&&this.updateBackbufferFormat(this._defaultFramebuffer),this._defaultFramebufferChanged=!1,this.backBufferSize.set(this.canvas.width,this.canvas.height),this.backBuffer.destroy(),this.createBackbuffer(this._defaultFramebuffer))}createVertexBufferImpl(e,t){return new Xz}createIndexBufferImpl(e){return new qz(e)}createShaderImpl(e){return new Zz(e)}createDrawCommandImpl(e){return new Qz(e.indexSizeBytes)}createTextureImpl(e){return this.textures.add(e),new Jz(e)}createRenderTargetImpl(e){return new tk}createUploadStreamImpl(e){return new sk(e)}getPrecision(){const e=this.gl;let t="highp";if(e.getShaderPrecisionFormat){const s=e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT),i=e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT),r=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT),a=e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT);if(s&&i&&r&&a){const o=s.precision>0&&r.precision>0,h=i.precision>0&&a.precision>0;o||(h?t="mediump":t="lowp")}}return t}getExtension(){for(let e=0;e<arguments.length;e++)if(this.supportedExtensions.indexOf(arguments[e])!==-1)return this.gl.getExtension(arguments[e]);return null}get extDisjointTimerQuery(){return this._extDisjointTimerQuery||(this._extDisjointTimerQuery=this.getExtension("EXT_disjoint_timer_query_webgl2","EXT_disjoint_timer_query")),this._extDisjointTimerQuery}initializeExtensions(){const e=this.gl;this.supportedExtensions=e.getSupportedExtensions()??[],this._extDisjointTimerQuery=null,this.textureRG11B10Renderable=!0,this.extColorBufferFloat=this.getExtension("EXT_color_buffer_float"),this.textureFloatRenderable=!!this.extColorBufferFloat,this.extColorBufferHalfFloat=this.getExtension("EXT_color_buffer_half_float"),this.textureHalfFloatRenderable=!!this.extColorBufferHalfFloat||!!this.extColorBufferFloat,this.extDebugRendererInfo=this.getExtension("WEBGL_debug_renderer_info"),this.extTextureFloatLinear=this.getExtension("OES_texture_float_linear"),this.textureFloatFilterable=!!this.extTextureFloatLinear,this.extFloatBlend=this.getExtension("EXT_float_blend"),this.extTextureFilterAnisotropic=this.getExtension("EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic"),this.extParallelShaderCompile=this.getExtension("KHR_parallel_shader_compile"),this.extMultiDraw=this.getExtension("WEBGL_multi_draw"),this.supportsMultiDraw=!!this.extMultiDraw,this.extCompressedTextureETC1=this.getExtension("WEBGL_compressed_texture_etc1"),this.extCompressedTextureETC=this.getExtension("WEBGL_compressed_texture_etc"),this.extCompressedTexturePVRTC=this.getExtension("WEBGL_compressed_texture_pvrtc","WEBKIT_WEBGL_compressed_texture_pvrtc"),this.extCompressedTextureS3TC=this.getExtension("WEBGL_compressed_texture_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc"),this.extCompressedTextureS3TC_SRGB=this.getExtension("WEBGL_compressed_texture_s3tc_srgb"),this.extCompressedTextureATC=this.getExtension("WEBGL_compressed_texture_atc"),this.extCompressedTextureASTC=this.getExtension("WEBGL_compressed_texture_astc"),this.extTextureCompressionBPTC=this.getExtension("EXT_texture_compression_bptc")}initializeCapabilities(){const e=this.gl;let t;const s=typeof navigator<"u"?navigator.userAgent:"";this.maxPrecision=this.precision=this.getPrecision();const i=e.getContextAttributes();this.supportsMsaa=i?.antialias??!1,this.supportsStencil=i?.stencil??!1,this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxCubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.maxRenderBufferSize=e.getParameter(e.MAX_RENDERBUFFER_SIZE),this.maxTextures=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.maxCombinedTextures=e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),this.maxVertexTextures=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),this.vertexUniformsCount=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),this.fragmentUniformsCount=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),this.maxColorAttachments=e.getParameter(e.MAX_COLOR_ATTACHMENTS),this.maxVolumeSize=e.getParameter(e.MAX_3D_TEXTURE_SIZE),t=this.extDebugRendererInfo,this.unmaskedRenderer=t?e.getParameter(t.UNMASKED_RENDERER_WEBGL):"",this.unmaskedVendor=t?e.getParameter(t.UNMASKED_VENDOR_WEBGL):"";const r=/\bMali-G52+/,a=/SM-[a-zA-Z0-9]+/;this.supportsGpuParticles=!(this.unmaskedVendor==="ARM"&&s.match(a))&&!this.unmaskedRenderer.match(r),t=this.extTextureFilterAnisotropic,this.maxAnisotropy=t?e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1;const o=!this.forceDisableMultisampling;this.maxSamples=o?e.getParameter(e.MAX_SAMPLES):1,this.maxSamples=Math.min(this.maxSamples,4),this.samples=o&&this.backBufferAntialias?this.maxSamples:1,this.supportsAreaLights=!Ve.android,this.maxTextures<=8&&(this.supportsAreaLights=!1),this.initCapsDefines()}initializeRenderState(){super.initializeRenderState();const e=this.gl;e.disable(e.BLEND),e.blendFunc(e.ONE,e.ZERO),e.blendEquation(e.FUNC_ADD),e.colorMask(!0,!0,!0,!0),e.blendColor(0,0,0,0),e.enable(e.CULL_FACE),this.cullFace=e.BACK,e.cullFace(e.BACK),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.depthMask(!0),this.stencil=!1,e.disable(e.STENCIL_TEST),this.stencilFuncFront=this.stencilFuncBack=$a,this.stencilRefFront=this.stencilRefBack=0,this.stencilMaskFront=this.stencilMaskBack=255,e.stencilFunc(e.ALWAYS,0,255),this.stencilFailFront=this.stencilFailBack=fh,this.stencilZfailFront=this.stencilZfailBack=fh,this.stencilZpassFront=this.stencilZpassBack=fh,this.stencilWriteMaskFront=255,this.stencilWriteMaskBack=255,e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.stencilMask(255),this.alphaToCoverage=!1,this.raster=!0,e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.disable(e.RASTERIZER_DISCARD),this.depthBiasEnabled=!1,e.disable(e.POLYGON_OFFSET_FILL),this.clearDepth=1,e.clearDepth(1),this.clearColor=new ue(0,0,0,0),e.clearColor(0,0,0,0),this.clearStencil=0,e.clearStencil(0),e.hint(e.FRAGMENT_SHADER_DERIVATIVE_HINT,e.NICEST),e.enable(e.SCISSOR_TEST),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE),this.unpackFlipY=!1,e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),this.unpackPremultiplyAlpha=!1,e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),e.pixelStorei(e.UNPACK_ALIGNMENT,1)}initTextureUnits(e=16){this.textureUnits=[];for(let t=0;t<e;t++)this.textureUnits.push([null,null,null])}initializeContextCaches(){super.initializeContextCaches(),this._vaoMap=new Map,this.boundVao=null,this.activeFramebuffer=null,this.feedback=null,this.transformFeedbackBuffer=null,this.textureUnit=0,this.initTextureUnits(this.maxCombinedTextures)}loseContext(){super.loseContext();for(const e of this.shaders)e.loseContext()}restoreContext(){this.initializeExtensions(),this.initializeCapabilities(),super.restoreContext();for(const e of this.shaders)e.restoreContext()}setViewport(e,t,s,i){(this.vx!==e||this.vy!==t||this.vw!==s||this.vh!==i)&&(this.gl.viewport(e,t,s,i),this.vx=e,this.vy=t,this.vw=s,this.vh=i)}setScissor(e,t,s,i){(this.sx!==e||this.sy!==t||this.sw!==s||this.sh!==i)&&(this.gl.scissor(e,t,s,i),this.sx=e,this.sy=t,this.sw=s,this.sh=i)}setFramebuffer(e){if(this.activeFramebuffer!==e){const t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,e),this.activeFramebuffer=e}}copyRenderTarget(e,t,s,i){const r=this.gl;if(e===this.backBuffer&&(e=null),s){if(t){if(e&&(!e._colorBuffer||!t._colorBuffer||e._colorBuffer._format!==t._colorBuffer._format))return!1}else if(!e._colorBuffer)return!1}if(i&&e&&!e._depth&&(!e._depthBuffer||!t._depthBuffer||e._depthBuffer._format!==t._depthBuffer._format))return!1;const a=this.renderTarget;this.renderTarget=t,this.updateBegin();const o=e?e.impl._glFrameBuffer:this.backBuffer?.impl._glFrameBuffer,h=t?t.impl._glFrameBuffer:this.backBuffer?.impl._glFrameBuffer;r.bindFramebuffer(r.READ_FRAMEBUFFER,o),r.bindFramebuffer(r.DRAW_FRAMEBUFFER,h);const u=e?e.width:t?t.width:this.width,f=e?e.height:t?t.height:this.height;return r.blitFramebuffer(0,0,u,f,0,0,u,f,(s?r.COLOR_BUFFER_BIT:0)|(i?r.DEPTH_BUFFER_BIT:0),r.NEAREST),this.renderTarget=a,r.bindFramebuffer(r.FRAMEBUFFER,a?a.impl._glFrameBuffer:null),!0}frameStart(){super.frameStart(),this.updateBackbuffer(),this.gpuProfiler.frameStart()}frameEnd(){super.frameEnd(),this.gpuProfiler.frameEnd(),this.gpuProfiler.request()}startRenderPass(e){const t=e.renderTarget??this.backBuffer;this.renderTarget=t,this.updateBegin();const{width:s,height:i}=t;this.setViewport(0,0,s,i),this.setScissor(0,0,s,i);const r=e.colorOps,a=e.depthStencilOps;if(r?.clear||a.clearDepth||a.clearStencil){let o=0;const h={};r?.clear&&(o|=qd,h.color=[r.clearValue.r,r.clearValue.g,r.clearValue.b,r.clearValue.a]),a.clearDepth&&(o|=Yd,h.depth=a.clearDepthValue),a.clearStencil&&(o|=W_,h.stencil=a.clearStencilValue),h.flags=o,this.clear(h)}this.insideRenderPass=!0}endRenderPass(e){this.unbindVertexArray();const t=this.renderTarget,s=e.colorArrayOps.length;if(t){Dc.length=0;const i=this.gl;for(let r=0;r<s;r++){const a=e.colorArrayOps[r];a.store||a.resolve||Dc.push(i.COLOR_ATTACHMENT0+r)}t!==this.backBuffer&&(e.depthStencilOps.storeDepth||Dc.push(i.DEPTH_ATTACHMENT),e.depthStencilOps.storeStencil||Dc.push(i.STENCIL_ATTACHMENT)),Dc.length>0&&e.fullSizeClearRect&&i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER,Dc),s&&e.colorOps?.resolve&&e.samples>1&&t.autoResolve&&t.resolve(!0,!1),t.depthBuffer&&e.depthStencilOps.resolveDepth&&e.samples>1&&t.autoResolve&&t.resolve(!1,!0);for(let r=0;r<s;r++)if(e.colorArrayOps[r].genMipmaps){const o=t._colorBuffers[r];o&&o.impl._glTexture&&o.mipmaps&&(this.activeTexture(this.maxCombinedTextures-1),this.bindTexture(o),this.gl.generateMipmap(o.impl._glTarget))}}this.insideRenderPass=!1}set defaultFramebuffer(e){this._defaultFramebuffer!==e&&(this._defaultFramebuffer=e,this._defaultFramebufferChanged=!0)}get defaultFramebuffer(){return this._defaultFramebuffer}updateBegin(){if(this.boundVao=null,this._tempEnableSafariTextureUnitWorkaround)for(let s=0;s<this.textureUnits.length;++s)for(let i=0;i<3;++i)this.textureUnits[s][i]=null;const e=this.renderTarget??this.backBuffer,t=e.impl;t.initialized||this.initRenderTarget(e),this.setFramebuffer(t._glFrameBuffer)}updateEnd(){this.unbindVertexArray();const e=this.renderTarget;if(e&&e!==this.backBuffer){e._samples>1&&e.autoResolve&&e.resolve();const t=e._colorBuffer;t&&t.impl._glTexture&&t.mipmaps&&(this.activeTexture(this.maxCombinedTextures-1),this.bindTexture(t),this.gl.generateMipmap(t.impl._glTarget))}}setUnpackFlipY(e){if(this.unpackFlipY!==e){this.unpackFlipY=e;const t=this.gl;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,e)}}setUnpackPremultiplyAlpha(e){if(this.unpackPremultiplyAlpha!==e){this.unpackPremultiplyAlpha=e;const t=this.gl;t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e)}}activeTexture(e){this.textureUnit!==e&&(this.gl.activeTexture(this.gl.TEXTURE0+e),this.textureUnit=e)}bindTexture(e){const t=e.impl,s=t._glTarget,i=t._glTexture,r=this.textureUnit,a=this.targetToSlot[s];this.textureUnits[r][a]!==i&&(this.gl.bindTexture(s,i),this.textureUnits[r][a]=i)}bindTextureOnUnit(e,t){const s=e.impl,i=s._glTarget,r=s._glTexture,a=this.targetToSlot[i];this.textureUnits[t][a]!==r&&(this.activeTexture(t),this.gl.bindTexture(i,r),this.textureUnits[t][a]=r)}setTextureParameters(e){const t=this.gl,s=e.impl.dirtyParameterFlags,i=e.impl._glTarget;if(s&$M){let r=e._minFilter;(!e._mipmaps||e._compressed&&e._levels.length===1)&&(r===Ef||r===bf?r=ze:(r===Af||r===Jn)&&(r=$t)),t.texParameteri(i,t.TEXTURE_MIN_FILTER,this.glFilter[r])}if(s&KM&&t.texParameteri(i,t.TEXTURE_MAG_FILTER,this.glFilter[e._magFilter]),s&ZM&&t.texParameteri(i,t.TEXTURE_WRAP_S,this.glAddress[e._addressU]),s&QM&&t.texParameteri(i,t.TEXTURE_WRAP_T,this.glAddress[e._addressV]),s&JM&&t.texParameteri(i,t.TEXTURE_WRAP_R,this.glAddress[e._addressW]),s&e2&&t.texParameteri(i,t.TEXTURE_COMPARE_MODE,e._compareOnRead?t.COMPARE_REF_TO_TEXTURE:t.NONE),s&t2&&t.texParameteri(i,t.TEXTURE_COMPARE_FUNC,this.glComparison[e._compareFunc]),s&s2){const r=this.extTextureFilterAnisotropic;r&&t.texParameterf(i,r.TEXTURE_MAX_ANISOTROPY_EXT,J.clamp(Math.round(e._anisotropy),1,this.maxAnisotropy))}}setTexture(e,t){const s=e.impl;s._glTexture||s.initialize(this,e),s.dirtyParameterFlags>0||e._needsUpload||e._needsMipmapsUpload?(this.activeTexture(t),this.bindTexture(e),s.dirtyParameterFlags&&(this.setTextureParameters(e),s.dirtyParameterFlags=0),(e._needsUpload||e._needsMipmapsUpload)&&(s.upload(this,e),e._needsUpload=!1,e._needsMipmapsUpload=!1)):this.bindTextureOnUnit(e,t)}createVertexArray(e){let t,s;const i=e.length>1;if(i){t="";for(let r=0;r<e.length;r++){const a=e[r];t+=a.id+a.format.renderingHash}s=this._vaoMap.get(t)}if(!s){const r=this.gl;s=r.createVertexArray(),r.bindVertexArray(s),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null);for(let a=0;a<e.length;a++){const o=e[a];r.bindBuffer(r.ARRAY_BUFFER,o.impl.bufferId);const h=o.format.elements;for(let u=0;u<h.length;u++){const f=h[u],m=$e[f.name];f.asInt?r.vertexAttribIPointer(m,f.numComponents,this.glType[f.dataType],f.stride,f.offset):r.vertexAttribPointer(m,f.numComponents,this.glType[f.dataType],f.normalize,f.stride,f.offset),r.enableVertexAttribArray(m),o.format.instancing&&r.vertexAttribDivisor(m,1)}}r.bindVertexArray(null),r.bindBuffer(r.ARRAY_BUFFER,null),i&&this._vaoMap.set(t,s)}return s}unbindVertexArray(){this.boundVao&&(this.boundVao=null,this.gl.bindVertexArray(null))}setBuffers(e){const t=this.gl;let s;if(this.vertexBuffers.length===1){const r=this.vertexBuffers[0];r.impl.vao||(r.impl.vao=this.createVertexArray(this.vertexBuffers)),s=r.impl.vao}else s=this.createVertexArray(this.vertexBuffers);this.boundVao!==s&&(this.boundVao=s,t.bindVertexArray(s));const i=e?e.impl.bufferId:null;t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,i)}_multiDrawLoopFallback(e,t,s,i,r){const a=this.gl;if(t.indexed){const o=s.impl.glFormat,{glCounts:h,glOffsetsBytes:u,glInstanceCounts:f,count:m}=r.impl;if(i>0)for(let _=0;_<m;_++)a.drawElementsInstanced(e,h[_],o,u[_],f[_]);else for(let _=0;_<m;_++)a.drawElements(e,h[_],o,u[_])}else{const{glCounts:o,glOffsetsBytes:h,glInstanceCounts:u,count:f}=r.impl;if(i>0)for(let m=0;m<f;m++)a.drawArraysInstanced(e,h[m],o[m],u[m]);else for(let m=0;m<f;m++)a.drawArrays(e,h[m],o[m])}}draw(e,t,s,i,r=!0,a=!0){const o=this.shader;if(o&&(this.activateShader(),this.shaderValid)){const h=this.gl;r&&this.setBuffers(t);let u=0;const f=o.impl.samplers;for(let S=0,x=f.length;S<x;S++){const T=f[S];let E=T.scopeId.value;if(!E){const b=T.scopeId.name;b==="uSceneDepthMap"&&(E=dl(this,"white")),b==="uSceneColorMap"&&(E=dl(this,"pink")),E||(E=dl(this,"pink"))}if(E instanceof De){const b=E;this.setTexture(b,u),T.slot!==u&&(h.uniform1i(T.locationId,u),T.slot=u),u++}else{T.array.length=0;const b=E.length;for(let C=0;C<b;C++){const w=E[C];this.setTexture(w,u),T.array[C]=u,u++}h.uniform1iv(T.locationId,T.array)}}const m=o.impl.uniforms;for(let S=0,x=m.length;S<x;S++){const T=m[S],E=T.scopeId,b=T.version,C=E.versionObject.version;if(b.globalId!==C.globalId||b.revision!==C.revision){b.globalId=C.globalId,b.revision=C.revision;const w=E.value;w!=null&&this.commitFunction[T.dataType](T,w)}}this.transformFeedbackBuffer&&(h.bindBufferBase(h.TRANSFORM_FEEDBACK_BUFFER,0,this.transformFeedbackBuffer.impl.bufferId),h.beginTransformFeedback(h.POINTS));const _=this.glPrimitive[e.type],g=e.count;if(i)if(this.extMultiDraw){const S=i.impl;if(e.indexed){const x=t.impl.glFormat;s>0?this.extMultiDraw.multiDrawElementsInstancedWEBGL(_,S.glCounts,0,x,S.glOffsetsBytes,0,S.glInstanceCounts,0,i.count):this.extMultiDraw.multiDrawElementsWEBGL(_,S.glCounts,0,x,S.glOffsetsBytes,0,i.count)}else s>0?this.extMultiDraw.multiDrawArraysInstancedWEBGL(_,S.glOffsetsBytes,0,S.glCounts,0,S.glInstanceCounts,0,i.count):this.extMultiDraw.multiDrawArraysWEBGL(_,S.glOffsetsBytes,0,S.glCounts,0,i.count)}else this._multiDrawLoopFallback(_,e,t,s,i);else if(e.indexed){const S=t.impl.glFormat,x=e.base*t.bytesPerIndex;s>0?h.drawElementsInstanced(_,g,S,x,s):h.drawElements(_,g,S,x)}else{const S=e.base;s>0?h.drawArraysInstanced(_,S,g,s):h.drawArrays(_,S,g)}this.transformFeedbackBuffer&&(h.endTransformFeedback(),h.bindBufferBase(h.TRANSFORM_FEEDBACK_BUFFER,0,null)),this._drawCallsPerFrame++}a&&this.clearVertexBuffer()}clear(e){const t=this.defaultClearOptions;e=e||t;const s=e.flags??t.flags;if(s!==0){const i=this.gl;if(s&qd){const r=e.color??t.color,a=r[0],o=r[1],h=r[2],u=r[3],f=this.clearColor;(a!==f.r||o!==f.g||h!==f.b||u!==f.a)&&(this.gl.clearColor(a,o,h,u),this.clearColor.set(a,o,h,u)),this.setBlendState(ht.NOBLEND)}if(s&Yd){const r=e.depth??t.depth;r!==this.clearDepth&&(this.gl.clearDepth(r),this.clearDepth=r),this.setDepthState(Gt.WRITEDEPTH)}if(s&W_){const r=e.stencil??t.stencil;r!==this.clearStencil&&(this.gl.clearStencil(r),this.clearStencil=r),i.stencilMask(255),this.stencilWriteMaskFront=255,this.stencilWriteMaskBack=255}i.clear(this.glClearFlag[s])}}submit(){this.gl.flush()}readPixels(e,t,s,i,r){const a=this.gl;a.readPixels(e,t,s,i,a.RGBA,a.UNSIGNED_BYTE,r)}clientWaitAsync(e,t){const s=this.gl,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);return this.submit(),new Promise((r,a)=>{function o(){const h=s.clientWaitSync(i,e,0);h===s.TIMEOUT_EXPIRED?setTimeout(o,t):(s.deleteSync(i),h===s.WAIT_FAILED?a(new Error("webgl clientWaitSync sync failed")):r())}o()})}async readPixelsAsync(e,t,s,i,r){const a=this.gl,o=this.renderTarget.colorBuffer?.impl,h=o?._glFormat??a.RGBA,u=o?._glPixelType??a.UNSIGNED_BYTE,f=a.createBuffer();return a.bindBuffer(a.PIXEL_PACK_BUFFER,f),a.bufferData(a.PIXEL_PACK_BUFFER,r.byteLength,a.STREAM_READ),a.readPixels(e,t,s,i,h,u,0),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),await this.clientWaitAsync(0,16),a.bindBuffer(a.PIXEL_PACK_BUFFER,f),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),a.deleteBuffer(f),r}readTextureAsync(e,t,s,i,r,a){const o=a.face??0,h=a.mipLevel??0,u=a.renderTarget??new At({colorBuffer:e,depth:!1,face:o,mipLevel:h}),f=new ArrayBuffer(Wi.calcLevelGpuSize(i,r,1,e._format)),m=a.data??new(dE(e._format))(f);return this.setRenderTarget(u),this.initRenderTarget(u),this.setFramebuffer(u.impl._glFrameBuffer),a.immediate&&this.gl.flush(),new Promise((_,g)=>{this.readPixelsAsync(t,s,i,r,m).then(S=>{this._destroyed||(a.renderTarget||u.destroy(),_(S))}).catch(g)})}async writeTextureAsync(e,t,s,i,r,a){const o=this.gl,h=e.impl,u=h?._glFormat??o.RGBA,f=h?._glPixelType??o.UNSIGNED_BYTE,m=o.createBuffer();o.bindBuffer(o.PIXEL_UNPACK_BUFFER,m),o.bufferData(o.PIXEL_UNPACK_BUFFER,a,o.STREAM_DRAW),o.bindTexture(o.TEXTURE_2D,h._glTexture),o.texSubImage2D(o.TEXTURE_2D,0,t,s,i,r,u,f,0),o.bindBuffer(o.PIXEL_UNPACK_BUFFER,null),e._needsUpload=!1,e._mipmapsUploaded=!1,await this.clientWaitAsync(0,16)}setAlphaToCoverage(e){this.alphaToCoverage!==e&&(this.alphaToCoverage=e,e?this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE):this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE))}setTransformFeedbackBuffer(e){if(this.transformFeedbackBuffer!==e){this.transformFeedbackBuffer=e;const t=this.gl;e?(this.feedback||(this.feedback=t.createTransformFeedback()),t.bindTransformFeedback(t.TRANSFORM_FEEDBACK,this.feedback)):t.bindTransformFeedback(t.TRANSFORM_FEEDBACK,null)}}setRaster(e){this.raster!==e&&(this.raster=e,e?this.gl.disable(this.gl.RASTERIZER_DISCARD):this.gl.enable(this.gl.RASTERIZER_DISCARD))}setStencilTest(e){if(this.stencil!==e){const t=this.gl;e?t.enable(t.STENCIL_TEST):t.disable(t.STENCIL_TEST),this.stencil=e}}setStencilFunc(e,t,s){(this.stencilFuncFront!==e||this.stencilRefFront!==t||this.stencilMaskFront!==s||this.stencilFuncBack!==e||this.stencilRefBack!==t||this.stencilMaskBack!==s)&&(this.gl.stencilFunc(this.glComparison[e],t,s),this.stencilFuncFront=this.stencilFuncBack=e,this.stencilRefFront=this.stencilRefBack=t,this.stencilMaskFront=this.stencilMaskBack=s)}setStencilFuncFront(e,t,s){if(this.stencilFuncFront!==e||this.stencilRefFront!==t||this.stencilMaskFront!==s){const i=this.gl;i.stencilFuncSeparate(i.FRONT,this.glComparison[e],t,s),this.stencilFuncFront=e,this.stencilRefFront=t,this.stencilMaskFront=s}}setStencilFuncBack(e,t,s){if(this.stencilFuncBack!==e||this.stencilRefBack!==t||this.stencilMaskBack!==s){const i=this.gl;i.stencilFuncSeparate(i.BACK,this.glComparison[e],t,s),this.stencilFuncBack=e,this.stencilRefBack=t,this.stencilMaskBack=s}}setStencilOperation(e,t,s,i){(this.stencilFailFront!==e||this.stencilZfailFront!==t||this.stencilZpassFront!==s||this.stencilFailBack!==e||this.stencilZfailBack!==t||this.stencilZpassBack!==s)&&(this.gl.stencilOp(this.glStencilOp[e],this.glStencilOp[t],this.glStencilOp[s]),this.stencilFailFront=this.stencilFailBack=e,this.stencilZfailFront=this.stencilZfailBack=t,this.stencilZpassFront=this.stencilZpassBack=s),(this.stencilWriteMaskFront!==i||this.stencilWriteMaskBack!==i)&&(this.gl.stencilMask(i),this.stencilWriteMaskFront=i,this.stencilWriteMaskBack=i)}setStencilOperationFront(e,t,s,i){(this.stencilFailFront!==e||this.stencilZfailFront!==t||this.stencilZpassFront!==s)&&(this.gl.stencilOpSeparate(this.gl.FRONT,this.glStencilOp[e],this.glStencilOp[t],this.glStencilOp[s]),this.stencilFailFront=e,this.stencilZfailFront=t,this.stencilZpassFront=s),this.stencilWriteMaskFront!==i&&(this.gl.stencilMaskSeparate(this.gl.FRONT,i),this.stencilWriteMaskFront=i)}setStencilOperationBack(e,t,s,i){(this.stencilFailBack!==e||this.stencilZfailBack!==t||this.stencilZpassBack!==s)&&(this.gl.stencilOpSeparate(this.gl.BACK,this.glStencilOp[e],this.glStencilOp[t],this.glStencilOp[s]),this.stencilFailBack=e,this.stencilZfailBack=t,this.stencilZpassBack=s),this.stencilWriteMaskBack!==i&&(this.gl.stencilMaskSeparate(this.gl.BACK,i),this.stencilWriteMaskBack=i)}setBlendState(e){const t=this.blendState;if(!t.equals(e)){const s=this.gl,{blend:i,colorOp:r,alphaOp:a,colorSrcFactor:o,colorDstFactor:h,alphaSrcFactor:u,alphaDstFactor:f}=e;if(t.blend!==i&&(i?s.enable(s.BLEND):s.disable(s.BLEND)),t.colorOp!==r||t.alphaOp!==a){const m=this.glBlendEquation;s.blendEquationSeparate(m[r],m[a])}(t.colorSrcFactor!==o||t.colorDstFactor!==h||t.alphaSrcFactor!==u||t.alphaDstFactor!==f)&&s.blendFuncSeparate(this.glBlendFunctionColor[o],this.glBlendFunctionColor[h],this.glBlendFunctionAlpha[u],this.glBlendFunctionAlpha[f]),t.allWrite!==e.allWrite&&this.gl.colorMask(e.redWrite,e.greenWrite,e.blueWrite,e.alphaWrite),t.copy(e)}}setBlendColor(e,t,s,i){const r=this.blendColor;(e!==r.r||t!==r.g||s!==r.b||i!==r.a)&&(this.gl.blendColor(e,t,s,i),r.set(e,t,s,i))}setStencilState(e,t){e||t?(this.setStencilTest(!0),e===t?(this.setStencilFunc(e.func,e.ref,e.readMask),this.setStencilOperation(e.fail,e.zfail,e.zpass,e.writeMask)):(e??(e=Xi.DEFAULT),this.setStencilFuncFront(e.func,e.ref,e.readMask),this.setStencilOperationFront(e.fail,e.zfail,e.zpass,e.writeMask),t??(t=Xi.DEFAULT),this.setStencilFuncBack(t.func,t.ref,t.readMask),this.setStencilOperationBack(t.fail,t.zfail,t.zpass,t.writeMask))):this.setStencilTest(!1)}setDepthState(e){const t=this.depthState;if(!t.equals(e)){const s=this.gl,i=e.write;t.write!==i&&s.depthMask(i);let{func:r,test:a}=e;!a&&i&&(a=!0,r=$a),t.func!==r&&s.depthFunc(this.glComparison[r]),t.test!==a&&(a?s.enable(s.DEPTH_TEST):s.disable(s.DEPTH_TEST));const{depthBias:o,depthBiasSlope:h}=e;o||h?(this.depthBiasEnabled||(this.depthBiasEnabled=!0,this.gl.enable(this.gl.POLYGON_OFFSET_FILL)),s.polygonOffset(h,o)):this.depthBiasEnabled&&(this.depthBiasEnabled=!1,this.gl.disable(this.gl.POLYGON_OFFSET_FILL)),t.copy(e)}}setCullMode(e){if(this.cullMode!==e){if(e===Ft)this.gl.disable(this.gl.CULL_FACE);else{this.cullMode===Ft&&this.gl.enable(this.gl.CULL_FACE);const t=this.glCull[e];this.cullFace!==t&&(this.gl.cullFace(t),this.cullFace=t)}this.cullMode=e}}setShader(e,t=!1){e!==this.shader&&(this.shader=e,this.shaderAsyncCompile=t,this.shaderValid=void 0)}activateShader(){const{shader:e}=this,{impl:t}=e;this.shaderValid===void 0&&(e.failed?this.shaderValid=!1:e.ready||(this.shaderAsyncCompile?t.isLinked(this)?t.finalize(this,e)||(e.failed=!0,this.shaderValid=!1):this.shaderValid=!1:t.finalize(this,e)||(e.failed=!0,this.shaderValid=!1))),this.shaderValid===void 0&&(this.gl.useProgram(t.glProgram),this.shaderValid=!0)}clearVertexArrayObjectCache(){const e=this.gl;this._vaoMap.forEach((t,s,i)=>{e.deleteVertexArray(t)}),this._vaoMap.clear()}set fullscreen(e){e?this.gl.canvas.requestFullscreen():document.exitFullscreen()}get fullscreen(){return!!document.fullscreenElement}constructor(e,t={}){super(e,t),this._defaultFramebuffer=null,this._defaultFramebufferChanged=!1,t=this.initOptions,this.updateClientRect(),this.initTextureUnits(),this.contextLost=!1,this._contextLostHandler=g=>{g.preventDefault(),this.loseContext(),this.fire("devicelost")},this._contextRestoredHandler=()=>{this.restoreContext(),this.fire("devicerestored")};const s=typeof navigator<"u"&&navigator.userAgent;if(this.forceDisableMultisampling=s&&s.includes("AppleWebKit")&&(s.includes("15.4")||s.includes("15_4")),this.forceDisableMultisampling&&(t.antialias=!1),Ve.browserName==="firefox"){const S=(typeof navigator<"u"?navigator.userAgent:"").match(/Firefox\/(\d+(\.\d+)*)/),x=S?S[1]:null;if(x){const T=parseFloat(x);(Ve.name==="windows"&&(T>=120||T===115)||Ve.name==="android"&&T>=132)&&(t.antialias=!1)}}this.backBufferAntialias=t.antialias??!1,t.antialias=!1;const i=t.gl??e.getContext("webgl2",t);if(!i)throw new Error("WebGL not supported");this.gl=i,this.isWebGL2=!0,this._deviceType=_h,this.updateBackbufferFormat(null);const r=Ve.browserName==="chrome",a=Ve.browserName==="safari",o=Ve.browser&&navigator.appVersion.indexOf("Mac")!==-1;this._tempEnableSafariTextureUnitWorkaround=a,this._tempMacChromeBlitFramebufferWorkaround=o&&r&&!t.alpha,e.addEventListener("webglcontextlost",this._contextLostHandler,!1),e.addEventListener("webglcontextrestored",this._contextRestoredHandler,!1),this.initializeExtensions(),this.initializeCapabilities(),this.initializeRenderState(),this.initializeContextCaches(),this.createBackbuffer(null),this.supportsImageBitmap=!a&&typeof ImageBitmap<"u",this._samplerTypes=new Set([i.SAMPLER_2D,i.SAMPLER_CUBE,i.UNSIGNED_INT_SAMPLER_2D,i.INT_SAMPLER_2D,i.SAMPLER_2D_SHADOW,i.SAMPLER_CUBE_SHADOW,i.SAMPLER_3D,i.INT_SAMPLER_3D,i.UNSIGNED_INT_SAMPLER_3D,i.SAMPLER_2D_ARRAY,i.INT_SAMPLER_2D_ARRAY,i.UNSIGNED_INT_SAMPLER_2D_ARRAY]),this.glAddress=[i.REPEAT,i.CLAMP_TO_EDGE,i.MIRRORED_REPEAT],this.glBlendEquation=[i.FUNC_ADD,i.FUNC_SUBTRACT,i.FUNC_REVERSE_SUBTRACT,i.MIN,i.MAX],this.glBlendFunctionColor=[i.ZERO,i.ONE,i.SRC_COLOR,i.ONE_MINUS_SRC_COLOR,i.DST_COLOR,i.ONE_MINUS_DST_COLOR,i.SRC_ALPHA,i.SRC_ALPHA_SATURATE,i.ONE_MINUS_SRC_ALPHA,i.DST_ALPHA,i.ONE_MINUS_DST_ALPHA,i.CONSTANT_COLOR,i.ONE_MINUS_CONSTANT_COLOR],this.glBlendFunctionAlpha=[i.ZERO,i.ONE,i.SRC_COLOR,i.ONE_MINUS_SRC_COLOR,i.DST_COLOR,i.ONE_MINUS_DST_COLOR,i.SRC_ALPHA,i.SRC_ALPHA_SATURATE,i.ONE_MINUS_SRC_ALPHA,i.DST_ALPHA,i.ONE_MINUS_DST_ALPHA,i.CONSTANT_ALPHA,i.ONE_MINUS_CONSTANT_ALPHA],this.glComparison=[i.NEVER,i.LESS,i.EQUAL,i.LEQUAL,i.GREATER,i.NOTEQUAL,i.GEQUAL,i.ALWAYS],this.glStencilOp=[i.KEEP,i.ZERO,i.REPLACE,i.INCR,i.INCR_WRAP,i.DECR,i.DECR_WRAP,i.INVERT],this.glClearFlag=[0,i.COLOR_BUFFER_BIT,i.DEPTH_BUFFER_BIT,i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT,i.STENCIL_BUFFER_BIT,i.STENCIL_BUFFER_BIT|i.COLOR_BUFFER_BIT,i.STENCIL_BUFFER_BIT|i.DEPTH_BUFFER_BIT,i.STENCIL_BUFFER_BIT|i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT],this.glCull=[0,i.BACK,i.FRONT,i.FRONT_AND_BACK],this.glFilter=[i.NEAREST,i.LINEAR,i.NEAREST_MIPMAP_NEAREST,i.NEAREST_MIPMAP_LINEAR,i.LINEAR_MIPMAP_NEAREST,i.LINEAR_MIPMAP_LINEAR],this.glPrimitive=[i.POINTS,i.LINES,i.LINE_LOOP,i.LINE_STRIP,i.TRIANGLES,i.TRIANGLE_STRIP,i.TRIANGLE_FAN],this.glType=[i.BYTE,i.UNSIGNED_BYTE,i.SHORT,i.UNSIGNED_SHORT,i.INT,i.UNSIGNED_INT,i.FLOAT,i.HALF_FLOAT],this.pcUniformType={},this.pcUniformType[i.BOOL]=ph,this.pcUniformType[i.INT]=Ga,this.pcUniformType[i.FLOAT]=Bs,this.pcUniformType[i.FLOAT_VEC2]=xl,this.pcUniformType[i.FLOAT_VEC3]=Gi,this.pcUniformType[i.FLOAT_VEC4]=so,this.pcUniformType[i.INT_VEC2]=hl,this.pcUniformType[i.INT_VEC3]=Ha,this.pcUniformType[i.INT_VEC4]=ul,this.pcUniformType[i.BOOL_VEC2]=Kd,this.pcUniformType[i.BOOL_VEC3]=Zd,this.pcUniformType[i.BOOL_VEC4]=Qd,this.pcUniformType[i.FLOAT_MAT2]=rg,this.pcUniformType[i.FLOAT_MAT3]=Ah,this.pcUniformType[i.FLOAT_MAT4]=Or,this.pcUniformType[i.SAMPLER_2D]=HB,this.pcUniformType[i.SAMPLER_CUBE]=WB,this.pcUniformType[i.UNSIGNED_INT]=Qs,this.pcUniformType[i.UNSIGNED_INT_VEC2]=wh,this.pcUniformType[i.UNSIGNED_INT_VEC3]=Ch,this.pcUniformType[i.UNSIGNED_INT_VEC4]=Dh,this.pcUniformType[i.SAMPLER_2D_SHADOW]=XB,this.pcUniformType[i.SAMPLER_CUBE_SHADOW]=qB,this.pcUniformType[i.SAMPLER_2D_ARRAY]=jB,this.pcUniformType[i.SAMPLER_3D]=YB,this.pcUniformType[i.INT_SAMPLER_2D]=$B,this.pcUniformType[i.UNSIGNED_INT_SAMPLER_2D]=KB,this.pcUniformType[i.INT_SAMPLER_CUBE]=ZB,this.pcUniformType[i.UNSIGNED_INT_SAMPLER_2D]=QB,this.pcUniformType[i.INT_SAMPLER_3D]=JB,this.pcUniformType[i.UNSIGNED_INT_SAMPLER_3D]=eU,this.pcUniformType[i.INT_SAMPLER_2D_ARRAY]=tU,this.pcUniformType[i.UNSIGNED_INT_SAMPLER_2D_ARRAY]=sU,this.targetToSlot={},this.targetToSlot[i.TEXTURE_2D]=0,this.targetToSlot[i.TEXTURE_CUBE_MAP]=1,this.targetToSlot[i.TEXTURE_3D]=2;let h,u,f,m,_;this.commitFunction=[],this.commitFunction[ph]=function(g,S){g.value!==S&&(i.uniform1i(g.locationId,S),g.value=S)},this.commitFunction[Ga]=this.commitFunction[ph],this.commitFunction[Bs]=function(g,S){g.value!==S&&(i.uniform1f(g.locationId,S),g.value=S)},this.commitFunction[xl]=function(g,S){_=g.value,h=S[0],u=S[1],(_[0]!==h||_[1]!==u)&&(i.uniform2fv(g.locationId,S),_[0]=h,_[1]=u)},this.commitFunction[Gi]=function(g,S){_=g.value,h=S[0],u=S[1],f=S[2],(_[0]!==h||_[1]!==u||_[2]!==f)&&(i.uniform3fv(g.locationId,S),_[0]=h,_[1]=u,_[2]=f)},this.commitFunction[so]=function(g,S){_=g.value,h=S[0],u=S[1],f=S[2],m=S[3],(_[0]!==h||_[1]!==u||_[2]!==f||_[3]!==m)&&(i.uniform4fv(g.locationId,S),_[0]=h,_[1]=u,_[2]=f,_[3]=m)},this.commitFunction[hl]=function(g,S){_=g.value,h=S[0],u=S[1],(_[0]!==h||_[1]!==u)&&(i.uniform2iv(g.locationId,S),_[0]=h,_[1]=u)},this.commitFunction[Kd]=this.commitFunction[hl],this.commitFunction[Ha]=function(g,S){_=g.value,h=S[0],u=S[1],f=S[2],(_[0]!==h||_[1]!==u||_[2]!==f)&&(i.uniform3iv(g.locationId,S),_[0]=h,_[1]=u,_[2]=f)},this.commitFunction[Zd]=this.commitFunction[Ha],this.commitFunction[ul]=function(g,S){_=g.value,h=S[0],u=S[1],f=S[2],m=S[3],(_[0]!==h||_[1]!==u||_[2]!==f||_[3]!==m)&&(i.uniform4iv(g.locationId,S),_[0]=h,_[1]=u,_[2]=f,_[3]=m)},this.commitFunction[Qd]=this.commitFunction[ul],this.commitFunction[rg]=function(g,S){i.uniformMatrix2fv(g.locationId,!1,S)},this.commitFunction[Ah]=function(g,S){i.uniformMatrix3fv(g.locationId,!1,S)},this.commitFunction[Or]=function(g,S){i.uniformMatrix4fv(g.locationId,!1,S)},this.commitFunction[fv]=function(g,S){i.uniform1fv(g.locationId,S)},this.commitFunction[mv]=function(g,S){i.uniform2fv(g.locationId,S)},this.commitFunction[pv]=function(g,S){i.uniform3fv(g.locationId,S)},this.commitFunction[xE]=function(g,S){i.uniform4fv(g.locationId,S)},this.commitFunction[Qs]=function(g,S){g.value!==S&&(i.uniform1ui(g.locationId,S),g.value=S)},this.commitFunction[wh]=function(g,S){_=g.value,h=S[0],u=S[1],(_[0]!==h||_[1]!==u)&&(i.uniform2uiv(g.locationId,S),_[0]=h,_[1]=u)},this.commitFunction[Ch]=function(g,S){_=g.value,h=S[0],u=S[1],f=S[2],(_[0]!==h||_[1]!==u||_[2]!==f)&&(i.uniform3uiv(g.locationId,S),_[0]=h,_[1]=u,_[2]=f)},this.commitFunction[Dh]=function(g,S){_=g.value,h=S[0],u=S[1],f=S[2],m=S[3],(_[0]!==h||_[1]!==u||_[2]!==f||_[3]!==m)&&(i.uniform4uiv(g.locationId,S),_[0]=h,_[1]=u,_[2]=f,_[3]=m)},this.commitFunction[Ph]=function(g,S){i.uniform1iv(g.locationId,S)},this.commitFunction[_v]=function(g,S){i.uniform1uiv(g.locationId,S)},this.commitFunction[gv]=this.commitFunction[Ph],this.commitFunction[Rh]=function(g,S){i.uniform2iv(g.locationId,S)},this.commitFunction[vv]=function(g,S){i.uniform2uiv(g.locationId,S)},this.commitFunction[Sv]=this.commitFunction[Rh],this.commitFunction[Mh]=function(g,S){i.uniform3iv(g.locationId,S)},this.commitFunction[yv]=function(g,S){i.uniform3uiv(g.locationId,S)},this.commitFunction[xv]=this.commitFunction[Mh],this.commitFunction[ag]=function(g,S){i.uniform4iv(g.locationId,S)},this.commitFunction[TE]=function(g,S){i.uniform4uiv(g.locationId,S)},this.commitFunction[EE]=this.commitFunction[ag],this.commitFunction[qM]=function(g,S){i.uniformMatrix4fv(g.locationId,!1,S)},this.constantTexSource=this.scope.resolve("source"),this.postInit()}}class ak{unlock(e){}}class nk{destroy(e){}init(e,t){}loseContext(){}resolve(e,t,s,i){}}class ok{destroy(e){}loseContext(){}restoreContext(e,t){}}class lk{destroy(e){}propertyChanged(e){}loseContext(){}}class ck{destroy(e){}unlock(e){}}class hk{add(e,t,s,i){}}class v2 extends Yh{destroy(){super.destroy()}initDeviceCaps(){this.disableParticleSystem=!0,this.precision="highp",this.maxPrecision="highp",this.maxSamples=4,this.maxTextures=16,this.maxTextureSize=4096,this.maxCubeMapSize=4096,this.maxVolumeSize=4096,this.maxColorAttachments=8,this.maxPixelRatio=1,this.maxAnisotropy=16,this.supportsUniformBuffers=!1,this.supportsAreaLights=!0,this.supportsGpuParticles=!1,this.textureFloatRenderable=!0,this.textureHalfFloatRenderable=!0,this.supportsImageBitmap=!1}postInit(){super.postInit()}frameStart(){super.frameStart()}frameEnd(){super.frameEnd()}updateBegin(){}updateEnd(){}readPixels(e,t,s,i,r){}createVertexBufferImpl(e,t){return new ck(e,t)}createIndexBufferImpl(e){return new ak(e)}createShaderImpl(e){return new ok(e)}createTextureImpl(e){return new lk(e)}createRenderTargetImpl(e){return new nk(e)}createDrawCommandImpl(e){return new hk}createUploadStreamImpl(e){return null}draw(e,t,s,i,r=!0,a=!0){}setShader(e,t=!1){}setBlendState(e){}setDepthState(e){}setStencilState(e,t){}setBlendColor(e,t,s,i){}setCullMode(e){}setAlphaToCoverage(e){}initializeContextCaches(){super.initializeContextCaches()}clear(e){}setViewport(e,t,s,i){}setScissor(e,t,s,i){}copyRenderTarget(e,t,s,i){return!0}constructor(e,t={}){super(e,t),t=this.initOptions,this.isNull=!0,this._deviceType=og,this.samples=1,this.backBuffer=new At({name:"Framebuffer",graphicsDevice:this,depth:this.initOptions.depth,stencil:this.supportsStencil,samples:this.samples}),this.initDeviceCaps()}}class uk{constructor(){this.scopeId=null}}class sf{setParameter(e,t){let s=this.parameters.get(e);s||(s=new uk,s.scopeId=this.device.scope.resolve(e),this.parameters.set(e,s)),s.value=t}getParameter(e){return this.parameters.get(e)?.value}deleteParameter(e){this.parameters.delete(e)}applyParameters(){for(const[,e]of this.parameters)e.scopeId.setValue(e.value)}setupDispatch(e,t,s){this.countX=e,this.countY=t,this.countZ=s,this.indirectSlotIndex=-1,this.indirectBuffer=null}setupIndirectDispatch(e,t=null){this.indirectSlotIndex=e,this.indirectBuffer=t,this.indirectFrameStamp=this.device.renderVersion}constructor(e,t,s="Unnamed"){this.shader=null,this.parameters=new Map,this.countX=1,this.indirectSlotIndex=-1,this.indirectBuffer=null,this.indirectFrameStamp=0,this.device=e,this.shader=t,this.name=s,e.supportsCompute&&(this.impl=e.createComputeImpl(this))}}class ED{get maxCount(){return this._maxCount}get count(){return this._count}destroy(){this.impl?.destroy?.(),this.impl=null}allocate(e){this._maxCount=e,this.impl.allocate?.(e)}add(e,t,s,i,r=0,a=0){this.impl.add(e,t,s,i,r,a)}update(e){this._count=e,this.primitiveCount=this.impl.update?.(e)??0}constructor(e,t=0){this._maxCount=0,this.impl=null,this._count=1,this.slotIndex=0,this.primitiveCount=0,this.device=e,this.indexSizeBytes=t,this.impl=e.createDrawCommandImpl(this)}}let dk=0;class bl{destroy(){const e=this.device;e.buffers.delete(this),this.device.indexBuffer===this&&(this.device.indexBuffer=null),this.impl.initialized&&(this.impl.destroy(e),this.adjustVramSizeTracking(e._vram,-this.storage.byteLength))}adjustVramSizeTracking(e,t){e.ib+=t}loseContext(){this.impl.loseContext()}getFormat(){return this.format}getNumIndices(){return this.numIndices}lock(){return this.storage}unlock(){this.impl.unlock(this)}setData(e){return e.byteLength!==this.numBytes?!1:(this.storage=e,this.unlock(),!0)}_lockTypedArray(){const e=this.lock();return this.format===eo?new Uint32Array(e):this.format===Ka?new Uint16Array(e):new Uint8Array(e)}writeData(e,t){const s=this._lockTypedArray();if(e.length>t)if(ArrayBuffer.isView(e))e=e.subarray(0,t),s.set(e);else for(let i=0;i<t;i++)s[i]=e[i];else s.set(e);this.unlock()}readData(e){const t=this._lockTypedArray(),s=this.numIndices;if(ArrayBuffer.isView(e))e.set(t);else{e.length=0;for(let i=0;i<s;i++)e[i]=t[i]}return s}constructor(e,t,s,i=Hi,r,a){this.device=e,this.format=t,this.numIndices=s,this.usage=i,this.id=dk++,this.impl=e.createIndexBufferImpl(this,a);const o=nU[t];this.bytesPerIndex=o,this.numBytes=this.numIndices*o,r?this.setData(r):this.storage=new ArrayBuffer(this.numBytes),this.adjustVramSizeTracking(e._vram,this.numBytes),this.device.buffers.add(this)}}class fk{constructor(){this.clearValue=new ue(0,0,0,1),this.clearValueLinear=new ue(0,0,0,1),this.clear=!1,this.store=!1,this.resolve=!0,this.genMipmaps=!1}}class mk{constructor(){this.clearDepthValue=1,this.clearStencilValue=0,this.clearDepth=!1,this.clearStencil=!1,this.storeDepth=!1,this.resolveDepth=!1,this.storeStencil=!1}}class ii{get colorOps(){return this.colorArrayOps[0]}set name(e){this._name=e}get name(){return this._name||(this._name=this.constructor.name),this._name}set scaleX(e){this._options.scaleX=e}get scaleX(){return this._options.scaleX}set scaleY(e){this._options.scaleY=e}get scaleY(){return this._options.scaleY}set options(e){this._options=e,e&&(this.scaleX=this.scaleX??1,this.scaleY=this.scaleY??1)}get options(){return this._options}init(e=null,t){this.options=t,this.renderTarget=e,this.samples=Math.max(this.renderTarget?this.renderTarget.samples:this.device.samples,1),this.allocateAttachments(),this.postInit()}allocateAttachments(){const e=this.renderTarget;this.depthStencilOps=new mk,e?.depthBuffer&&(this.depthStencilOps.storeDepth=!0);const t=e?e._colorBuffers?.length??0:1;this.colorArrayOps.length=0;for(let s=0;s<t;s++){const i=new fk;this.colorArrayOps[s]=i,this.samples===1&&(i.store=!0,i.resolve=!1);const r=this.renderTarget?._colorBuffers?.[s];if(this.renderTarget?.mipmaps&&r?.mipmaps){const a=qn(r._format);i.genMipmaps=!a}}}destroy(){}postInit(){}frameUpdate(){if(this._options&&this.renderTarget){const e=this._options.resizeSource??this.device.backBuffer,t=Math.floor(e.width*this.scaleX),s=Math.floor(e.height*this.scaleY);this.renderTarget.resize(t,s)}}before(){}execute(){}after(){}onEnable(){}onDisable(){}set enabled(e){this._enabled!==e&&(this._enabled=e,e?this.onEnable():this.onDisable())}get enabled(){return this._enabled}setClearColor(e){const t=this.colorArrayOps.length;for(let s=0;s<t;s++){const i=this.colorArrayOps[s];e&&(i.clearValue.copy(e),i.clearValueLinear.linear(e)),i.clear=!!e}}setClearDepth(e){e!==void 0&&(this.depthStencilOps.clearDepthValue=e),this.depthStencilOps.clearDepth=e!==void 0}setClearStencil(e){e!==void 0&&(this.depthStencilOps.clearStencilValue=e),this.depthStencilOps.clearStencil=e!==void 0}render(){if(this.enabled){const e=this.device,t=this.renderTarget!==void 0;this.before(),this.executeEnabled&&(t&&!this._skipStart&&e.startRenderPass(this),this.execute(),t&&!this._skipEnd&&e.endRenderPass(this)),this.after(),e.renderPassIndex++}}constructor(e){this._enabled=!0,this._skipStart=!1,this._skipEnd=!1,this.executeEnabled=!0,this.samples=0,this.colorArrayOps=[],this.requiresCubemaps=!0,this.fullSizeClearRect=!0,this.beforePasses=[],this.afterPasses=[],this.device=e}}function pk(c){this.array[this.index]=c}function _k(c,e){this.array[this.index]=c,this.array[this.index+1]=e}function gk(c,e,t){this.array[this.index]=c,this.array[this.index+1]=e,this.array[this.index+2]=t}function vk(c,e,t,s){this.array[this.index]=c,this.array[this.index+1]=e,this.array[this.index+2]=t,this.array[this.index+3]=s}function Sk(c,e,t){this.array[c]=e[t]}function yk(c,e,t){this.array[c]=e[t],this.array[c+1]=e[t+1]}function xk(c,e,t){this.array[c]=e[t],this.array[c+1]=e[t+1],this.array[c+2]=e[t+2]}function Tk(c,e,t){this.array[c]=e[t],this.array[c+1]=e[t+1],this.array[c+2]=e[t+2],this.array[c+3]=e[t+3]}function Ek(c,e,t){e[t]=this.array[c]}function bk(c,e,t){e[t]=this.array[c],e[t+1]=this.array[c+1]}function Ak(c,e,t){e[t]=this.array[c],e[t+1]=this.array[c+1],e[t+2]=this.array[c+2]}function wk(c,e,t){e[t]=this.array[c],e[t+1]=this.array[c+1],e[t+2]=this.array[c+2],e[t+3]=this.array[c+3]}class Ck{get(e){return this.array[this.index+e]}set(e,t,s,i){}getToArray(e,t,s){}setFromArray(e,t,s){}constructor(e,t,s){switch(this.index=0,this.numComponents=t.numComponents,s.interleaved?this.array=new gh[t.dataType](e,t.offset):this.array=new gh[t.dataType](e,t.offset,s.vertexCount*t.numComponents),this.stride=t.stride/this.array.constructor.BYTES_PER_ELEMENT,t.numComponents){case 1:this.set=pk,this.getToArray=Ek,this.setFromArray=Sk;break;case 2:this.set=_k,this.getToArray=bk,this.setFromArray=yk;break;case 3:this.set=gk,this.getToArray=Ak,this.setFromArray=xk;break;case 4:this.set=vk,this.getToArray=wk,this.setFromArray=Tk;break}}}class zd{next(e=1){let t=0;const s=this.accessors,i=this.accessors.length;for(;t<i;){const r=s[t++];r.index+=e*r.stride}}end(){this.vertexBuffer.unlock()}writeData(e,t,s){const i=this.element[e];if(i){s>this.vertexBuffer.numVertices&&(s=this.vertexBuffer.numVertices);const r=i.numComponents;if(this.vertexBuffer.getFormat().interleaved){let a=0;for(let o=0;o<s;o++)i.setFromArray(a,t,o*r),a+=i.stride}else if(t.length>s*r){const a=s*r;if(ArrayBuffer.isView(t))t=t.subarray(0,a),i.array.set(t);else for(let o=0;o<a;o++)i.array[o]=t[o]}else i.array.set(t)}}readData(e,t){const s=this.element[e];let i=0;if(s){i=this.vertexBuffer.numVertices;let r;const a=s.numComponents;if(this.vertexBuffer.getFormat().interleaved){Array.isArray(t)&&(t.length=0),s.index=0;let o=0;for(r=0;r<i;r++)s.getToArray(o,t,r*a),o+=s.stride}else if(ArrayBuffer.isView(t))t.set(s.array);else{t.length=0;const o=i*a;for(r=0;r<o;r++)t[r]=s.array[r]}}return i}constructor(e){this.vertexBuffer=e,this.vertexFormatSize=e.getFormat().size,this.buffer=this.vertexBuffer.lock(),this.accessors=[],this.element={};const t=this.vertexBuffer.getFormat();for(let s=0;s<t.elements.length;s++){const i=t.elements[s];this.accessors[s]=new Ck(this.buffer,i,t),this.element[i.name]=this.accessors[s]}}}const Dk=-1;function Yx(){return!!(document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement)}class nh{constructor(e,t){this.x=0,this.y=0,this.dx=0,this.dy=0,this.button=Dk,this.wheelDelta=0,this.ctrlKey=!1,this.altKey=!1,this.shiftKey=!1,this.metaKey=!1;let s={x:0,y:0};if(t){if(t instanceof nh)throw Error("Expected MouseEvent");s=e._getTargetCoords(t)}else t={};if(s)this.x=s.x,this.y=s.y;else if(Yx())this.x=0,this.y=0;else return;t.type==="wheel"&&(t.deltaY>0?this.wheelDelta=1:t.deltaY<0&&(this.wheelDelta=-1)),Yx()?(this.dx=t.movementX||t.webkitMovementX||t.mozMovementX||0,this.dy=t.movementY||t.webkitMovementY||t.mozMovementY||0):(this.dx=this.x-e._lastX,this.dy=this.y-e._lastY),(t.type==="mousedown"||t.type==="mouseup")&&(this.button=t.button),this.buttons=e._buttons.slice(0),this.element=t.target,this.ctrlKey=t.ctrlKey??!1,this.altKey=t.altKey??!1,this.shiftKey=t.shiftKey??!1,this.metaKey=t.metaKey??!1,this.event=t}}class Gf extends Pe{static isPointerLocked(){return Yx()}attach(e){if(this._target=e,this._attached)return;this._attached=!0;const t={passive:!1},s=Ve.passiveEvents?t:!1;window.addEventListener("mouseup",this._upHandler,s),window.addEventListener("mousedown",this._downHandler,s),window.addEventListener("mousemove",this._moveHandler,s),window.addEventListener("wheel",this._wheelHandler,s)}detach(){if(!this._attached)return;this._attached=!1,this._target=null;const e={passive:!1},t=Ve.passiveEvents?e:!1;window.removeEventListener("mouseup",this._upHandler,t),window.removeEventListener("mousedown",this._downHandler,t),window.removeEventListener("mousemove",this._moveHandler,t),window.removeEventListener("wheel",this._wheelHandler,t)}disableContextMenu(){this._target&&this._target.addEventListener("contextmenu",this._contextMenuHandler)}enableContextMenu(){this._target&&this._target.removeEventListener("contextmenu",this._contextMenuHandler)}enablePointerLock(e,t){if(!document.body.requestPointerLock){t&&t();return}const s=()=>{e(),document.removeEventListener("pointerlockchange",s)},i=()=>{t(),document.removeEventListener("pointerlockerror",i)};e&&document.addEventListener("pointerlockchange",s,!1),t&&document.addEventListener("pointerlockerror",i,!1),document.body.requestPointerLock()}disablePointerLock(e){if(!document.exitPointerLock)return;const t=()=>{e(),document.removeEventListener("pointerlockchange",t)};e&&document.addEventListener("pointerlockchange",t,!1),document.exitPointerLock()}update(){this._lastbuttons[0]=this._buttons[0],this._lastbuttons[1]=this._buttons[1],this._lastbuttons[2]=this._buttons[2]}isPressed(e){return this._buttons[e]}wasPressed(e){return this._buttons[e]&&!this._lastbuttons[e]}wasReleased(e){return!this._buttons[e]&&this._lastbuttons[e]}_handleUp(e){this._buttons[e.button]=!1;const t=new nh(this,e);t.event&&this.fire("mouseup",t)}_handleDown(e){this._buttons[e.button]=!0;const t=new nh(this,e);t.event&&this.fire("mousedown",t)}_handleMove(e){const t=new nh(this,e);t.event&&(this.fire("mousemove",t),this._lastX=t.x,this._lastY=t.y)}_handleWheel(e){const t=new nh(this,e);t.event&&this.fire("mousewheel",t)}_getTargetCoords(e){const t=this._target.getBoundingClientRect(),s=Math.floor(t.left),i=Math.floor(t.top);return e.clientX<s||e.clientX>=s+this._target.clientWidth||e.clientY<i||e.clientY>=i+this._target.clientHeight?null:{x:e.clientX-s,y:e.clientY-i}}constructor(e){super(),this._lastX=0,this._lastY=0,this._buttons=[!1,!1,!1],this._lastbuttons=[!1,!1,!1],this._target=null,this._attached=!1,this._upHandler=this._handleUp.bind(this),this._downHandler=this._handleDown.bind(this),this._moveHandler=this._handleMove.bind(this),this._wheelHandler=this._handleWheel.bind(this),this._contextMenuHandler=t=>{t.preventDefault()},this.attach(e)}}Gf.EVENT_MOUSEMOVE="mousemove";Gf.EVENT_MOUSEDOWN="mousedown";Gf.EVENT_MOUSEUP="mouseup";Gf.EVENT_MOUSEWHEEL="mousewheel";function Pk(c){let e=0,t=0,s=c.target;for(;!(s instanceof HTMLElement)&&s;)s=s.parentNode;for(;s;)e+=s.offsetLeft-s.scrollLeft,t+=s.offsetTop-s.scrollTop,s=s.offsetParent;return{x:c.pageX-e,y:c.pageY-t}}class bD{constructor(e){const t=Pk(e);this.id=e.identifier,this.x=t.x,this.y=t.y,this.target=e.target,this.touch=e}}class Mp{getTouchById(e,t){return t.find(s=>s.id===e)||null}constructor(e,t){this.touches=[],this.changedTouches=[],this.element=t.target,this.event=t,this.touches=Array.from(t.touches).map(s=>new bD(s)),this.changedTouches=Array.from(t.changedTouches).map(s=>new bD(s))}}class Hf extends Pe{attach(e){this._element&&this.detach(),this._element=e,this._element.addEventListener("touchstart",this._startHandler,!1),this._element.addEventListener("touchend",this._endHandler,!1),this._element.addEventListener("touchmove",this._moveHandler,!1),this._element.addEventListener("touchcancel",this._cancelHandler,!1)}detach(){this._element&&(this._element.removeEventListener("touchstart",this._startHandler,!1),this._element.removeEventListener("touchend",this._endHandler,!1),this._element.removeEventListener("touchmove",this._moveHandler,!1),this._element.removeEventListener("touchcancel",this._cancelHandler,!1)),this._element=null}_handleTouchStart(e){this.fire("touchstart",new Mp(this,e))}_handleTouchEnd(e){this.fire("touchend",new Mp(this,e))}_handleTouchMove(e){e.preventDefault(),this.fire("touchmove",new Mp(this,e))}_handleTouchCancel(e){this.fire("touchcancel",new Mp(this,e))}constructor(e){super(),this._element=null,this._startHandler=this._handleTouchStart.bind(this),this._endHandler=this._handleTouchEnd.bind(this),this._moveHandler=this._handleTouchMove.bind(this),this._cancelHandler=this._handleTouchCancel.bind(this),this.attach(e)}}Hf.EVENT_TOUCHSTART="touchstart";Hf.EVENT_TOUCHEND="touchend";Hf.EVENT_TOUCHMOVE="touchmove";Hf.EVENT_TOUCHCANCEL="touchcancel";class Oe{get(e,t,s){typeof t=="function"&&(s=t,t={});const i=this.request("GET",e,t,s),{progress:r}=t;if(r){const a=h=>{h.lengthComputable&&r.fire("progress",h.loaded,h.total)},o=h=>{a(h),i.removeEventListener("loadstart",a),i.removeEventListener("progress",a),i.removeEventListener("loadend",o)};i.addEventListener("loadstart",a),i.addEventListener("progress",a),i.addEventListener("loadend",o)}return i}post(e,t,s,i){return typeof s=="function"&&(i=s,s={}),s.postdata=t,this.request("POST",e,s,i)}put(e,t,s,i){return typeof s=="function"&&(i=s,s={}),s.postdata=t,this.request("PUT",e,s,i)}del(e,t,s){return typeof t=="function"&&(s=t,t={}),this.request("DELETE",e,t,s)}request(e,t,s,i){let r,a,o,h=!1;if(typeof s=="function"&&(i=s,s={}),s.retry&&(s=Object.assign({retries:0,maxRetries:5},s)),s.callback=i,s.async==null&&(s.async=!0),s.headers==null&&(s.headers={}),s.postdata!=null)if(s.postdata instanceof Document)o=s.postdata;else if(s.postdata instanceof FormData)o=s.postdata;else if(s.postdata instanceof Object){let f=s.headers["Content-Type"];switch(f===void 0&&(s.headers["Content-Type"]=Oe.ContentType.FORM_URLENCODED,f=s.headers["Content-Type"]),f){case Oe.ContentType.FORM_URLENCODED:{o="";let m=!0;for(const _ in s.postdata)if(s.postdata.hasOwnProperty(_)){m?m=!1:o+="&";const g=encodeURIComponent(_),S=encodeURIComponent(s.postdata[_]);o+=`${g}=${S}`}break}default:case Oe.ContentType.JSON:f==null&&(s.headers["Content-Type"]=Oe.ContentType.JSON),o=JSON.stringify(s.postdata);break}}else o=s.postdata;if(s.cache===!1){const f=vs();r=new a0(t),r.query?r.query=`${r.query}&ts=${f}`:r.query=`ts=${f}`,t=r.toString()}s.query&&(r=new a0(t),a=V_(r.getQuery(),s.query),r.setQuery(a),t=r.toString());const u=new XMLHttpRequest;u.open(e,t,s.async),u.withCredentials=s.withCredentials!==void 0?s.withCredentials:!1,u.responseType=s.responseType||this._guessResponseType(t);for(const f in s.headers)s.headers.hasOwnProperty(f)&&u.setRequestHeader(f,s.headers[f]);u.onreadystatechange=()=>{this._onReadyStateChange(e,t,s,u)},u.onerror=()=>{this._onError(e,t,s,u),h=!0};try{u.send(o)}catch(f){h||s.error(u.status,u,f)}return u}_guessResponseType(e){const t=new a0(e),s=Re.getExtension(t.path).toLowerCase();return Oe.binaryExtensions.indexOf(s)>=0?Oe.ResponseType.ARRAY_BUFFER:s===".json"?Oe.ResponseType.JSON:s===".xml"?Oe.ResponseType.DOCUMENT:Oe.ResponseType.TEXT}_isBinaryContentType(e){return[Oe.ContentType.BASIS,Oe.ContentType.BIN,Oe.ContentType.DDS,Oe.ContentType.GLB,Oe.ContentType.MP3,Oe.ContentType.MP4,Oe.ContentType.OGG,Oe.ContentType.OPUS,Oe.ContentType.WAV].indexOf(e)>=0}_isBinaryResponseType(e){return e===Oe.ResponseType.ARRAY_BUFFER||e===Oe.ResponseType.BLOB||e===Oe.ResponseType.JSON}_onReadyStateChange(e,t,s,i){if(i.readyState===4)switch(i.status){case 0:{i.responseURL&&i.responseURL.startsWith("file:///")?this._onSuccess(e,t,s,i):this._onError(e,t,s,i);break}case 200:case 201:case 206:case 304:{this._onSuccess(e,t,s,i);break}default:{this._onError(e,t,s,i);break}}}_onSuccess(e,t,s,i){let r,a;const o=i.getResponseHeader("Content-Type");o&&(a=o.split(";")[0].trim());try{this._isBinaryContentType(a)||this._isBinaryResponseType(i.responseType)?r=i.response:a===Oe.ContentType.JSON||t.split("?")[0].endsWith(".json")?r=JSON.parse(i.responseText):i.responseType===Oe.ResponseType.DOCUMENT||a===Oe.ContentType.XML?r=i.responseXML:r=i.responseText,s.callback(null,r)}catch(h){s.callback(h)}}_onError(e,t,s,i){if(!s.retrying)if(s.retry&&s.retries<s.maxRetries){s.retries++,s.retrying=!0;const r=J.clamp(Math.pow(2,s.retries)*Oe.retryDelay,0,s.maxRetryDelay||5e3);console.log(`${e}: ${t} - Error ${i.status}. Retrying in ${r} ms`),setTimeout(()=>{s.retrying=!1,this.request(e,t,s,s.callback)},r)}else s.callback(i.status===0?"Network error":i.status,null)}}Oe.ContentType={AAC:"audio/aac",BASIS:"image/basis",BIN:"application/octet-stream",DDS:"image/dds",FORM_URLENCODED:"application/x-www-form-urlencoded",GIF:"image/gif",GLB:"model/gltf-binary",JPEG:"image/jpeg",JSON:"application/json",MP3:"audio/mpeg",MP4:"audio/mp4",OGG:"audio/ogg",OPUS:'audio/ogg; codecs="opus"',PNG:"image/png",TEXT:"text/plain",WAV:"audio/x-wav",XML:"application/xml"};Oe.ResponseType={TEXT:"text",ARRAY_BUFFER:"arraybuffer",BLOB:"blob",DOCUMENT:"document",JSON:"json"};Oe.binaryExtensions=[".model",".wav",".ogg",".mp3",".mp4",".m4a",".aac",".dds",".basis",".glb",".opus"];Oe.retryDelay=100;const Pt=new Oe,CE="linear",Rk="inverse",Mk="exponential";class Lk{getPosition(){return this.position}setPosition(e){this.position.copy(e);const t=this.listener;t&&("positionX"in t?(t.positionX.value=e.x,t.positionY.value=e.y,t.positionZ.value=e.z):t.setPosition&&t.setPosition(e.x,e.y,e.z))}setOrientation(e){this.orientation.copy(e);const t=this.listener;if(t){const s=e.data;"forwardX"in t?(t.forwardX.value=-s[8],t.forwardY.value=-s[9],t.forwardZ.value=-s[10],t.upX.value=s[4],t.upY.value=s[5],t.upZ.value=s[6]):t.setOrientation&&t.setOrientation(-s[8],-s[9],-s[10],s[4],s[5],s[6])}}getOrientation(){return this.orientation}get listener(){const e=this._manager.context;return e?e.listener:null}constructor(e){this.position=new D,this.orientation=new fe,this._manager=e}}const Lp="running",AD=["click","touchstart","mousedown"];class Ik extends Pe{set volume(e){e=J.clamp(e,0,1),this._volume=e,this.fire("volumechange",e)}get volume(){return this._volume}get suspended(){return this._userSuspended}get context(){return!this._context&&this.AudioContext&&(this._context=new this.AudioContext,this._context.state!==Lp&&this._registerUnlockListeners()),this._context}suspend(){this._userSuspended||(this._userSuspended=!0,this._context&&this._context.state===Lp&&this._suspend())}resume(){this._userSuspended&&(this._userSuspended=!1,this._context&&this._context.state!==Lp&&this._resume())}destroy(){this.fire("destroy"),this._context&&(this._removeUnlockListeners(),this._context?.close(),this._context=null)}_resume(){this._context.resume().then(()=>{const e=this._context.createBufferSource();e.buffer=this._context.createBuffer(1,1,this._context.sampleRate),e.connect(this._context.destination),e.start(0),e.onended=t=>{e.disconnect(0),this.fire("resume")}},e=>{}).catch(e=>{})}_suspend(){this._context.suspend().then(()=>{this.fire("suspend")},e=>{}).catch(e=>{})}_unlockHandler(){this._removeUnlockListeners(),!this._userSuspended&&this._context.state!==Lp&&this._resume()}_registerUnlockListeners(){AD.forEach(e=>{window.addEventListener(e,this._unlockHandlerFunc,!1)})}_removeUnlockListeners(){AD.forEach(e=>{window.removeEventListener(e,this._unlockHandlerFunc,!1)})}constructor(){super(),this._context=null,this.AudioContext=typeof AudioContext<"u"&&AudioContext||typeof webkitAudioContext<"u"&&webkitAudioContext,this.AudioContext,this._unlockHandlerFunc=this._unlockHandler.bind(this),this._userSuspended=!1,this.listener=new Lk(this),this._volume=1}}class Ok{get duration(){let e=0;return this.buffer?e=this.buffer.duration:this.audio&&(e=this.audio.duration),e||0}constructor(e){e instanceof Audio?this.audio=e:this.buffer=e}}function Wf(){return typeof AudioContext<"u"||typeof webkitAudioContext<"u"}const js=0,oh=1,cr=2;function $s(c,e){return c%e||0}class Vi extends Pe{set currentTime(e){if(!(e<0))if(this._state===js){const t=this._suspendInstanceEvents;this._suspendInstanceEvents=!0,this.stop(),this._startOffset=e,this.play(),this._suspendInstanceEvents=t}else this._startOffset=e,this._currentTime=e}get currentTime(){return this._startOffset!==null?this._startOffset:this._state===oh?this._currentTime:this._state===cr||!this.source?0:(this._updateCurrentTime(),this._currentTime)}set duration(e){this._duration=Math.max(0,Number(e)||0);const t=this._state===js;this.stop(),t&&this.play()}get duration(){return this._sound?this._duration?$s(this._duration,this._sound.duration):this._sound.duration:0}get isPaused(){return this._state===oh}get isPlaying(){return this._state===js}get isStopped(){return this._state===cr}get isSuspended(){return this._suspended}set loop(e){this._loop=!!e,this.source&&(this.source.loop=this._loop)}get loop(){return this._loop}set pitch(e){this._currentOffset=this.currentTime,this._startedAt=this._manager.context.currentTime,this._pitch=Math.max(Number(e)||0,.01),this.source&&(this.source.playbackRate.value=this._pitch)}get pitch(){return this._pitch}set sound(e){this._sound=e,this._state!==cr?this.stop():this._createSource()}get sound(){return this._sound}set startTime(e){this._startTime=Math.max(0,Number(e)||0);const t=this._state===js;this.stop(),t&&this.play()}get startTime(){return this._startTime}set volume(e){e=J.clamp(e,0,1),this._volume=e,this.gain&&(this.gain.gain.value=e*this._manager.volume)}get volume(){return this._volume}_onPlay(){this.fire("play"),this._onPlayCallback&&this._onPlayCallback(this)}_onPause(){this.fire("pause"),this._onPauseCallback&&this._onPauseCallback(this)}_onResume(){this.fire("resume"),this._onResumeCallback&&this._onResumeCallback(this)}_onStop(){this.fire("stop"),this._onStopCallback&&this._onStopCallback(this)}_onEnded(){if(this._suspendEndEvent>0){this._suspendEndEvent--;return}this.fire("end"),this._onEndCallback&&this._onEndCallback(this),this.stop()}_onManagerVolumeChange(){this.volume=this._volume}_onManagerSuspend(){this._state===js&&!this._suspended&&(this._suspended=!0,this.pause())}_onManagerResume(){this._suspended&&(this._suspended=!1,this.resume())}_initializeNodes(){this.gain=this._manager.context.createGain(),this._inputNode=this.gain,this._connectorNode=this.gain,this._connectorNode.connect(this._manager.context.destination)}play(){return this._state!==cr&&this.stop(),this._state=js,this._playWhenLoaded=!1,this._waitingContextSuspension?!1:this._manager.suspended?(this._manager.once("resume",this._playAudioImmediate,this),this._waitingContextSuspension=!0,!1):(this._playAudioImmediate(),!0)}_playAudioImmediate(){if(this._waitingContextSuspension=!1,this._state!==js)return;this.source||this._createSource();let e=$s(this._startOffset,this.duration);e=$s(this._startTime+e,this._sound.duration),this._startOffset=null,this._duration?this.source.start(0,e,this._duration):this.source.start(0,e),this._startedAt=this._manager.context.currentTime,this._currentTime=0,this._currentOffset=e,this.volume=this._volume,this.loop=this._loop,this.pitch=this._pitch,this._manager.on("volumechange",this._onManagerVolumeChange,this),this._manager.on("suspend",this._onManagerSuspend,this),this._manager.on("resume",this._onManagerResume,this),this._manager.on("destroy",this._onManagerDestroy,this),this._suspendInstanceEvents||this._onPlay()}pause(){return this._playWhenLoaded=!1,this._state!==js?!1:(this._state=oh,this._waitingContextSuspension||(this._updateCurrentTime(),this._suspendEndEvent++,this.source.stop(0),this.source=null,this._startOffset=null,this._suspendInstanceEvents||this._onPause()),!0)}resume(){if(this._state!==oh)return!1;let e=this.currentTime;return this._state=js,this._waitingContextSuspension||(this.source||this._createSource(),this._startOffset!==null&&(e=$s(this._startOffset,this.duration),e=$s(this._startTime+e,this._sound.duration),this._startOffset=null),this._duration?this.source.start(0,e,this._duration):this.source.start(0,e),this._startedAt=this._manager.context.currentTime,this._currentOffset=e,this.volume=this._volume,this.loop=this._loop,this.pitch=this._pitch,this._playWhenLoaded=!1,this._suspendInstanceEvents||this._onResume()),!0}stop(){if(this._playWhenLoaded=!1,this._state===cr)return!1;const e=this._state===js;return this._state=cr,this._waitingContextSuspension||(this._manager.off("volumechange",this._onManagerVolumeChange,this),this._manager.off("suspend",this._onManagerSuspend,this),this._manager.off("resume",this._onManagerResume,this),this._manager.off("destroy",this._onManagerDestroy,this),this._startedAt=0,this._currentTime=0,this._currentOffset=0,this._startOffset=null,this._suspendEndEvent++,e&&this.source&&this.source.stop(0),this.source=null,this._suspendInstanceEvents||this._onStop()),!0}setExternalNodes(e,t){if(!e){console.error("The firstNode must be a valid Audio Node");return}t||(t=e);const s=this._manager.context.destination;this._firstNode!==e&&(this._firstNode?this._connectorNode.disconnect(this._firstNode):this._connectorNode.disconnect(s),this._firstNode=e,this._connectorNode.connect(e)),this._lastNode!==t&&(this._lastNode&&this._lastNode.disconnect(s),this._lastNode=t,this._lastNode.connect(s))}clearExternalNodes(){const e=this._manager.context.destination;this._firstNode&&(this._connectorNode.disconnect(this._firstNode),this._firstNode=null),this._lastNode&&(this._lastNode.disconnect(e),this._lastNode=null),this._connectorNode.connect(e)}getExternalNodes(){return[this._firstNode,this._lastNode]}_createSource(){if(!this._sound)return null;const e=this._manager.context;return this._sound.buffer&&(this.source=e.createBufferSource(),this.source.buffer=this._sound.buffer,this.source.connect(this._inputNode),this.source.onended=this._endedHandler,this.source.loopStart=$s(this._startTime,this.source.buffer.duration),this._duration&&(this.source.loopEnd=Math.max(this.source.loopStart,$s(this._startTime+this._duration,this.source.buffer.duration)))),this.source}_updateCurrentTime(){this._currentTime=$s((this._manager.context.currentTime-this._startedAt)*this._pitch+this._currentOffset,this.duration)}_onManagerDestroy(){this.source&&this._state===js&&(this.source.stop(0),this.source=null)}constructor(e,t,s){super(),this.source=null,this._manager=e,this._volume=s.volume!==void 0?J.clamp(Number(s.volume)||0,0,1):1,this._pitch=s.pitch!==void 0?Math.max(.01,Number(s.pitch)||0):1,this._loop=!!(s.loop!==void 0&&s.loop),this._sound=t,this._state=cr,this._suspended=!1,this._suspendEndEvent=0,this._suspendInstanceEvents=!1,this._playWhenLoaded=!0,this._startTime=Math.max(0,Number(s.startTime)||0),this._duration=Math.max(0,Number(s.duration)||0),this._startOffset=null,this._onPlayCallback=s.onPlay,this._onPauseCallback=s.onPause,this._onResumeCallback=s.onResume,this._onStopCallback=s.onStop,this._onEndCallback=s.onEnd,Wf()?(this._startedAt=0,this._currentTime=0,this._currentOffset=0,this._inputNode=null,this._connectorNode=null,this._firstNode=null,this._lastNode=null,this._waitingContextSuspension=!1,this._initializeNodes(),this._endedHandler=this._onEnded.bind(this)):(this._isReady=!1,this._loadedMetadataHandler=this._onLoadedMetadata.bind(this),this._timeUpdateHandler=this._onTimeUpdate.bind(this),this._endedHandler=this._onEnded.bind(this),this._createSource())}}Vi.EVENT_PLAY="play";Vi.EVENT_PAUSE="pause";Vi.EVENT_RESUME="resume";Vi.EVENT_STOP="stop";Vi.EVENT_END="end";Wf()||(Object.assign(Vi.prototype,{play:function(){return this._state!==cr&&this.stop(),!this.source&&!this._createSource()?!1:(this.volume=this._volume,this.pitch=this._pitch,this.loop=this._loop,this.source.play(),this._state=js,this._playWhenLoaded=!1,this._manager.on("volumechange",this._onManagerVolumeChange,this),this._manager.on("suspend",this._onManagerSuspend,this),this._manager.on("resume",this._onManagerResume,this),this._manager.on("destroy",this._onManagerDestroy,this),this._manager.suspended&&this._onManagerSuspend(),this._suspendInstanceEvents||this._onPlay(),!0)},pause:function(){return!this.source||this._state!==js?!1:(this._suspendEndEvent++,this.source.pause(),this._playWhenLoaded=!1,this._state=oh,this._startOffset=null,this._suspendInstanceEvents||this._onPause(),!0)},resume:function(){return!this.source||this._state!==oh?!1:(this._state=js,this._playWhenLoaded=!1,this.source.paused&&(this.source.play(),this._suspendInstanceEvents||this._onResume()),!0)},stop:function(){return!this.source||this._state===cr?!1:(this._manager.off("volumechange",this._onManagerVolumeChange,this),this._manager.off("suspend",this._onManagerSuspend,this),this._manager.off("resume",this._onManagerResume,this),this._manager.off("destroy",this._onManagerDestroy,this),this._suspendEndEvent++,this.source.pause(),this._playWhenLoaded=!1,this._state=cr,this._startOffset=null,this._suspendInstanceEvents||this._onStop(),!0)},setExternalNodes:function(){},clearExternalNodes:function(){},getExternalNodes:function(){return[null,null]},_onLoadedMetadata:function(){this.source.removeEventListener("loadedmetadata",this._loadedMetadataHandler),this._isReady=!0;let c=$s(this._startOffset,this.duration);c=$s(this._startTime+c,this._sound.duration),this._startOffset=null,this.source.currentTime=c},_createSource:function(){return this._sound&&this._sound.audio&&(this._isReady=!1,this.source=this._sound.audio.cloneNode(!0),this.source.addEventListener("loadedmetadata",this._loadedMetadataHandler),this.source.addEventListener("timeupdate",this._timeUpdateHandler),this.source.onended=this._endedHandler),this.source},_onTimeUpdate:function(){this._duration&&this.source.currentTime>$s(this._startTime+this._duration,this.source.duration)&&(this.loop?this.source.currentTime=$s(this._startTime,this.source.duration):(this.source.removeEventListener("timeupdate",this._timeUpdateHandler),this.source.pause(),this._onEnded()))},_onManagerDestroy:function(){this.source&&this.source.pause()}}),Object.defineProperty(Vi.prototype,"volume",{get:function(){return this._volume},set:function(c){c=J.clamp(c,0,1),this._volume=c,this.source&&(this.source.volume=c*this._manager.volume)}}),Object.defineProperty(Vi.prototype,"pitch",{get:function(){return this._pitch},set:function(c){this._pitch=Math.max(Number(c)||0,.01),this.source&&(this.source.playbackRate=this._pitch)}}),Object.defineProperty(Vi.prototype,"sound",{get:function(){return this._sound},set:function(c){this.stop(),this._sound=c}}),Object.defineProperty(Vi.prototype,"currentTime",{get:function(){return this._startOffset!==null?this._startOffset:this._state===cr||!this.source?0:this.source.currentTime-this._startTime},set:function(c){c<0||(this._startOffset=c,this.source&&this._isReady&&(this.source.currentTime=$s(this._startTime+$s(c,this.duration),this._sound.duration),this._startOffset=null))}}));const Nk=1e4;class sh extends Vi{_initializeNodes(){this.gain=this._manager.context.createGain(),this.panner=this._manager.context.createPanner(),this.panner.connect(this.gain),this._inputNode=this.panner,this._connectorNode=this.gain,this._connectorNode.connect(this._manager.context.destination)}set position(e){this._position.copy(e);const t=this.panner;"positionX"in t?(t.positionX.value=e.x,t.positionY.value=e.y,t.positionZ.value=e.z):t.setPosition&&t.setPosition(e.x,e.y,e.z)}get position(){return this._position}set velocity(e){this._velocity.copy(e)}get velocity(){return this._velocity}set maxDistance(e){this.panner.maxDistance=e}get maxDistance(){return this.panner.maxDistance}set refDistance(e){this.panner.refDistance=e}get refDistance(){return this.panner.refDistance}set rollOffFactor(e){this.panner.rolloffFactor=e}get rollOffFactor(){return this.panner.rolloffFactor}set distanceModel(e){this.panner.distanceModel=e}get distanceModel(){return this.panner.distanceModel}constructor(e,t,s={}){super(e,t,s),this._position=new D,this._velocity=new D,s.position&&(this.position=s.position),this.maxDistance=s.maxDistance!==void 0?Number(s.maxDistance):Nk,this.refDistance=s.refDistance!==void 0?Number(s.refDistance):1,this.rollOffFactor=s.rollOffFactor!==void 0?Number(s.rollOffFactor):1,this.distanceModel=s.distanceModel!==void 0?s.distanceModel:CE}}if(!Wf()){let c=new D;const e=function(t,s,i,r,a,o){c=c.sub2(t,s);const h=c.length();if(h<i)return 1;if(h>r)return 0;let u=0;return o===CE?u=1-a*(h-i)/(r-i):o===Rk?u=i/(i+a*(h-i)):o===Mk&&(u=Math.pow(h/i,-a)),J.clamp(u,0,1)};Object.defineProperty(sh.prototype,"position",{get:function(){return this._position},set:function(t){if(this._position.copy(t),this.source){const i=this._manager.listener.getPosition(),r=e(i,this._position,this.refDistance,this.maxDistance,this.rollOffFactor,this.distanceModel),a=this.volume;this.source.volume=a*r*this._manager.volume}}}),Object.defineProperty(sh.prototype,"maxDistance",{get:function(){return this._maxDistance},set:function(t){this._maxDistance=t}}),Object.defineProperty(sh.prototype,"refDistance",{get:function(){return this._refDistance},set:function(t){this._refDistance=t}}),Object.defineProperty(sh.prototype,"rollOffFactor",{get:function(){return this._rollOffFactor},set:function(t){this._rollOffFactor=t}}),Object.defineProperty(sh.prototype,"distanceModel",{get:function(){return this._distanceModel},set:function(t){this._distanceModel=t}})}const DE=0,rf=1,jr=2,qi=3,ro=4,PE=5,RE=6,ME=7,LE=8,IE=9,OE=10,S2={[DE]:"SUBTRACTIVE",[rf]:"ADDITIVE",[jr]:"NORMAL",[qi]:"NONE",[ro]:"PREMULTIPLIED",[PE]:"MULTIPLICATIVE",[RE]:"ADDITIVEALPHA",[ME]:"MULTIPLICATIVE2X",[LE]:"SCREEN",[IE]:"MIN",[OE]:"MAX"},Kh="none",Fk="linear",Bk=0,NE=2,Uk={[Bk]:"NONE",[NE]:"SCHLICK"},zk=0,y2=15,sn=0,xi=1,FE=2,BE=3,Cv=4,Ne=0,wt=1,bt=2,wD={[Ne]:"DIRECTIONAL",[wt]:"OMNI",[bt]:"SPOT"},E_=100,_r=0,x2=1,T2=2,E2=3,kk={[_r]:"PUNCTUAL",[x2]:"RECT",[T2]:"DISK",[E2]:"SPHERE"},UE=0,b2=1,Vk={[UE]:"LINEAR",[b2]:"INVERSESQUARED"},ur=0,jx=2,zE=3,Gk=4,A2=5,af=6,w2=7,C2=8,Hk=9,Xa=new Map([[A2,{name:"PCF1_32F",kind:"PCF1",format:Br,pcf:!0}],[ur,{name:"PCF3_32F",kind:"PCF3",format:Br,pcf:!0}],[Gk,{name:"PCF5_32F",kind:"PCF5",format:Br,pcf:!0}],[w2,{name:"PCF1_16F",kind:"PCF1",format:ll,pcf:!0}],[C2,{name:"PCF3_16F",kind:"PCF3",format:ll,pcf:!0}],[Hk,{name:"PCF5_16F",kind:"PCF5",format:ll,pcf:!0}],[jx,{name:"VSM_16F",kind:"VSM",format:kt,vsm:!0}],[zE,{name:"VSM_32F",kind:"VSM",format:fs,vsm:!0}],[af,{name:"PCSS_32F",kind:"PCSS",format:Wr,pcss:!0}]]),Wk=255,kE=1,$x=0,D2=0,Lr=0,Xk=1,lg=0,qk=1,dr=0,Dv=1,lh=0,sl=1,Ip=2,VE=0,P2=1,Yk={[VE]:"NONE",[P2]:"BOX"},CD="mul",Xf=0,Rd=1,jk={[Xf]:"NONE",[Rd]:"SRGB"},GE=0,R2=6,M2=["LINEAR","FILMIC","HEJL","ACES","ACES2","NEUTRAL","NONE"],L2=0,Pv=1,I2=2,$k={[L2]:"NONE",[Pv]:"AO",[I2]:"GLOSSDEPENDENT"},$n="none",cg="envAtlas",hg="envAtlasHQ",ug="cubeMap",O2="sphereMap",Kk={[$n]:"NONE",[cg]:"ENVATLAS",[hg]:"ENVATLASHQ",[ug]:"CUBEMAP",[O2]:"SPHEREMAP"},HE="ambientSH",WE="envAtlas",XE="constant",Zk={[HE]:"AMBIENTSH",[WE]:"ENVALATLAS",[XE]:"CONSTANT"},dg=1,nf=2,qE=4,N2=8,F2=16,of=32,Kx=64,B2=128,fg=256,YE=512,lf=1024,cf=2048,U2=4096,hf=8192,b_=16384,Yi=0,Kn=1,jE=2,Qi=1,Ba=2,Ua=4,Zh=0,Rv=1,z2=2,qf=3,k2=4,Nr=0,hs=1,us=2,Qk={[Nr]:"SIMPLE",[hs]:"SLICED",[us]:"TILED"},A_=1,Op=0,w_=0,Jk=1,eV=2,DD=3,tV=4,sV=5,$E=0,Zx=1,We=0,Tt=1,kd="infinite",iV="box",V2="dome",Al="none",rV="bayer8",aV="bluenoise",nV="ignnoise",oV={[Al]:"NONE",[rV]:"BAYER8",[aV]:"BLUENOISE",[nV]:"IGNNOISE"},lV="prerender",cV="postrender",hV="prerender:layer",uV="postrender:layer",G2="precull",H2="postcull",dV="cull:end",ch=1,hh=2,W2="pcShadowCamera";class Mv{hasUniform(e){for(let t=0;t<this.uniformFormats.length;t++)if(this.uniformFormats[t]?.get(e))return!0;return!1}hasTexture(e){for(let t=0;t<this.bindGroupFormats.length;t++)if(this.bindGroupFormats[t]?.getTexture(e))return!0;return!1}getVertexElement(e){return this.vertexFormat?.elements.find(t=>t.name===e)}generateKey(e){let t=JSON.stringify(this.uniformFormats)+JSON.stringify(this.bindGroupFormats);return e.isWebGPU&&(t+=this.vertexFormat?.shaderProcessingHashString),t}constructor(e,t,s){this.uniformFormats=[],this.bindGroupFormats=[],this.uniformFormats[Jd]=e,this.bindGroupFormats[Jd]=t,this.vertexFormat=s}}const X2=new ks;function Ih(c){return X2.get(c)}function fV(c,e){X2.get(c,()=>e)}class wl{static definesHash(e){const t=Array.from(e).sort((s,i)=>s[0]>i[0]?1:-1);return Fr(JSON.stringify(t))}}const mV=new ks;class pV{buildShaderDefines(){let e;this.isShadow?e="SHADOW":this.isForward?e="FORWARD":this.index===qf?e="PICK":this.index===k2&&(e="PICK",this.defines.set("DEPTH_PICK_PASS","")),this.defines.set(`${e}_PASS`,""),this.defines.set(`${this.name.toUpperCase()}_PASS`,"")}constructor(e,t,s={}){this.defines=new Map,this.name=e,this.index=t,Object.assign(this,s),this.buildShaderDefines()}}class Gr{static get(e){return mV.get(e,()=>new Gr)}allocate(e,t){let s=this.passesNamed.get(e);return s===void 0&&(s=new pV(e,this.nextIndex,t),this.passesNamed.set(s.name,s),this.passesIndexed[s.index]=s,this.nextIndex++),s}getByIndex(e){return this.passesIndexed[e]}getByName(e){return this.passesNamed.get(e)}constructor(){this.passesNamed=new Map,this.passesIndexed=[],this.nextIndex=0;const e=(t,s,i)=>{this.allocate(t,i)};e("forward",Zh,{isForward:!0}),e("prepass"),e("shadow"),e("pick"),e("depth_pick")}}class PD extends Map{set(e,t){return(!this.has(e)||this.get(e)!==t)&&this.markDirty(),super.set(e,t)}add(e,t=!0){for(const[s,i]of Object.entries(e))(t||!this.has(s))&&this.set(s,i);return this}delete(e){const t=this.has(e),s=super.delete(e);return t&&s&&this.markDirty(),s}clear(){this.size>0&&this.markDirty(),super.clear()}markDirty(){this._dirty=!0,this._keyDirty=!0}isDirty(){return this._dirty}resetDirty(){this._dirty=!1}get key(){return this._keyDirty&&(this._keyDirty=!1,this._key=Array.from(this.entries()).sort(([e],[t])=>e<t?-1:e>t?1:0).map(([e,t])=>`${e}=${Fr(t)}`).join(",")),this._key}copy(e){this.clear();for(const[t,s]of e)this.set(t,s);return this}constructor(e){super(),this._keyDirty=!1,this._key="",this._validations=e}}const _V=new ks;class Ue{static get(e,t=ot){const s=_V.get(e,()=>new Ue);return t===ot?s.glsl:s.wgsl}static registerValidation(e,t){}get useWGSL(){return this.glsl.size===0||this.wgsl.size>0}get key(){return`GLSL:${this.glsl.key}|WGSL:${this.wgsl.key}|API:${this.version}`}isDirty(){return this.glsl.isDirty()||this.wgsl.isDirty()}resetDirty(){this.glsl.resetDirty(),this.wgsl.resetDirty()}copy(e){return this.version=e.version,this.glsl.copy(e.glsl),this.wgsl.copy(e.wgsl),this}constructor(){this.glsl=new PD(Ue._validations),this.wgsl=new PD(Ue._validations),this.version=""}}Ue._validations=new Map;class mg{static merge(...e){const t=new Map(e[0]??[]);for(let s=1;s<e.length;s++){const i=e[s];if(i)for(const[r,a]of i)t.set(r,a)}return t}}class gV extends wl{generateKey(e){return this.key}createShaderDefinition(e,t){return this.shaderDefinition}constructor(e,t){super(),this.key=e,this.shaderDefinition=t}}class ns{static createShader(e,t){const s=Ih(e);let i=s.getCachedShader(t.uniqueName);if(!i){const r=e.isWebGPU&&(!!t.vertexWGSL||!!t.vertexChunk)&&(!!t.fragmentWGSL||!!t.fragmentChunk),a=Ue.get(e,r?Je:ot),o=t.vertexChunk?a.get(t.vertexChunk):r?t.vertexWGSL:t.vertexGLSL,h=t.fragmentChunk?a.get(t.fragmentChunk):r?t.fragmentWGSL:t.fragmentGLSL,u=mg.merge(a,t.fragmentIncludes),f=mg.merge(a,t.vertexIncludes);i=new fo(e,Os.createDefinition(e,{name:t.uniqueName,shaderLanguage:r?Je:ot,attributes:t.attributes,vertexCode:o,fragmentCode:h,useTransformFeedback:t.useTransformFeedback,vertexIncludes:f,vertexDefines:t.vertexDefines,fragmentIncludes:u,fragmentDefines:t.fragmentDefines,fragmentOutputTypes:t.fragmentOutputTypes})),s.setCachedShader(t.uniqueName,i)}return i}static getCoreDefines(e,t){const s=new Map(e.defines);return t.cameraShaderParams.defines.forEach((r,a)=>s.set(a,r)),Gr.get(t.device).getByIndex(t.pass).defines.forEach((r,a)=>s.set(a,r)),s}static processShader(e,t){const s=e.definition,r=`${s.name??"shader"}-id-${e.id}`,a=new gV(r,s),o="shader",h=Ih(e.device);h.register(o,a);const u=h.getProgram(o,{},t);return h.unregister(o),u}static addScreenDepthChunkDefines(e,t,s){t.sceneDepthMapLinear&&s.set("SCENE_DEPTHMAP_LINEAR",""),e.textureFloatRenderable&&s.set("SCENE_DEPTHMAP_FLOAT","")}}const vV={type:zr,base:0,baseVertex:0,count:4,indexed:!1},rd=new me,ad=new me,y0=new wE;class uf{destroy(){this.uniformBuffer?.destroy(),this.uniformBuffer=null,this.bindGroup?.destroy(),this.bindGroup=null}render(e,t){const s=this.shader.device;e&&(rd.set(s.vx,s.vy,s.vw,s.vh),ad.set(s.sx,s.sy,s.sw,s.sh),t=t??e,s.setViewport(e.x,e.y,e.z,e.w),s.setScissor(t.x,t.y,t.z,t.w)),s.setVertexBuffer(s.quadVertexBuffer);const i=this.shader;if(s.setShader(i),s.supportsUniformBuffers){s.setBindGroup(Jd,s.emptyBindGroup);const r=this.bindGroup;r.update(),s.setBindGroup(kf,r);const a=this.uniformBuffer;a?(a.update(y0),s.setBindGroup(Lh,y0.bindGroup,y0.offsets)):s.setBindGroup(Lh,s.emptyBindGroup)}s.draw(vV),e&&(s.setViewport(rd.x,rd.y,rd.z,rd.w),s.setScissor(ad.x,ad.y,ad.z,ad.w))}constructor(e){const t=e.device;if(this.shader=e,t.supportsUniformBuffers){const s=new Mv;this.shader=ns.processShader(e,s);const i=this.shader.meshUniformBufferFormat;i&&(this.uniformBuffer=new Vf(t,i,!1));const r=this.shader.meshBindGroupFormat;this.bindGroup=new qh(t,r)}}}class SV extends ii{execute(){const{device:e}=this;e.setCullMode(Ft),e.setDepthState(Gt.NODEPTH),e.setStencilState(null,null),this.quad.render(this.rect,this.scissorRect)}constructor(e,t,s,i){super(e),this.quad=t,this.rect=s,this.scissorRect=i}}const yV=new me;function gr(c,e,t,s,i){const r=new uf(t);s||(s=yV,s.x=0,s.y=0,s.z=e?e.width:c.width,s.w=e?e.height:c.height);const a=new SV(c,r,s,i);a.init(e),a.colorOps.clear=!1,a.depthStencilOps.clearDepth=!1,c.isWebGPU&&e===null&&c.samples>1&&(a.colorOps.store=!0),a.render(),r.destroy()}class RD{destroy(e,t){this.meshInstance&&(this.removeFromLayers(e,t),this.meshInstance.destroy(),this.meshInstance=null)}addToLayers(e,t){for(let s=0;s<t.length;s++){const i=e.layers.getLayerById(t[s]);i&&i.addMeshInstances([this.meshInstance])}}removeFromLayers(e,t){for(let s=0;s<t.length;s++){const i=e.layers.getLayerById(t[s]);i&&i.removeMeshInstances([this.meshInstance])}}updateBoundingBox(){this._aabb.copy(this.origMeshInstances[0].aabb);for(let e=1;e<this.origMeshInstances.length;e++)this._aabb.add(this.origMeshInstances[e].aabb);this.meshInstance.aabb=this._aabb,this.meshInstance._aabbVer=0}get model(){}constructor(e,t,s){this._aabb=new Ge,this.meshInstance=null,this.origMeshInstances=e,this.dynamic=t,this.batchGroupId=s}}class Jt{constructor(e,t,s,i,r=[sn]){this._ui=!1,this._sprite=!1,this._obj={model:[],element:[],sprite:[],render:[]},this.id=e,this.name=t,this.dynamic=s,this.maxAabbSize=i,this.layers=r}}Jt.MODEL="model";Jt.ELEMENT="element";Jt.SPRITE="sprite";Jt.RENDER="render";const MD=new fe;class Yf{set rootBone(e){this._rootBone=e}get rootBone(){return this._rootBone}init(e,t){const s=t*3;let i=Math.ceil(Math.sqrt(s));i=J.roundUp(i,3);const r=Math.ceil(s/i);this.boneTexture=new De(e,{width:i,height:r,format:fs,mipmaps:!1,minFilter:ze,magFilter:ze,name:"skin"}),this.matrixPalette=this.boneTexture.lock({mode:WM}),this.boneTexture.unlock()}destroy(){this.boneTexture&&(this.boneTexture.destroy(),this.boneTexture=null)}resolve(e,t){this.rootBone=e;const s=this.skin,i=[];for(let r=0;r<s.boneNames.length;r++){const a=s.boneNames[r];let o=e.findByName(a);o||(o=t),i.push(o)}this.bones=i}initSkin(e){this.skin=e,this.bones=[];const t=e.inverseBindPose.length;this.init(e.device,t),this.matrices=[];for(let s=0;s<t;s++)this.matrices[s]=new fe}uploadBones(e){this.boneTexture.upload()}_updateMatrices(e,t){if(this._skinUpdateIndex!==t){this._skinUpdateIndex=t,MD.copy(e.getWorldTransform()).invert();for(let s=this.bones.length-1;s>=0;s--)this.matrices[s].mulAffine2(MD,this.bones[s].getWorldTransform()),this.matrices[s].mulAffine2(this.matrices[s],this.skin.inverseBindPose[s])}}updateMatrices(e,t){this._updateBeforeCull&&this._updateMatrices(e,t)}updateMatrixPalette(e,t){this._updateMatrices(e,t);const s=this.matrixPalette,i=this.bones.length;for(let r=0;r<i;r++){const a=this.matrices[r].data,o=r*12;s[o]=a[0],s[o+1]=a[4],s[o+2]=a[8],s[o+3]=a[12],s[o+4]=a[1],s[o+5]=a[5],s[o+6]=a[9],s[o+7]=a[13],s[o+8]=a[2],s[o+9]=a[6],s[o+10]=a[10],s[o+11]=a[14]}this.uploadBones(this.skin.device)}constructor(e){this._dirty=!0,this._rootBone=null,this._skinUpdateIndex=-1,this._updateBeforeCull=!0,e&&this.initSkin(e)}}class LD extends Yf{updateMatrices(e,t){}updateMatrixPalette(e,t){const s=this.matrixPalette,i=this.bones.length;for(let r=0;r<i;r++){const a=this.bones[r].getWorldTransform().data,o=r*12;s[o]=a[0],s[o+1]=a[4],s[o+2]=a[8],s[o+3]=a[12],s[o+4]=a[1],s[o+5]=a[5],s[o+6]=a[9],s[o+7]=a[13],s[o+8]=a[2],s[o+9]=a[6],s[o+10]=a[10],s[o+11]=a[14]}this.uploadBones(this.device)}constructor(e,t,s){super();const i=t.length;this.init(e,i),this.device=e,this.rootNode=s,this.bones=t}}let xV=0;class Ir{initDefaults(){this.recreate=!1,this.verticesUsage=Hi,this.indicesUsage=Hi,this.maxVertices=0,this.maxIndices=0,this.vertexCount=0,this.indexCount=0,this.vertexStreamsUpdated=!1,this.indexStreamUpdated=!1,this.vertexStreamDictionary={},this.indices=null}_changeVertexCount(e,t){this.vertexCount||(this.vertexCount=e)}constructor(){this.initDefaults()}}Ir.DEFAULT_COMPONENTS_POSITION=3;Ir.DEFAULT_COMPONENTS_NORMAL=3;Ir.DEFAULT_COMPONENTS_UV=2;Ir.DEFAULT_COMPONENTS_COLORS=4;class TV{constructor(e,t,s,i,r){this.data=e,this.componentCount=t,this.dataType=s,this.dataTypeNormalize=i,this.asInt=r}}class Ct extends wv{static fromGeometry(e,t,s={}){const i=new Ct(e,s),{positions:r,normals:a,tangents:o,colors:h,uvs:u,uvs1:f,blendIndices:m,blendWeights:_,indices:g}=t;return r&&i.setPositions(r),a&&i.setNormals(a),o&&i.setVertexStream(Xr,o,4),h&&i.setColors32(h),u&&i.setUvs(0,u),f&&i.setUvs(1,f),m&&i.setVertexStream(yi,m,4,m.length/4,Va),_&&i.setVertexStream(kr,_,4),g&&i.setIndices(g),i.update(),i}set morph(e){e!==this._morph&&(this._morph&&this._morph.decRefCount(),this._morph=e,e&&e.incRefCount())}get morph(){return this._morph}set aabb(e){this._aabb=e,this._aabbVer++}get aabb(){return this._aabb}destroy(){const e=this.morph;e&&(this.morph=null,e.refCount<1&&e.destroy()),this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=null);for(let t=0;t<this.indexBuffer.length;t++)this._destroyIndexBuffer(t);this.indexBuffer.length=0,this._geometryData=null}_destroyIndexBuffer(e){this.indexBuffer[e]&&(this.indexBuffer[e].destroy(),this.indexBuffer[e]=null)}_initBoneAabbs(e){this.boneAabb=[],this.boneUsed=[];let t,s,i,r,a;const o=[],h=[],u=this.boneUsed,f=this.skin.boneNames.length;let m,_,g;for(let w=0;w<f;w++)o[w]=new D(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),h[w]=new D(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);const S=new zd(this.vertexBuffer),x=S.element[He],T=S.element[kr],E=S.element[yi],b=this.vertexBuffer.numVertices;for(let w=0;w<b;w++){for(let P=0;P<4;P++)if(T.array[T.index+P]>0){const M=E.array[E.index+P];if(u[M]=!0,t=x.array[x.index],s=x.array[x.index+1],i=x.array[x.index+2],r=h[M],a=o[M],a.x>t&&(a.x=t),a.y>s&&(a.y=s),a.z>i&&(a.z=i),r.x<t&&(r.x=t),r.y<s&&(r.y=s),r.z<i&&(r.z=i),e){let R=m=t,L=_=s,B=g=i;for(let G=0;G<e.length;G++){const H=e[G],ee=H.deltaPositions[w*3],j=H.deltaPositions[w*3+1],ae=H.deltaPositions[w*3+2];ee<0?R+=ee:m+=ee,j<0?L+=j:_+=j,ae<0?B+=ae:g+=ae}a.x>R&&(a.x=R),a.y>L&&(a.y=L),a.z>B&&(a.z=B),r.x<m&&(r.x=m),r.y<_&&(r.y=_),r.z<g&&(r.z=g)}}S.next()}const C=this.vertexBuffer.getFormat().elements.find(w=>w.name===He);if(C&&C.normalize){const w=(()=>{switch(C.dataType){case co:return P=>Math.max(P/127,-1);case Va:return P=>P/255;case ho:return P=>Math.max(P/32767,-1);case Nl:return P=>P/65535;default:return P=>P}})();for(let P=0;P<f;P++)if(u[P]){const I=o[P],M=h[P];I.set(w(I.x),w(I.y),w(I.z)),M.set(w(M.x),w(M.y),w(M.z))}}for(let w=0;w<f;w++){const P=new Ge;P.setMinMax(o[w],h[w]),this.boneAabb.push(P)}}_initGeometryData(){this._geometryData||(this._geometryData=new Ir,this.vertexBuffer&&(this._geometryData.vertexCount=this.vertexBuffer.numVertices,this._geometryData.maxVertices=this.vertexBuffer.numVertices),this.indexBuffer.length>0&&this.indexBuffer[0]&&(this._geometryData.indexCount=this.indexBuffer[0].numIndices,this._geometryData.maxIndices=this.indexBuffer[0].numIndices))}clear(e,t,s=0,i=0){this._initGeometryData(),this._geometryData.initDefaults(),this._geometryData.recreate=!0,this._geometryData.maxVertices=s,this._geometryData.maxIndices=i,this._geometryData.verticesUsage=e?Hi:H_,this._geometryData.indicesUsage=t?Hi:H_}setVertexStream(e,t,s,i,r=ct,a=!1,o=!1){this._initGeometryData();const h=i||t.length/s;this._geometryData._changeVertexCount(h,e),this._geometryData.vertexStreamsUpdated=!0,this._geometryData.vertexStreamDictionary[e]=new TV(t,s,r,a,o)}getVertexStream(e,t){let s=0,i=!1;if(this._geometryData){const r=this._geometryData.vertexStreamDictionary[e];r&&(i=!0,s=this._geometryData.vertexCount,ArrayBuffer.isView(t)?t.set(r.data):(t.length=0,t.push(r.data)))}return i||this.vertexBuffer&&(s=new zd(this.vertexBuffer).readData(e,t)),s}setPositions(e,t=Ir.DEFAULT_COMPONENTS_POSITION,s){this.setVertexStream(He,e,t,s,ct,!1)}setNormals(e,t=Ir.DEFAULT_COMPONENTS_NORMAL,s){this.setVertexStream(si,e,t,s,ct,!1)}setUvs(e,t,s=Ir.DEFAULT_COMPONENTS_UV,i){this.setVertexStream(W1+e,t,s,i,ct,!1)}setColors(e,t=Ir.DEFAULT_COMPONENTS_COLORS,s){this.setVertexStream(Rs,e,t,s,ct,!1)}setColors32(e,t){this.setVertexStream(Rs,e,Ir.DEFAULT_COMPONENTS_COLORS,t,Va,!0)}setIndices(e,t){this._initGeometryData(),this._geometryData.indexStreamUpdated=!0,this._geometryData.indices=e,this._geometryData.indexCount=t||e.length}getPositions(e){return this.getVertexStream(He,e)}getNormals(e){return this.getVertexStream(si,e)}getUvs(e,t){return this.getVertexStream(W1+e,t)}getColors(e){return this.getVertexStream(Rs,e)}getIndices(e){let t=0;if(this._geometryData&&this._geometryData.indices){const s=this._geometryData.indices;if(t=this._geometryData.indexCount,ArrayBuffer.isView(e))e.set(s);else{e.length=0;for(let i=0,r=s.length;i<r;i++)e.push(s[i])}}else this.indexBuffer.length>0&&this.indexBuffer[0]&&(t=this.indexBuffer[0].readData(e));return t}update(e=ka,t=!0){if(this._geometryData){if(t){const r=this._geometryData.vertexStreamDictionary[He];r&&r.componentCount===3&&(this._aabb.compute(r.data,this._geometryData.vertexCount),this._aabbVer++)}let s=this._geometryData.recreate;this._geometryData.vertexCount>this._geometryData.maxVertices&&(s=!0,this._geometryData.maxVertices=this._geometryData.vertexCount),s&&this.vertexBuffer&&(this.vertexBuffer.destroy(),this.vertexBuffer=null);let i=this._geometryData.recreate;this._geometryData.indexCount>this._geometryData.maxIndices&&(i=!0,this._geometryData.maxIndices=this._geometryData.indexCount),i&&this.indexBuffer.length>0&&this.indexBuffer[0]&&(this.indexBuffer[0].destroy(),this.indexBuffer[0]=null),this._geometryData.vertexStreamsUpdated&&this._updateVertexBuffer(),this._geometryData.indexStreamUpdated&&this._updateIndexBuffer(),this.primitive[0].type=e,this.indexBuffer.length>0&&this.indexBuffer[0]?this._geometryData.indexStreamUpdated&&(this.primitive[0].count=this._geometryData.indexCount,this.primitive[0].indexed=!0):this._geometryData.vertexStreamsUpdated&&(this.primitive[0].count=this._geometryData.vertexCount,this.primitive[0].indexed=!1),this._geometryData.vertexCount=0,this._geometryData.indexCount=0,this._geometryData.vertexStreamsUpdated=!1,this._geometryData.indexStreamUpdated=!1,this._geometryData.recreate=!1,this.updateRenderStates()}}_buildVertexFormat(e){const t=[];for(const s in this._geometryData.vertexStreamDictionary){const i=this._geometryData.vertexStreamDictionary[s];t.push({semantic:s,components:i.componentCount,type:i.dataType,normalize:i.dataTypeNormalize,asInt:i.asInt})}return new Ti(this.device,t,e)}_updateVertexBuffer(){if(!this.vertexBuffer){const s=this._geometryData.maxVertices,i=this._buildVertexFormat(s);this.vertexBuffer=new Yr(this.device,i,s,{usage:this._geometryData.verticesUsage,storage:this._storageVertex})}const e=new zd(this.vertexBuffer),t=this._geometryData.vertexCount;for(const s in this._geometryData.vertexStreamDictionary){const i=this._geometryData.vertexStreamDictionary[s];e.writeData(s,i.data,t),delete this._geometryData.vertexStreamDictionary[s]}e.end()}_updateIndexBuffer(){if(this.indexBuffer.length<=0||!this.indexBuffer[0]){const t=this._geometryData.maxVertices,s=t>65535||t===0?eo:Ka,i=this._storageIndex?{storage:!0}:void 0;this.indexBuffer[0]=new bl(this.device,s,this._geometryData.maxIndices,this._geometryData.indicesUsage,void 0,i)}const e=this._geometryData.indices;e&&(this.indexBuffer[0].writeData(e,this._geometryData.indexCount),this._geometryData.indices=null)}prepareRenderState(e){e===sl?this.generateWireframe():e===Ip&&(this.primitive[Ip]={type:cv,base:0,baseVertex:0,count:this.vertexBuffer?this.vertexBuffer.numVertices:0,indexed:!1})}updateRenderStates(){this.primitive[Ip]&&this.prepareRenderState(Ip),this.primitive[sl]&&this.prepareRenderState(sl)}generateWireframe(){this._destroyIndexBuffer(sl);const e=this.vertexBuffer.numVertices;let t,s;if(this.indexBuffer.length>0&&this.indexBuffer[0]){const r=[[0,1],[1,2],[2,0]],a=this.primitive[lh].base,o=this.primitive[lh].count,h=this.primitive[lh].baseVertex||0,u=this.indexBuffer[lh],f=AE[u.format],m=new f(u.storage),_=new f(o*2),g=new Set;let S=0;for(let x=a;x<a+o;x+=3)for(let T=0;T<3;T++){const E=m[x+r[T][0]]+h,b=m[x+r[T][1]]+h,C=E>b?b*e+E:E*e+b;g.has(C)||(g.add(C),_[S++]=E,_[S++]=b)}g.clear(),s=u.format,t=_.slice(0,S)}else{const r=e-e%3,a=r/3*6;s=a>65535?eo:Ka,t=a>65535?new Uint32Array(a):new Uint16Array(a);let o=0;for(let h=0;h<r;h+=3)t[o++]=h,t[o++]=h+1,t[o++]=h+1,t[o++]=h+2,t[o++]=h+2,t[o++]=h}const i=new bl(this.vertexBuffer.device,s,t.length,Hi,t.buffer);this.primitive[sl]={type:hv,base:0,baseVertex:0,count:t.length,indexed:!0},this.indexBuffer[sl]=i}constructor(e,t){super(),this.indexBuffer=[null],this.vertexBuffer=null,this.primitive=[{type:0,base:0,baseVertex:0,count:0}],this.skin=null,this.boneAabb=null,this._aabbVer=0,this._aabb=new Ge,this._geometryData=null,this._morph=null,this._storageIndex=!1,this._storageVertex=!1,this.id=xV++,this.device=e,this._storageIndex=t?.storageIndex||!1,this._storageVertex=t?.storageVertex||!1}}const q2=new ks;function jf(c){return q2.get(c)}function EV(c,e){q2.get(c,()=>e)}class bV{destroy(){this.cache.forEach((e,t)=>{t.destroy()}),this.cache.clear()}incRef(e){const t=(this.cache.get(e)||0)+1;this.cache.set(e,t)}decRef(e){if(e){let t=this.cache.get(e);t&&(t--,t===0?(this.cache.delete(e),e.destroy()):this.cache.set(e,t))}}constructor(){this.cache=new Map}}class Ra{static incRef(e){this.cache.incRef(e)}static decRef(e){this.cache.decRef(e)}static destroy(){this.cache.destroy()}}Ra.cache=new bV;let AV=0;const wV=new Ge,Np=new Ge,x0=new KT,T0=new Set,Pc=new Uint32Array(4);class CV{destroy(){this._destroyVertexBuffer&&this.vertexBuffer?.destroy(),this.vertexBuffer=null}constructor(e){this.vertexBuffer=null,this._destroyVertexBuffer=!1,this.count=e}}class DV{getBindGroup(e){if(!this.bindGroup){const s=this.shader.meshBindGroupFormat;this.bindGroup=new qh(e,s)}return this.bindGroup}getUniformBuffer(e){if(!this.uniformBuffer){const s=this.shader.meshUniformBufferFormat;this.uniformBuffer=new Vf(e,s,!1)}return this.uniformBuffer}destroy(){this.bindGroup?.destroy(),this.bindGroup=null,this.uniformBuffer?.destroy(),this.uniformBuffer=null}constructor(){this.bindGroup=null,this.uniformBuffer=null}}class lt{set drawBucket(e){this._drawBucket=Math.floor(e)&255,this.updateKey()}get drawBucket(){return this._drawBucket}set renderStyle(e){this._renderStyle=e,this.mesh.prepareRenderState(e)}get renderStyle(){return this._renderStyle}set mesh(e){e!==this._mesh&&(this._mesh&&this._mesh.decRefCount(),this._mesh=e,e&&e.incRefCount())}get mesh(){return this._mesh}set aabb(e){this._aabb=e}get aabb(){if(!this._updateAabb)return this._aabb;if(this._updateAabbFunc)return this._updateAabbFunc(this._aabb);let e=this._customAabb,t=!!e;if(!e){if(e=wV,this.skinInstance){if(!this.mesh.boneAabb){const r=this._morphInstance?this._morphInstance.morph._targets:null;this.mesh._initBoneAabbs(r)}const s=this.mesh.boneUsed;let i=!0;for(let r=0;r<this.mesh.boneAabb.length;r++)s[r]&&(Np.setFromTransformedAabb(this.mesh.boneAabb[r],this.skinInstance.matrices[r]),i?(i=!1,e.center.copy(Np.center),e.halfExtents.copy(Np.halfExtents)):e.add(Np));t=!0}else if(this.node._aabbVer!==this._aabbVer||this.mesh._aabbVer!==this._aabbMeshVer){if(this.mesh?(e.center.copy(this.mesh.aabb.center),e.halfExtents.copy(this.mesh.aabb.halfExtents)):(e.center.set(0,0,0),e.halfExtents.set(0,0,0)),this.mesh&&this.mesh.morph){const s=this.mesh.morph.aabb;e._expand(s.getMin(),s.getMax())}t=!0,this._aabbVer=this.node._aabbVer,this._aabbMeshVer=this.mesh._aabbVer}}return t&&this._aabb.setFromTransformedAabb(e,this.node.getWorldTransform()),this._aabb}clearShaders(){this._shaderCache.forEach(e=>{e.destroy()}),this._shaderCache.clear()}getShaderInstance(e,t,s,i,r,a,o){const h=this._shaderDefs;Pc[0]=e,Pc[1]=t,Pc[2]=h,Pc[3]=i.hash;const u=bv(Pc);let f=this._shaderCache.get(u);if(!f){const m=this._material;if(f=new DV,f.shader=m.variants.get(u),f.hashes=new Uint32Array(Pc),!f.shader){const _=m.getShaderVariant({device:this.mesh.device,scene:s,objDefs:h,cameraShaderParams:i,pass:e,sortedLights:o,viewUniformFormat:r,viewBindGroupFormat:a,vertexFormat:this.mesh.vertexBuffer?.format});m.variants.set(u,_),f.shader=_}this._shaderCache.set(u,f)}return f}set material(e){this.clearShaders();const t=this._material;t&&t.removeMeshInstanceRef(this),this._material=e,e&&(e.addMeshInstanceRef(this),this.transparent=e.transparent,this.updateKey())}get material(){return this._material}_updateShaderDefs(e){e!==this._shaderDefs&&(this._shaderDefs=e,this.clearShaders())}set calculateSortDistance(e){this._calculateSortDistance=e}get calculateSortDistance(){return this._calculateSortDistance}set receiveShadow(e){this._receiveShadow!==e&&(this._receiveShadow=e,this._updateShaderDefs(e?this._shaderDefs&~dg:this._shaderDefs|dg))}get receiveShadow(){return this._receiveShadow}set batching(e){this._updateShaderDefs(e?this._shaderDefs|b_:this._shaderDefs&~b_)}get batching(){return(this._shaderDefs&b_)!==0}set skinInstance(e){this._skinInstance=e,this._updateShaderDefs(e?this._shaderDefs|nf:this._shaderDefs&~nf),this._setupSkinUpdate()}get skinInstance(){return this._skinInstance}set morphInstance(e){this._morphInstance?.destroy(),this._morphInstance=e;let t=this._shaderDefs;t=e&&e.morph.morphPositions?t|lf:t&~lf,t=e&&e.morph.morphNormals?t|cf:t&~cf,t=e&&e.morph.intRenderFormat?t|hf:t&~hf,this._updateShaderDefs(t)}get morphInstance(){return this._morphInstance}set screenSpace(e){this._screenSpace!==e&&(this._screenSpace=e,this._updateShaderDefs(e?this._shaderDefs|fg:this._shaderDefs&~fg))}get screenSpace(){return this._screenSpace}set key(e){this._sortKeyForward=e}get key(){return this._sortKeyForward}set mask(e){const t=this._shaderDefs&65535;this._updateShaderDefs(t|e<<16)}get mask(){return this._shaderDefs>>16}set instancingCount(e){this.instancingData&&(this.instancingData.count=e)}get instancingCount(){return this.instancingData?this.instancingData.count:0}destroy(){const e=this.mesh;e&&(this.mesh=null,e.refCount<1&&e.destroy()),this.setRealtimeLightmap(lt.lightmapParamNames[0],null),this.setRealtimeLightmap(lt.lightmapParamNames[1],null),this._skinInstance?.destroy(),this._skinInstance=null,this.morphInstance?.destroy(),this.morphInstance=null,this.clearShaders(),this.material=null,this.instancingData?.destroy(),this.destroyDrawCommands()}destroyDrawCommands(){if(this.drawCommands){for(const e of this.drawCommands.values())e?.destroy();this.drawCommands=null}}static _prepareRenderStyleForArray(e,t){if(e){for(let s=0;s<e.length;s++){e[s]._renderStyle=t;const i=e[s].mesh;T0.has(i)||(T0.add(i),i.prepareRenderState(t))}T0.clear()}}_isVisible(e){return this.visible?this.isVisibleFunc?this.isVisibleFunc(e):(x0.center=this.aabb.center,x0.radius=this._aabb.halfExtents.length(),e.frustum.containsSphere(x0)>0):!1}updateKey(){const{material:e}=this;this._sortKeyForward=this._drawBucket<<23|(e.alphaToCoverage||e.alphaTest?4194304:0)|e.id&4194303}setInstancing(e,t=!1){e?(this.instancingData=new CV(e.numVertices),this.instancingData.vertexBuffer=e,e.format.instancing=!0,this.cull=t):(this.instancingData=null,this.cull=!0),this._updateShaderDefs(e?this._shaderDefs|of:this._shaderDefs&~of)}setIndirect(e,t,s=1){const i=e?.camera??null;if(t===-1)this._deleteDrawCommandsKey(i);else{this.drawCommands??(this.drawCommands=new Map);const r=this.drawCommands.get(i)??new ED(this.mesh.device);r.slotIndex=t,r.update(s),this.drawCommands.set(i,r),this.mesh.device.mapsToClear.add(this.drawCommands)}}setMultiDraw(e,t=1){const s=e?.camera??null;let i;if(t===0)this._deleteDrawCommandsKey(s);else{if(this.drawCommands??(this.drawCommands=new Map),i=this.drawCommands.get(s),!i){const a=this.mesh.indexBuffer?.[0]?.format,o=a!==void 0?RB[a]:0;i=new ED(this.mesh.device,o),this.drawCommands.set(s,i)}i.allocate(t)}return i}_deleteDrawCommandsKey(e){const t=this.drawCommands;t&&(t.get(e)?.destroy(),t.delete(e),t.size===0&&this.destroyDrawCommands())}getDrawCommands(e){const t=this.drawCommands;if(t)return t.get(e)??t.get(null)}getIndirectMetaData(){const e=this.mesh?.primitive[this.renderStyle],t=this.meshMetaData??(this.meshMetaData=new Int32Array(4));return t[0]=e.count,t[1]=e.base,t[2]=e.baseVertex,t}ensureMaterial(e){this.material||(this.material=jf(e))}clearParameters(){this.parameters={}}getParameters(){return this.parameters}getParameter(e){return this.parameters[e]}setParameter(e,t,s=4294967295){const i=this.parameters[e];i?(i.data=t,i.passFlags=s):this.parameters[e]={scopeId:null,data:t,passFlags:s}}setRealtimeLightmap(e,t){const s=this.getParameter(e);s!==t&&(s&&Ra.decRef(s.data),t?(Ra.incRef(t),this.setParameter(e,t)):this.deleteParameter(e))}deleteParameter(e){this.parameters[e]&&delete this.parameters[e]}setParameters(e,t){const s=this.parameters;for(const i in s){const r=s[i];r.passFlags&t&&(r.scopeId||(r.scopeId=e.scope.resolve(i)),r.scopeId.setValue(r.data))}}setLightmapped(e){e?this.mask=(this.mask|Ba)&-6:(this.setRealtimeLightmap(lt.lightmapParamNames[0],null),this.setRealtimeLightmap(lt.lightmapParamNames[1],null),this._shaderDefs&=-4289,this.mask=(this.mask|Qi)&-7)}setCustomAabb(e){e?this._customAabb?this._customAabb.copy(e):this._customAabb=e.clone():(this._customAabb=null,this._aabbVer=-1),this._setupSkinUpdate()}_setupSkinUpdate(){this._skinInstance&&(this._skinInstance._updateBeforeCull=!this._customAabb)}constructor(e,t,s=null){if(this.castShadow=!1,this.shadowCascadeMask=Wk,this.cull=!0,this.drawOrder=0,this._drawBucket=127,this.visible=!0,this.visibleThisFrame=!1,this.flipFacesFactor=1,this.gsplatInstance=null,this.id=AV++,this.isVisibleFunc=null,this.instancingData=null,this.indirectData=null,this.drawCommands=null,this.meshMetaData=null,this.parameters={},this.pick=!0,this.stencilFront=null,this.stencilBack=null,this.transparent=!1,this._aabb=new Ge,this._aabbVer=-1,this._aabbMeshVer=-1,this._customAabb=null,this._updateAabb=!0,this._updateAabbFunc=null,this._sortKeyShadow=0,this._sortKeyForward=0,this._sortKeyDynamic=0,this._layer=y2,this._material=null,this._skinInstance=null,this._morphInstance=null,this._receiveShadow=!0,this._renderStyle=lh,this._screenSpace=!1,this._shaderCache=new Map,this._shaderDefs=Qi<<16,this._calculateSortDistance=null,this.node=s,this._mesh=e,e.incRefCount(),this.material=t,e.vertexBuffer){const i=e.vertexBuffer.format;this._shaderDefs|=i.hasUv0?qE:0,this._shaderDefs|=i.hasUv1?N2:0,this._shaderDefs|=i.hasColor?F2:0,this._shaderDefs|=i.hasTangents?YE:0}this.updateKey()}}lt.lightmapParamNames=["texture_lightMap","texture_dirLightMap"];const PV=[0,1,3,2,3,1],RV=[0,1,3,0,3,2],ID=new $i;function OD(c,e){if(c&&!e||!c&&e)return!1;if(c=c.data,e=e.data,c===e)return!0;if(c instanceof Float32Array&&e instanceof Float32Array){if(c.length!==e.length)return!1;for(let t=0;t<c.length;t++)if(c[t]!==e[t])return!1;return!0}return!1}function MV(c,e){for(const t in c)if(c.hasOwnProperty(t)&&!OD(c[t],e[t]))return!1;for(const t in e)if(e.hasOwnProperty(t)&&!OD(e[t],c[t]))return!1;return!0}function E0(c){return c.node.worldTransform.scaleSign}class LV{destroy(){this.device=null,this.rootNode=null,this.scene=null,this._batchGroups={},this._batchList=[],this._dirtyGroups=[]}addGroup(e,t,s,i,r){if(i===void 0&&(i=this._batchGroupCounter,this._batchGroupCounter++),this._batchGroups[i])return;const a=new Jt(i,e,t,s,r);return this._batchGroups[i]=a,a}removeGroup(e){if(!this._batchGroups[e])return;const t=[];for(let s=0;s<this._batchList.length;s++)this._batchList[s].batchGroupId===e?this.destroyBatch(this._batchList[s]):t.push(this._batchList[s]);this._batchList=t,this._removeModelsFromBatchGroup(this.rootNode,e),delete this._batchGroups[e]}markGroupDirty(e){this._dirtyGroups.indexOf(e)<0&&this._dirtyGroups.push(e)}getGroupByName(e){const t=this._batchGroups;for(const s in t)if(t.hasOwnProperty(s)&&t[s].name===e)return t[s];return null}getBatches(e){const t=[],s=this._batchList.length;for(let i=0;i<s;i++){const r=this._batchList[i];r.batchGroupId===e&&t.push(r)}return t}_removeModelsFromBatchGroup(e,t){if(e.enabled){e.model&&e.model.batchGroupId===t&&(e.model.batchGroupId=-1),e.render&&e.render.batchGroupId===t&&(e.render.batchGroupId=-1),e.element&&e.element.batchGroupId===t&&(e.element.batchGroupId=-1),e.sprite&&e.sprite.batchGroupId===t&&(e.sprite.batchGroupId=-1);for(let s=0;s<e._children.length;s++)this._removeModelsFromBatchGroup(e._children[s],t)}}insert(e,t,s){const i=this._batchGroups[t];i&&i._obj[e].indexOf(s)<0&&(i._obj[e].push(s),this.markGroupDirty(t))}remove(e,t,s){const i=this._batchGroups[t];if(i){const r=i._obj[e].indexOf(s);r>=0&&(i._obj[e].splice(r,1),this.markGroupDirty(t))}}_extractRender(e,t,s,i){return e.render&&(t=i[e.render.batchGroupId]=t.concat(e.render.meshInstances),e.render.removeFromLayers()),t}_extractModel(e,t,s,i){return e.model&&e.model.model&&(t=i[e.model.batchGroupId]=t.concat(e.model.meshInstances),e.model.removeModelFromLayers()),t}_extractElement(e,t,s){if(!e.element)return;let i=!1;e.element._text&&e.element._text._model.meshInstances.length>0?(t.push(e.element._text._model.meshInstances[0]),e.element.removeModelFromLayers(e.element._text._model),i=!0):e.element._image&&(t.push(e.element._image._renderable.meshInstance),e.element.removeModelFromLayers(e.element._image._renderable.model),e.element._image._renderable.unmaskMeshInstance&&(t.push(e.element._image._renderable.unmaskMeshInstance),(!e.element._image._renderable.unmaskMeshInstance.stencilFront||!e.element._image._renderable.unmaskMeshInstance.stencilBack)&&(e.element._dirtifyMask(),e.element._onPrerender())),i=!0),i&&(s._ui=!0)}_collectAndRemoveMeshInstances(e,t){for(let s=0;s<t.length;s++){const i=t[s],r=this._batchGroups[i];if(!r)continue;let a=e[i];a||(a=e[i]=[]);for(let o=0;o<r._obj.model.length;o++)a=this._extractModel(r._obj.model[o],a,r,e);for(let o=0;o<r._obj.render.length;o++)a=this._extractRender(r._obj.render[o],a,r,e);for(let o=0;o<r._obj.element.length;o++)this._extractElement(r._obj.element[o],a,r);for(let o=0;o<r._obj.sprite.length;o++){const h=r._obj.sprite[o];h.sprite&&h.sprite._meshInstance&&(r.dynamic||h.sprite.sprite._renderMode===Nr)&&(a.push(h.sprite._meshInstance),h.sprite.removeModelFromLayers(),r._sprite=!0,h.sprite._batchGroup=r)}}}generate(e){const t={};e||(e=Object.keys(this._batchGroups));const s=[];for(let h=0;h<this._batchList.length;h++){if(e.indexOf(this._batchList[h].batchGroupId)<0){s.push(this._batchList[h]);continue}this.destroyBatch(this._batchList[h])}if(this._batchList=s,this._collectAndRemoveMeshInstances(t,e),e===this._dirtyGroups)this._dirtyGroups.length=0;else{const h=[];for(let u=0;u<this._dirtyGroups.length;u++)e.indexOf(this._dirtyGroups[u])<0&&h.push(this._dirtyGroups[u]);this._dirtyGroups=h}let i,r,a,o;for(const h in t)if(t.hasOwnProperty(h)&&(i=t[h],a=this._batchGroups[h],!!a)){r=this.prepare(i,a.dynamic,a.maxAabbSize,a._ui||a._sprite);for(let u=0;u<r.length;u++)o=this.create(r[u],a.dynamic,parseInt(h,10)),o&&o.addToLayers(this.scene,a.layers)}}prepare(e,t,s=Number.POSITIVE_INFINITY,i){if(e.length===0)return[];const r=s*.5,a=1024,o=4294967295,h=new Ge,u=new Ge;let f=null,m;const _=[];let g=0;i&&e.sort((E,b)=>E.drawOrder-b.drawOrder);let S=e,x;const T=i?function(E){f?f.add(E.aabb):f=E.aabb.clone(),x.push(E)}:function(E){x.push(E)};for(;S.length>0;){_[g]=[S[0]],x=[];const E=S[0].material,b=S[0].layer,C=S[0]._shaderDefs,w=S[0].parameters,P=S[0].stencilFront;let I=S[0].mesh.vertexBuffer.getNumVertices();const M=S[0].drawOrder;h.copy(S[0].aabb);const R=E0(S[0]),L=S[0].mesh.vertexBuffer.format.batchingHash,B=S[0].mesh.primitive[0].indexed;f=null;for(let G=1;G<S.length;G++){const H=S[G];if(t&&_[g].length>=a){x=x.concat(S.slice(G));break}if(E!==H.material||b!==H.layer||L!==H.mesh.vertexBuffer.format.batchingHash||B!==H.mesh.primitive[0].indexed||C!==H._shaderDefs||I+H.mesh.vertexBuffer.getNumVertices()>o){T(H);continue}if(u.copy(h),u.add(H.aabb),u.halfExtents.x>r||u.halfExtents.y>r||u.halfExtents.z>r){T(H);continue}if(P&&(!(m=H.stencilFront)||P.func!==m.func||P.zpass!==m.zpass)){T(H);continue}if(R!==E0(H)){T(H);continue}if(!MV(w,H.parameters)){T(H);continue}if(i&&f&&f.intersects(H.aabb)&&H.drawOrder!==M){T(H);continue}h.add(H.aabb),I+=H.mesh.vertexBuffer.getNumVertices(),_[g].push(H)}g++,S=x}return _}collectBatchedMeshData(e,t){let s=null,i=0,r=0,a=null;for(let o=0;o<e.length;o++)if(e[o].visible){const h=e[o].mesh,u=h.vertexBuffer.numVertices;if(i+=u,h.primitive[0].indexed)r+=h.primitive[0].count;else{const f=h.primitive[0].type;(f===cl||f===zr)&&h.primitive[0].count===4&&(r+=6)}if(!s){a=e[o].material,s={};const f=h.vertexBuffer.format.elements;for(let m=0;m<f.length;m++){const _=f[m].name;s[_]={numComponents:f[m].numComponents,dataType:f[m].dataType,normalize:f[m].normalize,count:0}}t&&(s[yi]={numComponents:1,dataType:ct,normalize:!1,count:0})}}return{streams:s,batchNumVerts:i,batchNumIndices:r,material:a}}create(e,t,s){this._init||(this.vertexFormats={},this._init=!0);let i=null,r,a,o,h=null;const u=this.collectBatchedMeshData(e,t);if(u.streams){const f=u.streams;let m=u.material;const _=u.batchNumVerts,g=u.batchNumIndices;h=new RD(e,t,s),this._batchList.push(h);let S,x,T,E,b=0,C=0,w;const P=_<=65535?Uint16Array:Uint32Array,I=new P(g);for(r in f)i=f[r],i.typeArrayType=gh[i.dataType],i.elementByteSize=Bd[i.dataType],i.buffer=new i.typeArrayType(_*i.numComponents);for(let L=0;L<e.length;L++)if(e[L].visible){a=e[L].mesh,o=a.vertexBuffer.numVertices,t||(w=e[L].node.getWorldTransform());for(r in f)if(r!==yi){i=f[r];const B=new i.typeArrayType(i.buffer.buffer,i.elementByteSize*i.count),G=a.getVertexStream(r,B)*i.numComponents;if(i.count+=G,!t&&i.numComponents>=3){if(r===He){const H=w.data,ee=H[0],j=H[1],ae=H[2],k=H[4],O=H[5],z=H[6],X=H[8],Y=H[9],F=H[10],U=H[12],K=H[13],se=H[14];let le,re,de;for(let ye=0;ye<G;ye+=i.numComponents)le=B[ye],re=B[ye+1],de=B[ye+2],B[ye]=le*ee+re*k+de*X+U,B[ye+1]=le*j+re*O+de*Y+K,B[ye+2]=le*ae+re*z+de*F+se}else if(r===si||r===Xr){ID.invertMat4(w).transpose();const[H,ee,j,ae,k,O,z,X,Y]=ID.data;let F,U,K;for(let se=0;se<G;se+=i.numComponents)F=B[se],U=B[se+1],K=B[se+2],B[se]=F*H+U*ae+K*z,B[se+1]=F*ee+U*k+K*X,B[se+2]=F*j+U*O+K*Y}}}if(t){i=f[yi];for(let B=0;B<o;B++)i.buffer[i.count++]=L}if(a.primitive[0].indexed){S=a.primitive[0].base,x=a.primitive[0].baseVertex||0,T=a.primitive[0].count;const B=a.indexBuffer[0].getFormat();E=new AE[B](a.indexBuffer[0].storage)}else{x=0;const B=a.primitive[0].type;if(B===cl||B===zr)if(a.primitive[0].count===4)S=0,T=6,E=B===cl?PV:RV;else{T=0;continue}}for(let B=0;B<T;B++)I[B+C]=E[S+B]+x+b;C+=T,b+=o}a=new Ct(this.device);for(r in f)i=f[r],a.setVertexStream(r,i.buffer,i.numComponents,void 0,i.dataType,i.normalize);I.length>0&&a.setIndices(I),a.update(ka,!1),t&&(m=m.clone(),m.update());const M=new lt(a,m,this.rootNode);M.castShadow=h.origMeshInstances[0].castShadow,M.parameters=h.origMeshInstances[0].parameters,M.layer=h.origMeshInstances[0].layer,M._shaderDefs=h.origMeshInstances[0]._shaderDefs,M.batching=!0,M.cull=h.origMeshInstances[0].cull;const R=this._batchGroups[s];if(R&&R._ui&&(M.cull=!1),t){const L=[];for(let B=0;B<h.origMeshInstances.length;B++)L.push(h.origMeshInstances[B].node);M.skinInstance=new LD(this.device,L,this.rootNode)}M._updateAabb=!1,M.drawOrder=h.origMeshInstances[0].drawOrder,M.stencilFront=h.origMeshInstances[0].stencilFront,M.stencilBack=h.origMeshInstances[0].stencilBack,M.flipFacesFactor=E0(h.origMeshInstances[0]),M.castShadow=h.origMeshInstances[0].castShadow,h.meshInstance=M,h.updateBoundingBox()}return h}updateAll(){this._dirtyGroups.length>0&&this.generate(this._dirtyGroups);for(let e=0;e<this._batchList.length;e++)this._batchList[e].dynamic&&this._batchList[e].updateBoundingBox()}clone(e,t){const s=new RD(t,e.dynamic,e.batchGroupId);this._batchList.push(s);const i=[];for(let r=0;r<t.length;r++)i.push(t[r].node);return s.meshInstance=new lt(e.meshInstance.mesh,e.meshInstance.material,e.meshInstance.node),s.meshInstance._updateAabb=!1,s.meshInstance.parameters=t[0].parameters,s.meshInstance.cull=t[0].cull,s.meshInstance.layer=t[0].layer,e.dynamic&&(s.meshInstance.skinInstance=new LD(this.device,i,this.rootNode)),s.meshInstance.castShadow=e.meshInstance.castShadow,s}destroyBatch(e){e.destroy(this.scene,this._batchGroups[e.batchGroupId].layers)}constructor(e,t,s){this.device=e,this.rootNode=t,this.scene=s,this._init=!1,this._batchGroups={},this._batchGroupCounter=0,this._batchList=[],this._dirtyGroups=[]}}const ND="uSceneColorMap";class IV extends ii{destroy(){super.destroy(),this.releaseRenderTarget(this.colorRenderTarget)}shouldReallocate(e,t,s){if(e?.colorBuffer.format!==s)return!0;const r=t?.width||this.device.width,a=t?.height||this.device.height;return!e||r!==e.width||a!==e.height}allocateRenderTarget(e,t,s,i){const r=new De(s,{name:ND,format:i,width:t?t.colorBuffer.width:s.width,height:t?t.colorBuffer.height:s.height,mipmaps:!0,minFilter:Jn,magFilter:$t,addressU:Te,addressV:Te});return e?(e.destroyFrameBuffers(),e._colorBuffer=r,e._colorBuffers=[r],e.evaluateDimensions()):e=new At({name:"ColorGrabRT",colorBuffer:r,depth:!1,stencil:!1,autoResolve:!1}),e}releaseRenderTarget(e){e&&(e.destroyTextureBuffers(),e.destroy())}frameUpdate(){const e=this.device,t=this.source,s=t?.colorBuffer.format??this.device.backBufferFormat;this.shouldReallocate(this.colorRenderTarget,t?.colorBuffer,s)&&(this.releaseRenderTarget(this.colorRenderTarget),this.colorRenderTarget=this.allocateRenderTarget(this.colorRenderTarget,t,e,s));const i=this.colorRenderTarget.colorBuffer;e.scope.resolve(ND).setValue(i)}execute(){const e=this.device,t=this.source,s=this.colorRenderTarget.colorBuffer;e.isWebGPU?(e.copyRenderTarget(t,this.colorRenderTarget,!0,!1),e.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl)):(e.copyRenderTarget(t,this.colorRenderTarget,!0,!1),e.activeTexture(e.maxCombinedTextures-1),e.bindTexture(s),e.gl.generateMipmap(s.impl._glTarget))}constructor(...e){super(...e),this.colorRenderTarget=null,this.source=null}}const FD="uSceneDepthMap";class OV extends ii{destroy(){super.destroy(),this.releaseRenderTarget(this.depthRenderTarget)}shouldReallocate(e,t){const s=t?.width||this.device.width,i=t?.height||this.device.height;return!e||s!==e.width||i!==e.height}allocateRenderTarget(e,t,s,i,r){const a=new De(s,{name:FD,format:i,width:t?t.colorBuffer.width:s.width,height:t?t.colorBuffer.height:s.height,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te});return e?(e.destroyFrameBuffers(),r?e._depthBuffer=a:(e._colorBuffer=a,e._colorBuffers=[a]),e.evaluateDimensions()):e=new At({name:"DepthGrabRT",colorBuffer:r?null:a,depthBuffer:r?a:null,depth:!r,stencil:s.supportsStencil,autoResolve:!1}),e}releaseRenderTarget(e){e&&(e.destroyTextureBuffers(),e.destroy())}before(){const e=this.camera,t=this.device,s=e?.renderTarget??t.backBuffer;let i=!0,r=s.stencil?gl:Br;t.isWebGPU&&s.samples>1&&(r=Wr,i=!1);const a=e.renderTarget?.depthBuffer??e.renderTarget?.colorBuffer;this.shouldReallocate(this.depthRenderTarget,a)&&(this.releaseRenderTarget(this.depthRenderTarget),this.depthRenderTarget=this.allocateRenderTarget(this.depthRenderTarget,e.renderTarget,t,r,i));const o=i?this.depthRenderTarget.depthBuffer:this.depthRenderTarget.colorBuffer;t.scope.resolve(FD).setValue(o)}execute(){const e=this.device;if(e.isWebGL2&&e.renderTarget.samples>1){const t=e.renderTarget.impl._glFrameBuffer,s=this.depthRenderTarget;e.renderTarget=s,e.updateBegin(),this.depthRenderTarget.impl.internalResolve(e,t,s.impl._glFrameBuffer,this.depthRenderTarget,e.gl.DEPTH_BUFFER_BIT)}else e.copyRenderTarget(e.renderTarget,this.depthRenderTarget,!1,!0)}constructor(e,t){super(e),this.depthRenderTarget=null,this.camera=null,this.camera=t}}class Y2{get hash(){if(this._hash===void 0){const e=`${this.gammaCorrection}_${this.toneMapping}_${this.srgbRenderTarget}_${this.fog}_${this.ssaoEnabled}_${this.sceneDepthMapLinear}`;this._hash=Fr(e)}return this._hash}get defines(){const e=this._defines;return this._definesDirty&&(this._definesDirty=!1,e.clear(),this._sceneDepthMapLinear&&e.set("SCENE_DEPTHMAP_LINEAR",""),this.shaderOutputGamma===Rd&&e.set("SCENE_COLORMAP_GAMMA",""),e.set("FOG",this._fog.toUpperCase()),e.set("TONEMAP",M2[this._toneMapping]),e.set("GAMMA",jk[this.shaderOutputGamma])),e}markDirty(){this._hash=void 0,this._definesDirty=!0}set fog(e){this._fog!==e&&(this._fog=e,this.markDirty())}get fog(){return this._fog}set ssaoEnabled(e){this._ssaoEnabled!==e&&(this._ssaoEnabled=e,this.markDirty())}get ssaoEnabled(){return this._ssaoEnabled}set gammaCorrection(e){this._gammaCorrectionAssigned=!0,this._gammaCorrection!==e&&(this._gammaCorrection=e,this.markDirty())}get gammaCorrection(){return this._gammaCorrection}set toneMapping(e){this._toneMapping!==e&&(this._toneMapping=e,this.markDirty())}get toneMapping(){return this._toneMapping}set srgbRenderTarget(e){this._srgbRenderTarget!==e&&(this._srgbRenderTarget=e,this.markDirty())}get srgbRenderTarget(){return this._srgbRenderTarget}set sceneDepthMapLinear(e){this._sceneDepthMapLinear!==e&&(this._sceneDepthMapLinear=e,this.markDirty())}get sceneDepthMapLinear(){return this._sceneDepthMapLinear}get shaderOutputGamma(){return this._gammaCorrection===Rd&&!this._srgbRenderTarget?Rd:Xf}constructor(){this._gammaCorrection=Rd,this._toneMapping=GE,this._srgbRenderTarget=!1,this._ssaoEnabled=!1,this._fog=Kh,this._sceneDepthMapLinear=!1,this._defines=new Map,this._definesDirty=!0}}const Rc=new D,nd=new D,BD=new D,UD=new fe,NV=[new D,new D,new D,new D,new D,new D,new D,new D];let KE=class j2{destroy(){this.renderPassColorGrab?.destroy(),this.renderPassColorGrab=null,this.renderPassDepthGrab?.destroy(),this.renderPassDepthGrab=null,this.renderPasses.length=0}_storeShaderMatrices(e,t,s,i){this._shaderMatricesVersion!==i&&(this._shaderMatricesVersion=i,this._viewProjPrevious.copy(this._viewProjCurrent??e),this._viewProjCurrent??(this._viewProjCurrent=new fe),this._viewProjCurrent.copy(e),this._viewProjInverse.invert(e),this._jitters[2]=this._jitters[0],this._jitters[3]=this._jitters[1],this._jitters[0]=t,this._jitters[1]=s)}get fullSizeClearRect(){const e=this._scissorRectClear?this.scissorRect:this._rect;return e.x===0&&e.y===0&&e.z===1&&e.w===1}set aspectRatio(e){this._aspectRatio!==e&&(this._aspectRatio=e,this._projMatDirty=!0)}get aspectRatio(){return this.xr?.active?this._xrProperties.aspectRatio:this._aspectRatio}set aspectRatioMode(e){this._aspectRatioMode!==e&&(this._aspectRatioMode=e,this._projMatDirty=!0)}get aspectRatioMode(){return this._aspectRatioMode}set calculateProjection(e){this._calculateProjection=e,this._projMatDirty=!0}get calculateProjection(){return this._calculateProjection}set calculateTransform(e){this._calculateTransform=e}get calculateTransform(){return this._calculateTransform}set clearColor(e){this._clearColor.copy(e)}get clearColor(){return this._clearColor}set clearColorBuffer(e){this._clearColorBuffer=e}get clearColorBuffer(){return this._clearColorBuffer}set clearDepth(e){this._clearDepth=e}get clearDepth(){return this._clearDepth}set clearDepthBuffer(e){this._clearDepthBuffer=e}get clearDepthBuffer(){return this._clearDepthBuffer}set clearStencil(e){this._clearStencil=e}get clearStencil(){return this._clearStencil}set clearStencilBuffer(e){this._clearStencilBuffer=e}get clearStencilBuffer(){return this._clearStencilBuffer}set cullFaces(e){this._cullFaces=e}get cullFaces(){return this._cullFaces}set farClip(e){this._farClip!==e&&(this._farClip=e,this._projMatDirty=!0)}get farClip(){return this.xr?.active?this._xrProperties.farClip:this._farClip}set flipFaces(e){this._flipFaces=e}get flipFaces(){return this._flipFaces}set fov(e){this._fov!==e&&(this._fov=e,this._projMatDirty=!0)}get fov(){return this.xr?.active?this._xrProperties.fov:this._fov}set frustumCulling(e){this._frustumCulling=e}get frustumCulling(){return this._frustumCulling}set horizontalFov(e){this._horizontalFov!==e&&(this._horizontalFov=e,this._projMatDirty=!0)}get horizontalFov(){return this.xr?.active?this._xrProperties.horizontalFov:this._horizontalFov}set layers(e){this._layers=e.slice(0),this._layersSet=new Set(this._layers)}get layers(){return this._layers}get layersSet(){return this._layersSet}set nearClip(e){this._nearClip!==e&&(this._nearClip=e,this._projMatDirty=!0)}get nearClip(){return this.xr?.active?this._xrProperties.nearClip:this._nearClip}set node(e){this._node=e}get node(){return this._node}set orthoHeight(e){this._orthoHeight!==e&&(this._orthoHeight=e,this._projMatDirty=!0)}get orthoHeight(){return this._orthoHeight}set projection(e){this._projection!==e&&(this._projection=e,this._projMatDirty=!0)}get projection(){return this._projection}get projectionMatrix(){return this._evaluateProjectionMatrix(),this._projMat}set rect(e){this._rect.copy(e)}get rect(){return this._rect}set renderTarget(e){this._renderTarget=e}get renderTarget(){return this._renderTarget}set scissorRect(e){this._scissorRect.copy(e)}get scissorRect(){return this._scissorRect}get viewMatrix(){if(this._viewMatDirty){const e=this._node.getWorldTransform();this._viewMat.copy(e).invert(),this._viewMatDirty=!1}return this._viewMat}set aperture(e){this._aperture=e}get aperture(){return this._aperture}set sensitivity(e){this._sensitivity=e}get sensitivity(){return this._sensitivity}set shutter(e){this._shutter=e}get shutter(){return this._shutter}set xr(e){this._xr!==e&&(this._xr=e,this._projMatDirty=!0)}get xr(){return this._xr}clone(){return new j2().copy(this)}copy(e){return this._aspectRatio=e._aspectRatio,this._farClip=e._farClip,this._fov=e._fov,this._horizontalFov=e._horizontalFov,this._nearClip=e._nearClip,this._xrProperties.aspectRatio=e._xrProperties.aspectRatio,this._xrProperties.farClip=e._xrProperties.farClip,this._xrProperties.fov=e._xrProperties.fov,this._xrProperties.horizontalFov=e._xrProperties.horizontalFov,this._xrProperties.nearClip=e._xrProperties.nearClip,this.aspectRatioMode=e.aspectRatioMode,this.calculateProjection=e.calculateProjection,this.calculateTransform=e.calculateTransform,this.clearColor=e.clearColor,this.clearColorBuffer=e.clearColorBuffer,this.clearDepth=e.clearDepth,this.clearDepthBuffer=e.clearDepthBuffer,this.clearStencil=e.clearStencil,this.clearStencilBuffer=e.clearStencilBuffer,this.cullFaces=e.cullFaces,this.flipFaces=e.flipFaces,this.frustumCulling=e.frustumCulling,this.layers=e.layers,this.orthoHeight=e.orthoHeight,this.projection=e.projection,this.rect=e.rect,this.renderTarget=e.renderTarget,this.scissorRect=e.scissorRect,this.aperture=e.aperture,this.shutter=e.shutter,this.sensitivity=e.sensitivity,this.shaderPassInfo=e.shaderPassInfo,this.jitter=e.jitter,this._projMatDirty=!0,this}_enableRenderPassColorGrab(e,t){t?this.renderPassColorGrab||(this.renderPassColorGrab=new IV(e)):(this.renderPassColorGrab?.destroy(),this.renderPassColorGrab=null)}_enableRenderPassDepthGrab(e,t,s){s?this.renderPassDepthGrab||(this.renderPassDepthGrab=new OV(e,this)):(this.renderPassDepthGrab?.destroy(),this.renderPassDepthGrab=null)}_updateViewProjMat(){(this._projMatDirty||this._viewMatDirty||this._viewProjMatDirty)&&(this._viewProjMat.mul2(this.projectionMatrix,this.viewMatrix),this._viewProjMatDirty=!1)}worldToScreen(e,t,s,i=new D){this._updateViewProjMat(),this._viewProjMat.transformPoint(e,i);const r=this._viewProjMat.data,a=e.x*r[3]+e.y*r[7]+e.z*r[11]+1*r[15];i.x=(i.x/a+1)*.5,i.y=(1-i.y/a)*.5;const{x:o,y:h,z:u,w:f}=this._rect;return i.x=i.x*u*t+o*t,i.y=i.y*f*s+(1-h-f)*s,i}screenToWorld(e,t,s,i,r,a=new D){const{x:o,y:h,z:u,w:f}=this._rect,m=this.farClip-this.nearClip;if(Rc.set((e-o*i)/(u*i),1-(t-(1-h-f)*r)/(f*r),s/m),Rc.mulScalar(2),Rc.sub(D.ONE),this._projection===dr){fe._getPerspectiveHalfSize(nd,this.fov,this.aspectRatio,this.nearClip,this.horizontalFov),nd.x*=Rc.x,nd.y*=Rc.y;const _=this._node.getWorldTransform();nd.z=-this.nearClip,_.transformPoint(nd,BD);const g=this._node.getPosition();a.sub2(BD,g),a.normalize(),a.mulScalar(s),a.add(g)}else this._updateViewProjMat(),UD.copy(this._viewProjMat).invert(),UD.transformPoint(Rc,a);return a}_evaluateProjectionMatrix(){if(this._projMatDirty){if(this._projection===dr)this._projMat.setPerspective(this.fov,this.aspectRatio,this.nearClip,this.farClip,this.horizontalFov),this._projMatSkybox.copy(this._projMat);else{const e=this._orthoHeight,t=e*this.aspectRatio;this._projMat.setOrtho(-t,t,-e,e,this.nearClip,this.farClip),this._projMatSkybox.setPerspective(this.fov,this.aspectRatio,this.nearClip,this.farClip)}this._projMatDirty=!1}}getProjectionMatrixSkybox(){return this._evaluateProjectionMatrix(),this._projMatSkybox}getExposure(){const e=Math.log2(this._aperture*this._aperture/this._shutter*100/this._sensitivity);return 1/(Math.pow(2,e)*1.2)}getScreenSize(e){if(this._projection===dr){const t=this._node.getPosition().distance(e.center);if(t<e.radius)return 1;const s=Math.asin(e.radius/t),i=Math.tan(s),r=Math.tan(this.fov/2*J.DEG_TO_RAD);return Math.min(i/r,1)}return J.clamp(e.radius/this._orthoHeight,0,1)}getFrustumCorners(e=this.nearClip,t=this.farClip){const s=this.fov*J.DEG_TO_RAD;let i,r;this.projection===dr?this.horizontalFov?(i=e*Math.tan(s/2),r=i/this.aspectRatio):(r=e*Math.tan(s/2),i=r*this.aspectRatio):(r=this._orthoHeight,i=r*this.aspectRatio);const a=NV;return a[0].x=i,a[0].y=-r,a[0].z=-e,a[1].x=i,a[1].y=r,a[1].z=-e,a[2].x=-i,a[2].y=r,a[2].z=-e,a[3].x=-i,a[3].y=-r,a[3].z=-e,this._projection===dr&&(this.horizontalFov?(i=t*Math.tan(s/2),r=i/this.aspectRatio):(r=t*Math.tan(s/2),i=r*this.aspectRatio)),a[4].x=i,a[4].y=-r,a[4].z=-t,a[5].x=i,a[5].y=r,a[5].z=-t,a[6].x=-i,a[6].y=r,a[6].z=-t,a[7].x=-i,a[7].y=-r,a[7].z=-t,a}setXrProperties(e){Object.assign(this._xrProperties,e),this._projMatDirty=!0}fillShaderParams(e){const t=this._farClip;return e[0]=1/t,e[1]=t,e[2]=this._nearClip,e[3]=this._projection===Dv?1:0,e}constructor(){this.shaderPassInfo=null,this.renderPassColorGrab=null,this.renderPassDepthGrab=null,this.fogParams=null,this.shaderParams=new Y2,this.renderPasses=[],this.jitter=0,this._aspectRatio=16/9,this._aspectRatioMode=$E,this._calculateProjection=null,this._calculateTransform=null,this._clearColor=new ue(.75,.75,.75,1),this._clearColorBuffer=!0,this._clearDepth=1,this._clearDepthBuffer=!0,this._clearStencil=0,this._clearStencilBuffer=!0,this._cullFaces=!0,this._farClip=1e3,this._flipFaces=!1,this._fov=45,this._frustumCulling=!0,this._horizontalFov=!1,this._layers=[sn,xi,FE,Cv,BE],this._layersSet=new Set(this._layers),this._nearClip=.1,this._node=null,this._orthoHeight=10,this._projection=dr,this._rect=new me(0,0,1,1),this._renderTarget=null,this._scissorRect=new me(0,0,1,1),this._scissorRectClear=!1,this._aperture=16,this._shutter=1/1e3,this._sensitivity=1e3,this._projMat=new fe,this._projMatDirty=!0,this._projMatSkybox=new fe,this._viewMat=new fe,this._viewMatDirty=!0,this._viewProjMat=new fe,this._viewProjMatDirty=!0,this._shaderMatricesVersion=0,this._viewProjInverse=new fe,this._viewProjCurrent=null,this._viewProjPrevious=new fe,this._jitters=[0,0,0,0],this.frustum=new kM,this._xr=null,this._xrProperties={horizontalFov:this._horizontalFov,fov:this._fov,aspectRatio:this._aspectRatio,farClip:this._farClip,nearClip:this._nearClip}}};const zD=new fe,b0=new D,kD=new pe,A0=new pe,VD=new D,GD=new D,FV=new fe,BV=new pe,fi=new D,od=new fe,mi=new pe,Mc=new pe,HD=new fe,w0=new D,Fp=new D;function WD(c,e){return c instanceof Function?c:t=>{let s=t[c];return s instanceof Function&&(s=s()),s===e}}function $2(c,e){if(e(c))return c;const t=c._children,s=t.length;for(let i=0;i<s;++i){const r=$2(t[i],e);if(r)return r}return null}class Dt extends Pe{get right(){return this._right||(this._right=new D),this.getWorldTransform().getX(this._right).normalize()}get up(){return this._up||(this._up=new D),this.getWorldTransform().getY(this._up).normalize()}get forward(){return this._forward||(this._forward=new D),this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1)}get normalMatrix(){const e=this._normalMatrix;return this._dirtyNormal&&(e.invertMat4(this.getWorldTransform()).transpose(),this._dirtyNormal=!1),e}set enabled(e){this._enabled!==e&&(this._enabled=e,(e&&this._parent?.enabled||!e)&&this._notifyHierarchyStateChanged(this,e))}get enabled(){return this._enabled&&this._enabledInHierarchy}get parent(){return this._parent}get path(){let e=this._parent;if(!e)return"";let t=this.name;for(;e&&e._parent;)t=`${e.name}/${t}`,e=e._parent;return t}get root(){let e=this;for(;e._parent;)e=e._parent;return e}get children(){return this._children}get graphDepth(){return this._graphDepth}_notifyHierarchyStateChanged(e,t){e._onHierarchyStateChanged(t);const s=e._children;for(let i=0,r=s.length;i<r;i++)s[i]._enabled&&this._notifyHierarchyStateChanged(s[i],t)}_onHierarchyStateChanged(e){this._enabledInHierarchy=e,e&&!this._frozen&&this._unfreezeParentToRoot()}_cloneInternal(e){e.name=this.name;const t=this.tags._list;e.tags.clear();for(let s=0;s<t.length;s++)e.tags.add(t[s]);e.localPosition.copy(this.localPosition),e.localRotation.copy(this.localRotation),e.localScale.copy(this.localScale),e.localEulerAngles.copy(this.localEulerAngles),e.position.copy(this.position),e.rotation.copy(this.rotation),e.eulerAngles.copy(this.eulerAngles),e.localTransform.copy(this.localTransform),e._dirtyLocal=this._dirtyLocal,e.worldTransform.copy(this.worldTransform),e._dirtyWorld=this._dirtyWorld,e._dirtyNormal=this._dirtyNormal,e._aabbVer=this._aabbVer+1,e._enabled=this._enabled,e.scaleCompensation=this.scaleCompensation,e._enabledInHierarchy=!1}clone(){const e=new this.constructor;return this._cloneInternal(e),e}copy(e){return e._cloneInternal(this),this}destroy(){this.remove();const e=this._children;for(;e.length;){const t=e.pop();t._parent=null,t.destroy()}this.fire("destroy",this),this.off()}find(e,t){const s=[],i=WD(e,t);return this.forEach(r=>{i(r)&&s.push(r)}),s}findOne(e,t){const s=WD(e,t);return $2(this,s)}findByTag(...e){const t=[],s=(i,r)=>{r&&i.tags.has(...e)&&t.push(i);for(let a=0;a<i._children.length;a++)s(i._children[a],!0)};return s(this,!1),t}findByName(e){return this.findOne("name",e)}findByPath(e){const t=Array.isArray(e)?e:e.split("/");let s=this;for(let i=0,r=t.length;i<r;++i)if(s=s.children.find(a=>a.name===t[i]),!s)return null;return s}forEach(e,t){e.call(t,this);const s=this._children,i=s.length;for(let r=0;r<i;++r)s[r].forEach(e,t)}isDescendantOf(e){let t=this._parent;for(;t;){if(t===e)return!0;t=t._parent}return!1}isAncestorOf(e){return e.isDescendantOf(this)}getEulerAngles(){return this.getWorldTransform().getEulerAngles(this.eulerAngles),this.eulerAngles}getLocalEulerAngles(){return this.localRotation.getEulerAngles(this.localEulerAngles),this.localEulerAngles}getLocalPosition(){return this.localPosition}getLocalRotation(){return this.localRotation}getLocalScale(){return this.localScale}getLocalTransform(){return this._dirtyLocal&&(this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale),this._dirtyLocal=!1),this.localTransform}getPosition(){return this.getWorldTransform().getTranslation(this.position),this.position}getRotation(){return this.rotation.setFromMat4(this.getWorldTransform()),this.rotation}getScale(){return this._scale||(this._scale=new D),this.getWorldTransform().getScale(this._scale)}getWorldTransform(){return!this._dirtyLocal&&!this._dirtyWorld?this.worldTransform:(this._parent&&this._parent.getWorldTransform(),this._sync(),this.worldTransform)}get worldScaleSign(){return this._worldScaleSign===0&&(this._worldScaleSign=this.getWorldTransform().scaleSign),this._worldScaleSign}remove(){this._parent?.removeChild(this)}reparent(e,t){this.remove(),e&&(t>=0?e.insertChild(this,t):e.addChild(this))}setLocalEulerAngles(e,t,s){this.localRotation.setFromEulerAngles(e,t,s),this._dirtyLocal||this._dirtifyLocal()}setLocalPosition(e,t,s){e instanceof D?this.localPosition.copy(e):this.localPosition.set(e,t,s),this._dirtyLocal||this._dirtifyLocal()}setLocalRotation(e,t,s,i){e instanceof pe?this.localRotation.copy(e):this.localRotation.set(e,t,s,i),this._dirtyLocal||this._dirtifyLocal()}setLocalScale(e,t,s){e instanceof D?this.localScale.copy(e):this.localScale.set(e,t,s),this._dirtyLocal||this._dirtifyLocal()}_dirtifyLocal(){this._dirtyLocal||(this._dirtyLocal=!0,this._dirtyWorld||this._dirtifyWorld())}_unfreezeParentToRoot(){let e=this._parent;for(;e;)e._frozen=!1,e=e._parent}_dirtifyWorld(){this._dirtyWorld||this._unfreezeParentToRoot(),this._dirtifyWorldInternal()}_dirtifyWorldInternal(){if(!this._dirtyWorld){this._frozen=!1,this._dirtyWorld=!0;for(let e=0;e<this._children.length;e++)this._children[e]._dirtyWorld||this._children[e]._dirtifyWorldInternal()}this._dirtyNormal=!0,this._worldScaleSign=0,this._aabbVer++}setPosition(e,t,s){e instanceof D?fi.copy(e):fi.set(e,t,s),this._parent===null?this.localPosition.copy(fi):(od.copy(this._parent.getWorldTransform()).invert(),od.transformPoint(fi,this.localPosition)),this._dirtyLocal||this._dirtifyLocal()}setRotation(e,t,s,i){if(e instanceof pe?mi.copy(e):mi.set(e,t,s,i),this._parent===null)this.localRotation.copy(mi);else{const r=this._parent.getRotation();Mc.copy(r).invert(),this.localRotation.copy(Mc).mul(mi)}this._dirtyLocal||this._dirtifyLocal()}setPositionAndRotation(e,t){if(this._parent===null)this.localPosition.copy(e),this.localRotation.copy(t);else{const s=this._parent.getWorldTransform();od.copy(s).invert(),od.transformPoint(e,this.localPosition),this.localRotation.setFromMat4(od).mul(t)}this._dirtyLocal||this._dirtifyLocal()}setEulerAngles(e,t,s){if(this.localRotation.setFromEulerAngles(e,t,s),this._parent!==null){const i=this._parent.getRotation();Mc.copy(i).invert(),this.localRotation.mul2(Mc,this.localRotation)}this._dirtyLocal||this._dirtifyLocal()}addChild(e){this._prepareInsertChild(e),this._children.push(e),this._onInsertChild(e)}addChildAndSaveTransform(e){const t=e.getPosition(),s=e.getRotation();this._prepareInsertChild(e),e.setPosition(FV.copy(this.worldTransform).invert().transformPoint(t)),e.setRotation(BV.copy(this.getRotation()).invert().mul(s)),this._children.push(e),this._onInsertChild(e)}insertChild(e,t){this._prepareInsertChild(e),this._children.splice(t,0,e),this._onInsertChild(e)}_prepareInsertChild(e){e.remove()}_fireOnHierarchy(e,t,s){this.fire(e,s);for(let i=0;i<this._children.length;i++)this._children[i]._fireOnHierarchy(t,t,s)}_onInsertChild(e){e._parent=this;const t=e._enabled&&this.enabled;e._enabledInHierarchy!==t&&(e._enabledInHierarchy=t,e._notifyHierarchyStateChanged(e,t)),e._updateGraphDepth(),e._dirtifyWorld(),this._frozen&&e._unfreezeParentToRoot(),e._fireOnHierarchy("insert","inserthierarchy",this),this.fire&&this.fire("childinsert",e)}_updateGraphDepth(){this._graphDepth=this._parent?this._parent._graphDepth+1:0;for(let e=0,t=this._children.length;e<t;e++)this._children[e]._updateGraphDepth()}removeChild(e){const t=this._children.indexOf(e);t!==-1&&(this._children.splice(t,1),e._parent=null,e._fireOnHierarchy("remove","removehierarchy",this),this.fire("childremove",e))}_sync(){if(this._dirtyLocal&&(this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale),this._dirtyLocal=!1),this._dirtyWorld){if(this._parent===null)this.worldTransform.copy(this.localTransform);else if(this.scaleCompensation){let e;const t=this._parent;let s=this.localScale,i=t;if(i){for(;i&&i.scaleCompensation;)i=i._parent;i&&(i=i._parent,i&&(e=i.worldTransform.getScale(),VD.mul2(e,this.localScale),s=VD))}A0.setFromMat4(t.worldTransform),kD.mul2(A0,this.localRotation);let r=t.worldTransform;t.scaleCompensation&&(GD.mul2(e,t.getLocalScale()),zD.setTRS(t.worldTransform.getTranslation(b0),A0,GD),r=zD),r.transformPoint(this.localPosition,b0),this.worldTransform.setTRS(b0,kD,s)}else this.worldTransform.mulAffine2(this._parent.worldTransform,this.localTransform);this._dirtyWorld=!1}}syncHierarchy(){if(!this._enabled||this._frozen)return;this._frozen=!0,(this._dirtyLocal||this._dirtyWorld)&&this._sync();const e=this._children;for(let t=0,s=e.length;t<s;t++)e[t].syncHierarchy()}lookAt(e,t,s,i=0,r=1,a=0){if(e instanceof D)w0.copy(e),t instanceof D?Fp.copy(t):Fp.copy(D.UP);else{if(s===void 0)return;w0.set(e,t,s),Fp.set(i,r,a)}HD.setLookAt(this.getPosition(),w0,Fp),mi.setFromMat4(HD),this.setRotation(mi)}translate(e,t,s){e instanceof D?fi.copy(e):fi.set(e,t,s),fi.add(this.getPosition()),this.setPosition(fi)}translateLocal(e,t,s){e instanceof D?fi.copy(e):fi.set(e,t,s),this.localRotation.transformVector(fi,fi),this.localPosition.add(fi),this._dirtyLocal||this._dirtifyLocal()}rotate(e,t,s){if(mi.setFromEulerAngles(e,t,s),this._parent===null)this.localRotation.mul2(mi,this.localRotation);else{const i=this.getRotation(),r=this._parent.getRotation();Mc.copy(r).invert(),mi.mul2(Mc,mi),this.localRotation.mul2(mi,i)}this._dirtyLocal||this._dirtifyLocal()}rotateLocal(e,t,s){mi.setFromEulerAngles(e,t,s),this.localRotation.mul(mi),this._dirtyLocal||this._dirtifyLocal()}constructor(e="Untitled"){super(),this.tags=new xf(this),this.localPosition=new D,this.localRotation=new pe,this.localScale=new D(1,1,1),this.localEulerAngles=new D,this.position=new D,this.rotation=new pe,this.eulerAngles=new D,this._scale=null,this.localTransform=new fe,this._dirtyLocal=!1,this._aabbVer=0,this._frozen=!1,this.worldTransform=new fe,this._dirtyWorld=!1,this._worldScaleSign=0,this._normalMatrix=new $i,this._dirtyNormal=!0,this._right=null,this._up=null,this._forward=null,this._parent=null,this._children=[],this._graphDepth=0,this._enabled=!0,this._enabledInHierarchy=!1,this.scaleCompensation=!1,this.name=e}}const XD=new fe,qD=new fe,YD=new fe;class pr{static create(e,t,s){const i=new KE;switch(i.node=new Dt(e),i.aspectRatio=1,i.aspectRatioMode=Zx,i._scissorRectClear=!0,t){case wt:i.node.setRotation(pr.pointLightRotations[s]),i.fov=90,i.projection=dr;break;case bt:i.projection=dr;break;case Ne:i.projection=Dv;break}return i}static evalSpotCookieMatrix(e){let t=pr._spotCookieCamera;t||(t=pr.create("SpotCookieCamera",bt),pr._spotCookieCamera=t),t.fov=e._outerConeAngle*2;const s=t._node;s.setPosition(e._node.getPosition()),s.setRotation(e._node.getRotation()),s.rotateLocal(-90,0,0),XD.setTRS(s.getPosition(),s.getRotation(),D.ONE).invert(),qD.mul2(t.projectionMatrix,XD);const i=e.cookieMatrix,r=e.atlasViewport;return YD.setViewport(r.x,r.y,r.z,r.w),i.mul2(YD,qD),i}}pr.pointLightRotations=[new pe().setFromEulerAngles(0,90,180),new pe().setFromEulerAngles(0,-90,180),new pe().setFromEulerAngles(90,0,0),new pe().setFromEulerAngles(-90,0,0),new pe().setFromEulerAngles(0,180,180),new pe().setFromEulerAngles(0,0,180)];pr._spotCookieCamera=null;const Ni=new D,zo=new Float32Array(6),UV=new D(-.5,0,0),zV=new D(0,0,.5),zt={POSITION_RANGE:0,DIRECTION_FLAGS:1,COLOR_ANGLES_BIAS:2,PROJ_MAT_0:3,ATLAS_VIEWPORT:3,PROJ_MAT_1:4,PROJ_MAT_2:5,PROJ_MAT_3:6,AREA_DATA_WIDTH:7,AREA_DATA_HEIGHT:8,COUNT:9},kV={LIGHTSHAPE_PUNCTUAL:`${_r}u`,LIGHTSHAPE_RECT:`${x2}u`,LIGHTSHAPE_DISK:`${T2}u`,LIGHTSHAPE_SPHERE:`${E2}u`,LIGHT_COLOR_DIVIDER:`${E_}.0`},jD=(c,e)=>Object.keys(c).map(t=>`#define {${e}${t}} ${c[t]}`).join(`
`),$D=`

		${jD(zt,"CLUSTER_TEXTURE_")}
		${jD(kV,"")}
`;class VV{destroy(){this.lightsTexture?.destroy(),this.lightsTexture=null}createTexture(e,t,s,i,r){return new De(e,{name:r,width:t,height:s,mipmaps:!1,format:i,addressU:Te,addressV:Te,type:qr,magFilter:ze,minFilter:ze,anisotropy:1})}setBounds(e,t){this.boundsMin.copy(e),this.boundsDelta.copy(t)}uploadTextures(){this.lightsTexture.lock().set(this.lightsFloat),this.lightsTexture.unlock()}updateUniforms(){this._lightsTextureId.setValue(this.lightsTexture)}getSpotDirection(e,t){t._node.getWorldTransform().getY(e).mulScalar(-1),e.normalize()}getLightAreaSizes(e){const t=e._node.getWorldTransform();return t.transformVector(UV,Ni),zo[0]=Ni.x,zo[1]=Ni.y,zo[2]=Ni.z,t.transformVector(zV,Ni),zo[3]=Ni.x,zo[4]=Ni.y,zo[5]=Ni.z,zo}addLightData(e,t){const s=e._type===bt,i=e.atlasViewportAllocated,r=this.cookiesEnabled&&!!e._cookie&&i,a=this.areaLightsEnabled&&e.shape!==_r,o=this.shadowsEnabled&&e.castShadows&&i,h=e._node.getPosition();let u=null,f=null;s?o?u=e.getRenderData(null,0).shadowMatrix:r&&(u=pr.evalSpotCookieMatrix(e)):(o||r)&&(f=e.atlasViewport);const m=this.lightsFloat,_=this.lightsUint,g=t*this.lightsTexture.width*4;m[g+4*zt.POSITION_RANGE+0]=h.x,m[g+4*zt.POSITION_RANGE+1]=h.y,m[g+4*zt.POSITION_RANGE+2]=h.z,m[g+4*zt.POSITION_RANGE+3]=e.attenuationEnd;const S=e.clusteredData;if(_[g+4*zt.COLOR_ANGLES_BIAS+0]=S[0],_[g+4*zt.COLOR_ANGLES_BIAS+1]=S[1],_[g+4*zt.COLOR_ANGLES_BIAS+2]=S[2],e.castShadows){const x=e.getRenderData(null,0),T=e._getUniformBiasValues(x),E=pl.float2Half(T.bias),b=pl.float2Half(T.normalBias);_[g+4*zt.COLOR_ANGLES_BIAS+3]=E|b<<16}if(s&&(this.getSpotDirection(Ni,e),m[g+4*zt.DIRECTION_FLAGS+0]=Ni.x,m[g+4*zt.DIRECTION_FLAGS+1]=Ni.y,m[g+4*zt.DIRECTION_FLAGS+2]=Ni.z),_[g+4*zt.DIRECTION_FLAGS+3]=e.getClusteredFlags(o,r),u){const x=u.data;for(let T=0;T<16;T++)m[g+4*zt.PROJ_MAT_0+T]=x[T]}if(f&&(m[g+4*zt.ATLAS_VIEWPORT+0]=f.x,m[g+4*zt.ATLAS_VIEWPORT+1]=f.y,m[g+4*zt.ATLAS_VIEWPORT+2]=f.z/3),a){const x=this.getLightAreaSizes(e);m[g+4*zt.AREA_DATA_WIDTH+0]=x[0],m[g+4*zt.AREA_DATA_WIDTH+1]=x[1],m[g+4*zt.AREA_DATA_WIDTH+2]=x[2],m[g+4*zt.AREA_DATA_HEIGHT+0]=x[3],m[g+4*zt.AREA_DATA_HEIGHT+1]=x[4],m[g+4*zt.AREA_DATA_HEIGHT+2]=x[5]}}constructor(e){this.areaLightsEnabled=!1,this.device=e,Ue.get(e,ot).set("lightBufferDefinesPS",$D),Ue.get(e,Je).set("lightBufferDefinesPS",$D),this.cookiesEnabled=!1,this.shadowsEnabled=!1,this.areaLightsEnabled=!1,this.maxLights=255;const t=zt.COUNT;this.lightsFloat=new Float32Array(4*t*this.maxLights),this.lightsUint=new Uint32Array(this.lightsFloat.buffer),this.lightsTexture=this.createTexture(this.device,t,this.maxLights,fs,"LightsTexture"),this._lightsTextureId=this.device.scope.resolve("lightsTexture"),this.invMaxColorValue=0,this.invMaxAttenuation=0,this.boundsMin=new D,this.boundsDelta=new D}}const Bp=new D,Up=new D,zp=new D,C0=new Ge;class KD{constructor(){this.light=null,this.min=new D,this.max=new D}}class Qx{set maxCellLightCount(e){e!==this._maxCellLightCount&&(this._maxCellLightCount=e,this._cellsDirty=!0)}get maxCellLightCount(){return this._maxCellLightCount}set cells(e){Bp.copy(e).floor(),this._cells.equals(Bp)||(this._cells.copy(Bp),this._cellsLimit.copy(Bp).sub(D.ONE),this._cellsDirty=!0)}get cells(){return this._cells}destroy(){this.lightsBuffer.destroy(),this.releaseClusterTexture()}releaseClusterTexture(){this.clusterTexture&&(this.clusterTexture.destroy(),this.clusterTexture=null)}registerUniforms(e){this._numClusteredLightsId=e.scope.resolve("numClusteredLights"),this._clusterMaxCellsId=e.scope.resolve("clusterMaxCells"),this._clusterWorldTextureId=e.scope.resolve("clusterWorldTexture"),this._clusterBoundsMinId=e.scope.resolve("clusterBoundsMin"),this._clusterBoundsMinData=new Float32Array(3),this._clusterBoundsDeltaId=e.scope.resolve("clusterBoundsDelta"),this._clusterBoundsDeltaData=new Float32Array(3),this._clusterCellsCountByBoundsSizeId=e.scope.resolve("clusterCellsCountByBoundsSize"),this._clusterCellsCountByBoundsSizeData=new Float32Array(3),this._clusterCellsDotId=e.scope.resolve("clusterCellsDot"),this._clusterCellsDotData=new Int32Array(3),this._clusterCellsMaxId=e.scope.resolve("clusterCellsMax"),this._clusterCellsMaxData=new Int32Array(3),this._clusterTextureWidthId=e.scope.resolve("clusterTextureWidth")}updateParams(e){e&&(this.cells=e.cells,this.maxCellLightCount=e.maxLightsPerCell,this.lightsBuffer.cookiesEnabled=e.cookiesEnabled,this.lightsBuffer.shadowsEnabled=e.shadowsEnabled,this.lightsBuffer.areaLightsEnabled=e.areaLightsEnabled)}updateCells(){if(this._cellsDirty){this._cellsDirty=!1;const e=this._cells.x,t=this._cells.y,s=this._cells.z,i=e*t*s,r=this.maxCellLightCount*i;let a=Math.ceil(Math.sqrt(r));a=J.roundUp(a,this.maxCellLightCount);const o=Math.ceil(r/a);this._clusterCellsMaxData[0]=e,this._clusterCellsMaxData[1]=t,this._clusterCellsMaxData[2]=s,this._clusterCellsDotData[0]=this.maxCellLightCount,this._clusterCellsDotData[1]=e*s*this.maxCellLightCount,this._clusterCellsDotData[2]=e*this.maxCellLightCount,this.clusters=new Uint8ClampedArray(r),this.counts=new Int32Array(i),this.releaseClusterTexture(),this.clusterTexture=this.lightsBuffer.createTexture(this.device,a,o,Gg,"ClusterTexture")}}uploadTextures(){this.clusterTexture.lock().set(this.clusters),this.clusterTexture.unlock(),this.lightsBuffer.uploadTextures()}updateUniforms(){this._numClusteredLightsId.setValue(this._usedLights.length),this.lightsBuffer.updateUniforms(),this._clusterWorldTextureId.setValue(this.clusterTexture),this._clusterMaxCellsId.setValue(this.maxCellLightCount);const e=this.boundsDelta;this._clusterCellsCountByBoundsSizeData[0]=this._cells.x/e.x,this._clusterCellsCountByBoundsSizeData[1]=this._cells.y/e.y,this._clusterCellsCountByBoundsSizeData[2]=this._cells.z/e.z,this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData),this._clusterBoundsMinData[0]=this.boundsMin.x,this._clusterBoundsMinData[1]=this.boundsMin.y,this._clusterBoundsMinData[2]=this.boundsMin.z,this._clusterBoundsDeltaData[0]=e.x,this._clusterBoundsDeltaData[1]=e.y,this._clusterBoundsDeltaData[2]=e.z,this._clusterBoundsMinId.setValue(this._clusterBoundsMinData),this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData),this._clusterCellsDotId.setValue(this._clusterCellsDotData),this._clusterCellsMaxId.setValue(this._clusterCellsMaxData),this._clusterTextureWidthId.setValue(this.clusterTexture.width)}evalLightCellMinMax(e,t,s){t.copy(e.min),t.sub(this.boundsMin),t.div(this.boundsDelta),t.mul2(t,this.cells),t.floor(),s.copy(e.max),s.sub(this.boundsMin),s.div(this.boundsDelta),s.mul2(s,this.cells),s.ceil(),t.max(D.ZERO),s.min(this._cellsLimit)}collectLights(e){const t=this.lightsBuffer.maxLights,s=this._usedLights;let i=1;e.forEach(r=>{const a=!!(r.mask&(Qi|Ba)),o=r.type===bt&&r._outerConeAngle===0;if(r.enabled&&r.type!==Ne&&r.visibleThisFrame&&r.intensity>0&&a&&!o&&i<t){let h;i<s.length?h=s[i]:(h=new KD,s.push(h)),h.light=r,r.getBoundingBox(C0),h.min.copy(C0.getMin()),h.max.copy(C0.getMax()),i++}}),s.length=i}evaluateBounds(){const e=this._usedLights,t=this.boundsMin,s=this.boundsMax;if(e.length>1){t.copy(e[1].min),s.copy(e[1].max);for(let i=2;i<e.length;i++)t.min(e[i].min),s.max(e[i].max)}else t.set(0,0,0),s.set(1,1,1);this.boundsDelta.sub2(s,t),this.lightsBuffer.setBounds(t,this.boundsDelta)}updateClusters(e){this.counts.fill(0),this.clusters.fill(0),this.lightsBuffer.areaLightsEnabled=e?e.areaLightsEnabled:!1;const t=this._cells.x,s=this._cells.z,i=this.counts,r=this._maxCellLightCount,a=this.clusters,o=this.maxCellLightCount,h=this._usedLights;for(let u=1;u<h.length;u++){const f=h[u],m=f.light;this.lightsBuffer.addLightData(m,u),this.evalLightCellMinMax(f,Up,zp);const _=Up.x,g=zp.x,S=Up.y,x=zp.y,T=Up.z,E=zp.z;for(let b=_;b<=g;b++)for(let C=T;C<=E;C++)for(let w=S;w<=x;w++){const P=b+t*(C+w*s),I=i[P];I<r&&(a[o*P+I]=u,i[P]=I+1)}}}update(e,t=null){this.updateParams(t),this.updateCells(),this.collectLights(e),this.evaluateBounds(),this.updateClusters(t),this.uploadTextures()}activate(){this.updateUniforms()}constructor(e){this.device=e,this.name="Untitled",this.reportCount=0,this.boundsMin=new D,this.boundsMax=new D,this.boundsDelta=new D,this._cells=new D(1,1,1),this._cellsLimit=new D,this.cells=this._cells,this.maxCellLightCount=4,this._usedLights=[],this._usedLights.push(new KD),this.lightsBuffer=new VV(e),this.registerUniforms(e)}}const GV="muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==";let Ma=null;const K2=()=>{if(!Ma){const c=atob(GV);Ma=Uint8Array.from(c,e=>e.charCodeAt(0))}},HV=()=>(K2(),Ma);class WV{_next(){this.seed=(this.seed+4)%Ma.length}value(){return this._next(),Ma[this.seed]/255}vec4(e=new me){return this._next(),e.set(Ma[this.seed],Ma[this.seed+1],Ma[this.seed+2],Ma[this.seed+3]).mulScalar(1/255)}constructor(e=0){this.seed=0,this.seed=e*4,K2()}}const XV=[new D(-1,0,0),new D(1,0,0),new D(0,-1,0),new D(0,1,0),new D(0,0,-1),new D(0,0,1)];class qV{update(e,t){const s=this.colors,{r:i,g:r,b:a}=e;for(let o=0;o<6;o++)s[o*3]=i,s[o*3+1]=r,s[o*3+2]=a;for(let o=0;o<t.length;o++){const h=t[o];if(h._type===Ne)for(let u=0;u<6;u++){const f=Math.max(XV[u].dot(h._direction),0)*h._intensity,m=h._color;s[u*3]+=m.r*f,s[u*3+1]+=m.g*f,s[u*3+2]+=m.b*f}}}constructor(){this.colors=new Float32Array(18)}}const YV=(c,e,t,s)=>{const i=new De(c,{name:`${e}${t}`,width:t,height:t,format:Ze,addressU:as,addressV:as,type:qr,magFilter:ze,minFilter:ze,anisotropy:1,mipmaps:!1});return i.lock().set(s),i.unlock(),i},jV=new ks,$V=c=>jV.get(c,()=>{const e=HV(),t=Math.sqrt(e.length/4);return YV(c,"BlueNoise",t,e)});class Cl{destroy(){this.texture&&(this.texture.destroy(),this.texture=null);const e=this.renderTargets;for(let t=0;t<e.length;t++)e[t].destroy();this.renderTargets.length=0}static create(e,t){let s=null;return t._type===wt?s=this.createCubemap(e,t._shadowResolution,t._shadowType):s=this.create2dMap(e,t._shadowResolution,t._shadowType),s}static createAtlas(e,t,s){const i=this.create2dMap(e,t,s),r=i.renderTargets,a=r[0];for(let o=0;o<5;o++)r.push(a);return i}static create2dMap(e,t,s){const i=Xa.get(s);let r=i.format;r===Wr&&!e.textureFloatRenderable&&e.textureHalfFloatRenderable&&(r=If);const a=Ki.get(r)?.name;let o=$t;s===zE&&(o=e.extTextureFloatLinear?$t:ze),s===af&&(o=ze);const h=new De(e,{format:r,width:t,height:t,mipmaps:!1,minFilter:o,magFilter:o,addressU:Te,addressV:Te,name:`ShadowMap2D_${a}`});let u=null;return i?.pcf?(h.compareOnRead=!0,h.compareFunc=X_,u=new At({depthBuffer:h})):u=new At({colorBuffer:h,depth:!0}),e.isWebGPU&&(u.flipY=!0),new Cl(h,[u])}static createCubemap(e,t,s){const i=Xa.get(s),r=Ki.get(i.format)?.name,a=s===af,o=a?ze:$t,h=new De(e,{format:i?.format,width:t,height:t,cubemap:!0,mipmaps:!1,minFilter:o,magFilter:o,addressU:Te,addressV:Te,name:`ShadowMapCube_${r}`});a||(h.compareOnRead=!0,h.compareFunc=X_);const u=[];for(let f=0;f<6;f++)a?u.push(new At({colorBuffer:h,face:f,depth:!0})):u.push(new At({depthBuffer:h,face:f}));return new Cl(h,u)}constructor(e,t){this.texture=e,this.cached=!1,this.renderTargets=t}}const KV=[],ZV=[],pa=new me,D0=new me;class P0{constructor(e){this.size=Math.floor(e.w*1024),this.used=!1,this.lightId=-1,this.rect=e}}class QV{destroy(){this.destroyShadowAtlas(),this.destroyCookieAtlas()}destroyShadowAtlas(){this.shadowAtlas?.destroy(),this.shadowAtlas=null}destroyCookieAtlas(){this.cookieAtlas?.destroy(),this.cookieAtlas=null,this.cookieRenderTarget?.destroy(),this.cookieRenderTarget=null}allocateShadowAtlas(e,t=ur){const s=this.shadowAtlas?.texture.format,i=Xa.get(t).format;if(!this.shadowAtlas||this.shadowAtlas.texture.width!==e||s!==i){this.version++,this.destroyShadowAtlas(),this.shadowAtlas=Cl.createAtlas(this.device,e,t),this.shadowAtlas.cached=!0;const r=4/this.shadowAtlasResolution;this.scissorVec.set(r,r,-2*r,-2*r)}}allocateCookieAtlas(e){this.cookieAtlas.width!==e&&(this.cookieRenderTarget.resize(e,e),this.version++)}allocateUniforms(){this._shadowAtlasTextureId=this.device.scope.resolve("shadowAtlasTexture"),this._shadowAtlasParamsId=this.device.scope.resolve("shadowAtlasParams"),this._shadowAtlasParams=new Float32Array(2),this._cookieAtlasTextureId=this.device.scope.resolve("cookieAtlasTexture")}updateUniforms(){const t=this.shadowAtlas.renderTargets[0].depthBuffer;this._shadowAtlasTextureId.setValue(t),this._shadowAtlasParams[0]=this.shadowAtlasResolution,this._shadowAtlasParams[1]=this.shadowEdgePixels,this._shadowAtlasParamsId.setValue(this._shadowAtlasParams),this._cookieAtlasTextureId.setValue(this.cookieAtlas)}subdivide(e,t){let s=t.atlasSplit;if(!s){const r=Math.ceil(Math.sqrt(e));s=ZV,s[0]=r,s.length=1}if(!((r,a)=>r.length===a.length&&r.every((o,h)=>o===a[h]))(s,this.atlasSplit)){this.version++,this.slots.length=0,this.atlasSplit.length=0,this.atlasSplit.push(...s);const r=this.atlasSplit[0];if(r>1){const a=1/r;for(let o=0;o<r;o++)for(let h=0;h<r;h++){const u=new me(o*a,h*a,a,a),f=this.atlasSplit[1+o*r+h];if(f>1)for(let m=0;m<f;m++)for(let _=0;_<f;_++){const g=a/f,S=new me(u.x+m*g,u.y+_*g,g,g);this.slots.push(new P0(S))}else this.slots.push(new P0(u))}}else this.slots.push(new P0(new me(0,0,1,1)));this.slots.sort((a,o)=>o.size-a.size)}}collectLights(e,t){const s=t.cookiesEnabled,i=t.shadowsEnabled;let r=!1,a=!1;const o=KV;return o.length=0,(s||i)&&(u=>{for(let f=0;f<u.length;f++){const m=u[f];if(m.visibleThisFrame){const _=i&&m.castShadows,g=s&&!!m.cookie;r||(r=_),a||(a=g),(_||g)&&o.push(m)}}})(e),o.sort((u,f)=>f.maxScreenSize-u.maxScreenSize),r&&this.allocateShadowAtlas(this.shadowAtlasResolution,t.shadowType),a&&this.allocateCookieAtlas(this.cookieAtlasResolution),(r||a)&&this.subdivide(o.length,t),o}setupSlot(e,t){e.atlasViewport.copy(t);const s=e.numShadowFaces;for(let i=0;i<s;i++)if(e.castShadows||e._cookie){if(pa.copy(t),D0.copy(t),e._type===bt&&pa.add(this.scissorVec),e._type===wt){const r=pa.z/3,a=this.cubeSlotsOffsets[i];pa.x+=r*a.x,pa.y+=r*a.y,pa.z=r,pa.w=r,D0.copy(pa)}if(e.castShadows){const r=e.getRenderData(null,i);r.shadowViewport.copy(pa),r.shadowScissor.copy(D0)}}}assignSlot(e,t,s){e.atlasViewportAllocated=!0;const i=this.slots[t];i.lightId=e.id,i.used=!0,s&&(e.atlasSlotUpdated=!0,e.atlasVersion=this.version,e.atlasSlotIndex=t)}update(e,t){this.shadowAtlasResolution=t.shadowAtlasResolution,this.cookieAtlasResolution=t.cookieAtlasResolution;const s=this.collectLights(e,t);if(s.length>0){const i=this.slots;for(let o=0;o<i.length;o++)i[o].used=!1;const r=Math.min(s.length,i.length);for(let o=0;o<r;o++){const h=s[o];h.castShadows&&(h._shadowMap=this.shadowAtlas);const u=i[h.atlasSlotIndex];if(h.atlasVersion===this.version&&h.id===u?.lightId){const f=i[h.atlasSlotIndex];f.size===i[o].size&&!f.used&&this.assignSlot(h,h.atlasSlotIndex,!1)}}let a=0;for(let o=0;o<r;o++){for(;a<i.length&&i[a].used;)a++;const h=s[o];h.atlasViewportAllocated||this.assignSlot(h,a,!0);const u=i[h.atlasSlotIndex];this.setupSlot(h,u.rect)}}this.updateUniforms()}constructor(e){this.device=e,this.version=1,this.shadowAtlasResolution=2048,this.shadowAtlas=null,this.shadowEdgePixels=3,this.cookieAtlasResolution=4,this.cookieAtlas=new De(this.device,{name:"CookieAtlas",width:this.cookieAtlasResolution,height:this.cookieAtlasResolution,format:Us,cubemap:!1,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te}),this.cookieRenderTarget=new At({colorBuffer:this.cookieAtlas,depth:!1,flipY:!0}),this.slots=[],this.atlasSplit=[],this.cubeSlotsOffsets=[new ne(0,0),new ne(0,1),new ne(1,0),new ne(1,1),new ne(2,0),new ne(2,1)],this.scissorVec=new me,this.allocateShadowAtlas(1),this.allocateCookieAtlas(1),this.allocateUniforms()}}const ti=[];ti[DE]={src:Ms,dst:Ms,op:gB};ti[qi]={src:Ms,dst:ZT,op:Sr};ti[jr]={src:QT,dst:JT,op:Sr,alphaSrc:Ms};ti[ro]={src:Ms,dst:JT,op:Sr};ti[rf]={src:Ms,dst:Ms,op:Sr};ti[RE]={src:QT,dst:Ms,op:Sr};ti[ME]={src:VM,dst:pB,op:Sr};ti[LE]={src:_B,dst:Ms,op:Sr};ti[PE]={src:VM,dst:ZT,op:Sr};ti[IE]={src:Ms,dst:Ms,op:vB};ti[OE]={src:Ms,dst:Ms,op:SB};let JV=0;class Dl{get hasShaderChunks(){return this._shaderChunks!=null}get shaderChunks(){return this._shaderChunks||(this._shaderChunks=new Ue),this._shaderChunks}getShaderChunks(e=ot){const t=this.shaderChunks;return e===ot?t.glsl:t.wgsl}set shaderChunksVersion(e){this.shaderChunks.version=e}get shaderChunksVersion(){return this.shaderChunks.version}set chunks(e){this._oldChunks=e}get chunks(){return Object.assign(this._oldChunks,Object.fromEntries(this.shaderChunks.glsl)),this._oldChunks}set depthBias(e){this._depthState.depthBias=e}get depthBias(){return this._depthState.depthBias}set slopeDepthBias(e){this._depthState.depthBiasSlope=e}get slopeDepthBias(){return this._depthState.depthBiasSlope}set redWrite(e){this._blendState.redWrite=e}get redWrite(){return this._blendState.redWrite}set greenWrite(e){this._blendState.greenWrite=e}get greenWrite(){return this._blendState.greenWrite}set blueWrite(e){this._blendState.blueWrite=e}get blueWrite(){return this._blendState.blueWrite}set alphaWrite(e){this._blendState.alphaWrite=e}get alphaWrite(){return this._blendState.alphaWrite}get transparent(){return this._blendState.blend}_updateTransparency(){const e=this.transparent,t=this.meshInstances;for(let s=0;s<t.length;s++)t[s].transparent=e}set blendState(e){this._blendState.copy(e),this._updateTransparency()}get blendState(){return this._blendState}set blendType(e){const t=ti[e];this._blendState.setColorBlend(t.op,t.src,t.dst),this._blendState.setAlphaBlend(t.alphaOp??t.op,t.alphaSrc??t.src,t.alphaDst??t.dst);const s=e!==qi;this._blendState.blend!==s&&(this._blendState.blend=s,this._updateTransparency()),this._updateMeshInstanceKeys()}get blendType(){if(!this.transparent)return qi;const{colorOp:e,colorSrcFactor:t,colorDstFactor:s,alphaOp:i,alphaSrcFactor:r,alphaDstFactor:a}=this._blendState;for(let o=0;o<ti.length;o++){const h=ti[o];if(h.src===t&&h.dst===s&&h.op===e&&h.src===r&&h.dst===a&&h.op===i)return o}return jr}set depthState(e){this._depthState.copy(e)}get depthState(){return this._depthState}set depthTest(e){this._depthState.test=e}get depthTest(){return this._depthState.test}set depthFunc(e){this._depthState.func=e}get depthFunc(){return this._depthState.func}set depthWrite(e){this._depthState.write=e}get depthWrite(){return this._depthState.write}copy(e){this.name=e.name,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this._blendState.copy(e._blendState),this._depthState.copy(e._depthState),this.cull=e.cull,this.stencilFront=e.stencilFront?.clone(),e.stencilBack&&(this.stencilBack=e.stencilFront===e.stencilBack?this.stencilFront:e.stencilBack.clone()),this.clearParameters();for(const t in e.parameters)e.parameters.hasOwnProperty(t)&&this._setParameterSimple(t,e.parameters[t].data);return this.defines.clear(),e.defines.forEach((t,s)=>this.defines.set(s,t)),this._shaderChunks=e.hasShaderChunks?new Ue:null,this._shaderChunks?.copy(e._shaderChunks),this}clone(){return new this.constructor().copy(this)}_updateMeshInstanceKeys(){const e=this.meshInstances;for(let t=0;t<e.length;t++)e[t].updateKey()}updateUniforms(e,t){this._dirtyShader&&this.clearVariants()}getShaderVariant(e){}update(){if(Object.keys(this._oldChunks).length>0)for(const[e,t]of Object.entries(this._oldChunks))this.shaderChunks.glsl.set(e,t),delete this._oldChunks[e];(this._definesDirty||this._shaderChunks?.isDirty())&&(this._definesDirty=!1,this._shaderChunks?.resetDirty(),this.clearVariants()),this.dirty=!0}clearParameters(){this.parameters={}}getParameters(){return this.parameters}clearVariants(){this.variants.clear();const e=this.meshInstances,t=e.length;for(let s=0;s<t;s++)e[s].clearShaders()}getParameter(e){return this.parameters[e]}_setParameterSimple(e,t){const s=this.parameters[e];s?s.data=t:this.parameters[e]={scopeId:null,data:t}}setParameter(e,t){if(t===void 0&&typeof e=="object"){const s=e;if(s.length){for(let i=0;i<s.length;i++)this.setParameter(s[i]);return}e=s.name,t=s.value}this._setParameterSimple(e,t)}deleteParameter(e){this.parameters[e]&&delete this.parameters[e]}setParameters(e,t){const s=this.parameters;t===void 0&&(t=s);for(const i in t){const r=s[i];r&&(r.scopeId||(r.scopeId=e.scope.resolve(i)),r.scopeId.setValue(r.data))}}setDefine(e,t){let s=!1;const{defines:i}=this;t!==void 0&&t!==!1?(s=!i.has(e)||i.get(e)!==t,i.set(e,t)):(s=i.has(e),i.delete(e)),this._definesDirty||(this._definesDirty=s)}getDefine(e){return this.defines.has(e)}destroy(){this.variants.clear();for(let e=0;e<this.meshInstances.length;e++){const t=this.meshInstances[e];if(t.clearShaders(),t._material=null,t.mesh){const s=jf(t.mesh.device);this!==s&&(t.material=s)}}this.meshInstances.length=0}addMeshInstanceRef(e){this.meshInstances.push(e)}removeMeshInstanceRef(e){const t=this.meshInstances,s=t.indexOf(e);s!==-1&&t.splice(s,1)}constructor(){this.meshInstances=[],this.name="Untitled",this.userId="",this.id=JV++,this.variants=new Map,this.defines=new Map,this._definesDirty=!1,this.parameters={},this.alphaTest=0,this.alphaToCoverage=!1,this._blendState=new ht,this._depthState=new Gt,this.cull=_l,this.stencilFront=null,this.stencilBack=null,this._shaderChunks=null,this._oldChunks={},this._dirtyShader=!0,this._shaderVersion=0,this._scene=null,this.dirty=!0}}class e4{destroy(){this.clear(),this.cache=null}clear(){this.cache.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.cache.clear()}getKey(e){const t=e._type===wt,s=e._shadowType,i=e._shadowResolution;return`${t}-${s}-${i}`}get(e,t){const s=this.getKey(t),i=this.cache.get(s);if(i&&i.length)return i.pop();const r=Cl.create(e,t);return r.cached=!0,r}add(e,t){const s=this.getKey(e),i=this.cache.get(s);i?i.push(t):this.cache.set(s,[t])}constructor(){this.cache=new Map}}class Z2 extends ii{execute(){this.shadowRenderer.renderFace(this.light,null,this.face,!1)}after(){this.applyVsm&&this.shadowRenderer.renderVsm(this.light,this.shadowCamera)}constructor(e,t,s,i,r){super(e),this.requiresCubemaps=!1,this.shadowRenderer=t,this.light=s,this.face=i,this.applyVsm=r,this.shadowCamera=t.prepareFace(s,null,i),t.setupRenderPass(this,this.shadowCamera,!0)}}class t4{cull(e,t,s=null){const i=this.renderer.scene.clusteredLightingEnabled;e.visibleThisFrame=!0,i||e._shadowMap||(e._shadowMap=Cl.create(this.device,e));const r=e._type,a=r===bt?1:6;for(let o=0;o<a;o++){const h=e.getRenderData(null,o),u=h.shadowCamera;u.nearClip=e.attenuationEnd/1e3,u.farClip=e.attenuationEnd;const f=u._node,m=e._node;if(f.setPosition(m.getPosition()),r===bt)u.fov=e._outerConeAngle*2,f.setRotation(m.getRotation()),f.rotateLocal(-90,0,0);else if(r===wt)if(i){const S=2/(this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution*e.atlasViewport.z/3)*this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;u.fov=Math.atan(1+S)*J.RAD_TO_DEG*2}else u.fov=90;this.renderer.updateCameraFrustum(u),this.shadowRenderer.cullShadowCasters(t,e,h.visibleCasters,u,s)}}prepareLights(e,t){let s;for(let i=0;i<t.length;i++){const r=t[i];if(this.shadowRenderer.needsShadowRendering(r)&&r.atlasViewportAllocated){e.push(r);for(let a=0;a<r.numShadowFaces;a++)s=this.shadowRenderer.prepareFace(r,null,a)}}return s}buildNonClusteredRenderPasses(e,t){for(let s=0;s<t.length;s++){const i=t[s];if(this.shadowRenderer.needsShadowRendering(i)){const r=i._type===bt,a=i.numShadowFaces;for(let o=0;o<a;o++){const h=new Z2(this.device,this.shadowRenderer,i,o,r);e.addRenderPass(h)}}}}constructor(e,t){this.shadowLights=[],this.renderer=e,this.shadowRenderer=t,this.device=e.device}}class s4 extends ii{execute(){const{light:e,camera:t,shadowRenderer:s,allCascadesRendering:i}=this,r=e.numShadowFaces,a=e.shadowUpdateOverrides;for(let o=0;o<r;o++)a?.[o]!==Yi&&s.renderFace(e,t,o,!i),a?.[o]===Kn&&(a[o]=Yi)}after(){this.shadowRenderer.renderVsm(this.light,this.camera)}constructor(e,t,s,i,r){super(e),this.shadowRenderer=t,this.light=s,this.camera=i,this.allCascadesRendering=r}}const kp=new Ge,_a=new D,ZD=new fe,yt=[new D,new D,new D,new D,new D,new D,new D,new D],R0={min:0,max:0};function i4(c,e,t){yt[0].x=yt[1].x=yt[2].x=yt[3].x=e.x,yt[1].y=yt[3].y=yt[7].y=yt[5].y=e.y,yt[2].z=yt[3].z=yt[6].z=yt[7].z=e.z,yt[4].x=yt[5].x=yt[6].x=yt[7].x=t.x,yt[0].y=yt[2].y=yt[4].y=yt[6].y=t.y,yt[0].z=yt[1].z=yt[4].z=yt[5].z=t.z;let s=9999999999,i=-9999999999;for(let r=0;r<8;++r){c.transformPoint(yt[r],yt[r]);const a=yt[r].z;a<s&&(s=a),a>i&&(i=a)}return R0.min=s,R0.max=i,R0}class r4{cull(e,t,s,i=null){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=Cl.create(this.device,e));const r=s._nearClip;this.generateSplitDistances(e,r,Math.min(s._farClip,e.shadowDistance));const a=e.shadowUpdateOverrides;for(let o=0;o<e.numCascades&&a?.[o]!==Yi;o++){const h=e.getRenderData(s,o),u=h.shadowCamera;u.renderTarget=e._shadowMap.renderTargets[0],h.shadowViewport.copy(e.cascades[o]),h.shadowScissor.copy(e.cascades[o]);const f=u._node,m=e._node;f.setPosition(m.getPosition()),f.setRotation(m.getRotation()),f.rotateLocal(-90,0,0);const _=o===0?r:e._shadowCascadeDistances[o-1],g=e._shadowCascadeDistances[o],S=s.getFrustumCorners(_,g);_a.set(0,0,0);const x=s.node.getWorldTransform();for(let k=0;k<8;k++)x.transformPoint(S[k],S[k]),_a.add(S[k]);_a.mulScalar(1/8);let T=0;for(let k=0;k<8;k++){const O=S[k].sub(_a).length();O>T&&(T=O)}const E=f.right,b=f.up,C=f.forward,w=.25*e._shadowResolution/T,P=Math.ceil(_a.dot(b)*w)/w,I=Math.ceil(_a.dot(E)*w)/w,M=b.mulScalar(P),R=E.mulScalar(I),L=_a.dot(C),B=C.mulScalar(L);_a.add2(M,R).add(B),f.setPosition(_a),f.translateLocal(0,0,1e6),u.nearClip=.01,u.farClip=2e6,u.orthoHeight=T,this.renderer.updateCameraFrustum(u),this.shadowRenderer.cullShadowCasters(t,e,h.visibleCasters,u,i);const G=1<<o,H=h.visibleCasters,ee=H.length;let j=0;for(let k=0;k<ee;k++){const O=H[k];O.shadowCascadeMask&G&&(H[j++]=O,j===1?kp.copy(O.aabb):kp.add(O.aabb))}ee!==j&&(H.length=j),ZD.copy(f.getWorldTransform()).invert();const ae=i4(ZD,kp.getMin(),kp.getMax());f.translateLocal(0,0,ae.max+.1),u.farClip=ae.max-ae.min+.2,h.projectionCompensation=T}}generateSplitDistances(e,t,s){e._shadowCascadeDistances.fill(s);for(let i=1;i<e.numCascades;i++){const r=i/e.numCascades,a=t+(s-t)*r,o=t*(s/t)**r,h=J.lerp(a,o,e.cascadeDistribution);e._shadowCascadeDistances[i-1]=h}}getLightRenderPass(e,t){let s=null;if(this.shadowRenderer.needsShadowRendering(e)){const i=e.numShadowFaces,r=e.shadowUpdateOverrides;let a=!0,o;for(let h=0;h<i;h++)r?.[h]===Yi&&(a=!1),o=this.shadowRenderer.prepareFace(e,t,h);s=new s4(this.device,this.shadowRenderer,e,t,a),this.shadowRenderer.setupRenderPass(s,o,a)}return s}constructor(e,t){this.renderer=e,this.shadowRenderer=t,this.device=e.device}}const M0=new Set,QD=new fe,JD=new fe,ko=new Float32Array(2),ld=new me(1,1,0,0),eP=new fe;function a4(c,e){return Math.exp(-(c*c)/(2*e*e))}function n4(c){const e=(c-1)/6,t=(c-1)*.5,s=new Array(c);let i=0;for(let r=0;r<c;++r)s[r]=a4(r-t,e),i+=s[r];for(let r=0;r<c;++r)s[r]/=i;return s}class Q2{static createShadowCamera(e,t,s){const i=pr.create(W2,t,s),r=Xa.get(e),a=r?.vsm??!1,o=r?.pcf??!1;return a?i.clearColor=new ue(0,0,0,0):i.clearColor=new ue(1,1,1,1),i.clearDepthBuffer=!0,i.clearStencilBuffer=!1,i.clearColorBuffer=!o,i}_cullShadowCastersInternal(e,t,s){const i=e.length;for(let r=0;r<i;r++){const a=e[r];a.castShadow&&(!a.cull||a._isVisible(s))&&(a.visibleThisFrame=!0,t.push(a))}}cullShadowCasters(e,t,s,i,r){if(this.renderer.scene?.fire(G2,i),s.length=0,r)this._cullShadowCastersInternal(r,s,i);else{const a=e.layerList,o=a.length;for(let h=0;h<o;h++){const u=a[h];u._lightsSet.has(t)&&(M0.has(u)||(M0.add(u),this._cullShadowCastersInternal(u.shadowCasters,s,i)))}M0.clear()}s.sort(this.sortCompareShader),this.renderer.scene?.fire(H2,i)}sortCompareShader(e,t){const s=e._sortKeyShadow,i=t._sortKeyShadow;return s===i?t.mesh.id-e.mesh.id:i-s}setupRenderState(e,t){const i=this.renderer.scene.clusteredLightingEnabled?t._isPcf:t._isPcf&&t._type!==wt;e.setBlendState(i?this.blendStateNoWrite:this.blendStateWrite),e.setDepthState(t.shadowDepthState),e.setStencilState(null,null)}dispatchUniforms(e,t,s,i){const r=t._node;e._type!==Ne&&(this.renderer.dispatchViewPos(r.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),QD.setTRS(r.getPosition(),r.getRotation(),D.ONE).invert(),JD.mul2(t.projectionMatrix,QD);const a=s.shadowViewport;t.rect=a,t.scissorRect=s.shadowScissor,eP.setViewport(a.x,a.y,a.z,a.w),s.shadowMatrix.mul2(eP,JD),e._type===Ne&&e._shadowMatrixPalette.set(s.shadowMatrix.data,i*16)}getShadowPass(e){const t=e._type,s=e._shadowType;let i=this.shadowPassCache[t]?.[s];if(!i){const r=`ShadowPass_${t}_${s}`;i=Gr.get(this.device).allocate(r,{isShadow:!0,lightType:t,shadowType:s}),this.shadowPassCache[t]||(this.shadowPassCache[t]=[]),this.shadowPassCache[t][s]=i}return i.index}submitCasters(e,t,s){const i=this.device,r=this.renderer,a=r.scene,o=1<<z2,h=this.getShadowPass(t),u=s.shaderParams,f=s.renderTarget.flipY?-1:1,m=e.length;for(let _=0;_<m;_++){const g=e[_],S=g.mesh,x=g.instancingData;if(x&&x.count<=0)continue;g.ensureMaterial(i);const T=g.material;r.setBaseConstants(i,T),r.setSkinning(i,g),T.dirty&&(T.updateUniforms(i,a),T.dirty=!1),r.setupCullMode(!0,f,g),T.setParameters(i),g.setParameters(i,o);const E=g.getShaderInstance(h,0,a,u,this.viewUniformFormat,this.viewBindGroupFormat),b=E.shader;if(b.failed)continue;g._sortKeyShadow=b.id,i.setShader(b),r.setVertexBuffers(i,S),r.setMorphing(i,g.morphInstance),x&&i.setVertexBuffer(x.vertexBuffer),r.setMeshInstanceMatrices(g),r.setupMeshUniformBuffers(E);const C=g.renderStyle,w=g.getDrawCommands(s);i.draw(S.primitive[C],S.indexBuffer[C],x?.count,w),r._shadowDrawCalls++,x&&r._instancedDrawCalls++}}needsShadowRendering(e){const t=e.enabled&&e.castShadows&&e.shadowUpdateMode!==Yi&&e.visibleThisFrame;return e.shadowUpdateMode===Kn&&(e.shadowUpdateMode=Yi),t&&(this.renderer._shadowMapUpdates+=e.numShadowFaces),t}getLightRenderData(e,t,s){return e.getRenderData(e._type===Ne?t:null,s)}setupRenderPass(e,t,s){const i=t.renderTarget;e.init(i),e.depthStencilOps.clearDepthValue=1,e.depthStencilOps.clearDepth=s,i.depthBuffer?e.depthStencilOps.storeDepth=!0:(e.colorOps.clearValue.copy(t.clearColor),e.colorOps.clear=s,e.depthStencilOps.storeDepth=!1),e.requiresCubemaps=!1}prepareFace(e,t,s){const i=e._type,a=this.getLightRenderData(e,t,s).shadowCamera,o=i===Ne?0:s;return a.renderTarget=e._shadowMap.renderTargets[o],a}renderFace(e,t,s,i){const r=this.device,a=this.getLightRenderData(e,t,s),o=a.shadowCamera;this.dispatchUniforms(e,o,a,s);const h=o.renderTarget,u=this.renderer;u.setCameraUniforms(o,h),r.supportsUniformBuffers&&u.setupViewUniformBuffers(a.viewBindGroups,this.viewUniformFormat,this.viewBindGroupFormat,null),u.setupViewport(o,h),i&&u.clear(o),this.setupRenderState(r,e),this.submitCasters(a.visibleCasters,e,o)}renderVsm(e,t){e._isVsm&&e._vsmBlurSize>1&&(!this.renderer.scene.clusteredLightingEnabled||e._type===Ne)&&this.applyVsmBlur(e,t)}getVsmBlurShader(e,t){const s=this.blurVsmShader;let i=s[e][t];if(!i){this.blurVsmWeights[t]=n4(t);const r=new Map;r.set("{SAMPLES}",t),e===1&&r.set("GAUSS",""),i=ns.createShader(this.device,{uniqueName:`blurVsm${e}${t}`,attributes:{vertex_position:He},vertexChunk:"fullscreenQuadVS",fragmentChunk:"blurVSMPS",fragmentDefines:r}),s[e][t]=i}return i}applyVsmBlur(e,t){const s=this.device;s.setBlendState(ht.NOBLEND);const a=e.getRenderData(e._type===Ne?t:null,0).shadowCamera.renderTarget,o=this.renderer.shadowMapCache.get(s,e),h=o.renderTargets[0],u=e.vsmBlurMode,f=e._vsmBlurSize,m=this.getVsmBlurShader(u,f);ld.z=e._shadowResolution-2,ld.w=ld.z,this.sourceId.setValue(a.colorBuffer),ko[0]=1/e._shadowResolution,ko[1]=0,this.pixelOffsetId.setValue(ko),u===kE&&this.weightId.setValue(this.blurVsmWeights[f]),gr(s,h,m,null,ld),this.sourceId.setValue(h.colorBuffer),ko[1]=ko[0],ko[0]=0,this.pixelOffsetId.setValue(ko),gr(s,a,m,null,ld),this.renderer.shadowMapCache.add(e,o)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new uo(this.device,[new Be("matrix_viewProjection",Or)]),this.viewBindGroupFormat=new Vr(this.device,[new io(Tv,Tl|El)]))}frameUpdate(){this.initViewBindGroupFormat()}constructor(e,t){this.shadowPassCache=[],this.device=e.device,this.renderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this.blendStateWrite=new ht,this.blendStateNoWrite=new ht,this.blendStateNoWrite.setColorWrite(!1,!1,!1,!1)}}const Vp=[];class o4{destroy(){this._empty&&(this._empty.destroy(),this._empty=null),this._allocated.forEach(e=>{e.destroy()}),this._allocated.length=0}get count(){return this._allocated.length}get empty(){if(!this._empty){const e=new Qx(this.device);e.name="ClusterEmpty",e.update([]),this._empty=e}return this._empty}assign(e){Vp.push(...this._allocated),this._allocated.length=0,this._clusters.clear();const t=e.length;for(let s=0;s<t;s++){const r=e[s].renderActions;if(r){const a=r.length;for(let o=0;o<a;o++){const h=r[o];h.lightClusters=null;const u=h.layer;if(u.hasClusteredLights&&u.meshInstances.length){const f=u.getLightIdHash();let _=this._clusters.get(f)?.lightClusters;_||(_=Vp.pop()??new Qx(this.device),this._allocated.push(_),this._clusters.set(f,h)),h.lightClusters=_}h.lightClusters||(h.lightClusters=this.empty)}}}Vp.forEach(s=>s.destroy()),Vp.length=0}update(e,t){this.assign(e),this._clusters.forEach(s=>{const i=s.layer;s.lightClusters.update(i.clusteredLightsSet,t)})}constructor(e){this._empty=null,this._allocated=[],this._clusters=new Map,this.device=e}}const Nn=new me,L0=[];class ZE extends ii{destroy(){this._quadRenderer2D?.destroy(),this._quadRenderer2D=null,this._quadRendererCube?.destroy(),this._quadRendererCube=null,this._evtDeviceRestored?.off(),this._evtDeviceRestored=null}static create(e,t){const s=new ZE(e.device,t);return s.init(e),s.colorOps.clear=!1,s.depthStencilOps.clearDepth=!1,s}onDeviceRestored(){this._forceCopy=!0}update(e){const t=this._filteredLights;this.filter(e,t),this.executeEnabled=t.length>0}filter(e,t){for(let s=0;s<e.length;s++){const i=e[s];i._type!==Ne&&i.atlasViewportAllocated&&(!i.atlasSlotUpdated&&!this._forceCopy||i.enabled&&i.cookie&&i.visibleThisFrame&&t.push(i))}this._forceCopy=!1}initInvViewProjMatrices(){if(!L0.length)for(let e=0;e<6;e++){const t=pr.create(null,wt,e),s=t.projectionMatrix,i=t.node.getLocalTransform().clone().invert();L0[e]=new fe().mul2(s,i).invert()}}get quadRenderer2D(){if(!this._quadRenderer2D){const e=ns.createShader(this.device,{uniqueName:"cookieRenderer2d",attributes:{vertex_position:He},vertexChunk:"cookieBlitVS",fragmentChunk:"cookieBlit2DPS"});this._quadRenderer2D=new uf(e)}return this._quadRenderer2D}get quadRendererCube(){if(!this._quadRendererCube){const e=ns.createShader(this.device,{uniqueName:"cookieRendererCube",attributes:{vertex_position:He},vertexChunk:"cookieBlitVS",fragmentChunk:"cookieBlitCubePS"});this._quadRendererCube=new uf(e)}return this._quadRendererCube}execute(){const e=this.device;e.setBlendState(ht.NOBLEND),e.setCullMode(Ft),e.setDepthState(Gt.NODEPTH),e.setStencilState();const t=this.renderTarget.colorBuffer.width,s=this._cubeSlotsOffsets,i=this._filteredLights;for(let r=0;r<i.length;r++){const a=i[r],o=a.numShadowFaces,h=o>1?this.quadRendererCube:this.quadRenderer2D;o>1&&this.initInvViewProjMatrices(),this.blitTextureId.setValue(a.cookie);for(let u=0;u<o;u++){if(Nn.copy(a.atlasViewport),o>1){const f=Nn.z/3,m=s[u];Nn.x+=f*m.x,Nn.y+=f*m.y,Nn.z=f,Nn.w=f,this.invViewProjId.setValue(L0[u].data)}Nn.mulScalar(t),h.render(Nn)}}i.length=0}constructor(e,t){super(e),this._quadRenderer2D=null,this._quadRendererCube=null,this._filteredLights=[],this._forceCopy=!1,this._evtDeviceRestored=null,this._cubeSlotsOffsets=t,this.requiresCubemaps=!1,this.blitTextureId=e.scope.resolve("blitTexture"),this.invViewProjId=e.scope.resolve("invViewProj"),this._evtDeviceRestored=e.on("devicerestored",this.onDeviceRestored,this)}}class J2 extends ii{update(e){const t=this.shadowRendererLocal.shadowLights,s=this.shadowRendererLocal.prepareLights(t,e),i=t.length;this.enabled=i>0,i&&this.shadowRenderer.setupRenderPass(this,s,!1)}execute(){const e=this.shadowRendererLocal.shadowLights,t=e.length;for(let s=0;s<t;s++){const i=e[s];for(let r=0;r<i.numShadowFaces;r++)this.shadowRenderer.renderFace(i,null,r,!0)}e.length=0}constructor(e,t,s){super(e),this.requiresCubemaps=!1,this.shadowRenderer=t,this.shadowRendererLocal=s}}class l4 extends ii{update(e,t,s,i,r){this.frameGraph=e,this.cookiesRenderPass.enabled=s,s&&this.cookiesRenderPass.update(i),this.shadowRenderPass.enabled=t,t&&this.shadowRenderPass.update(r)}destroy(){this.cookiesRenderPass.destroy(),this.cookiesRenderPass=null}execute(){const{renderer:e}=this,{scene:t}=e;e.worldClustersAllocator.update(this.frameGraph.renderPasses,t.lighting)}constructor(e,t,s,i,r){super(e),this.renderer=t,this.frameGraph=null,this.cookiesRenderPass=ZE.create(r.cookieRenderTarget,r.cubeSlotsOffsets),this.beforePasses.push(this.cookiesRenderPass),this.shadowRenderPass=new J2(e,s,i),this.beforePasses.push(this.shadowRenderPass)}}let I0=0;const Pr=new fe,Fn=new fe,Lc=new fe,tP=new $i,O0=new KT,sP=new kM,iP=new fe().setScale(1,-1,1),N0=new Set,F0=new Set,B0=new wE,rP=new fe().set([1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1]),aP=[new ne(.5,.333333),new ne(.25,.666667),new ne(.75,.111111),new ne(.125,.444444),new ne(.625,.777778),new ne(.375,.222222),new ne(.875,.555556),new ne(.0625,.888889),new ne(.5625,.037037),new ne(.3125,.37037),new ne(.8125,.703704),new ne(.1875,.148148),new ne(.6875,.481481),new ne(.4375,.814815),new ne(.9375,.259259),new ne(.03125,.592593)],c4=new fe,h4=new fe,u4=new fe,d4=new fe,f4=new fe,m4=new fe,Ic=new Set,U0=[],z0=[];class p4{destroy(){this.shadowRenderer=null,this._shadowRendererLocal=null,this._shadowRendererDirectional=null,this.shadowMapCache.destroy(),this.shadowMapCache=null,this._renderPassUpdateClustered?.destroy(),this._renderPassUpdateClustered=null,this.lightTextureAtlas.destroy(),this.lightTextureAtlas=null,this.gsplatDirector?.destroy(),this.gsplatDirector=null}setupViewport(e,t){const s=this.device,i=t?t.width:s.width,r=t?t.height:s.height,a=e.rect;let o=Math.floor(a.x*i),h=Math.floor(a.y*r),u=Math.floor(a.z*i),f=Math.floor(a.w*r);if(s.setViewport(o,h,u,f),e._scissorRectClear){const m=e.scissorRect;o=Math.floor(m.x*i),h=Math.floor(m.y*r),u=Math.floor(m.z*i),f=Math.floor(m.w*r)}s.setScissor(o,h,u,f)}setCameraUniforms(e,t){const s=t?.flipY;let i=null;if(e.xr&&e.xr.session){const o=e._node?.parent?.getWorldTransform()||null;i=e.xr.views.list;for(let u=0;u<i.length;u++)i[u].updateTransforms(o)}else{let o=e.projectionMatrix;e.calculateProjection&&e.calculateProjection(o,Op);let h=e.getProjectionMatrixSkybox();s&&(o=c4.mul2(iP,o),h=h4.mul2(iP,h)),this.device.isWebGPU&&(o=u4.mul2(rP,o),h=d4.mul2(rP,h));const{jitter:u}=e;let f=0,m=0;if(u>0){const g=t?t.width:this.device.width,S=t?t.height:this.device.height,x=aP[this.device.renderVersion%aP.length];f=u*(x.x*2-1)/g,m=u*(x.y*2-1)/S,o=f4.copy(o),o.data[8]=f,o.data[9]=m,h=m4.copy(h),h.data[8]=f,h.data[9]=m,this.blueNoiseJitterVersion!==this.device.renderVersion&&(this.blueNoiseJitterVersion=this.device.renderVersion,this.blueNoise.vec4(this.blueNoiseJitterVec))}const _=u>0?this.blueNoiseJitterVec:me.ZERO;if(this.blueNoiseJitterData[0]=_.x,this.blueNoiseJitterData[1]=_.y,this.blueNoiseJitterData[2]=_.z,this.blueNoiseJitterData[3]=_.w,this.blueNoiseJitterId.setValue(this.blueNoiseJitterData),this.projId.setValue(o.data),this.projSkyboxId.setValue(h.data),e.calculateTransform)e.calculateTransform(Fn,Op);else{const g=e._node.getPosition(),S=e._node.getRotation();Fn.setTRS(g,S,D.ONE)}this.viewInvId.setValue(Fn.data),Lc.copy(Fn).invert(),this.viewId.setValue(Lc.data),tP.setFromMat4(Lc),this.viewId3.setValue(tP.data),Pr.mul2(o,Lc),this.viewProjId.setValue(Pr.data),e._storeShaderMatrices(Pr,f,m,this.device.renderVersion),this.flipYId.setValue(s?-1:1),this.dispatchViewPos(e._node.getPosition()),e.frustum.setFromMat4(Pr)}this.tbnBasis.setValue(s?-1:1),this.cameraParamsId.setValue(e.fillShaderParams(this.cameraParams));let r=t?t.width:this.device.width,a=t?t.height:this.device.height;return r*=e.rect.z,a*=e.rect.w,e.xr?.active&&e.xr.views.list.length===2&&(r*=.5),this.viewportSize[0]=r,this.viewportSize[1]=a,this.viewportSize[2]=1/r,this.viewportSize[3]=1/a,this.viewportSizeId.setValue(this.viewportSize),this.exposureId.setValue(this.scene.physicalUnits?e.getExposure():this.scene.exposure),i}clear(e,t,s,i){const r=(t??e._clearColorBuffer?qd:0)|(s??e._clearDepthBuffer?Yd:0)|(i??e._clearStencilBuffer?W_:0);r&&this.device.clear({color:[e._clearColor.r,e._clearColor.g,e._clearColor.b,e._clearColor.a],depth:e._clearDepth,stencil:e._clearStencil,flags:r})}setupCullMode(e,t,s){const i=s.material;let r=Ft;if(e){let a=1;(i.cull===Fd||i.cull===_l)&&(a=t*s.flipFacesFactor*s.node.worldScaleSign),a<0?r=i.cull===Fd?_l:Fd:r=i.cull}this.device.setCullMode(r),r===Ft&&i.cull===Ft&&this.twoSidedLightingNegScaleFactorId.setValue(s.node.worldScaleSign)}updateCameraFrustum(e){if(e.xr&&e.xr.views.list.length){const s=e.xr.views.list;Pr.mul2(s[0].projMat,s[0].viewOffMat),e.frustum.setFromMat4(Pr);for(let i=1;i<s.length;i++)Pr.mul2(s[i].projMat,s[i].viewOffMat),sP.setFromMat4(Pr),e.frustum.add(sP);return}const t=e.projectionMatrix;if(e.calculateProjection&&e.calculateProjection(t,Op),e.calculateTransform)e.calculateTransform(Fn,Op);else{const s=e._node.getPosition(),i=e._node.getRotation();Fn.setTRS(s,i,D.ONE),this.viewInvId.setValue(Fn.data)}Lc.copy(Fn).invert(),Pr.mul2(t,Lc),e.frustum.setFromMat4(Pr)}setBaseConstants(e,t){e.setCullMode(t.cull),t.opacityMap&&this.opacityMapId.setValue(t.opacityMap),(t.opacityMap||t.alphaTest>0)&&this.alphaTestId.setValue(t.alphaTest)}updateCpuSkinMatrices(e){I0++;const t=e.length;if(t!==0)for(let s=0;s<t;s++){const i=e[s].skinInstance;i&&(i.updateMatrices(e[s].node,I0),i._dirty=!0)}}updateGpuSkinMatrices(e){for(const t of e){const s=t.skinInstance;s&&s._dirty&&(s.updateMatrixPalette(t.node,I0),s._dirty=!1)}}updateMorphing(e){for(const t of e){const s=t.morphInstance;s&&s._dirty&&s.update()}}updateGSplats(e){for(const t of e)t.gsplatInstance?.update()}gpuUpdate(e){this.updateGpuSkinMatrices(e),this.updateMorphing(e),this.updateGSplats(e)}setVertexBuffers(e,t){e.setVertexBuffer(t.vertexBuffer)}setMorphing(e,t){t&&(t.prepareRendering(e),e.setVertexBuffer(t.morph.vertexBufferIds),this.morphPositionTex.setValue(t.texturePositions),this.morphNormalTex.setValue(t.textureNormals),this.morphTexParams.setValue(t._textureParams))}setSkinning(e,t){const s=t.skinInstance;if(s){this._skinDrawCalls++;const i=s.boneTexture;this.boneTextureId.setValue(i)}}dispatchViewPos(e){const t=this.viewPos;t[0]=e.x,t[1]=e.y,t[2]=e.z,this.viewPosId.setValue(t)}initViewBindGroupFormat(e){if(this.device.supportsUniformBuffers&&!this.viewUniformFormat){const t=[new Be("matrix_view",Or),new Be("matrix_viewInverse",Or),new Be("matrix_projection",Or),new Be("matrix_projectionSkybox",Or),new Be("matrix_viewProjection",Or),new Be("matrix_view3",Ah),new Be("cubeMapRotationMatrix",Ah),new Be("view_position",Gi),new Be("viewport_size",so),new Be("skyboxIntensity",Bs),new Be("exposure",Bs),new Be("textureBias",Bs),new Be("view_index",Bs)];e&&t.push(new Be("clusterCellsCountByBoundsSize",Gi),new Be("clusterBoundsMin",Gi),new Be("clusterBoundsDelta",Gi),new Be("clusterCellsDot",Ha),new Be("clusterCellsMax",Ha),new Be("shadowAtlasParams",xl),new Be("clusterMaxCells",Ga),new Be("numClusteredLights",Ga),new Be("clusterTextureWidth",Ga)),this.viewUniformFormat=new uo(this.device,t);const s=[new io(Tv,Tl|El)];this.viewBindGroupFormat=new Vr(this.device,s)}}setupViewUniforms(e,t){this.projId.setValue(e.projMat.data),this.projSkyboxId.setValue(e.projMat.data),this.viewId.setValue(e.viewOffMat.data),this.viewInvId.setValue(e.viewInvOffMat.data),this.viewId3.setValue(e.viewMat3.data),this.viewProjId.setValue(e.projViewOffMat.data),this.viewPosId.setValue(e.positionData),this.viewIndexId.setValue(t)}setupViewUniformBuffers(e,t,s,i){const{device:r}=this,a=i?.length??1;for(;e.length<a;){const o=new Vf(r,t,!1),h=new qh(r,s,o);e.push(h)}if(i)for(let o=0;o<a;o++){const h=i[o];this.setupViewUniforms(h,o);const u=e[o];u.defaultUniformBuffer.update(),u.update()}else{const o=e[0];o.defaultUniformBuffer.update(),o.update()}i||r.setBindGroup(Jd,e[0])}setupMeshUniformBuffers(e){const t=this.device;if(t.supportsUniformBuffers){const s=e.getBindGroup(t);s.update(),t.setBindGroup(kf,s),e.getUniformBuffer(t).update(B0),t.setBindGroup(Lh,B0.bindGroup,B0.offsets)}}setMeshInstanceMatrices(e,t=!1){const s=e.node.worldTransform;this.modelMatrixId.setValue(s.data),t&&this.normalMatrixId.setValue(e.node.normalMatrix.data)}cull(e,t,s){const i=s.opaque;i.length=0;const r=s.transparent;r.length=0;const a=e.frustumCulling,o=t.length;for(let h=0;h<o;h++){const u=t[h];u.visible&&(!a||!u.cull||u._isVisible(e))&&(u.visibleThisFrame=!0,(u.transparent?r:i).push(u),(u.skinInstance||u.morphInstance||u.gsplatInstance)&&(this.processingMeshInstances.add(u),u.gsplatInstance&&u.gsplatInstance.cameras.push(e)))}}collectLights(e){this.lights.length=0,this.localLights.length=0;const t=this.scene._stats,s=e.layerList.length;for(let i=0;i<s;i++){const r=e.layerList[i];if(!F0.has(r)){F0.add(r);const a=r._lights;for(let o=0;o<a.length;o++){const h=a[o];N0.has(h)||(N0.add(h),this.lights.push(h),h._type!==Ne&&this.localLights.push(h))}}}t.lights=this.lights.length,N0.clear(),F0.clear()}cullLights(e,t){const s=this.scene.clusteredLightingEnabled,i=this.scene.physicalUnits;for(let r=0;r<t.length;r++){const a=t[r];if(a.enabled)if(a._type!==Ne)if(a.getBoundingSphere(O0),e.frustum.containsSphere(O0)){a.visibleThisFrame=!0,a.usePhysicalUnits=i;const o=e.getScreenSize(O0);a.maxScreenSize=Math.max(a.maxScreenSize,o)}else s||a.castShadows&&!a.shadowMap&&(a.visibleThisFrame=!0);else a.usePhysicalUnits=this.scene.physicalUnits}}cullShadowmaps(e){const t=this.scene.clusteredLightingEnabled;for(let i=0;i<this.localLights.length;i++){const r=this.localLights[i];r._type!==Ne&&(t?r.atlasSlotUpdated&&r.shadowUpdateMode===Yi&&(r.shadowUpdateMode=Kn):r.shadowUpdateMode===Yi&&r.castShadows&&(r.getRenderData(null,0).shadowCamera.renderTarget||(r.shadowUpdateMode=Kn)),r.visibleThisFrame&&r.castShadows&&r.shadowUpdateMode!==Yi&&this._shadowRendererLocal.cull(r,e))}this.cameraDirShadowLights.clear();const s=e.cameras;for(let i=0;i<s.length;i++){const r=s[i];if(r.enabled){const a=r.camera;let o;const h=a.layers;for(let u=0;u<h.length;u++){const f=e.getLayerById(h[u]);if(f){const m=f.splitLights[Ne];for(let _=0;_<m.length;_++){const g=m[_];g.castShadows&&!Ic.has(g)&&(Ic.add(g),o=o??[],o.push(g),this._shadowRendererDirectional.cull(g,e,a))}}}o&&this.cameraDirShadowLights.set(a,o),Ic.clear()}}}cullComposition(e){const{scene:t}=this;this.processingMeshInstances.clear();const s=e.cameras.length;this._camerasRendered+=s;for(let i=0;i<s;i++){const r=e.cameras[i];t?.fire(G2,r);const a=r.renderTarget;r.frameUpdate(a),this.updateCameraFrustum(r.camera);const o=r.layers;for(let h=0;h<o.length;h++){const u=e.getLayerById(o[h]);if(u&&u.enabled){this.cullLights(r.camera,u._lights);const f=u.getCulledInstances(r.camera);this.cull(r.camera,u.meshInstances,f)}}t?.fire(H2,r)}t.clusteredLightingEnabled&&this.updateLightTextureAtlas(),this.cullShadowmaps(e),t?.fire(dV)}updateShaders(e,t){const s=e.length;for(let i=0;i<s;i++){const r=e[i].material;if(r&&!Ic.has(r)&&(Ic.add(r),r.getShaderVariant!==Dl.prototype.getShaderVariant)){if(t&&(!r.useLighting||r.emitter&&!r.emitter.lighting))continue;r.clearVariants()}}Ic.clear()}updateFrameUniforms(){this.blueNoiseTextureId.setValue($V(this.device))}beginFrame(e){const t=this.scene,s=t.updateShaders||this.device._shadersDirty,i=e.layerList,r=i.length;for(let h=0;h<r;h++){const f=i[h].meshInstances,m=f.length;for(let _=0;_<m;_++){const g=f[_];g.visibleThisFrame=!1,s&&U0.push(g),g.skinInstance&&z0.push(g)}}if(s){const h=!t.updateShaders||!this.device._shadersDirty;this.updateShaders(U0,h),t.updateShaders=!1,this.device._shadersDirty=!1,t._shaderVersion++}this.updateFrameUniforms(),this.updateCpuSkinMatrices(z0),U0.length=0,z0.length=0;const a=this.lights,o=a.length;for(let h=0;h<o;h++)a[h].beginFrame()}updateLightTextureAtlas(){this.lightTextureAtlas.update(this.localLights,this.scene.lighting)}updateLayerComposition(e){const t=e.layerList.length,i=this.scene._shaderVersion;for(let r=0;r<t;r++){const a=e.layerList[r];a._shaderVersion=i}e._update()}frameUpdate(){this.clustersDebugRendered=!1,this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled),this.dirLightShadows.clear()}constructor(e,t){this.clustersDebugRendered=!1,this.processingMeshInstances=new Set,this.lights=[],this.localLights=[],this.cameraDirShadowLights=new Map,this.dirLightShadows=new Map,this.blueNoise=new WV(123),this.gsplatDirector=null,this.device=e,this.scene=t,this.worldClustersAllocator=new o4(e),this.lightTextureAtlas=new QV(e),this.shadowMapCache=new e4,this.shadowRenderer=new Q2(this,this.lightTextureAtlas),this._shadowRendererLocal=new t4(this,this.shadowRenderer),this._shadowRendererDirectional=new r4(this,this.shadowRenderer),this.scene.clusteredLightingEnabled&&(this._renderPassUpdateClustered=new l4(this.device,this,this.shadowRenderer,this._shadowRendererLocal,this.lightTextureAtlas)),this.viewUniformFormat=null,this.viewBindGroupFormat=null,this._skinTime=0,this._morphTime=0,this._cullTime=0,this._shadowMapTime=0,this._lightClustersTime=0,this._layerCompositionUpdateTime=0,this._shadowDrawCalls=0,this._skinDrawCalls=0,this._instancedDrawCalls=0,this._shadowMapUpdates=0,this._numDrawCallsCulled=0,this._camerasRendered=0,this._lightClusters=0,this._gsplatCount=0;const s=e.scope;this.boneTextureId=s.resolve("texture_poseMap"),this.modelMatrixId=s.resolve("matrix_model"),this.normalMatrixId=s.resolve("matrix_normal"),this.viewInvId=s.resolve("matrix_viewInverse"),this.viewPos=new Float32Array(3),this.viewPosId=s.resolve("view_position"),this.projId=s.resolve("matrix_projection"),this.projSkyboxId=s.resolve("matrix_projectionSkybox"),this.viewId=s.resolve("matrix_view"),this.viewId3=s.resolve("matrix_view3"),this.viewProjId=s.resolve("matrix_viewProjection"),this.flipYId=s.resolve("projectionFlipY"),this.tbnBasis=s.resolve("tbnBasis"),this.cameraParams=new Float32Array(4),this.cameraParamsId=s.resolve("camera_params"),this.viewportSize=new Float32Array(4),this.viewportSizeId=s.resolve("viewport_size"),this.viewIndexId=s.resolve("view_index"),this.viewIndexId.setValue(0),this.blueNoiseJitterVersion=0,this.blueNoiseJitterVec=new me,this.blueNoiseJitterData=new Float32Array(4),this.blueNoiseJitterId=s.resolve("blueNoiseJitter"),this.blueNoiseTextureId=s.resolve("blueNoiseTex32"),this.alphaTestId=s.resolve("alpha_ref"),this.opacityMapId=s.resolve("texture_opacityMap"),this.exposureId=s.resolve("exposure"),this.twoSidedLightingNegScaleFactorId=s.resolve("twoSidedLightingNegScaleFactor"),this.twoSidedLightingNegScaleFactorId.setValue(0),this.morphPositionTex=s.resolve("morphPositionTex"),this.morphNormalTex=s.resolve("morphNormalTex"),this.morphTexParams=s.resolve("morph_tex_params"),this.lightCube=new qV,this.constantLightCube=s.resolve("lightCube[0]")}}class eL{destroy(){this.viewBindGroups.forEach(e=>{e.defaultUniformBuffer.destroy(),e.destroy()}),this.viewBindGroups.length=0}setupClears(e,t){this.clearColor=e?.clearColorBuffer||t.clearColorBuffer,this.clearDepth=e?.clearDepthBuffer||t.clearDepthBuffer,this.clearStencil=e?.clearStencilBuffer||t.clearStencilBuffer}constructor(){this.camera=null,this.layer=null,this.transparent=!1,this.renderTarget=null,this.lightClusters=null,this.clearColor=!1,this.clearDepth=!1,this.clearStencil=!1,this.triggerPostprocess=!1,this.firstCameraUse=!1,this.lastCameraUse=!1,this.viewBindGroups=[],this.useCameraPasses=!1}}class _4 extends ii{get rendersAnything(){return this.renderActions.length>0}addRenderAction(e){this.renderActions.push(e)}addLayer(e,t,s,i=!0){const r=new eL;if(r.renderTarget=this.renderTarget,r.camera=e,r.layer=t,r.transparent=s,i){const a=this.renderActions.length===0;r.setupClears(a?e:void 0,t)}this.addRenderAction(r)}addLayers(e,t,s,i,r,a=!0){const{layerList:o,subLayerList:h}=e;let u=i,f=s;for(;f<o.length;){const m=o[f],_=h[f];if(t.camera.layersSet.has(m.id)&&(this.addLayer(t,m,_,u),u=!1),f++,m.id===r&&_===a)break}return f}updateDirectionalShadows(){const{renderer:e,renderActions:t}=this;for(let s=0;s<t.length;s++){const a=t[s].camera.camera,o=this.renderer.cameraDirShadowLights.get(a);if(o)for(let h=0;h<o.length;h++){const u=o[h];if(e.dirLightShadows.get(u)!==a){e.dirLightShadows.set(u,a);const f=e._shadowRendererDirectional.getLightRenderPass(u,a);f&&this.beforePasses.push(f)}}}}updateClears(){const e=this.renderActions[0];if(e){const s=e.camera.camera,i=s.fullSizeClearRect;this.setClearColor(i&&e.clearColor?s.clearColor:void 0),this.setClearDepth(i&&e.clearDepth&&!this.noDepthClear?s.clearDepth:void 0),this.setClearStencil(i&&e.clearStencil?s.clearStencil:void 0)}}frameUpdate(){super.frameUpdate(),this.updateDirectionalShadows(),this.updateClears()}before(){const{renderActions:e}=this;for(let t=0;t<e.length;t++){const s=e[t];s.firstCameraUse&&this.scene.fire(lV,s.camera)}}execute(){const{layerComposition:e,renderActions:t}=this;for(let s=0;s<t.length;s++){const i=t[s],r=i.layer;e.isEnabled(r,i.transparent)&&this.renderRenderAction(i,s===0)}}after(){for(let e=0;e<this.renderActions.length;e++){const t=this.renderActions[e];t.lastCameraUse&&this.scene.fire(cV,t.camera)}this.beforePasses.length=0}renderRenderAction(e,t){const{renderer:s,scene:i}=this,r=s.device,{layer:a,transparent:o,camera:h}=e;if(h){const u=h.gammaCorrection,f=h.toneMapping;this.gammaCorrection!==void 0&&(h.gammaCorrection=this.gammaCorrection),this.toneMapping!==void 0&&(h.toneMapping=this.toneMapping),i.fire(hV,h,a,o);const m={lightClusters:e.lightClusters},_=h.camera.shaderPassInfo?.index??Zh;(!t||!h.camera.fullSizeClearRect)&&(m.clearColor=e.clearColor,m.clearDepth=e.clearDepth,m.clearStencil=e.clearStencil);const g=e.renderTarget??r.backBuffer;s.renderForwardLayer(h.camera,g,a,o,_,e.viewBindGroups,m),r.setBlendState(ht.NOBLEND),r.setStencilState(null,null),r.setAlphaToCoverage(!1),i.fire(uV,h,a,o),this.gammaCorrection!==void 0&&(h.gammaCorrection=u),this.toneMapping!==void 0&&(h.toneMapping=f)}}constructor(e,t,s,i){super(e),this.renderActions=[],this.noDepthClear=!1,this.layerComposition=t,this.scene=s,this.renderer=i}}class g4 extends ii{execute(){this.renderAction.camera.onPostprocessing()}constructor(e,t,s){super(e),this.renderer=t,this.renderAction=s,this.requiresCubemaps=!1}}const v4=[[],[],[]],Bn=new ue,Vo={drawCalls:[],shaderInstances:[],isNewMaterial:[],lightMaskChanged:[],clear:function(){this.drawCalls.length=0,this.shaderInstances.length=0,this.isNewMaterial.length=0,this.lightMaskChanged.length=0}};function S4(c){const e=[];for(let t=0;t<c;++t){const s=Math.sqrt(t+.5)/Math.sqrt(c);e.push(s)}return e}function y4(c){const e=[];for(let t=0;t<c;t++){const s=t/c,i=Math.sqrt(s*s);e.push(i)}return e}class x4 extends p4{destroy(){super.destroy()}dispatchGlobalLights(e){const t=this.ambientColor;if(Bn.linear(e.ambientLight),t[0]=Bn.r,t[1]=Bn.g,t[2]=Bn.b,e.physicalUnits)for(let s=0;s<3;s++)t[s]*=e.ambientLuminance;this.ambientId.setValue(t),this.skyboxIntensityId.setValue(e.physicalUnits?e.skyboxLuminance:e.skyboxIntensity),this.cubeMapRotationMatrixId.setValue(e._skyboxRotationMat3.data)}_resolveLight(e,t){const s=`light${t}`;this.lightColorId[t]=e.resolve(`${s}_color`),this.lightDir[t]=new Float32Array(3),this.lightDirId[t]=e.resolve(`${s}_direction`),this.lightShadowMapId[t]=e.resolve(`${s}_shadowMap`),this.lightShadowMatrixId[t]=e.resolve(`${s}_shadowMatrix`),this.lightShadowParamsId[t]=e.resolve(`${s}_shadowParams`),this.lightShadowIntensity[t]=e.resolve(`${s}_shadowIntensity`),this.lightShadowSearchAreaId[t]=e.resolve(`${s}_shadowSearchArea`),this.lightRadiusId[t]=e.resolve(`${s}_radius`),this.lightPos[t]=new Float32Array(3),this.lightPosId[t]=e.resolve(`${s}_position`),this.lightWidth[t]=new Float32Array(3),this.lightWidthId[t]=e.resolve(`${s}_halfWidth`),this.lightHeight[t]=new Float32Array(3),this.lightHeightId[t]=e.resolve(`${s}_halfHeight`),this.lightInAngleId[t]=e.resolve(`${s}_innerConeAngle`),this.lightOutAngleId[t]=e.resolve(`${s}_outerConeAngle`),this.lightCookieId[t]=e.resolve(`${s}_cookie`),this.lightCookieIntId[t]=e.resolve(`${s}_cookieIntensity`),this.lightCookieMatrixId[t]=e.resolve(`${s}_cookieMatrix`),this.lightCookieOffsetId[t]=e.resolve(`${s}_cookieOffset`),this.lightCameraParamsId[t]=e.resolve(`${s}_cameraParams`),this.lightSoftShadowParamsId[t]=e.resolve(`${s}_softShadowParams`),this.shadowMatrixPaletteId[t]=e.resolve(`${s}_shadowMatrixPalette[0]`),this.shadowCascadeDistancesId[t]=e.resolve(`${s}_shadowCascadeDistances`),this.shadowCascadeCountId[t]=e.resolve(`${s}_shadowCascadeCount`),this.shadowCascadeBlendId[t]=e.resolve(`${s}_shadowCascadeBlend`)}setLTCDirectionalLight(e,t,s,i,r){this.lightPos[t][0]=i.x-s.x*r,this.lightPos[t][1]=i.y-s.y*r,this.lightPos[t][2]=i.z-s.z*r,this.lightPosId[t].setValue(this.lightPos[t]);const a=e.transformVector(new D(-.5,0,0));this.lightWidth[t][0]=a.x*r,this.lightWidth[t][1]=a.y*r,this.lightWidth[t][2]=a.z*r,this.lightWidthId[t].setValue(this.lightWidth[t]);const o=e.transformVector(new D(0,0,.5));this.lightHeight[t][0]=o.x*r,this.lightHeight[t][1]=o.y*r,this.lightHeight[t][2]=o.z*r,this.lightHeightId[t].setValue(this.lightHeight[t])}dispatchDirectLights(e,t,s){let i=0;const r=this.device.scope;for(let a=0;a<e.length;a++){if(!(e[a].mask&t))continue;const o=e[a],h=o._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(r,i),this.lightColorId[i].setValue(o._colorLinear),h.getY(o._direction).mulScalar(-1),o._direction.normalize(),this.lightDir[i][0]=o._direction.x,this.lightDir[i][1]=o._direction.y,this.lightDir[i][2]=o._direction.z,this.lightDirId[i].setValue(this.lightDir[i]),o.shape!==_r&&this.setLTCDirectionalLight(h,i,o._direction,s._node.getPosition(),s.farClip),o.castShadows){const u=o.getRenderData(s,0),f=o._getUniformBiasValues(u);this.lightShadowMapId[i].setValue(u.shadowBuffer),this.lightShadowMatrixId[i].setValue(u.shadowMatrix.data),this.shadowMatrixPaletteId[i].setValue(o._shadowMatrixPalette),this.shadowCascadeDistancesId[i].setValue(o._shadowCascadeDistances),this.shadowCascadeCountId[i].setValue(o.numCascades),this.shadowCascadeBlendId[i].setValue(1-o.cascadeBlend),this.lightShadowIntensity[i].setValue(o.shadowIntensity),this.lightSoftShadowParamsId[i].setValue(o._softShadowParams),u.shadowCamera.renderTarget&&this.lightShadowSearchAreaId[i].setValue(o.penumbraSize/u.shadowCamera.renderTarget.width*u.projectionCompensation);const _=o._shadowCameraParams;_.length=4,_[0]=0,_[1]=u.shadowCamera._farClip,_[2]=u.shadowCamera._nearClip,_[3]=1,this.lightCameraParamsId[i].setValue(_);const g=o._shadowRenderParams;g.length=4,g[0]=o._shadowResolution,g[1]=f.normalBias,g[2]=f.bias,g[3]=0,this.lightShadowParamsId[i].setValue(g)}i++}return i}setLTCPositionalLight(e,t){const s=e.transformVector(new D(-.5,0,0));this.lightWidth[t][0]=s.x,this.lightWidth[t][1]=s.y,this.lightWidth[t][2]=s.z,this.lightWidthId[t].setValue(this.lightWidth[t]);const i=e.transformVector(new D(0,0,.5));this.lightHeight[t][0]=i.x,this.lightHeight[t][1]=i.y,this.lightHeight[t][2]=i.z,this.lightHeightId[t].setValue(this.lightHeight[t])}dispatchOmniLight(e,t,s){const i=t._node.getWorldTransform();if(this.lightColorId[s]||this._resolveLight(e,s),this.lightRadiusId[s].setValue(t.attenuationEnd),this.lightColorId[s].setValue(t._colorLinear),i.getTranslation(t._position),this.lightPos[s][0]=t._position.x,this.lightPos[s][1]=t._position.y,this.lightPos[s][2]=t._position.z,this.lightPosId[s].setValue(this.lightPos[s]),t.shape!==_r&&this.setLTCPositionalLight(i,s),t.castShadows){const r=t.getRenderData(null,0);this.lightShadowMapId[s].setValue(r.shadowBuffer);const a=t._getUniformBiasValues(r),o=t._shadowRenderParams;o.length=4,o[0]=t._shadowResolution,o[1]=a.normalBias,o[2]=a.bias,o[3]=1/t.attenuationEnd,this.lightShadowParamsId[s].setValue(o),this.lightShadowIntensity[s].setValue(t.shadowIntensity);const h=t.penumbraSize/r.shadowCamera.renderTarget.width;this.lightShadowSearchAreaId[s].setValue(h);const u=t._shadowCameraParams;u.length=4,u[0]=0,u[1]=r.shadowCamera._farClip,u[2]=r.shadowCamera._nearClip,u[3]=0,this.lightCameraParamsId[s].setValue(u)}t._cookie&&(this.lightCookieId[s].setValue(t._cookie),this.lightShadowMatrixId[s].setValue(i.data),this.lightCookieIntId[s].setValue(t.cookieIntensity))}dispatchSpotLight(e,t,s){const i=t._node.getWorldTransform();if(this.lightColorId[s]||this._resolveLight(e,s),this.lightInAngleId[s].setValue(t._innerConeAngleCos),this.lightOutAngleId[s].setValue(t._outerConeAngleCos),this.lightRadiusId[s].setValue(t.attenuationEnd),this.lightColorId[s].setValue(t._colorLinear),i.getTranslation(t._position),this.lightPos[s][0]=t._position.x,this.lightPos[s][1]=t._position.y,this.lightPos[s][2]=t._position.z,this.lightPosId[s].setValue(this.lightPos[s]),t.shape!==_r&&this.setLTCPositionalLight(i,s),i.getY(t._direction).mulScalar(-1),t._direction.normalize(),this.lightDir[s][0]=t._direction.x,this.lightDir[s][1]=t._direction.y,this.lightDir[s][2]=t._direction.z,this.lightDirId[s].setValue(this.lightDir[s]),t.castShadows){const r=t.getRenderData(null,0);this.lightShadowMapId[s].setValue(r.shadowBuffer),this.lightShadowMatrixId[s].setValue(r.shadowMatrix.data);const a=t._getUniformBiasValues(r),o=t._shadowRenderParams;o.length=4,o[0]=t._shadowResolution,o[1]=a.normalBias,o[2]=a.bias,o[3]=1/t.attenuationEnd,this.lightShadowParamsId[s].setValue(o),this.lightShadowIntensity[s].setValue(t.shadowIntensity);const h=t.penumbraSize/r.shadowCamera.renderTarget.width,u=r.shadowCamera._fov*J.DEG_TO_RAD,f=1/Math.tan(u/2);this.lightShadowSearchAreaId[s].setValue(h*f);const m=t._shadowCameraParams;m.length=4,m[0]=0,m[1]=r.shadowCamera._farClip,m[2]=r.shadowCamera._nearClip,m[3]=0,this.lightCameraParamsId[s].setValue(m)}if(t._cookie){if(!t.castShadows){const r=pr.evalSpotCookieMatrix(t);this.lightShadowMatrixId[s].setValue(r.data)}this.lightCookieId[s].setValue(t._cookie),this.lightCookieIntId[s].setValue(t.cookieIntensity),t._cookieTransform&&(t._cookieTransformUniform[0]=t._cookieTransform.x,t._cookieTransformUniform[1]=t._cookieTransform.y,t._cookieTransformUniform[2]=t._cookieTransform.z,t._cookieTransformUniform[3]=t._cookieTransform.w,this.lightCookieMatrixId[s].setValue(t._cookieTransformUniform),t._cookieOffsetUniform[0]=t._cookieOffset.x,t._cookieOffsetUniform[1]=t._cookieOffset.y,this.lightCookieOffsetId[s].setValue(t._cookieOffsetUniform))}}dispatchLocalLights(e,t,s){let i=s;const r=this.device.scope,a=e[wt],o=a.length;for(let f=0;f<o;f++){const m=a[f];m.mask&t&&(this.dispatchOmniLight(r,m,i),i++)}const h=e[bt],u=h.length;for(let f=0;f<u;f++){const m=h[f];m.mask&t&&(this.dispatchSpotLight(r,m,i),i++)}}renderForwardPrepareMaterials(e,t,s,i,r,a){const o=e.fogParams??this.scene.fog,h=e.shaderParams;h.fog=o.type,h.srgbRenderTarget=t?.isColorBufferSrgb(0)??!1;const u=(b,C,w,P)=>{Vo.drawCalls.push(b),Vo.shaderInstances.push(C),Vo.isNewMaterial.push(w),Vo.lightMaskChanged.push(P)};Vo.clear();const f=this.device,m=this.scene,_=m.clusteredLightingEnabled,g=r?.getLightHash(_)??0;let S=null,x,T;const E=s.length;for(let b=0;b<E;b++){const C=s[b],w=C.instancingData;if(w&&w.count<=0)continue;C.ensureMaterial(f);const P=C.material,I=C._shaderDefs,M=C.mask;P&&P===S&&I!==x&&(S=null),P!==S&&(this._materialSwitches++,P._scene=m,P.dirty&&(P.updateUniforms(f,m),P.dirty=!1));const R=C.getShaderInstance(a,g,m,h,this.viewUniformFormat,this.viewBindGroupFormat,i);u(C,R,P!==S,!S||M!==T),S=P,x=I,T=M}return Vo}renderForwardInternal(e,t,s,i,r,a,o){const h=this.device,u=this.scene,f=1<<i,m=a?-1:1,_=u.clusteredLightingEnabled,g=e.xr?.session&&e.xr.views.list.length?e.xr.views.list:null,S=t.drawCalls.length;for(let x=0;x<S;x++){const T=t.drawCalls[x],E=t.isNewMaterial[x],b=t.lightMaskChanged[x],C=t.shaderInstances[x],w=T.material,P=T.mask;if(C.shader.failed)continue;if(E){if(h.setShader(C.shader,!1),w.setParameters(h),b){const j=this.dispatchDirectLights(s[Ne],P,e);_||this.dispatchLocalLights(s,P,j)}this.alphaTestId.setValue(w.alphaTest),h.setBlendState(w.blendState),h.setDepthState(w.depthState),h.setAlphaToCoverage(w.alphaToCoverage)}this.setupCullMode(e._cullFaces,m,T);const I=T.stencilFront??w.stencilFront,M=T.stencilBack??w.stencilBack;h.setStencilState(I,M),T.setParameters(h,f),h.scope.resolve("meshInstanceId").setValue(T.id);const R=T.mesh;this.setVertexBuffers(h,R),this.setMorphing(h,T.morphInstance),this.setSkinning(h,T);const L=T.instancingData;L&&h.setVertexBuffer(L.vertexBuffer),this.setMeshInstanceMatrices(T,!0),this.setupMeshUniformBuffers(C);const B=T.renderStyle,G=R.indexBuffer[B];r?.(T,x);const H=T.getDrawCommands(e);if(g)for(let ee=0;ee<g.length;ee++){const j=g[ee];if(h.setViewport(j.viewport.x,j.viewport.y,j.viewport.z,j.viewport.w),h.supportsUniformBuffers){const O=o[ee];h.setBindGroup(Jd,O)}else this.setupViewUniforms(j,ee);const ae=ee===0,k=ee===g.length-1;h.draw(R.primitive[B],G,L?.count,H,ae,k),this._forwardDrawCalls++,T.instancingData&&this._instancedDrawCalls++}else h.draw(R.primitive[B],G,L?.count,H),this._forwardDrawCalls++,T.instancingData&&this._instancedDrawCalls++;x<S-1&&!t.isNewMaterial[x+1]&&w.setParameters(h,T.parameters)}}renderForward(e,t,s,i,r,a,o,h,u){const f=this.renderForwardPrepareMaterials(e,t,s,i,o,r);this.renderForwardInternal(e,f,i,r,a,h,u),Vo.clear()}renderForwardLayer(e,t,s,i,r,a,o={}){const{scene:h,device:u}=this,f=h.clusteredLightingEnabled;this.setupViewport(e,t);let m,_;if(s){s.sortVisible(e,i);const w=s.getCulledInstances(e);m=i?w.transparent:w.opaque,h.immediate.onPreRenderLayer(s,m,i),s.requiresLightCube&&(this.lightCube.update(h.ambientLight,s._lights),this.constantLightCube.setValue(this.lightCube.colors)),_=s.splitLights}else m=o.meshInstances,_=o.splitLights??v4;f&&((o.lightClusters??this.worldClustersAllocator.empty).activate(),s&&!this.clustersDebugRendered&&h.lighting.debugLayer===s.id&&(this.clustersDebugRendered=!0)),h._activeCamera=e;const g=e.fogParams??this.scene.fog;this.setFogConstants(g);const S=this.setCameraUniforms(e,t);u.supportsUniformBuffers&&this.setupViewUniformBuffers(a,this.viewUniformFormat,this.viewBindGroupFormat,S);const x=o.clearColor??!1,T=o.clearDepth??!1,E=o.clearStencil??!1;(x||T||E)&&this.clear(e,x,T,E);const b=!!(e._flipFaces^t?.flipY),C=this._forwardDrawCalls;this.renderForward(e,t,m,_,r,null,s,b,a),s&&(s._forwardDrawCalls+=this._forwardDrawCalls-C)}setFogConstants(e){if(e.type!==Kh){Bn.linear(e.color);const t=this.fogColor;t[0]=Bn.r,t[1]=Bn.g,t[2]=Bn.b,this.fogColorId.setValue(t),e.type===Fk?(this.fogStartId.setValue(e.start),this.fogEndId.setValue(e.end)):this.fogDensityId.setValue(e.density)}}setSceneConstants(){const e=this.scene;this.dispatchGlobalLights(e);const t=this.device;this._screenSize[0]=t.width,this._screenSize[1]=t.height,this._screenSize[2]=1/t.width,this._screenSize[3]=1/t.height,this.screenSizeId.setValue(this._screenSize),this.pcssDiskSamplesId.setValue(this.pcssDiskSamples),this.pcssSphereSamplesId.setValue(this.pcssSphereSamples)}buildFrameGraph(e,t){const s=this.scene;if(e.reset(),s.clusteredLightingEnabled){const{shadowsEnabled:h,cookiesEnabled:u}=s.lighting;this._renderPassUpdateClustered.update(e,h,u,this.lights,this.localLights),e.addRenderPass(this._renderPassUpdateClustered)}else this._shadowRendererLocal.buildNonClusteredRenderPasses(e,this.localLights);let i=0,r=!0,a=null;const o=t._renderActions;for(let h=i;h<o.length;h++){const u=o[h],{layer:f,camera:m}=u;if(u.useCameraPasses)m.camera.renderPasses.forEach(_=>{e.addRenderPass(_)});else{const _=f.id===xi,g=_&&(m.renderSceneColorMap||m.renderSceneDepthMap);r&&(r=!1,i=h,a=u.renderTarget);const S=o[h+1],T=(S?!S.useCameraPasses&&S.layer.id===xi:!1)&&(m.renderSceneColorMap||m.renderSceneDepthMap),E=S?S.firstCameraUse&&this.cameraDirShadowLights.has(S.camera.camera):!1;if(!S||S.renderTarget!==a||E||T||g){if(_&&i===h||this.addMainRenderPass(e,t,a,i,h),_){if(m.renderSceneColorMap){const C=m.camera.renderPassColorGrab;C.source=m.renderTarget,e.addRenderPass(C)}m.renderSceneDepthMap&&e.addRenderPass(m.camera.renderPassDepthGrab)}if(u.triggerPostprocess&&m?.onPostprocessing){const C=new g4(this.device,this,u);e.addRenderPass(C)}r=!0}}}}addMainRenderPass(e,t,s,i,r){const a=new _4(this.device,t,this.scene,this);a.init(s);const o=t._renderActions;for(let h=i;h<=r;h++)a.addRenderAction(o[h]);e.addRenderPass(a)}update(e){this.frameUpdate(),this.shadowRenderer.frameUpdate(),this.scene._updateSkyMesh(),this.updateLayerComposition(e),this.collectLights(e),this.beginFrame(e),this.setSceneConstants(),this.gsplatDirector?.update(e),this.cullComposition(e),this.gpuUpdate(this.processingMeshInstances)}constructor(e,t){super(e,t);const s=this.device;this._forwardDrawCalls=0,this._materialSwitches=0,this._depthMapTime=0,this._forwardTime=0,this._sortTime=0;const i=s.scope;this.fogColorId=i.resolve("fog_color"),this.fogStartId=i.resolve("fog_start"),this.fogEndId=i.resolve("fog_end"),this.fogDensityId=i.resolve("fog_density"),this.ambientId=i.resolve("light_globalAmbient"),this.skyboxIntensityId=i.resolve("skyboxIntensity"),this.cubeMapRotationMatrixId=i.resolve("cubeMapRotationMatrix"),this.pcssDiskSamplesId=i.resolve("pcssDiskSamples[0]"),this.pcssSphereSamplesId=i.resolve("pcssSphereSamples[0]"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightShadowIntensity=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.lightShadowSearchAreaId=[],this.lightCameraParamsId=[],this.lightSoftShadowParamsId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.shadowCascadeBlendId=[],this.screenSizeId=i.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3),this.pcssDiskSamples=S4(16),this.pcssSphereSamples=y4(16)}}let k0=0;const cd=[],Gp=new Set;function T4(c,e){return c.drawOrder-e.drawOrder}function E4(c,e){const t=c._sortKeyForward,s=e._sortKeyForward;return t===s?e.mesh.id-c.mesh.id:s-t}function b4(c,e){return e._sortKeyDynamic-c._sortKeyDynamic}function A4(c,e){return c._sortKeyDynamic-e._sortKeyDynamic}const w4=[null,T4,E4,b4,A4];class C4{constructor(){this.opaque=[],this.transparent=[]}}class il{set enabled(e){e!==this._enabled&&(this._dirtyComposition=!0,this.gsplatPlacementsDirty=!0,this._enabled=e,e?(this.incrementCounter(),this.onEnable&&this.onEnable()):(this.decrementCounter(),this.onDisable&&this.onDisable()))}get enabled(){return this._enabled}set clearColorBuffer(e){this._clearColorBuffer=e,this._dirtyComposition=!0}get clearColorBuffer(){return this._clearColorBuffer}set clearDepthBuffer(e){this._clearDepthBuffer=e,this._dirtyComposition=!0}get clearDepthBuffer(){return this._clearDepthBuffer}set clearStencilBuffer(e){this._clearStencilBuffer=e,this._dirtyComposition=!0}get clearStencilBuffer(){return this._clearStencilBuffer}get hasClusteredLights(){return this._clusteredLightsSet.size>0}get clusteredLightsSet(){return this._clusteredLightsSet}incrementCounter(){this._refCounter===0&&(this._enabled=!0,this.onEnable&&this.onEnable()),this._refCounter++}decrementCounter(){if(this._refCounter===1)this._enabled=!1,this.onDisable&&this.onDisable();else if(this._refCounter===0)return;this._refCounter--}addGSplatPlacement(e){this.gsplatPlacementsSet.has(e)||(this.gsplatPlacements.push(e),this.gsplatPlacementsSet.add(e),this.gsplatPlacementsDirty=!0)}removeGSplatPlacement(e){const t=this.gsplatPlacements.indexOf(e);t>=0&&(this.gsplatPlacements.splice(t,1),this.gsplatPlacementsSet.delete(e),this.gsplatPlacementsDirty=!0)}addGSplatShadowCaster(e){this.gsplatShadowCastersSet.has(e)||(this.gsplatShadowCasters.push(e),this.gsplatShadowCastersSet.add(e),this.gsplatPlacementsDirty=!0)}removeGSplatShadowCaster(e){const t=this.gsplatShadowCasters.indexOf(e);t>=0&&(this.gsplatShadowCasters.splice(t,1),this.gsplatShadowCastersSet.delete(e),this.gsplatPlacementsDirty=!0)}addMeshInstances(e,t){const s=this.meshInstances,i=this.meshInstancesSet;for(let r=0;r<e.length;r++){const a=e[r];i.has(a)||(s.push(a),i.add(a),Gp.add(a.material))}if(t||this.addShadowCasters(e),Gp.size>0){const r=this._shaderVersion;Gp.forEach(a=>{r>=0&&a._shaderVersion!==r&&(a.getShaderVariant!==Dl.prototype.getShaderVariant&&a.clearVariants(),a._shaderVersion=r)}),Gp.clear()}}removeMeshInstances(e,t){const s=this.meshInstances,i=this.meshInstancesSet;for(let r=0;r<e.length;r++){const a=e[r];if(i.has(a)){i.delete(a);const o=s.indexOf(a);o>=0&&s.splice(o,1)}}t||this.removeShadowCasters(e)}addShadowCasters(e){const t=this.shadowCasters,s=this.shadowCastersSet;for(let i=0;i<e.length;i++){const r=e[i];r.castShadow&&!s.has(r)&&(s.add(r),t.push(r))}}removeShadowCasters(e){const t=this.shadowCasters,s=this.shadowCastersSet;for(let i=0;i<e.length;i++){const r=e[i];if(s.has(r)){s.delete(r);const a=t.indexOf(r);a>=0&&t.splice(a,1)}}}clearMeshInstances(e=!1){this.meshInstances.length=0,this.meshInstancesSet.clear(),e||(this.shadowCasters.length=0,this.shadowCastersSet.clear())}markLightsDirty(){this._lightHashDirty=!0,this._lightIdHashDirty=!0,this._splitLightsDirty=!0}hasLight(e){return this._lightsSet.has(e)}addLight(e){const t=e.light;this._lightsSet.has(t)||(this._lightsSet.add(t),this._lights.push(t),this.markLightsDirty()),t.type!==Ne&&this._clusteredLightsSet.add(t)}removeLight(e){const t=e.light;this._lightsSet.has(t)&&(this._lightsSet.delete(t),this._lights.splice(this._lights.indexOf(t),1),this.markLightsDirty()),t.type!==Ne&&this._clusteredLightsSet.delete(t)}clearLights(){this._lightsSet.forEach(e=>e.removeLayer(this)),this._lightsSet.clear(),this._clusteredLightsSet.clear(),this._lights.length=0,this.markLightsDirty()}get splitLights(){if(this._splitLightsDirty){this._splitLightsDirty=!1;const e=this._splitLights;for(let s=0;s<e.length;s++)e[s].length=0;const t=this._lights;for(let s=0;s<t.length;s++){const i=t[s];i.enabled&&e[i._type].push(i)}for(let s=0;s<e.length;s++)e[s].sort((i,r)=>i.key-r.key)}return this._splitLights}evaluateLightHash(e,t,s){let i=0;const r=this._lights;for(let a=0;a<r.length;a++){const o=r[a].type!==Ne;(e&&o||t&&!o)&&cd.push(s?r[a].id:r[a].key)}return cd.length>0&&(cd.sort(),i=bv(cd),cd.length=0),i}getLightHash(e){return this._lightHashDirty&&(this._lightHashDirty=!1,this._lightHash=this.evaluateLightHash(!e,!0,!1)),this._lightHash}getLightIdHash(){return this._lightIdHashDirty&&(this._lightIdHashDirty=!1,this._lightIdHash=this.evaluateLightHash(!0,!1,!0)),this._lightIdHash}addCamera(e){this.camerasSet.has(e.camera)||(this.camerasSet.add(e.camera),this.cameras.push(e),this._dirtyComposition=!0)}removeCamera(e){if(this.camerasSet.has(e.camera)){this.camerasSet.delete(e.camera);const t=this.cameras.indexOf(e);this.cameras.splice(t,1),this._dirtyComposition=!0}}clearCameras(){this.cameras.length=0,this.camerasSet.clear(),this._dirtyComposition=!0}_calculateSortDistances(e,t,s){const i=e.length,{x:r,y:a,z:o}=t,{x:h,y:u,z:f}=s;for(let m=0;m<i;m++){const _=e[m];let g;if(_.calculateSortDistance)g=_.calculateSortDistance(_,t,s);else{const x=_.aabb.center;g=(x.x-r)*h+(x.y-a)*u+(x.z-o)*f}const S=_._drawBucket*1e9;_._sortKeyDynamic=S+g}}getCulledInstances(e){let t=this._visibleInstances.get(e);return t||(t=new C4,this._visibleInstances.set(e,t)),t}sortVisible(e,t){const s=t?this.transparentSortMode:this.opaqueSortMode;if(s===w_)return;const i=this.getCulledInstances(e),r=t?i.transparent:i.opaque,a=e.node;if(s===sV){const o=a.getPosition(),h=a.forward;this.customCalculateSortValues&&this.customCalculateSortValues(r,r.length,o,h),this.customSortCallback&&r.sort(this.customSortCallback)}else{if(s===DD||s===tV){const o=a.getPosition(),h=a.forward;this._calculateSortDistances(r,o,h)}r.sort(w4[s])}}constructor(e={}){this.meshInstances=[],this.meshInstancesSet=new Set,this.shadowCasters=[],this.shadowCastersSet=new Set,this._visibleInstances=new WeakMap,this._lights=[],this._lightsSet=new Set,this._clusteredLightsSet=new Set,this._splitLights=[[],[],[]],this._splitLightsDirty=!0,this.requiresLightCube=!1,this.cameras=[],this.camerasSet=new Set,this.gsplatPlacements=[],this.gsplatPlacementsSet=new Set,this.gsplatShadowCasters=[],this.gsplatShadowCastersSet=new Set,this.gsplatPlacementsDirty=!0,this._dirtyComposition=!1,e.id!==void 0?(this.id=e.id,k0=Math.max(this.id+1,k0)):this.id=k0++,this.name=e.name,this._enabled=e.enabled??!0,this._refCounter=this._enabled?1:0,this.opaqueSortMode=e.opaqueSortMode??eV,this.transparentSortMode=e.transparentSortMode??DD,e.renderTarget&&(this.renderTarget=e.renderTarget),this._clearColorBuffer=!!e.clearColorBuffer,this._clearDepthBuffer=!!e.clearDepthBuffer,this._clearStencilBuffer=!!e.clearStencilBuffer,this.onEnable=e.onEnable,this.onDisable=e.onDisable,this._enabled&&this.onEnable&&this.onEnable(),this.customSortCallback=null,this.customCalculateSortValues=null,this._lightHash=0,this._lightHashDirty=!1,this._lightIdHash=0,this._lightIdHashDirty=!1,this._shaderVersion=-1}}const D4=(c,e)=>c.priority-e.priority,df=c=>c.sort(D4);class nP extends Pe{destroy(){this.destroyRenderActions()}destroyRenderActions(){this._renderActions.forEach(e=>e.destroy()),this._renderActions.length=0}markDirty(){this._dirty=!0}_update(){const e=this.layerList.length;if(!this._dirty){for(let t=0;t<e;t++)if(this.layerList[t]._dirtyComposition){this._dirty=!0;break}}if(this._dirty){this._dirty=!1,this.cameras.length=0,this.camerasSet.clear();for(let s=0;s<e;s++){const i=this.layerList[s];i._dirtyComposition=!1;for(let r=0;r<i.cameras.length;r++){const a=i.cameras[r];this.camerasSet.has(a.camera)||(this.camerasSet.add(a.camera),this.cameras.push(a))}}this.cameras.length>1&&df(this.cameras);let t=0;this.destroyRenderActions();for(let s=0;s<this.cameras.length;s++){const i=this.cameras[s];if(i.camera.renderPasses.length>0){this.addDummyRenderAction(t,i),t++;continue}let r=!0;const a=t;let o=null,h=!1;for(let u=0;u<e;u++){const f=this.layerList[u];if(f.enabled&&this.subLayerEnabled[u]&&f.cameras.length>0&&i.layers.indexOf(f.id)>=0){!h&&f.id===i.disablePostEffectsLayer&&(h=!0,o&&(o.triggerPostprocess=!0));const _=this.subLayerList[u];o=this.addRenderAction(t,f,_,i,r,h),t++,r=!1}}a<t&&(o.lastCameraUse=!0),!h&&o&&(o.triggerPostprocess=!0),i.renderTarget&&i.postEffectsEnabled&&this.propagateRenderTarget(a-1,i)}this._logRenderActions()}}getNextRenderAction(e){const t=new eL;return this._renderActions.push(t),t}addDummyRenderAction(e,t){const s=this.getNextRenderAction(e);s.camera=t,s.useCameraPasses=!0}addRenderAction(e,t,s,i,r,a){let o=t.id!==xi?i.renderTarget:null,h=!1;const u=this._renderActions;for(let g=e-1;g>=0;g--)if(u[g].camera===i&&u[g].renderTarget===o){h=!0;break}a&&i.postEffectsEnabled&&(o=null);const f=this.getNextRenderAction(e);f.triggerPostprocess=!1,f.layer=t,f.transparent=s,f.camera=i,f.renderTarget=o,f.firstCameraUse=r,f.lastCameraUse=!1;const m=r||!h,_=t.clearColorBuffer||t.clearDepthBuffer||t.clearStencilBuffer;return(m||_)&&f.setupClears(m?i:void 0,t),f}propagateRenderTarget(e,t){for(let s=e;s>=0;s--){const i=this._renderActions[s],r=i.layer;if(i.renderTarget&&r.id!==xi)break;if(r.id===xi)continue;if(i.useCameraPasses)break;const a=i?.camera.camera;if(a&&(!t.camera.rect.equals(a.rect)||!t.camera.scissorRect.equals(a.scissorRect)))break;i.renderTarget=t.renderTarget}}_logRenderActions(){}_isLayerAdded(e){return this.layerIdMap.get(e.id)===e}_isSublayerAdded(e,t){return(t?this.layerTransparentIndexMap:this.layerOpaqueIndexMap).get(e)!==void 0}push(e){this._isLayerAdded(e)||(this.layerList.push(e),this.layerList.push(e),this._opaqueOrder[e.id]=this.subLayerList.push(!1)-1,this._transparentOrder[e.id]=this.subLayerList.push(!0)-1,this.subLayerEnabled.push(!0),this.subLayerEnabled.push(!0),this._updateLayerMaps(),this._dirty=!0,this.fire("add",e))}insert(e,t){if(this._isLayerAdded(e))return;this.layerList.splice(t,0,e,e),this.subLayerList.splice(t,0,!1,!0);const s=this.layerList.length;this._updateOpaqueOrder(t,s-1),this._updateTransparentOrder(t,s-1),this.subLayerEnabled.splice(t,0,!0,!0),this._updateLayerMaps(),this._dirty=!0,this.fire("add",e)}remove(e){let t=this.layerList.indexOf(e);for(delete this._opaqueOrder[t],delete this._transparentOrder[t];t>=0;)this.layerList.splice(t,1),this.subLayerList.splice(t,1),this.subLayerEnabled.splice(t,1),t=this.layerList.indexOf(e),this._dirty=!0,this.fire("remove",e);const s=this.layerList.length;this._updateOpaqueOrder(0,s-1),this._updateTransparentOrder(0,s-1),this._updateLayerMaps()}pushOpaque(e){this._isSublayerAdded(e,!1)||(this.layerList.push(e),this._opaqueOrder[e.id]=this.subLayerList.push(!1)-1,this.subLayerEnabled.push(!0),this._updateLayerMaps(),this._dirty=!0,this.fire("add",e))}insertOpaque(e,t){if(this._isSublayerAdded(e,!1))return;this.layerList.splice(t,0,e),this.subLayerList.splice(t,0,!1);const s=this.subLayerList.length;this._updateOpaqueOrder(t,s-1),this.subLayerEnabled.splice(t,0,!0),this._updateLayerMaps(),this._dirty=!0,this.fire("add",e)}removeOpaque(e){for(let t=0,s=this.layerList.length;t<s;t++)if(this.layerList[t]===e&&!this.subLayerList[t]){this.layerList.splice(t,1),this.subLayerList.splice(t,1),s--,this._updateOpaqueOrder(t,s-1),this.subLayerEnabled.splice(t,1),this._dirty=!0,this.layerList.indexOf(e)<0&&this.fire("remove",e);break}this._updateLayerMaps()}pushTransparent(e){this._isSublayerAdded(e,!0)||(this.layerList.push(e),this._transparentOrder[e.id]=this.subLayerList.push(!0)-1,this.subLayerEnabled.push(!0),this._updateLayerMaps(),this._dirty=!0,this.fire("add",e))}insertTransparent(e,t){if(this._isSublayerAdded(e,!0))return;this.layerList.splice(t,0,e),this.subLayerList.splice(t,0,!0);const s=this.subLayerList.length;this._updateTransparentOrder(t,s-1),this.subLayerEnabled.splice(t,0,!0),this._updateLayerMaps(),this._dirty=!0,this.fire("add",e)}removeTransparent(e){for(let t=0,s=this.layerList.length;t<s;t++)if(this.layerList[t]===e&&this.subLayerList[t]){this.layerList.splice(t,1),this.subLayerList.splice(t,1),s--,this._updateTransparentOrder(t,s-1),this.subLayerEnabled.splice(t,1),this._dirty=!0,this.layerList.indexOf(e)<0&&this.fire("remove",e);break}this._updateLayerMaps()}getOpaqueIndex(e){return this.layerOpaqueIndexMap.get(e)??-1}getTransparentIndex(e){return this.layerTransparentIndexMap.get(e)??-1}isEnabled(e,t){if(e.enabled){const s=t?this.getTransparentIndex(e):this.getOpaqueIndex(e);if(s>=0)return this.subLayerEnabled[s]}return!1}_updateLayerMaps(){this.layerIdMap.clear(),this.layerNameMap.clear(),this.layerOpaqueIndexMap.clear(),this.layerTransparentIndexMap.clear();for(let e=0;e<this.layerList.length;e++){const t=this.layerList[e];this.layerIdMap.set(t.id,t),this.layerNameMap.set(t.name,t),(this.subLayerList[e]?this.layerTransparentIndexMap:this.layerOpaqueIndexMap).set(t,e)}}getLayerById(e){return this.layerIdMap.get(e)??null}getLayerByName(e){return this.layerNameMap.get(e)??null}_updateOpaqueOrder(e,t){for(let s=e;s<=t;s++)this.subLayerList[s]===!1&&(this._opaqueOrder[this.layerList[s].id]=s)}_updateTransparentOrder(e,t){for(let s=e;s<=t;s++)this.subLayerList[s]===!0&&(this._transparentOrder[this.layerList[s].id]=s)}_sortLayersDescending(e,t,s){let i=-1,r=-1;for(let a=0,o=e.length;a<o;a++){const h=e[a];s.hasOwnProperty(h)&&(i=Math.max(i,s[h]))}for(let a=0,o=t.length;a<o;a++){const h=t[a];s.hasOwnProperty(h)&&(r=Math.max(r,s[h]))}return i===-1&&r!==-1?1:r===-1&&i!==-1?-1:r-i}sortTransparentLayers(e,t){return this._sortLayersDescending(e,t,this._transparentOrder)}sortOpaqueLayers(e,t){return this._sortLayersDescending(e,t,this._opaqueOrder)}constructor(e="Untitled"){super(),this.layerList=[],this.layerIdMap=new Map,this.layerNameMap=new Map,this.layerOpaqueIndexMap=new Map,this.layerTransparentIndexMap=new Map,this.subLayerList=[],this.subLayerEnabled=[],this.cameras=[],this.camerasSet=new Set,this._renderActions=[],this._dirty=!1,this.name=e,this._opaqueOrder={},this._transparentOrder={}}}const Hp=new D,ga={bias:0,normalBias:0},hd=new ue,V0={r:0,g:1,b:2,a:3},Jx={directional:Ne,omni:wt,point:wt,spot:bt},P4=[[new me(0,0,1,1)],[new me(0,0,.5,.5),new me(0,.5,.5,.5)],[new me(0,0,.5,.5),new me(0,.5,.5,.5),new me(.5,0,.5,.5)],[new me(0,0,.5,.5),new me(0,.5,.5,.5),new me(.5,0,.5,.5),new me(.5,.5,.5,.5)]],R4={rrr:1,ggg:2,bbb:4,aaa:8,rgb:7};let M4=0;class L4{destroy(){this.viewBindGroups.forEach(e=>{e.defaultUniformBuffer.destroy(),e.destroy()}),this.viewBindGroups.length=0}get shadowBuffer(){const e=this.shadowCamera.renderTarget;return e?this.light._isPcf?e.depthBuffer:e.colorBuffer:null}constructor(e,t,s){this.light=s,this.camera=e,this.shadowCamera=Q2.createShadowCamera(s._shadowType,s._type,t),this.shadowMatrix=new fe,this.shadowViewport=new me(0,0,1,1),this.shadowScissor=new me(0,0,1,1),this.projectionCompensation=0,this.face=t,this.visibleCasters=[],this.viewBindGroups=[]}}class ff{destroy(){this._evtDeviceRestored?.off(),this._evtDeviceRestored=null,this._destroyShadowMap(),this.releaseRenderData(),this._renderData=null}onDeviceRestored(){this.shadowUpdateMode===Yi&&(this.shadowUpdateMode=Kn)}releaseRenderData(){if(this._renderData){for(let e=0;e<this._renderData.length;e++)this._renderData[e].destroy();this._renderData.length=0}}addLayer(e){this.layers.add(e)}removeLayer(e){this.layers.delete(e)}set shadowSamples(e){this._softShadowParams[0]=e}get shadowSamples(){return this._softShadowParams[0]}set shadowBlockerSamples(e){this._softShadowParams[1]=e}get shadowBlockerSamples(){return this._softShadowParams[1]}set shadowBias(e){this._shadowBias!==e&&(this._shadowBias=e,this._updateShadowBias())}get shadowBias(){return this._shadowBias}set numCascades(e){(!this.cascades||this.numCascades!==e)&&(this.cascades=P4[e-1],this._shadowMatrixPalette=new Float32Array(64),this._shadowCascadeDistances=new Float32Array(4),this._destroyShadowMap(),this.updateKey())}get numCascades(){return this.cascades.length}set cascadeBlend(e){this._cascadeBlend!==e&&(this._cascadeBlend=e,this.updateKey())}get cascadeBlend(){return this._cascadeBlend}set shadowMap(e){this._shadowMap!==e&&(this._destroyShadowMap(),this._shadowMap=e)}get shadowMap(){return this._shadowMap}set mask(e){this._mask!==e&&(this._mask=e,this.updateKey(),this.updateClusteredFlags())}get mask(){return this._mask}get numShadowFaces(){const e=this._type;return e===Ne?this.numCascades:e===wt?6:1}set type(e){if(this._type===e)return;this._type=e,this._destroyShadowMap(),this._updateShadowBias(),this.updateKey(),this.updateClusteredFlags();const t=this._shadowType;this._shadowType=null,this.shadowUpdateOverrides=null,this.shadowType=t}get type(){return this._type}set shape(e){if(this._shape===e)return;this._shape=e,this._destroyShadowMap(),this.updateKey(),this.updateClusteredFlags();const t=this._shadowType;this._shadowType=null,this.shadowType=t}get shape(){return this._shape}set usePhysicalUnits(e){this._usePhysicalUnits!==e&&(this._usePhysicalUnits=e,this._updateLinearColor())}get usePhysicalUnits(){return this._usePhysicalUnits}set shadowType(e){if(this._shadowType===e)return;let t=Xa.get(e);t||(e=ur);const s=this.device;e===af&&(!s.textureFloatRenderable||!s.textureFloatFilterable)&&(e=ur),this._type===wt&&e!==A2&&e!==ur&&e!==w2&&e!==C2&&e!==af&&(e=ur),e===zE&&(!s.textureFloatRenderable||!s.textureFloatFilterable)&&(e=jx),e===jx&&!s.textureHalfFloatRenderable&&(e=ur),t=Xa.get(e),this._isVsm=t?.vsm??!1,this._isPcf=t?.pcf??!1,this._shadowType=e,this._destroyShadowMap(),this.updateKey()}get shadowType(){return this._shadowType}set enabled(e){this._enabled!==e&&(this._enabled=e,this.layersDirty())}get enabled(){return this._enabled}set castShadows(e){this._castShadows!==e&&(this._castShadows=e,this._destroyShadowMap(),this.layersDirty(),this.updateKey())}get castShadows(){return this._castShadows&&this._mask!==Ua&&this._mask!==0}set shadowIntensity(e){this._shadowIntensity!==e&&(this._shadowIntensity=e,this.updateKey())}get shadowIntensity(){return this._shadowIntensity}get bakeShadows(){return this._castShadows&&this._mask===Ua}set shadowResolution(e){this._shadowResolution!==e&&(this._type===wt?e=Math.min(e,this.device.maxCubeMapSize):e=Math.min(e,this.device.maxTextureSize),this._shadowResolution=e,this._destroyShadowMap())}get shadowResolution(){return this._shadowResolution}set vsmBlurSize(e){this._vsmBlurSize!==e&&(e%2===0&&e++,this._vsmBlurSize=e)}get vsmBlurSize(){return this._vsmBlurSize}set normalOffsetBias(e){if(this._normalOffsetBias!==e){const t=!this._normalOffsetBias&&e||this._normalOffsetBias&&!e;this._normalOffsetBias=e,t&&this.updateKey()}}get normalOffsetBias(){return this._normalOffsetBias}set falloffMode(e){this._falloffMode!==e&&(this._falloffMode=e,this.updateKey(),this.updateClusteredFlags())}get falloffMode(){return this._falloffMode}set innerConeAngle(e){this._innerConeAngle!==e&&(this._innerConeAngle=e,this._innerConeAngleCos=Math.cos(e*J.DEG_TO_RAD),this.updateClusterData(!1,!0),this._usePhysicalUnits&&this._updateLinearColor())}get innerConeAngle(){return this._innerConeAngle}set outerConeAngle(e){this._outerConeAngle!==e&&(this._outerConeAngle=e,this._updateOuterAngle(e),this._usePhysicalUnits&&this._updateLinearColor())}get outerConeAngle(){return this._outerConeAngle}set penumbraSize(e){this._penumbraSize=e,this._softShadowParams[2]=e}get penumbraSize(){return this._penumbraSize}set penumbraFalloff(e){this._softShadowParams[3]=e}get penumbraFalloff(){return this._softShadowParams[3]}_updateOuterAngle(e){const t=e*J.DEG_TO_RAD;this._outerConeAngleCos=Math.cos(t),this._outerConeAngleSin=Math.sin(t),this.updateClusterData(!1,!0)}set intensity(e){this._intensity!==e&&(this._intensity=e,this._updateLinearColor())}get intensity(){return this._intensity}set affectSpecularity(e){this._type===Ne&&(this._affectSpecularity=e,this.updateKey())}get affectSpecularity(){return this._affectSpecularity}set luminance(e){this._luminance!==e&&(this._luminance=e,this._updateLinearColor())}get luminance(){return this._luminance}get cookieMatrix(){return this._cookieMatrix||(this._cookieMatrix=new fe),this._cookieMatrix}get atlasViewport(){return this._atlasViewport||(this._atlasViewport=new me(0,0,1,1)),this._atlasViewport}set cookie(e){this._cookie!==e&&(this._cookie=e,this.updateKey())}get cookie(){return this._cookie}set cookieFalloff(e){this._cookieFalloff!==e&&(this._cookieFalloff=e,this.updateKey())}get cookieFalloff(){return this._cookieFalloff}set cookieChannel(e){if(this._cookieChannel!==e){if(e.length<3){const t=e.charAt(e.length-1),s=3-e.length;for(let i=0;i<s;i++)e+=t}this._cookieChannel=e,this.updateKey(),this.updateClusteredFlags()}}get cookieChannel(){return this._cookieChannel}set cookieTransform(e){this._cookieTransform!==e&&(this._cookieTransform=e,this._cookieTransformSet=!!e,e&&!this._cookieOffset&&(this.cookieOffset=new ne,this._cookieOffsetSet=!1),this.updateKey())}get cookieTransform(){return this._cookieTransform}set cookieOffset(e){if(this._cookieOffset===e)return;!!(this._cookieTransformSet||e)&&!e&&this._cookieOffset?this._cookieOffset.set(0,0):this._cookieOffset=e,this._cookieOffsetSet=!!e,e&&!this._cookieTransform&&(this.cookieTransform=new me(1,1,0,0),this._cookieTransformSet=!1),this.updateKey()}get cookieOffset(){return this._cookieOffset}beginFrame(){this.visibleThisFrame=this._type===Ne&&this._enabled,this.maxScreenSize=0,this.atlasViewportAllocated=!1,this.atlasSlotUpdated=!1}_destroyShadowMap(){if(this.releaseRenderData(),this._shadowMap&&(this._shadowMap.cached||this._shadowMap.destroy(),this._shadowMap=null),this.shadowUpdateMode===Yi&&(this.shadowUpdateMode=Kn),this.shadowUpdateOverrides)for(let e=0;e<this.shadowUpdateOverrides.length;e++)this.shadowUpdateOverrides[e]===Yi&&(this.shadowUpdateOverrides[e]=Kn)}getRenderData(e,t){for(let i=0;i<this._renderData.length;i++){const r=this._renderData[i];if(r.camera===e&&r.face===t)return r}const s=new L4(e,t,this);return this._renderData.push(s),s}clone(){const e=new ff(this.device,this.clusteredLighting);return e.type=this._type,e.setColor(this._color),e.intensity=this._intensity,e.affectSpecularity=this._affectSpecularity,e.luminance=this._luminance,e.castShadows=this.castShadows,e._enabled=this._enabled,e.attenuationStart=this.attenuationStart,e.attenuationEnd=this.attenuationEnd,e.falloffMode=this._falloffMode,e.shadowType=this._shadowType,e.vsmBlurSize=this._vsmBlurSize,e.vsmBlurMode=this.vsmBlurMode,e.vsmBias=this.vsmBias,e.shadowUpdateMode=this.shadowUpdateMode,e.mask=this.mask,this.shadowUpdateOverrides&&(e.shadowUpdateOverrides=this.shadowUpdateOverrides.slice()),e.innerConeAngle=this._innerConeAngle,e.outerConeAngle=this._outerConeAngle,e.numCascades=this.numCascades,e.cascadeDistribution=this.cascadeDistribution,e.cascadeBlend=this._cascadeBlend,e.shape=this._shape,e.shadowDepthState.copy(this.shadowDepthState),e.shadowBias=this.shadowBias,e.normalOffsetBias=this._normalOffsetBias,e.shadowResolution=this._shadowResolution,e.shadowDistance=this.shadowDistance,e.shadowIntensity=this.shadowIntensity,e.shadowSamples=this.shadowSamples,e.shadowBlockerSamples=this.shadowBlockerSamples,e.penumbraSize=this.penumbraSize,e.penumbraFalloff=this.penumbraFalloff,e}static getLightUnitConversion(e,t=Math.PI/4,s=0){switch(e){case bt:{const i=Math.cos(t),r=Math.cos(s);return 2*Math.PI*(1-r+(r-i)/2)}case wt:return 4*Math.PI;case Ne:return 1}}_getUniformBiasValues(e){const t=e.shadowCamera._farClip;switch(this._type){case wt:ga.bias=this.shadowBias,ga.normalBias=this._normalOffsetBias;break;case bt:this._isVsm?ga.bias=-1e-5*20:ga.bias=this.shadowBias*20,ga.normalBias=this._isVsm?this.vsmBias/(this.attenuationEnd/7):this._normalOffsetBias;break;case Ne:this._isVsm?ga.bias=-1e-5*20:ga.bias=this.shadowBias/t*100,ga.normalBias=this._isVsm?this.vsmBias/(t/7):this._normalOffsetBias;break}return ga}getColor(){return this._color}getBoundingSphere(e){if(this._type===bt){const t=this.attenuationEnd,s=this._outerConeAngle,i=this._outerConeAngleCos,r=this._node;Hp.copy(r.up),s>45?(e.radius=t*this._outerConeAngleSin,Hp.mulScalar(-t*i)):(e.radius=t/(2*i),Hp.mulScalar(-e.radius)),e.center.add2(r.getPosition(),Hp)}else this._type===wt&&(e.center=this._node.getPosition(),e.radius=this.attenuationEnd)}getBoundingBox(e){if(this._type===bt){const t=this.attenuationEnd,s=this._outerConeAngle,i=this._node,r=Math.abs(Math.sin(s*J.DEG_TO_RAD)*t);e.center.set(0,-t*.5,0),e.halfExtents.set(r,t*.5,r),e.setFromTransformedAabb(e,i.getWorldTransform(),!0)}else this._type===wt&&(e.center.copy(this._node.getPosition()),e.halfExtents.set(this.attenuationEnd,this.attenuationEnd,this.attenuationEnd))}_updateShadowBias(){if(this._type===wt&&!this.clusteredLighting)this.shadowDepthState.depthBias=0,this.shadowDepthState.depthBiasSlope=0;else{const e=this.shadowBias*-1e3;this.shadowDepthState.depthBias=e,this.shadowDepthState.depthBiasSlope=e}}_updateLinearColor(){let e=this._intensity;this._usePhysicalUnits&&(e=this._luminance/ff.getLightUnitConversion(this._type,this._outerConeAngle*J.DEG_TO_RAD,this._innerConeAngle*J.DEG_TO_RAD));const t=this._color,s=this._colorLinear;e>=1?hd.linear(t).mulScalar(e):hd.copy(t).mulScalar(e).linear(),s[0]=hd.r,s[1]=hd.g,s[2]=hd.b,this.updateClusterData(!0)}setColor(){arguments.length===1?this._color.set(arguments[0].r,arguments[0].g,arguments[0].b):arguments.length===3&&this._color.set(arguments[0],arguments[1],arguments[2]),this._updateLinearColor()}layersDirty(){this.layers.forEach(e=>{e.hasLight(this)&&e.markLightsDirty()})}updateKey(){let e=this._type<<29|this._shadowType<<25|this._falloffMode<<23|(this._normalOffsetBias!==0?1:0)<<22|(this._cookie?1:0)<<21|(this._cookieFalloff?1:0)<<20|V0[this._cookieChannel.charAt(0)]<<18|(this._cookieTransform?1:0)<<12|this._shape<<10|(this.numCascades>0?1:0)<<9|(this._cascadeBlend>0?1:0)<<8|(this.affectSpecularity?1:0)<<7|this.mask<<6|(this._castShadows?1:0)<<3;this._cookieChannel.length===3&&(e|=V0[this._cookieChannel.charAt(1)]<<16,e|=V0[this._cookieChannel.charAt(2)]<<14),e!==this.key&&this.layersDirty(),this.key=e}updateClusteredFlags(){const e=!!(this.mask&Qi),t=!!(this.mask&Ba);this.clusteredFlags=(this.type===bt?1:0)<<30|(this._shape&3)<<28|(this._falloffMode&1)<<27|(R4[this._cookieChannel]??0)<<23|(e?1:0)<<22|(t?1:0)<<21}getClusteredFlags(e,t){return this.clusteredFlags|((e?Math.floor(this.shadowIntensity*255):0)&255)<<0|((t?Math.floor(this.cookieIntensity*255):0)&255)<<8}updateClusterData(e,t){const{clusteredData16:s}=this,i=pl.float2Half;if(e&&(s[0]=i(J.clamp(this._colorLinear[0]/E_,0,65504)),s[1]=i(J.clamp(this._colorLinear[1]/E_,0,65504)),s[2]=i(J.clamp(this._colorLinear[2]/E_,0,65504))),t){let a=0;const o=.99;let h=Math.cos(this._innerConeAngle*o*J.DEG_TO_RAD);h>.5&&(h=1-h,a|=1);let u=Math.cos(this._outerConeAngle*o*J.DEG_TO_RAD);u>.5&&(u=1-u,a|=2),s[3]=a,s[4]=i(h),s[5]=i(u)}}constructor(e,t){this.layers=new Set,this.shadowDepthState=Gt.DEFAULT.clone(),this.clusteredFlags=0,this.clusteredData=new Uint32Array(3),this.clusteredData16=new Uint16Array(this.clusteredData.buffer),this._evtDeviceRestored=null,this.device=e,this.clusteredLighting=t,this.id=M4++,this._evtDeviceRestored=e.on("devicerestored",this.onDeviceRestored,this),this._type=Ne,this._color=new ue(.8,.8,.8),this._intensity=1,this._affectSpecularity=!0,this._luminance=0,this._castShadows=!1,this._enabled=!1,this._mask=Qi,this.isStatic=!1,this.key=0,this.bakeDir=!0,this.bakeNumSamples=1,this.bakeArea=0,this.attenuationStart=10,this.attenuationEnd=10,this._falloffMode=UE,this._shadowType=ur,this._vsmBlurSize=11,this.vsmBlurMode=kE,this.vsmBias=.01*.25,this._cookie=null,this.cookieIntensity=1,this._cookieFalloff=!0,this._cookieChannel="rgb",this._cookieTransform=null,this._cookieTransformUniform=new Float32Array(4),this._cookieOffset=null,this._cookieOffsetUniform=new Float32Array(2),this._cookieTransformSet=!1,this._cookieOffsetSet=!1,this._innerConeAngle=40,this._outerConeAngle=45,this.cascades=null,this._shadowMatrixPalette=null,this._shadowCascadeDistances=null,this.numCascades=1,this._cascadeBlend=0,this.cascadeDistribution=.5,this._shape=_r,this._colorLinear=new Float32Array(3),this._updateLinearColor(),this._position=new D(0,0,0),this._direction=new D(0,0,0),this._innerConeAngleCos=Math.cos(this._innerConeAngle*J.DEG_TO_RAD),this._updateOuterAngle(this._outerConeAngle),this._usePhysicalUnits=void 0,this._shadowMap=null,this._shadowRenderParams=[],this._shadowCameraParams=[],this.shadowDistance=40,this._shadowResolution=1024,this._shadowBias=-5e-4,this._shadowIntensity=1,this._normalOffsetBias=0,this.shadowUpdateMode=jE,this.shadowUpdateOverrides=null,this._isVsm=!1,this._isPcf=!0,this._softShadowParams=new Float32Array(4),this.shadowSamples=16,this.shadowBlockerSamples=16,this.penumbraSize=1,this.penumbraFalloff=1,this._cookieMatrix=null,this._atlasViewport=null,this.atlasViewportAllocated=!1,this.atlasVersion=0,this.atlasSlotIndex=0,this.atlasSlotUpdated=!1,this._node=null,this._renderData=[],this.visibleThisFrame=!1,this.maxScreenSize=0,this._updateShadowBias()}}class tL{applySettings(e){this.shadowsEnabled=e.lightingShadowsEnabled??this.shadowsEnabled,this.cookiesEnabled=e.lightingCookiesEnabled??this.cookiesEnabled,this.areaLightsEnabled=e.lightingAreaLightsEnabled??this.areaLightsEnabled,this.shadowAtlasResolution=e.lightingShadowAtlasResolution??this.shadowAtlasResolution,this.cookieAtlasResolution=e.lightingCookieAtlasResolution??this.cookieAtlasResolution,this.maxLightsPerCell=e.lightingMaxLightsPerCell??this.maxLightsPerCell,this.shadowType=e.lightingShadowType??this.shadowType,e.lightingCells&&(this.cells=new D(e.lightingCells))}set cells(e){this._cells.copy(e)}get cells(){return this._cells}set maxLightsPerCell(e){this._maxLightsPerCell=J.clamp(e,1,255)}get maxLightsPerCell(){return this._maxLightsPerCell}set cookieAtlasResolution(e){this._cookieAtlasResolution=J.clamp(e,32,this._maxTextureSize)}get cookieAtlasResolution(){return this._cookieAtlasResolution}set shadowAtlasResolution(e){this._shadowAtlasResolution=J.clamp(e,32,this._maxTextureSize)}get shadowAtlasResolution(){return this._shadowAtlasResolution}set shadowType(e){this._shadowType!==e&&(this._shadowType=e,this._dirtyLightsFnc())}get shadowType(){return this._shadowType}set cookiesEnabled(e){this._cookiesEnabled!==e&&(this._cookiesEnabled=e,this._dirtyLightsFnc())}get cookiesEnabled(){return this._cookiesEnabled}set areaLightsEnabled(e){this._supportsAreaLights&&this._areaLightsEnabled!==e&&(this._areaLightsEnabled=e,this._dirtyLightsFnc())}get areaLightsEnabled(){return this._areaLightsEnabled}set shadowsEnabled(e){this._shadowsEnabled!==e&&(this._shadowsEnabled=e,this._dirtyLightsFnc())}get shadowsEnabled(){return this._shadowsEnabled}constructor(e,t,s){this._areaLightsEnabled=!1,this._cells=new D(10,3,10),this._maxLightsPerCell=255,this._shadowsEnabled=!0,this._shadowType=ur,this._shadowAtlasResolution=2048,this._cookiesEnabled=!1,this._cookieAtlasResolution=2048,this.atlasSplit=null,this._supportsAreaLights=e,this._maxTextureSize=t,this._dirtyLightsFnc=s}}class Pl{destroy(){this.shader=null;const e=this.morph;e&&(this.morph=null,e.decRefCount(),e.refCount<1&&e.destroy()),this.rtPositions?.destroy(),this.rtPositions=null,this.texturePositions?.destroy(),this.texturePositions=null,this.rtNormals?.destroy(),this.rtNormals=null,this.textureNormals?.destroy(),this.textureNormals=null}clone(){return new Pl(this.morph)}_getWeightIndex(e){return typeof e=="string"?this._weightMap.get(e):e}getWeight(e){const t=this._getWeightIndex(e);return this._weights[t]}setWeight(e,t){const s=this._getWeightIndex(e);this._weights[s]=t,this._dirty=!0}_createShader(e){const t=new Map;t.set("{MORPH_TEXTURE_MAX_COUNT}",e),this.morph.intRenderFormat&&t.set("MORPH_INT","");const s=this.morph.intRenderFormat?"uvec4":"vec4";return ns.createShader(this.device,{uniqueName:`TextureMorphShader_${e}-${this.morph.intRenderFormat?"int":"float"}`,attributes:{vertex_position:He},vertexChunk:"morphVS",fragmentChunk:"morphPS",fragmentDefines:t,fragmentOutputTypes:[s]})}_updateTextureRenderTarget(e,t,s){const{morph:i,device:r}=this;this.setAabbUniforms(s),this.morphTextureId.setValue(s?i.targetsTexturePositions:i.targetsTextureNormals),r.setBlendState(ht.NOBLEND),this.countId.setValue(t),this.morphFactor.setValue(this._shaderMorphWeights),this.morphIndex.setValue(this._shaderMorphIndex),gr(r,e,this.shader)}_updateTextureMorph(e){this.device,(e>0||!this.zeroTextures)&&(this.rtPositions&&this._updateTextureRenderTarget(this.rtPositions,e,!0),this.rtNormals&&this._updateTextureRenderTarget(this.rtNormals,e,!1),this.zeroTextures=e===0)}setAabbUniforms(e=!0){this.aabbSizeId.setValue(e?this._aabbSize:this._aabbNrmSize),this.aabbMinId.setValue(e?this._aabbMin:this._aabbNrmMin)}prepareRendering(e){this.setAabbUniforms()}update(){this._dirty=!1;const e=this.morph._targets,t=1e-5,s=this._shaderMorphWeights,i=this._shaderMorphIndex;let r=0;for(let a=0;a<e.length;a++)Math.abs(this.getWeight(a))>t&&(s[r]=this.getWeight(a),i[r]=a,r++);this._updateTextureMorph(r)}constructor(e){this.morph=e,e.incRefCount(),this.device=e.device;const t=e._targets.length;this.shader=this._createShader(t),this._weights=[],this._weightMap=new Map;for(let a=0;a<e._targets.length;a++){const o=e._targets[a];o.name&&this._weightMap.set(o.name,a),this.setWeight(a,o.defaultWeight)}this._shaderMorphWeights=new Float32Array(t),this._shaderMorphIndex=new Uint32Array(t);const s=(a,o)=>(this[o]=e._createTexture(a,e._renderTextureFormat),new At({colorBuffer:this[o],depth:!1}));e.morphPositions&&(this.rtPositions=s("MorphRTPos","texturePositions")),e.morphNormals&&(this.rtNormals=s("MorphRTNrm","textureNormals")),this._textureParams=new Float32Array([e.morphTextureWidth,e.morphTextureHeight]);const i=e.aabb.halfExtents;this._aabbSize=new Float32Array([i.x*4,i.y*4,i.z*4]);const r=e.aabb.getMin();this._aabbMin=new Float32Array([r.x*2,r.y*2,r.z*2]),this._aabbNrmSize=new Float32Array([2,2,2]),this._aabbNrmMin=new Float32Array([-1,-1,-1]),this.aabbSizeId=this.device.scope.resolve("aabbSize"),this.aabbMinId=this.device.scope.resolve("aabbMin"),this.morphTextureId=this.device.scope.resolve("morphTexture"),this.morphFactor=this.device.scope.resolve("morphFactor[0]"),this.morphIndex=this.device.scope.resolve("morphIndex[0]"),this.countId=this.device.scope.resolve("count"),this.zeroTextures=!1}}class rn{getGraph(){return this.graph}setGraph(e){this.graph=e}getCameras(){return this.cameras}setCameras(e){this.cameras=e}getLights(){return this.lights}setLights(e){this.lights=e}getMaterials(){const e=[];for(let t=0;t<this.meshInstances.length;t++){const s=this.meshInstances[t];e.indexOf(s.material)===-1&&e.push(s.material)}return e}clone(){const e=[],t=[],s=function(u){const f=u.clone();e.push(u),t.push(f);for(let m=0;m<u._children.length;m++)f.addChild(s(u._children[m]));return f},i=s(this.graph),r=[],a=[],o=[];for(let u=0;u<this.skinInstances.length;u++){const f=this.skinInstances[u].skin,m=new Yf(f),_=[];for(let g=0;g<f.boneNames.length;g++){const S=f.boneNames[g],x=i.findByName(S);_.push(x)}m.bones=_,a.push(m)}for(let u=0;u<this.morphInstances.length;u++){const f=this.morphInstances[u].morph,m=new Pl(f);o.push(m)}for(let u=0;u<this.meshInstances.length;u++){const f=this.meshInstances[u],m=e.indexOf(f.node),_=new lt(f.mesh,f.material,t[m]);if(f.skinInstance){const g=this.skinInstances.indexOf(f.skinInstance);_.skinInstance=a[g]}if(f.morphInstance){const g=this.morphInstances.indexOf(f.morphInstance);_.morphInstance=o[g]}r.push(_)}const h=new rn;return h.graph=i,h.meshInstances=r,h.skinInstances=a,h.morphInstances=o,h.getGraph().syncHierarchy(),h}destroy(){const e=this.meshInstances;for(let t=0;t<e.length;t++)e[t].destroy();this.meshInstances.length=0}generateWireframe(){lt._prepareRenderStyleForArray(this.meshInstances,sl)}constructor(){this.graph=null,this.meshInstances=[],this.skinInstances=[],this.morphInstances=[],this.cameras=[],this.lights=[],this._shadersVersion=0,this._immutable=!1}}class sL extends wv{destroy(){this.vertexBufferIds?.destroy(),this.vertexBufferIds=null,this.targetsTexturePositions?.destroy(),this.targetsTexturePositions=null,this.targetsTextureNormals?.destroy(),this.targetsTextureNormals=null}get aabb(){if(!this._aabb){const e=new D,t=new D;for(let s=0;s<this._targets.length;s++){const i=this._targets[s].aabb;e.min(i.getMin()),t.max(i.getMax())}this._aabb=new Ge,this._aabb.setMinMax(e,t)}return this._aabb}get morphPositions(){return this._morphPositions}get morphNormals(){return this._morphNormals}_init(){this._initTextureBased();for(let e=0;e<this._targets.length;e++)this._targets[e]._postInit()}_findSparseSet(e,t,s){let i=1;const r=e[0].length;for(let a=0;a<r;a+=3){let o=!1;for(let h=0;h<e.length;h++){const u=e[h];if(u[a]!==0||u[a+1]!==0||u[a+2]!==0){o=!0;break}}o?(t.push(i),s.push(a/3),i++):t.push(0)}return i}_initTextureBased(){const e=[],t=[],s=this._targets;for(let T=0;T<s.length;T++){const E=s[T];E.options.deltaPositions&&(e.push(E.options.deltaPositions),t.push(!0)),E.options.deltaNormals&&(e.push(E.options.deltaNormals),t.push(!1))}const i=[],r=[],a=this._findSparseSet(e,i,r),o=this.device.maxTextureSize;let h=Math.ceil(Math.sqrt(a));h=Math.min(h,o);const u=Math.ceil(a/h);if(u>o)return;this.morphTextureWidth=h,this.morphTextureHeight=u;let f=!1;const m=pl.float2Half;this._textureFormat===kt&&(f=!0);const _=[],g=[],S=h*u*4;for(let T=0;T<e.length;T++){const E=e[T],b=this._textureFormat===kt?new Uint16Array(S):new Float32Array(S);if((t[T]?_:g).push(b),f)for(let C=0;C<r.length;C++){const w=r[C]*3,P=C*4+4;b[P]=m(E[w]),b[P+1]=m(E[w+1]),b[P+2]=m(E[w+2])}else for(let C=0;C<r.length;C++){const w=r[C]*3,P=C*4+4;b[P]=E[w],b[P+1]=E[w+1],b[P+2]=E[w+2]}}_.length>0&&(this.targetsTexturePositions=this._createTexture("MorphPositionsTexture",this._textureFormat,s.length,[_])),g.length>0&&(this.targetsTextureNormals=this._createTexture("MorphNormalsTexture",this._textureFormat,s.length,[g]));const x=[{semantic:Eh,components:1,type:Xh,asInt:!0}];return this.vertexBufferIds=new Yr(this.device,new Ti(this.device,x,i.length),i.length,{data:new Uint32Array(i)}),!0}get targets(){return this._targets}_updateMorphFlags(){this._morphPositions=!1,this._morphNormals=!1;for(let e=0;e<this._targets.length;e++){const t=this._targets[e];t.morphPositions&&(this._morphPositions=!0),t.morphNormals&&(this._morphNormals=!0)}}_createTexture(e,t,s,i){return new De(this.device,{levels:i,arrayLength:s,width:this.morphTextureWidth,height:this.morphTextureHeight,format:t,cubemap:!1,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te,name:e})}constructor(e,t,{preferHighPrecision:s=!1}={}){super(),this.device=t;const i=t;this.preferHighPrecision=s,this._targets=e.slice();const r=i.textureHalfFloatRenderable?kt:void 0,a=i.textureFloatRenderable?fs:void 0;this._renderTextureFormat=this.preferHighPrecision?a??r:r??a,this._renderTextureFormat=this._renderTextureFormat??lo,this.intRenderFormat=qn(this._renderTextureFormat),this._textureFormat=this.preferHighPrecision?fs:kt,this._init(),this._updateMorphFlags()}}class Lv{get name(){return this._name}get defaultWeight(){return this._defaultWeight}get aabb(){return this._aabb||(this._aabb=new Ge,this.deltaPositions&&this._aabb.compute(this.deltaPositions)),this._aabb}clone(){return new Lv(this.options)}_postInit(){this.options.preserveData||(this.options=null),this.used=!0}constructor(e){this.used=!1,this.options=e,this._name=e.name,this._defaultWeight=e.defaultWeight||0,this._aabb=e.aabb,this.deltaPositions=e.deltaPositions,this.morphPositions=!!e.deltaPositions,this.morphNormals=!!e.deltaNormals}}let va,oP=1;const be=4,G0=new fe,H0=new fe,Rr=new D,It=new D,rr=new D,Oc=new D,pi=new D,Qt=new D,Nc=new D,Fc=new D,ud=new D,lP=new D,Cs=new D,Wp=new D,Go=new D;function uh(c){return c-Math.floor(c)}function I4(c){return Math.max(Math.min(c,1),0)}function W0(c,e){return c-e*Math.floor(c/e)}function O4(c){let e=uh(c),t=uh(255*c),s=uh(65025*c),i=uh(160581375*c);return e-=t/255,t-=s/255,s-=i/255,i-=i/255,[e,t,s,i]}function Xp(c){let e=uh(c),t=uh(255*c);return e-=t/255,t-=t/255,[e,t]}class N4{calcSpawnPosition(e,t,s,i,r){const a=this._emitter,o=Math.random(),h=Math.random(),u=Math.random(),f=Math.random();if(a.useCpu&&(e[r*be+0+a.numParticlesPot*2*be]=o,e[r*be+1+a.numParticlesPot*2*be]=h,e[r*be+2+a.numParticlesPot*2*be]=u),It.x=o-.5,It.y=h-.5,It.z=u-.5,a.emitterShape===Lr){const g=Math.max(Math.abs(It.x),Math.max(Math.abs(It.y),Math.abs(It.z))),S=g+(.5-g)*s[0],x=g+(.5-g)*s[1],T=g+(.5-g)*s[2];It.x=S*(g===Math.abs(It.x)?Math.sign(It.x):2*It.x),It.y=x*(g===Math.abs(It.y)?Math.sign(It.y):2*It.y),It.z=T*(g===Math.abs(It.z)?Math.sign(It.z):2*It.z),a.localSpace?Rr.copy(t.transformPoint(It)):Rr.copy(i).add(t.transformPoint(It))}else{It.normalize();const g=a.emitterRadius===0?0:a.emitterRadiusInner/a.emitterRadius,S=f*(1-g)+g;a.localSpace?Rr.copy(It.mulScalar(S*a.emitterRadius)):Rr.copy(i).add(It.mulScalar(S*a.emitterRadius))}let _=-J.lerp(a.rate,a.rate2,o)*r;if(a.pack8){const g=(Rr.x-a.worldBounds.center.x)/a.worldBoundsSize.x+.5,S=(Rr.y-a.worldBounds.center.y)/a.worldBoundsSize.y+.5,x=(Rr.z-a.worldBounds.center.z)/a.worldBoundsSize.z+.5;let T=J.lerp(a.startAngle*J.DEG_TO_RAD,a.startAngle2*J.DEG_TO_RAD,o);T=T%(Math.PI*2)/(Math.PI*2);const E=Xp(g);e[r*be]=E[0],e[r*be+1]=E[1];const b=Xp(S);e[r*be+2]=b[0],e[r*be+3]=b[1];const C=Xp(x);e[r*be+0+a.numParticlesPot*be]=C[0],e[r*be+1+a.numParticlesPot*be]=C[1];const w=Xp(T);e[r*be+2+a.numParticlesPot*be]=w[0],e[r*be+3+a.numParticlesPot*be]=w[1];const P=1;e[r*be+3+a.numParticlesPot*be*2]=P;const I=Math.max(a.lifetime,a.numParticles*Math.max(a.rate,a.rate2)),M=a.lifetime+1;_=(_+I)/(I+M);const R=O4(_);e[r*be+0+a.numParticlesPot*be*3]=R[0],e[r*be+1+a.numParticlesPot*be*3]=R[1],e[r*be+2+a.numParticlesPot*be*3]=R[2],e[r*be+3+a.numParticlesPot*be*3]=R[3]}else e[r*be]=Rr.x,e[r*be+1]=Rr.y,e[r*be+2]=Rr.z,e[r*be+3]=J.lerp(a.startAngle*J.DEG_TO_RAD,a.startAngle2*J.DEG_TO_RAD,o),e[r*be+3+a.numParticlesPot*be]=_}update(e,t,s,i,r,a,o,h){let u,f,m;const _=this._emitter;if(_.meshInstance.node){const L=_.meshInstance.node.worldTransform;for(let B=0;B<12;B++)G0.data[B]=L.data[B];H0.copy(G0),H0.invert(),va=_.meshInstance.node.localScale,oP=Math.max(Math.max(va.x,va.y),va.z)}a=_.meshInstance.node===null||_.localSpace?D.ZERO:_.meshInstance.node.getPosition();const g=_.camera?_.camera._node.getPosition():D.ZERO,S=_.useMesh?17:15;let x,T,E,b,C,w,P,I,M;const R=_.precision-1;for(let L=0;L<_.numParticles;L++){const B=Math.floor(_.vbCPU[L*_.numParticleVerts*(_.useMesh?6:4)+3]),G=s[B*be+0+_.numParticlesPot*2*be];rr.x=G,rr.y=s[B*be+1+_.numParticlesPot*2*be],rr.z=s[B*be+2+_.numParticlesPot*2*be];const H=_.rate+(_.rate2-_.rate)*G,ee=_.lifetime;let j=s[B*be+3+_.numParticlesPot*be]+o;const ae=I4(j/ee);let k=0,O=0;const z=0;(j-o<=0||j>=ee)&&this.calcSpawnPosition(s,i,r,a,B);let Y=j>0&&j<ee;Y&&(m=ae*R,x=Math.floor(m),T=Math.ceil(m),m%=1,u=_.qRotSpeed[x],f=_.qRotSpeed[T],E=u+(f-u)*m,u=_.qRotSpeed2[x],f=_.qRotSpeed2[T],b=u+(f-u)*m,u=_.qScale[x],f=_.qScale[T],k=u+(f-u)*m,u=_.qScale2[x],f=_.qScale2[T],C=u+(f-u)*m,u=_.qAlpha[x],f=_.qAlpha[T],w=u+(f-u)*m,u=_.qAlpha2[x],f=_.qAlpha2[T],P=u+(f-u)*m,u=_.qRadialSpeed[x],f=_.qRadialSpeed[T],I=u+(f-u)*m,u=_.qRadialSpeed2[x],f=_.qRadialSpeed2[T],M=u+(f-u)*m,I+=(M-I)*(G*100%1),Oc.x=s[B*be],Oc.y=s[B*be+1],Oc.z=s[B*be+2],_.localSpace?ud.copy(Oc):ud.copy(Oc).sub(a),ud.normalize().mulScalar(I),x*=3,T*=3,u=_.qLocalVelocity[x],f=_.qLocalVelocity[T],Qt.x=u+(f-u)*m,u=_.qLocalVelocity[x+1],f=_.qLocalVelocity[T+1],Qt.y=u+(f-u)*m,u=_.qLocalVelocity[x+2],f=_.qLocalVelocity[T+2],Qt.z=u+(f-u)*m,u=_.qLocalVelocity2[x],f=_.qLocalVelocity2[T],Fc.x=u+(f-u)*m,u=_.qLocalVelocity2[x+1],f=_.qLocalVelocity2[T+1],Fc.y=u+(f-u)*m,u=_.qLocalVelocity2[x+2],f=_.qLocalVelocity2[T+2],Fc.z=u+(f-u)*m,u=_.qVelocity[x],f=_.qVelocity[T],pi.x=u+(f-u)*m,u=_.qVelocity[x+1],f=_.qVelocity[T+1],pi.y=u+(f-u)*m,u=_.qVelocity[x+2],f=_.qVelocity[T+2],pi.z=u+(f-u)*m,u=_.qVelocity2[x],f=_.qVelocity2[T],Nc.x=u+(f-u)*m,u=_.qVelocity2[x+1],f=_.qVelocity2[T+1],Nc.y=u+(f-u)*m,u=_.qVelocity2[x+2],f=_.qVelocity2[T+2],Nc.z=u+(f-u)*m,Qt.x+=(Fc.x-Qt.x)*rr.x,Qt.y+=(Fc.y-Qt.y)*rr.y,Qt.z+=(Fc.z-Qt.z)*rr.z,_.initialVelocity>0&&(_.emitterShape===Xk?(It.copy(rr).mulScalar(2).sub(D.ONE).normalize(),Qt.add(It.mulScalar(_.initialVelocity))):Qt.add(D.FORWARD.mulScalar(_.initialVelocity))),pi.x+=(Nc.x-pi.x)*rr.x,pi.y+=(Nc.y-pi.y)*rr.y,pi.z+=(Nc.z-pi.z)*rr.z,E+=(b-E)*rr.y,k=(k+(C-k)*(G*1e4%1))*oP,O=(P-w)*(G*1e3%1),_.meshInstance.node&&(_.localSpace?(Qt.x/=va.x,Qt.y/=va.y,Qt.z/=va.z):G0.transformPoint(Qt,Qt)),_.localSpace?(H0.transformPoint(pi,pi),Qt.add(pi).add(ud)):(Qt.add(pi.mul(va)),Qt.add(ud.mul(va))),Wp.copy(Qt),lP.copy(Oc).add(Qt.mulScalar(o)),Cs.copy(lP),s[B*be]=Cs.x,s[B*be+1]=Cs.y,s[B*be+2]=Cs.z,s[B*be+3]+=E*o,_.wrap&&_.wrapBounds&&(_.localSpace||Cs.sub(a),Cs.x=W0(Cs.x,_.wrapBounds.x)-_.wrapBounds.x*.5,Cs.y=W0(Cs.y,_.wrapBounds.y)-_.wrapBounds.y*.5,Cs.z=W0(Cs.z,_.wrapBounds.z)-_.wrapBounds.z*.5,_.localSpace||Cs.add(a)),_.sort>0&&(_.sort===1?(Go.copy(Cs).sub(g),_.particleDistance[B]=-(Go.x*Go.x+Go.y*Go.y+Go.z*Go.z)):_.sort===2?_.particleDistance[B]=j:_.sort===3&&(_.particleDistance[B]=-j))),h?j<0&&(s[B*be+3+_.numParticlesPot*2*be]=-1):(j>=ee&&(j-=Math.max(ee,_.numParticles*H),s[B*be+3+_.numParticlesPot*2*be]=_.loop?1:-1),j<0&&_.loop&&(s[B*be+3+_.numParticlesPot*2*be]=1)),s[B*be+3+_.numParticlesPot*2*be]<0&&(Y=!1),s[B*be+3+_.numParticlesPot*be]=j;for(let F=0;F<_.numParticleVerts;F++){const U=(L*_.numParticleVerts+F)*(_.useMesh?6:4);let K=_.vbCPU[U],se=_.vbCPU[U+1],le=_.vbCPU[U+2];Y||(K=se=le=0);const re=L*_.numParticleVerts*S+F*S;e[re]=Cs.x,e[re+1]=Cs.y,e[re+2]=Cs.z,e[re+3]=ae,e[re+4]=_.alignToMotion?z:s[B*be+3],e[re+5]=k,e[re+6]=O,e[re+7]=Wp.x,e[re+8]=K,e[re+9]=se,e[re+10]=le,e[re+11]=Wp.y,e[re+12]=B,e[re+13]=Wp.z,e[re+14]=_.vbCPU[U+3],_.useMesh&&(e[re+15]=_.vbCPU[U+4],e[re+16]=_.vbCPU[U+5])}}if(_.sort>$x&&_.camera){const L=_.useMesh?6:4,B=_.particleDistance;for(let G=0;G<_.numParticles;G++)t[G][0]=G,t[G][1]=B[Math.floor(_.vbCPU[G*_.numParticleVerts*L+3])];_.vbOld.set(_.vbCPU),t.sort((G,H)=>G[1]-H[1]);for(let G=0;G<_.numParticles;G++){const H=t[G][0]*_.numParticleVerts*L,ee=G*_.numParticleVerts*L;for(let j=0;j<_.numParticleVerts*L;j++)_.vbCPU[ee+j]=_.vbOld[H+j]}}}constructor(e){this._emitter=e}}const cP=new $i,hP=new $i,uP=new $i;class F4{_setInputBounds(){this.inBoundsSizeUniform[0]=this._emitter.prevWorldBoundsSize.x,this.inBoundsSizeUniform[1]=this._emitter.prevWorldBoundsSize.y,this.inBoundsSizeUniform[2]=this._emitter.prevWorldBoundsSize.z,this.constantInBoundsSize.setValue(this.inBoundsSizeUniform),this.inBoundsCenterUniform[0]=this._emitter.prevWorldBoundsCenter.x,this.inBoundsCenterUniform[1]=this._emitter.prevWorldBoundsCenter.y,this.inBoundsCenterUniform[2]=this._emitter.prevWorldBoundsCenter.z,this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform)}randomize(){this.frameRandomUniform[0]=Math.random(),this.frameRandomUniform[1]=Math.random(),this.frameRandomUniform[2]=Math.random()}update(e,t,s,i,r){const a=this._emitter;e.setBlendState(ht.NOBLEND),e.setDepthState(Gt.NODEPTH),e.setCullMode(Ft),this.randomize(),this.constantRadialSpeedDivMult.setValue(a.material.getParameter("radialSpeedDivMult").data),this.constantGraphSampleSize.setValue(1/a.precision),this.constantGraphNumSamples.setValue(a.precision),this.constantNumParticles.setValue(a.numParticles),this.constantNumParticlesPot.setValue(a.numParticlesPot),this.constantInternalTex0.setValue(a.internalTex0),this.constantInternalTex1.setValue(a.internalTex1),this.constantInternalTex2.setValue(a.internalTex2),this.constantInternalTex3.setValue(a.internalTex3);const o=a.meshInstance.node,h=o===null?D.ONE:o.localScale;if(a.pack8){this.worldBoundsMulUniform[0]=a.worldBoundsMul.x,this.worldBoundsMulUniform[1]=a.worldBoundsMul.y,this.worldBoundsMulUniform[2]=a.worldBoundsMul.z,this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform),this.worldBoundsAddUniform[0]=a.worldBoundsAdd.x,this.worldBoundsAddUniform[1]=a.worldBoundsAdd.y,this.worldBoundsAddUniform[2]=a.worldBoundsAdd.z,this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform),this._setInputBounds();let g=a.maxVel*Math.max(Math.max(h.x,h.y),h.z);g=Math.max(g,1),this.constantMaxVel.setValue(g)}const u=o===null||a.localSpace?D.ZERO:o.getPosition(),f=o===null?fe.IDENTITY:o.getWorldTransform();a.emitterShape===Lr?(cP.setFromMat4(t),this.constantSpawnBounds.setValue(cP.data),this.constantSpawnPosInnerRatio.setValue(s)):(this.constantSpawnBoundsSphere.setValue(a.emitterRadius),this.constantSpawnBoundsSphereInnerRatio.setValue(a.emitterRadius===0?0:a.emitterRadiusInner/a.emitterRadius)),this.constantInitialVelocity.setValue(a.initialVelocity),hP.setFromMat4(f),uP.invertMat4(f),this.emitterPosUniform[0]=u.x,this.emitterPosUniform[1]=u.y,this.emitterPosUniform[2]=u.z,this.constantEmitterPos.setValue(this.emitterPosUniform),this.constantFrameRandom.setValue(this.frameRandomUniform),this.constantDelta.setValue(i),this.constantRate.setValue(a.rate),this.constantRateDiv.setValue(a.rate2-a.rate),this.constantStartAngle.setValue(a.startAngle*J.DEG_TO_RAD),this.constantStartAngle2.setValue(a.startAngle2*J.DEG_TO_RAD),this.constantSeed.setValue(a.seed),this.constantLifetime.setValue(a.lifetime),this.emitterScaleUniform[0]=h.x,this.emitterScaleUniform[1]=h.y,this.emitterScaleUniform[2]=h.z,this.constantEmitterScale.setValue(this.emitterScaleUniform),this.constantEmitterMatrix.setValue(hP.data),this.constantEmitterMatrixInv.setValue(uP.data),this.constantLocalVelocityDivMult.setValue(a.localVelocityUMax),this.constantVelocityDivMult.setValue(a.velocityUMax),this.constantRotSpeedDivMult.setValue(a.rotSpeedUMax[0]);let m=a.swapTex?a.particleTexOUT:a.particleTexIN;m=a.beenReset?a.particleTexStart:m;const _=a.swapTex?a.particleTexIN:a.particleTexOUT;this.constantParticleTexIN.setValue(m),gr(e,a.swapTex?a.rtParticleTexIN:a.rtParticleTexOUT,r?a.shaderParticleUpdateOnStop:a.loop?a.shaderParticleUpdateRespawn:a.shaderParticleUpdateNoRespawn),a.material.setParameter("particleTexOUT",m),a.material.setParameter("particleTexIN",_),a.beenReset=!1,a.swapTex=!a.swapTex,a.prevWorldBoundsSize.copy(a.worldBoundsSize),a.prevWorldBoundsCenter.copy(a.worldBounds.center),a.pack8&&this._setInputBounds()}constructor(e,t){this._emitter=e,this.frameRandomUniform=new Float32Array(3),this.emitterPosUniform=new Float32Array(3),this.emitterScaleUniform=new Float32Array([1,1,1]),this.worldBoundsMulUniform=new Float32Array(3),this.worldBoundsAddUniform=new Float32Array(3),this.inBoundsSizeUniform=new Float32Array(3),this.inBoundsCenterUniform=new Float32Array(3),this.constantParticleTexIN=t.scope.resolve("particleTexIN"),this.constantParticleTexOUT=t.scope.resolve("particleTexOUT"),this.constantEmitterPos=t.scope.resolve("emitterPos"),this.constantEmitterScale=t.scope.resolve("emitterScale"),this.constantSpawnBounds=t.scope.resolve("spawnBounds"),this.constantSpawnPosInnerRatio=t.scope.resolve("spawnPosInnerRatio"),this.constantSpawnBoundsSphere=t.scope.resolve("spawnBoundsSphere"),this.constantSpawnBoundsSphereInnerRatio=t.scope.resolve("spawnBoundsSphereInnerRatio"),this.constantInitialVelocity=t.scope.resolve("initialVelocity"),this.constantFrameRandom=t.scope.resolve("frameRandom"),this.constantDelta=t.scope.resolve("delta"),this.constantRate=t.scope.resolve("rate"),this.constantRateDiv=t.scope.resolve("rateDiv"),this.constantLifetime=t.scope.resolve("lifetime"),this.constantGraphSampleSize=t.scope.resolve("graphSampleSize"),this.constantGraphNumSamples=t.scope.resolve("graphNumSamples"),this.constantInternalTex0=t.scope.resolve("internalTex0"),this.constantInternalTex1=t.scope.resolve("internalTex1"),this.constantInternalTex2=t.scope.resolve("internalTex2"),this.constantInternalTex3=t.scope.resolve("internalTex3"),this.constantEmitterMatrix=t.scope.resolve("emitterMatrix"),this.constantEmitterMatrixInv=t.scope.resolve("emitterMatrixInv"),this.constantNumParticles=t.scope.resolve("numParticles"),this.constantNumParticlesPot=t.scope.resolve("numParticlesPot"),this.constantLocalVelocityDivMult=t.scope.resolve("localVelocityDivMult"),this.constantVelocityDivMult=t.scope.resolve("velocityDivMult"),this.constantRotSpeedDivMult=t.scope.resolve("rotSpeedDivMult"),this.constantSeed=t.scope.resolve("seed"),this.constantStartAngle=t.scope.resolve("startAngle"),this.constantStartAngle2=t.scope.resolve("startAngle2"),this.constantOutBoundsMul=t.scope.resolve("outBoundsMul"),this.constantOutBoundsAdd=t.scope.resolve("outBoundsAdd"),this.constantInBoundsSize=t.scope.resolve("inBoundsSize"),this.constantInBoundsCenter=t.scope.resolve("inBoundsCenter"),this.constantMaxVel=t.scope.resolve("maxVel"),this.constantFaceTangent=t.scope.resolve("faceTangent"),this.constantFaceBinorm=t.scope.resolve("faceBinorm"),this.constantRadialSpeedDivMult=t.scope.resolve("radialSpeedDivMult")}}const dP=["NONE","VERTEX","MAP"];class B4 extends wl{generateKey(e){let s=`particle_${wl.definesHash(e.defines)}_`;for(const i in e)e.hasOwnProperty(i)&&(s+=e[i]);return s}createVertexDefines(e,t){const s=new Map(e.defines);return e.mesh&&s.set("USE_MESH",""),e.meshUv&&s.set("USE_MESH_UV",""),e.localSpace&&s.set("LOCAL_SPACE",""),e.screenSpace&&s.set("SCREEN_SPACE",""),e.animTex&&s.set("ANIMTEX",""),e.soft>0&&s.set("SOFT",""),e.stretch>0&&s.set("STRETCH",""),e.customFace&&s.set("CUSTOM_FACE",""),e.pack8&&s.set("PACK8",""),e.localSpace&&s.set("LOCAL_SPACE",""),e.animTexLoop&&s.set("ANIMTEX_LOOP",""),e.wrap&&s.set("WRAP",""),e.alignToMotion&&s.set("ALIGN_TO_MOTION",""),s.set("NORMAL",dP[e.normal]),t.particle_vertexData=He,e.mesh&&e.meshUv&&(t.particle_uv=Zi),e.useCpu&&(t.particle_vertexData2=tg,t.particle_vertexData3=mE,t.particle_vertexData4=pE,t.particle_vertexData5=_E),s}createFragmentDefines(e){const t=new Map(e.defines);return e.soft>0&&t.set("SOFT",""),e.halflambert&&t.set("HALF_LAMBERT",""),t.set("NORMAL",dP[e.normal]),t.set("BLEND",S2[e.blend]),t}createShaderDefinition(e,t){const s=e.isWebGPU?Je:ot,i=Ue.get(e,s),r={},a=this.createVertexDefines(t,r),o=this.createFragmentDefines(t),h=`PARTICLE_${t.useCpu?"CPU":"GPU"}
`;a.set(h,""),o.set(h,"");const u=new Map(i);return Os.createDefinition(e,{name:"ParticleShader",shaderLanguage:s,attributes:r,vertexCode:i.get("particle_shaderVS"),fragmentCode:i.get("particle_shaderPS"),fragmentDefines:o,fragmentIncludes:u,vertexIncludes:u,vertexDefines:a})}}const U4=new B4;class z4 extends Dl{getShaderVariant(e){const{device:t,scene:s,cameraShaderParams:i,objDefs:r}=e,{emitter:a}=this,o={defines:ns.getCoreDefines(this,e),pass:Zh,useCpu:this.emitter.useCpu,normal:a.lighting?a.normalMap!==null?2:1:0,halflambert:this.emitter.halfLambert,stretch:this.emitter.stretch,alignToMotion:this.emitter.alignToMotion,soft:this.emitter.depthSoftening,mesh:this.emitter.useMesh,meshUv:r&qE,gamma:i?.shaderOutputGamma??Xf,toneMap:i?.toneMapping??GE,fog:s&&!this.emitter.noFog?s.fog.type:"none",wrap:this.emitter.wrap&&this.emitter.wrapBounds,localSpace:this.emitter.localSpace,screenSpace:a.inTools?!1:this.emitter.screenSpace,blend:this.emitter.blendType,animTex:this.emitter._isAnimated(),animTexLoop:this.emitter.animLoop,pack8:this.emitter.pack8,customFace:this.emitter.orientation!==lg},h=new Mv(e.viewUniformFormat,e.viewBindGroupFormat,e.vertexFormat),u=Ih(t);return u.register("particle",U4),u.getProgram("particle",o,h,this.userId)}constructor(e){super(),this.emitter=null,this.emitter=e}}const fP=[[-1,-1],[1,-1],[1,1],[-1,1]];function Fi(c,e,t,s,i=fs,r,a){let o=ze;a&&(i===Ze||i===Us)&&(o=$t);const h=new De(c,{width:e,height:t,format:i,cubemap:!1,mipmaps:!1,minFilter:o,magFilter:o,addressU:Te,addressV:Te,name:"ParticleSystemTexture"}),u=h.lock();if(i===Ze||i===Us){const f=new Uint8Array(s.length);for(let m=0;m<s.length;m++)f[m]=s[m]*r*255;s=f}return u.set(s),h.unlock(),h}function mP(c){return Math.max(Math.min(c,1),0)}const pP=new fr([0,0,1,0]),_P=new fr([0,1,1,1]),gP=new ol([0,0,1,0],[0,0,1,0],[0,0,1,0]),k4=new ol([0,1,1,1],[0,1,1,1],[0,1,1,1]);let Sa=2;const qp=4,ya=new Float32Array(3),Ho=new fe,vP=new D,Yp=new D,jp=new D;let eT,C_;function Ae(c,e){C_[c]!==void 0&&C_[c]!==null?eT[c]=C_[c]:eT[c]=e}function iL(c,e,t){return(c*255<<16|e*255<<8|t*255)/(1<<24)}function SP(c,e){const t=c.length/3,s=new Array(t*4);for(let i=0;i<t;i++)s[i*4]=c[i*3],s[i*4+1]=c[i*3+1],s[i*4+2]=c[i*3+2],s[i*4+3]=iL(e[i*3],e[i*3+1],e[i*3+2]);return s}function V4(c,e){const t=new Array(e.length*4);for(let s=0;s<e.length;s++)t[s*4]=c[s*3],t[s*4+1]=c[s*3+1],t[s*4+2]=c[s*3+2],t[s*4+3]=e[s];return t}function G4(c,e,t,s,i){const r=new Array(c.length*4);for(let a=0;a<c.length;a++)r[a*4]=c[a],r[a*4+1]=e[a],r[a*4+2]=0,r[a*4+3]=iL(t[a],s[a],i[a]);return r}function H4(c,e){const t=new Array(c.length*4);for(let s=0;s<c.length;s++)t[s*4]=c[s],t[s*4+1]=e[s],t[s*4+2]=0,t[s*4+3]=0;return t}function W4(c){const e=Math.max(c.rate,c.rate2)*c.numParticles+c.lifetime;return Date.now()+e*1e3}function X4(c,e){const t=new Float32Array(c.length);for(let s=0;s<c.length;s++)t[s]=c[s]-e[s];return t}function rl(c,e){const t=e.length,s=c.length/t;for(let i=0;i<s;i++)for(let r=0;r<t;r++){const a=Math.abs(c[i*t+r]);e[r]=Math.max(e[r],a)}}function q4(c,e){const t=e.length,s=c.length/t;for(let i=0;i<s;i++)for(let r=0;r<t;r++)c[i*t+r]/=e[r]===0?1:e[r],c[i*t+r]*=.5,c[i*t+r]+=.5}function Wo(c,e,t){const s=X4(e,c);return rl(s,t),q4(s,t),s}const Y4=new ks;class j4{get defaultParamTexture(){return Y4.get(this.graphicsDevice,()=>{const s=new Float32Array(1024);for(let r=0;r<16;r++)for(let a=0;a<16;a++){const o=a+1-8.5,h=r+1-8.5,u=mP(1-mP(Math.sqrt(o*o+h*h)/16)-.5),f=r*16+a;s[f*4]=1,s[f*4+1]=1,s[f*4+2]=1,s[f*4+3]=u}const i=Fi(this.graphicsDevice,16,16,s,Us,1,!0);return i.minFilter=$t,i.magFilter=$t,i})}onChangeCamera(){this.resetMaterial()}calculateBoundsMad(){this.worldBoundsMul.x=1/this.worldBoundsSize.x,this.worldBoundsMul.y=1/this.worldBoundsSize.y,this.worldBoundsMul.z=1/this.worldBoundsSize.z,this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1),this.worldBoundsAdd.x+=.5,this.worldBoundsAdd.y+=.5,this.worldBoundsAdd.z+=.5}calculateWorldBounds(){if(!this.node)return;if(this.prevWorldBoundsSize.copy(this.worldBoundsSize),this.prevWorldBoundsCenter.copy(this.worldBounds.center),!this.useCpu){let s=!1;this.emitterShape===Lr?s=!this.emitterExtents.equals(this.prevEmitterExtents):s=this.emitterRadius!==this.prevEmitterRadius,s&&this.calculateLocalBounds()}const e=this.node.getWorldTransform();this.localSpace?this.worldBoundsNoTrail.copy(this.localBounds):this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,e),this.worldBoundsTrail[0].add(this.worldBoundsNoTrail),this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);const t=this.simTimeTotal;t>=this.timeToSwitchBounds&&(this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]),this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),this.timeToSwitchBounds=t+this.lifetime),this.worldBounds.copy(this.worldBoundsTrail[0]),this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),this.localSpace?(this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,e),this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds,e)):(this.meshInstance.aabb.copy(this.worldBounds),this.meshInstance.mesh.aabb.copy(this.worldBounds)),this.meshInstance._aabbVer=1-this.meshInstance._aabbVer,this.pack8&&this.calculateBoundsMad()}resetWorldBounds(){this.node&&(this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds,this.localSpace?fe.IDENTITY:this.node.getWorldTransform()),this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail),this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),this.worldBounds.copy(this.worldBoundsTrail[0]),this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),this.prevWorldBoundsSize.copy(this.worldBoundsSize),this.prevWorldBoundsCenter.copy(this.worldBounds.center),this.simTimeTotal=0,this.timeToSwitchBounds=0)}calculateLocalBounds(){let e=Number.MAX_VALUE,t=Number.MAX_VALUE,s=Number.MAX_VALUE,i=-Number.MAX_VALUE,r=-Number.MAX_VALUE,a=-Number.MAX_VALUE,o=0,h=0;const u=this.lifetime/this.precision,f=[this.qVelocity,this.qVelocity2],m=[this.qLocalVelocity,this.qLocalVelocity2],_=[0,0],g=[0,0],S=[0,0],x=[0,0],T=[0,0];let E,b,C;for(let P=0;P<this.precision+1;P++){const I=Math.min(P,this.precision-1);for(let M=0;M<2;M++)E=m[M][I*3+0]*u+_[M],b=m[M][I*3+1]*u+g[M],C=m[M][I*3+2]*u+S[M],e=Math.min(E,e),t=Math.min(b,t),s=Math.min(C,s),i=Math.max(E,i),r=Math.max(b,r),a=Math.max(C,a),_[M]=E,g[M]=b,S[M]=C;for(let M=0;M<2;M++)T[M]+=u*Math.sqrt(f[M][I*3+0]*f[M][I*3+0]+f[M][I*3+1]*f[M][I*3+1]+f[M][I*3+2]*f[M][I*3+2]);x[0]+=this.qRadialSpeed[I]*u,x[1]+=this.qRadialSpeed2[I]*u,o=Math.max(o,Math.max(Math.abs(x[0]),Math.abs(x[1]))),h=Math.max(h,this.qScale[I])}this.emitterShape===Lr?(E=this.emitterExtents.x*.5,b=this.emitterExtents.y*.5,C=this.emitterExtents.z*.5):(E=this.emitterRadius,b=this.emitterRadius,C=this.emitterRadius);const w=Math.max(T[0],T[1]);Yp.x=e-h-E-o-w,Yp.y=t-h-b-o-w,Yp.z=s-h-C-o-w,jp.x=i+h+E+o+w,jp.y=r+h+b+o+w,jp.z=a+h+C+o+w,this.localBounds.setMinMax(Yp,jp)}rebuild(){const e=this.graphicsDevice;this.colorMap===null&&(this.colorMap=this.defaultParamTexture),this.spawnBounds=this.emitterShape===Lr?this.emitterExtents:this.emitterRadius,this.useCpu=this.useCpu||this.sort>$x||e.maxVertexTextures<=1||e.fragmentUniformsCount<64||e.forceCpuParticles;const t=this._destroyResources();this.pack8=(this.pack8||!e.textureFloatRenderable)&&!this.useCpu,Sa=this.useCpu||this.pack8?4:2,this.useMesh=!!this.mesh,this.numParticlesPot=J.nextPowerOfTwo(this.numParticles),this.rebuildGraphs(),this.calculateLocalBounds(),this.resetWorldBounds(),this.node&&(this.worldBounds.setFromTransformedAabb(this.localBounds,this.localSpace?fe.IDENTITY:this.node.getWorldTransform()),this.worldBoundsTrail[0].copy(this.worldBounds),this.worldBoundsTrail[1].copy(this.worldBounds),this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2),this.prevWorldBoundsSize.copy(this.worldBoundsSize),this.prevWorldBoundsCenter.copy(this.worldBounds.center),this.pack8&&this.calculateBoundsMad()),this.vbToSort=new Array(this.numParticles);for(let f=0;f<this.numParticles;f++)this.vbToSort[f]=[0,0];this.particleDistance=new Float32Array(this.numParticles),this._gpuUpdater.randomize(),this.particleTex=new Float32Array(this.numParticlesPot*Sa*qp);const s=this.node===null||this.localSpace?D.ZERO:this.node.getPosition();this.emitterShape===Lr&&(this.node===null||this.localSpace?Ho.setTRS(D.ZERO,pe.IDENTITY,this.spawnBounds):Ho.setTRS(D.ZERO,this.node.getRotation(),vP.copy(this.spawnBounds).mul(this.node.localScale)),ya[0]=this.emitterExtents.x!==0?this.emitterExtentsInner.x/this.emitterExtents.x:0,ya[1]=this.emitterExtents.y!==0?this.emitterExtentsInner.y/this.emitterExtents.y:0,ya[2]=this.emitterExtents.z!==0?this.emitterExtentsInner.z/this.emitterExtents.z:0);for(let f=0;f<this.numParticles;f++)this._cpuUpdater.calcSpawnPosition(this.particleTex,Ho,ya,s,f),this.useCpu&&(this.particleTex[f*qp+3+this.numParticlesPot*2*qp]=1);this.particleTexStart=new Float32Array(this.numParticlesPot*Sa*qp);for(let f=0;f<this.particleTexStart.length;f++)this.particleTexStart[f]=this.particleTex[f];this.useCpu||(this.pack8?(this.particleTexIN=Fi(e,this.numParticlesPot,Sa,this.particleTex,Ze,1,!1),this.particleTexOUT=Fi(e,this.numParticlesPot,Sa,this.particleTex,Ze,1,!1),this.particleTexStart=Fi(e,this.numParticlesPot,Sa,this.particleTexStart,Ze,1,!1)):(this.particleTexIN=Fi(e,this.numParticlesPot,Sa,this.particleTex),this.particleTexOUT=Fi(e,this.numParticlesPot,Sa,this.particleTex),this.particleTexStart=Fi(e,this.numParticlesPot,Sa,this.particleTexStart)),this.rtParticleTexIN=new At({colorBuffer:this.particleTexIN,depth:!1}),this.rtParticleTexOUT=new At({colorBuffer:this.particleTexOUT,depth:!1}),this.swapTex=!1);const i=new Map;this.localSpace&&i.set("LOCAL_SPACE",""),this.pack8&&i.set("PACK8",""),this.emitterShape===Lr&&i.set("EMITTERSHAPE_BOX","");const r=`Shape:${this.emitterShape}-Pack:${this.pack8}-Local:${this.localSpace}`,a=Ue.get(e,e.isWebGPU?Je:ot),o=new Map(a),h={attributes:{vertex_position:He},vertexChunk:"fullscreenQuadVS",fragmentChunk:"particle_simulationPS",fragmentDefines:i,fragmentIncludes:o};h.uniqueName=`ParticleUpdateRespawn-${r}`,i.set("RESPAWN",""),this.shaderParticleUpdateRespawn=ns.createShader(e,h),i.delete("RESPAWN"),h.uniqueName=`ParticleUpdateNoRespawn-${r}`,i.set("NO_RESPAWN",""),this.shaderParticleUpdateNoRespawn=ns.createShader(e,h),i.delete("NO_RESPAWN"),h.uniqueName=`ParticleUpdateStop-${r}`,i.set("ON_STOP",""),this.shaderParticleUpdateOnStop=ns.createShader(e,h),this.numParticleVerts=this.useMesh?this.mesh.vertexBuffer.numVertices:4,this.numParticleIndices=this.useMesh?this.mesh.indexBuffer[0].numIndices:6,this._allocate(this.numParticles);const u=new Ct(e);u.vertexBuffer=this.vertexBuffer,u.indexBuffer[0]=this.indexBuffer,u.primitive[0].type=ka,u.primitive[0].base=0,u.primitive[0].count=this.numParticles*this.numParticleIndices,u.primitive[0].indexed=!0,this.material=this._createMaterial(),this.resetMaterial(),this.meshInstance=new lt(u,this.material,this.node),this.meshInstance.pick=!1,this.meshInstance.updateKey(),this.meshInstance.cull=!0,this.localSpace?this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds,this.node.getWorldTransform()):this.meshInstance.aabb.copy(this.worldBounds),this.meshInstance._updateAabb=!1,this.meshInstance.visible=t,this._setMaterialTextures(),this.resetTime(),this.addTime(0,!1),this.preWarm&&this.prewarm(this.lifetime)}_isAnimated(){return this.animNumFrames>=1&&(this.animTilesX>1||this.animTilesY>1)&&(this.colorMap&&this.colorMap!==this.defaultParamTexture||this.normalMap)}rebuildGraphs(){const e=this.precision,t=this.graphicsDevice;this.qLocalVelocity=this.localVelocityGraph.quantize(e),this.qVelocity=this.velocityGraph.quantize(e),this.qColor=this.colorGraph.quantizeClamped(e,0,1),this.qRotSpeed=this.rotationSpeedGraph.quantize(e),this.qScale=this.scaleGraph.quantize(e),this.qAlpha=this.alphaGraph.quantize(e),this.qRadialSpeed=this.radialSpeedGraph.quantize(e),this.qLocalVelocity2=this.localVelocityGraph2.quantize(e),this.qVelocity2=this.velocityGraph2.quantize(e),this.qColor2=this.colorGraph2.quantizeClamped(e,0,1),this.qRotSpeed2=this.rotationSpeedGraph2.quantize(e),this.qScale2=this.scaleGraph2.quantize(e),this.qAlpha2=this.alphaGraph2.quantize(e),this.qRadialSpeed2=this.radialSpeedGraph2.quantize(e);for(let s=0;s<e;s++)this.qRotSpeed[s]*=J.DEG_TO_RAD,this.qRotSpeed2[s]*=J.DEG_TO_RAD;if(this.localVelocityUMax=new Float32Array(3),this.velocityUMax=new Float32Array(3),this.colorUMax=new Float32Array(3),this.rotSpeedUMax=[0],this.scaleUMax=[0],this.alphaUMax=[0],this.radialSpeedUMax=[0],this.qLocalVelocityDiv=Wo(this.qLocalVelocity,this.qLocalVelocity2,this.localVelocityUMax),this.qVelocityDiv=Wo(this.qVelocity,this.qVelocity2,this.velocityUMax),this.qColorDiv=Wo(this.qColor,this.qColor2,this.colorUMax),this.qRotSpeedDiv=Wo(this.qRotSpeed,this.qRotSpeed2,this.rotSpeedUMax),this.qScaleDiv=Wo(this.qScale,this.qScale2,this.scaleUMax),this.qAlphaDiv=Wo(this.qAlpha,this.qAlpha2,this.alphaUMax),this.qRadialSpeedDiv=Wo(this.qRadialSpeed,this.qRadialSpeed2,this.radialSpeedUMax),this.pack8){const s=[0,0,0];rl(this.qVelocity,s);const i=[0,0,0];rl(this.qVelocity2,i);const r=[0,0,0];rl(this.qLocalVelocity,r);const a=[0,0,0];rl(this.qLocalVelocity2,a);const o=[0];rl(this.qRadialSpeed,o);const h=[0];rl(this.qRadialSpeed2,h);let u=Math.max(s[0],i[0]);u=Math.max(u,s[1]),u=Math.max(u,i[1]),u=Math.max(u,s[2]),u=Math.max(u,i[2]);let f=Math.max(r[0],a[0]);f=Math.max(f,r[1]),f=Math.max(f,a[1]),f=Math.max(f,r[2]),f=Math.max(f,a[2]);const m=Math.max(o[0],h[0]);this.maxVel=u+f+m}this.useCpu||(this.internalTex0=Fi(t,e,1,SP(this.qLocalVelocity,this.qLocalVelocityDiv)),this.internalTex1=Fi(t,e,1,SP(this.qVelocity,this.qVelocityDiv)),this.internalTex2=Fi(t,e,1,G4(this.qRotSpeed,this.qScale,this.qScaleDiv,this.qRotSpeedDiv,this.qAlphaDiv)),this.internalTex3=Fi(t,e,1,H4(this.qRadialSpeed,this.qRadialSpeedDiv))),this.colorParam=Fi(t,e,1,V4(this.qColor,this.qAlpha),Us,1,!0)}_setMaterialTextures(){this.colorMap&&(this.material.setParameter("colorMap",this.colorMap),this.lighting&&this.normalMap&&this.material.setParameter("normalMap",this.normalMap))}_createMaterial(){const e=new z4(this);return e.name=`EmitterMaterial:${this.node.name}`,e.cull=Ft,e.alphaWrite=!1,e.blendType=this.blendType,e.depthWrite=this.depthWrite,e}resetMaterial(){const e=this.material;e.setParameter("stretch",this.stretch),this._isAnimated()&&(e.setParameter("animTexTilesParams",this.animTilesParams),e.setParameter("animTexParams",this.animParams),e.setParameter("animTexIndexParams",this.animIndexParams)),e.setParameter("colorMult",this.intensity),this.useCpu||(e.setParameter("internalTex0",this.internalTex0),e.setParameter("internalTex1",this.internalTex1),e.setParameter("internalTex2",this.internalTex2),e.setParameter("internalTex3",this.internalTex3)),e.setParameter("colorParam",this.colorParam),e.setParameter("numParticles",this.numParticles),e.setParameter("numParticlesPot",this.numParticlesPot),e.setParameter("lifetime",this.lifetime),e.setParameter("rate",this.rate),e.setParameter("rateDiv",this.rate2-this.rate),e.setParameter("seed",this.seed),e.setParameter("scaleDivMult",this.scaleUMax[0]),e.setParameter("alphaDivMult",this.alphaUMax[0]),e.setParameter("radialSpeedDivMult",this.radialSpeedUMax[0]),e.setParameter("graphNumSamples",this.precision),e.setParameter("graphSampleSize",1/this.precision),e.setParameter("emitterScale",new Float32Array([1,1,1])),this.pack8&&(this._gpuUpdater._setInputBounds(),e.setParameter("inBoundsSize",this._gpuUpdater.inBoundsSizeUniform),e.setParameter("inBoundsCenter",this._gpuUpdater.inBoundsCenterUniform),e.setParameter("maxVel",this.maxVel)),this.wrap&&this.wrapBounds&&(this.wrapBoundsUniform[0]=this.wrapBounds.x,this.wrapBoundsUniform[1]=this.wrapBounds.y,this.wrapBoundsUniform[2]=this.wrapBounds.z,e.setParameter("wrapBounds",this.wrapBoundsUniform)),this._setMaterialTextures(),this.depthSoftening>0&&e.setParameter("softening",1/(this.depthSoftening*this.depthSoftening*100)),this.stretch>0&&(e.cull=Ft),this._compParticleFaceParams()}_compParticleFaceParams(){let e,t;if(this.orientation===lg)e=new Float32Array([1,0,0]),t=new Float32Array([0,0,1]);else{let s;this.orientation===qk?s=this.particleNormal.normalize():s=(this.node===null?fe.IDENTITY:this.node.getWorldTransform()).transformVector(this.particleNormal).normalize();const i=new D(1,0,0);Math.abs(i.dot(s))===1&&i.set(0,0,1);const r=new D().cross(s,i).normalize();i.cross(r,s).normalize(),e=new Float32Array([i.x,i.y,i.z]),t=new Float32Array([r.x,r.y,r.z])}this.material.setParameter("faceTangent",e),this.material.setParameter("faceBinorm",t)}getVertexInfo(){const e=[];return this.useCpu?e.push({semantic:Hx,components:4,type:ct},{semantic:tg,components:4,type:ct},{semantic:mE,components:4,type:ct},{semantic:pE,components:1,type:ct},{semantic:_E,components:this.useMesh?4:2,type:ct}):(e.push({semantic:Hx,components:4,type:ct}),this.useMesh&&e.push({semantic:tg,components:2,type:ct})),e}_allocate(e){const t=e*this.numParticleVerts,s=e*this.numParticleIndices;if(this.vertexBuffer===void 0||this.vertexBuffer.getNumVertices()!==t){const i=this.getVertexInfo(),r=new Ti(this.graphicsDevice,i);this.vertexBuffer=new Yr(this.graphicsDevice,r,t,{usage:H_}),this.indexBuffer=new bl(this.graphicsDevice,eo,s);const a=new Float32Array(this.vertexBuffer.lock());let o,h,u;if(this.useMesh){o=new Float32Array(this.mesh.vertexBuffer.lock()),h=o.length/this.mesh.vertexBuffer.numVertices;for(let _=0;_<this.mesh.vertexBuffer.format.elements.length;_++)if(this.mesh.vertexBuffer.format.elements[_].name===Zi){u=this.mesh.vertexBuffer.format.elements[_].offset/4;break}}for(let _=0;_<t;_++){const g=Math.floor(_/this.numParticleVerts);if(this.useMesh){const S=_%this.numParticleVerts;a[_*6]=o[S*h],a[_*6+1]=o[S*h+1],a[_*6+2]=o[S*h+2],a[_*6+3]=g,a[_*6+4]=o[S*h+u+0],a[_*6+5]=1-o[S*h+u+1]}else{const S=_%4;a[_*4]=fP[S][0],a[_*4+1]=fP[S][1],a[_*4+2]=0,a[_*4+3]=g}}this.useCpu&&(this.vbCPU=new Float32Array(a),this.vbOld=new Float32Array(this.vbCPU.length)),this.vertexBuffer.unlock(),this.useMesh&&this.mesh.vertexBuffer.unlock();let f=0;const m=new Uint32Array(this.indexBuffer.lock());if(this.useMesh){const _=this.mesh.indexBuffer[0];o=new AE[_.format](_.lock())}for(let _=0;_<e;_++)if(this.useMesh)for(let g=0;g<this.numParticleIndices;g++)m[_*this.numParticleIndices+g]=o[g]+_*this.numParticleVerts;else{const g=_*4;m[f++]=g,m[f++]=g+1,m[f++]=g+2,m[f++]=g,m[f++]=g+2,m[f++]=g+3}this.indexBuffer.unlock(),this.useMesh&&this.mesh.indexBuffer[0].unlock()}}reset(){if(this.beenReset=!0,this.seed=Math.random(),this.material.setParameter("seed",this.seed),this.useCpu)for(let t=0;t<this.particleTexStart.length;t++)this.particleTex[t]=this.particleTexStart[t];else this._setMaterialTextures();this.resetWorldBounds(),this.resetTime();const e=this.loop;this.loop=!0,this.addTime(0,!1),this.loop=e,this.preWarm&&this.prewarm(this.lifetime)}prewarm(e){const t=e/this.lifetime,s=Math.min(Math.floor(t*this.precision),this.precision),i=e/s;for(let r=0;r<s;r++)this.addTime(i,!1)}resetTime(){this.endTime=W4(this)}finishFrame(){this.useCpu&&this.vertexBuffer.unlock()}addTime(e,t){const s=this.graphicsDevice;if(this.simTimeTotal+=e,this.calculateWorldBounds(),this._isAnimated()){const a=this.animTilesParams;a[0]=1/this.animTilesX,a[1]=1/this.animTilesY;const o=this.animParams;o[0]=this.animStartFrame,o[1]=this.animNumFrames*this.animSpeed,o[2]=this.animNumFrames-1,o[3]=this.animNumAnimations-1;const h=this.animIndexParams;h[0]=this.animIndex,h[1]=this.randomizeAnimIndex}this.scene&&this.camera!==this.scene._activeCamera&&(this.camera=this.scene._activeCamera,this.onChangeCamera()),this.emitterShape===Lr&&(ya[0]=this.emitterExtents.x!==0?this.emitterExtentsInner.x/this.emitterExtents.x:0,ya[1]=this.emitterExtents.y!==0?this.emitterExtentsInner.y/this.emitterExtents.y:0,ya[2]=this.emitterExtents.z!==0?this.emitterExtentsInner.z/this.emitterExtents.z:0,this.meshInstance.node===null?Ho.setTRS(D.ZERO,pe.IDENTITY,this.emitterExtents):Ho.setTRS(D.ZERO,this.meshInstance.node.getRotation(),vP.copy(this.emitterExtents).mul(this.meshInstance.node.localScale)));let i;const r=this.meshInstance.node===null?D.ONE:this.meshInstance.node.localScale;if(this.emitterScaleUniform[0]=r.x,this.emitterScaleUniform[1]=r.y,this.emitterScaleUniform[2]=r.z,this.material.setParameter("emitterScale",this.emitterScaleUniform),this.localSpace&&this.meshInstance.node&&(i=this.meshInstance.node.getPosition(),this.emitterPosUniform[0]=i.x,this.emitterPosUniform[1]=i.y,this.emitterPosUniform[2]=i.z,this.material.setParameter("emitterPos",this.emitterPosUniform)),this._compParticleFaceParams(),!this.useCpu)this._gpuUpdater.update(s,Ho,ya,e,t);else{const a=new Float32Array(this.vertexBuffer.lock());this._cpuUpdater.update(a,this.vbToSort,this.particleTex,Ho,ya,i,e,t)}this.loop||Date.now()>this.endTime&&(this.onFinished&&this.onFinished(),this.meshInstance.visible=!1),this.meshInstance&&(this.meshInstance.drawOrder=this.drawOrder)}_destroyResources(){this.particleTexIN?.destroy(),this.particleTexIN=null,this.particleTexOUT?.destroy(),this.particleTexOUT=null,this.particleTexStart&&this.particleTexStart.destroy&&(this.particleTexStart.destroy(),this.particleTexStart=null),this.rtParticleTexIN?.destroy(),this.rtParticleTexIN=null,this.rtParticleTexOUT?.destroy(),this.rtParticleTexOUT=null,this.internalTex0?.destroy(),this.internalTex0=null,this.internalTex1?.destroy(),this.internalTex1=null,this.internalTex2?.destroy(),this.internalTex2=null,this.internalTex3?.destroy(),this.internalTex3=null,this.colorParam?.destroy(),this.colorParam=null,this.vertexBuffer=void 0,this.indexBuffer=void 0;const e=this.meshInstance?.visible??!0;return this.meshInstance?.destroy(),this.meshInstance=null,this.material?.destroy(),this.material=null,e}destroy(){this.camera=null,this._destroyResources()}constructor(e,t){this.material=null,this.internalTex0=null,this.internalTex1=null,this.internalTex2=null,this.colorParam=null,this.graphicsDevice=e;const s=e,i=32;this.precision=i,this._addTimeTime=0,eT=this,C_=t,Ae("numParticles",1),this.numParticles>e.maxTextureSize&&(this.numParticles=e.maxTextureSize),Ae("rate",1),Ae("rate2",this.rate),Ae("lifetime",50),Ae("emitterExtents",new D(0,0,0)),Ae("emitterExtentsInner",new D(0,0,0)),Ae("emitterRadius",0),Ae("emitterRadiusInner",0),Ae("emitterShape",Lr),Ae("initialVelocity",1),Ae("wrap",!1),Ae("localSpace",!1),Ae("screenSpace",!1),Ae("wrapBounds",null),Ae("colorMap",this.defaultParamTexture),Ae("normalMap",null),Ae("loop",!0),Ae("preWarm",!1),Ae("sort",$x),Ae("mode",D2),Ae("scene",null),Ae("lighting",!1),Ae("halfLambert",!1),Ae("intensity",1),Ae("stretch",0),Ae("alignToMotion",!1),Ae("depthSoftening",0),Ae("mesh",null),Ae("particleNormal",new D(0,1,0)),Ae("orientation",lg),Ae("depthWrite",!1),Ae("noFog",!1),Ae("blendType",jr),Ae("node",null),Ae("startAngle",0),Ae("startAngle2",this.startAngle),Ae("animTilesX",1),Ae("animTilesY",1),Ae("animStartFrame",0),Ae("animNumFrames",1),Ae("animNumAnimations",1),Ae("animIndex",0),Ae("randomizeAnimIndex",!1),Ae("animSpeed",1),Ae("animLoop",!0),this._gpuUpdater=new F4(this,s),this._cpuUpdater=new N4(this),this.emitterPosUniform=new Float32Array(3),this.wrapBoundsUniform=new Float32Array(3),this.emitterScaleUniform=new Float32Array([1,1,1]),Ae("colorGraph",k4),Ae("colorGraph2",this.colorGraph),Ae("scaleGraph",_P),Ae("scaleGraph2",this.scaleGraph),Ae("alphaGraph",_P),Ae("alphaGraph2",this.alphaGraph),Ae("localVelocityGraph",gP),Ae("localVelocityGraph2",this.localVelocityGraph),Ae("velocityGraph",gP),Ae("velocityGraph2",this.velocityGraph),Ae("rotationSpeedGraph",pP),Ae("rotationSpeedGraph2",this.rotationSpeedGraph),Ae("radialSpeedGraph",pP),Ae("radialSpeedGraph2",this.radialSpeedGraph),this.animTilesParams=new Float32Array(2),this.animParams=new Float32Array(4),this.animIndexParams=new Float32Array(2),this.vbToSort=null,this.vbOld=null,this.particleDistance=null,this.camera=null,this.swapTex=!1,this.useMesh=!0,this.useCpu=!e.supportsGpuParticles,this.pack8=!0,this.localBounds=new Ge,this.worldBoundsNoTrail=new Ge,this.worldBoundsTrail=[new Ge,new Ge],this.worldBounds=new Ge,this.worldBoundsSize=new D,this.prevWorldBoundsSize=new D,this.prevWorldBoundsCenter=new D,this.prevEmitterExtents=this.emitterExtents,this.prevEmitterRadius=this.emitterRadius,this.worldBoundsMul=new D,this.worldBoundsAdd=new D,this.timeToSwitchBounds=0,this.shaderParticleUpdateRespawn=null,this.shaderParticleUpdateNoRespawn=null,this.shaderParticleUpdateOnStop=null,this.numParticleVerts=0,this.numParticleIndices=0,this.material=null,this.meshInstance=null,this.drawOrder=0,this.seed=Math.random(),this.fixedTimeStep=1/60,this.maxSubSteps=10,this.simTime=0,this.simTimeTotal=0,this.beenReset=!1,this._layer=null,this.rebuild()}}class $4 extends wl{generateKey(e){const t=e.shaderDesc,s=t.vertexGLSL?Fr(t.vertexGLSL):0,i=t.fragmentGLSL?Fr(t.fragmentGLSL):0,r=t.vertexWGSL?Fr(t.vertexWGSL):0,a=t.fragmentWGSL?Fr(t.fragmentWGSL):0,o=wl.definesHash(e.defines),h=e.shaderChunks?.key??"";let u=`${t.uniqueName}_${o}_${s}_${i}_${r}_${a}_${h}`;return e.skin&&(u+="_skin"),e.useInstancing&&(u+="_inst"),e.useMorphPosition&&(u+="_morphp"),e.useMorphNormal&&(u+="_morphn"),e.useMorphTextureBasedInt&&(u+="_morphi"),u}createAttributesDefinition(e,t){const s=t.shaderDesc.attributes,i=s?{...s}:void 0;t.skin&&(i.vertex_boneWeights=kr,i.vertex_boneIndices=yi),(t.useMorphPosition||t.useMorphNormal)&&(i.morph_vertex_id=Eh),e.attributes=i}createVertexDefinition(e,t,s,i){const r=t.shaderDesc,a=new Map(s);a.set("transformInstancingVS","");const o=new Map(t.defines);t.skin&&o.set("SKIN",!0),t.useInstancing&&o.set("INSTANCING",!0),(t.useMorphPosition||t.useMorphNormal)&&(o.set("MORPHING",!0),t.useMorphTextureBasedInt&&o.set("MORPHING_INT",!0),t.useMorphPosition&&o.set("MORPHING_POSITION",!0),t.useMorphNormal&&o.set("MORPHING_NORMAL",!0)),e.vertexCode=i?r.vertexWGSL:r.vertexGLSL,e.vertexIncludes=a,e.vertexDefines=o}createFragmentDefinition(e,t,s,i){const r=t.shaderDesc,a=new Map(s),o=new Map(t.defines);e.fragmentCode=i?r.fragmentWGSL:r.fragmentGLSL,e.fragmentIncludes=a,e.fragmentDefines=o}createShaderDefinition(e,t){const s=t.shaderDesc,i=e.isWebGPU&&!!s.vertexWGSL&&!!s.fragmentWGSL&&(t.shaderChunks?.useWGSL??!0),r={name:`ShaderMaterial-${s.uniqueName}`,shaderLanguage:i?Je:ot,fragmentOutputTypes:s.fragmentOutputTypes,meshUniformBufferFormat:s.meshUniformBufferFormat,meshBindGroupFormat:s.meshBindGroupFormat},a=i?Je:ot,o=mg.merge(Ue.get(e,a),t.shaderChunks[a]);return this.createAttributesDefinition(r,t),this.createVertexDefinition(r,t,o,i),this.createFragmentDefinition(r,t,o,i),Os.createDefinition(e,r)}}const K4=new $4;class Za extends Dl{set shaderDesc(e){if(this._shaderDesc=void 0,e&&(this._shaderDesc={uniqueName:e.uniqueName,attributes:e.attributes,fragmentOutputTypes:e.fragmentOutputTypes,vertexGLSL:e.vertexGLSL,fragmentGLSL:e.fragmentGLSL,vertexWGSL:e.vertexWGSL,fragmentWGSL:e.fragmentWGSL},e.vertexCode||e.fragmentCode||e.shaderLanguage)){const t=e.shaderLanguage??ot;t===ot?(this._shaderDesc.vertexGLSL=e.vertexCode,this._shaderDesc.fragmentGLSL=e.fragmentCode):t===Je&&(this._shaderDesc.vertexWGSL=e.vertexCode,this._shaderDesc.fragmentWGSL=e.fragmentCode)}this.clearVariants()}get shaderDesc(){return this._shaderDesc}copy(e){return super.copy(e),this.shaderDesc=e.shaderDesc,this}getShaderVariant(e){const{objDefs:t}=e,s={defines:ns.getCoreDefines(this,e),skin:(t&nf)!==0,useInstancing:(t&of)!==0,useMorphPosition:(t&lf)!==0,useMorphNormal:(t&cf)!==0,useMorphTextureBasedInt:(t&hf)!==0,pass:e.pass,gamma:e.cameraShaderParams.shaderOutputGamma,toneMapping:e.cameraShaderParams.toneMapping,fog:e.cameraShaderParams.fog,shaderDesc:this.shaderDesc,shaderChunks:this.shaderChunks},i=new Mv(e.viewUniformFormat,e.viewBindGroupFormat,e.vertexFormat),r=Ih(e.device);return r.register("shader-material",K4),r.getProgram("shader-material",s,i,this.userId)}constructor(e){super(),this.shaderDesc=e}}class Z4{set colorizeLod(e){this._colorizeLod!==e&&(this._colorizeLod=e,this.dirty=!0)}get colorizeLod(){return this._colorizeLod}set lodBehindPenalty(e){this._lodBehindPenalty!==e&&(this._lodBehindPenalty=e,this.dirty=!0)}get lodBehindPenalty(){return this._lodBehindPenalty}set lodRangeMin(e){this._lodRangeMin!==e&&(this._lodRangeMin=e,this.dirty=!0)}get lodRangeMin(){return this._lodRangeMin}set lodRangeMax(e){this._lodRangeMax!==e&&(this._lodRangeMax=e,this.dirty=!0)}get lodRangeMax(){return this._lodRangeMax}set lodUnderfillLimit(e){this._lodUnderfillLimit!==e&&(this._lodUnderfillLimit=e,this.dirty=!0)}get lodUnderfillLimit(){return this._lodUnderfillLimit}set splatBudget(e){}get splatBudget(){return 0}set colorRamp(e){this._colorRamp!==e&&(this._colorRamp=e,this.dirty=!0)}get colorRamp(){return this._colorRamp}get material(){return this._material}frameEnd(){this._material.dirty=!1,this.dirty=!1}constructor(){this._material=new Za,this.debugAabbs=!1,this.radialSorting=!1,this.gpuSorting=!1,this.debugNodeAabbs=!1,this.dirty=!1,this._colorizeLod=!1,this.lodUpdateDistance=1,this.lodUpdateAngle=0,this._lodBehindPenalty=1,this._lodRangeMin=0,this._lodRangeMax=10,this._lodUnderfillLimit=0,this._colorRamp=null,this.colorRampIntensity=1,this.colorizeColorUpdate=!1,this.colorUpdateDistance=.2,this.colorUpdateAngle=2,this.colorUpdateDistanceLodScale=2,this.colorUpdateAngleLodScale=2,this.cooldownTicks=100}}const Q4={linear:"decodeLinear",srgb:"decodeGamma",rgbm:"decodeRGBM",rgbe:"decodeRGBE",rgbp:"decodeRGBP",xy:"unpackNormalXY",xyz:"unpackNormalXYZ"},J4={linear:"encodeLinear",srgb:"encodeGamma",rgbm:"encodeRGBM",rgbe:"encodeRGBE",rgbp:"encodeRGBP"};class Zn{static decodeFunc(e){return Q4[e]??"decodeGamma"}static encodeFunc(e){return J4[e]??"encodeGamma"}}const rL=(c,e)=>{const t=e.length/3,s=c.length/3,i=new D,r=new D,a=new D,o=new D,h=new D,u=new D,f=[];for(let m=0;m<c.length;m++)f[m]=0;for(let m=0;m<t;m++){const _=e[m*3],g=e[m*3+1],S=e[m*3+2];i.set(c[_*3],c[_*3+1],c[_*3+2]),r.set(c[g*3],c[g*3+1],c[g*3+2]),a.set(c[S*3],c[S*3+1],c[S*3+2]),o.sub2(r,i),h.sub2(a,i),u.cross(o,h).normalize(),f[_*3]+=u.x,f[_*3+1]+=u.y,f[_*3+2]+=u.z,f[g*3]+=u.x,f[g*3+1]+=u.y,f[g*3+2]+=u.z,f[S*3]+=u.x,f[S*3+1]+=u.y,f[S*3+2]+=u.z}for(let m=0;m<s;m++){const _=f[m*3],g=f[m*3+1],S=f[m*3+2],x=1/Math.sqrt(_*_+g*g+S*S);f[m*3]*=x,f[m*3+1]*=x,f[m*3+2]*=x}return f},mo=(c,e,t,s)=>{const i=s.length/3,r=c.length/3,a=new D,o=new D,h=new D,u=new ne,f=new ne,m=new ne,_=new D,g=new D,S=new Float32Array(r*3),x=new Float32Array(r*3),T=[];for(let P=0;P<i;P++){const I=s[P*3],M=s[P*3+1],R=s[P*3+2];a.set(c[I*3],c[I*3+1],c[I*3+2]),o.set(c[M*3],c[M*3+1],c[M*3+2]),h.set(c[R*3],c[R*3+1],c[R*3+2]),u.set(t[I*2],t[I*2+1]),f.set(t[M*2],t[M*2+1]),m.set(t[R*2],t[R*2+1]);const L=o.x-a.x,B=h.x-a.x,G=o.y-a.y,H=h.y-a.y,ee=o.z-a.z,j=h.z-a.z,ae=f.x-u.x,k=m.x-u.x,O=f.y-u.y,z=m.y-u.y,X=ae*z-k*O;if(X===0)_.set(0,1,0),g.set(1,0,0);else{const Y=1/X;_.set((z*L-O*B)*Y,(z*G-O*H)*Y,(z*ee-O*j)*Y),g.set((ae*B-k*L)*Y,(ae*H-k*G)*Y,(ae*j-k*ee)*Y)}S[I*3+0]+=_.x,S[I*3+1]+=_.y,S[I*3+2]+=_.z,S[M*3+0]+=_.x,S[M*3+1]+=_.y,S[M*3+2]+=_.z,S[R*3+0]+=_.x,S[R*3+1]+=_.y,S[R*3+2]+=_.z,x[I*3+0]+=g.x,x[I*3+1]+=g.y,x[I*3+2]+=g.z,x[M*3+0]+=g.x,x[M*3+1]+=g.y,x[M*3+2]+=g.z,x[R*3+0]+=g.x,x[R*3+1]+=g.y,x[R*3+2]+=g.z}const E=new D,b=new D,C=new D,w=new D;for(let P=0;P<r;P++){C.set(e[P*3],e[P*3+1],e[P*3+2]),E.set(S[P*3],S[P*3+1],S[P*3+2]),b.set(x[P*3],x[P*3+1],x[P*3+2]);const I=C.dot(E);w.copy(C).mulScalar(I),w.sub2(E,w).normalize(),T[P*4]=w.x,T[P*4+1]=w.y,T[P*4+2]=w.z,w.cross(C,E),T[P*4+3]=w.dot(b)<0?-1:1}return T};class Rl{calculateNormals(){this.normals=rL(this.positions,this.indices)}calculateTangents(){this.tangents=mo(this.positions,this.normals,this.uvs,this.indices)}}const tT=8/64,yP=1-tT*2;class sT extends Rl{constructor(e={}){super();const t=e.halfExtents??new D(.5,.5,.5),s=e.widthSegments??1,i=e.lengthSegments??1,r=e.heightSegments??1,a=e.yOffset??0,o=-t.y+a,h=t.y+a,u=[new D(-t.x,o,t.z),new D(t.x,o,t.z),new D(t.x,h,t.z),new D(-t.x,h,t.z),new D(t.x,o,-t.z),new D(-t.x,o,-t.z),new D(-t.x,h,-t.z),new D(t.x,h,-t.z)],f=[[0,1,3],[4,5,7],[3,2,6],[1,0,4],[1,4,2],[5,0,6]],m=[[0,0,1],[0,0,-1],[0,1,0],[0,-1,0],[1,0,0],[-1,0,0]],_={FRONT:0,BACK:1,TOP:2,BOTTOM:3,RIGHT:4,LEFT:5},g=[],S=[],x=[],T=[],E=[];let b=0;const C=(w,P,I)=>{const M=new D,R=new D,L=new D,B=new D;for(let G=0;G<=P;G++)for(let H=0;H<=I;H++){M.lerp(u[f[w][0]],u[f[w][1]],G/P),R.lerp(u[f[w][0]],u[f[w][2]],H/I),L.sub2(R,u[f[w][0]]),B.add2(M,L);let ee=G/P,j=H/I;g.push(B.x,B.y,B.z),S.push(m[w][0],m[w][1],m[w][2]),x.push(ee,1-j),ee=ee*yP+tT,j=j*yP+tT,ee/=3,j/=3,ee+=w%3/3,j+=Math.floor(w/3)/3,T.push(ee,1-j),G<P&&H<I&&(E.push(b+I+1,b+1,b),E.push(b+I+1,b+I+2,b+1)),b++}};C(_.FRONT,s,r),C(_.BACK,s,r),C(_.TOP,s,i),C(_.BOTTOM,s,i),C(_.RIGHT,i,r),C(_.LEFT,i,r),this.positions=g,this.normals=S,this.uvs=x,this.uvs1=T,this.indices=E,e.calculateTangents&&(this.tangents=mo(g,S,x,E))}}class aL extends Rl{constructor(e={}){super();const t=e.radius??.5,s=e.latitudeBands??16,i=e.longitudeBands??16,r=[],a=[],o=[],h=[];for(let u=0;u<=s;u++){const f=u*Math.PI/s,m=Math.sin(f),_=Math.cos(f);for(let g=0;g<=i;g++){const S=g*2*Math.PI/i-Math.PI/2,x=Math.sin(S),E=Math.cos(S)*m,b=_,C=x*m,w=1-g/i,P=1-u/s;r.push(E*t,b*t,C*t),a.push(E,b,C),o.push(w,1-P)}}for(let u=0;u<s;++u)for(let f=0;f<i;++f){const m=u*(i+1)+f,_=m+i+1;h.push(m+1,_,m),h.push(m+1,_+1,_)}this.positions=r,this.normals=a,this.uvs=o,this.uvs1=o,this.indices=h,e.calculateTangents&&(this.tangents=mo(r,a,o,h))}}class eG extends aL{constructor(e={}){const s=e.latitudeBands??16,i=e.longitudeBands??16;super({radius:.5,latitudeBands:s,longitudeBands:i});const r=.1,a=.95,o=a*a,h=this.positions;for(let u=0;u<h.length;u+=3){const f=h[u]/.5;let m=h[u+1]/.5;const _=h[u+2]/.5;m<0&&(m*=.3,f*f+_*_<o&&(m=-r)),m+=r,m*=.5,h[u+1]=m}}}class Vd{static create(e,t){switch(t){case iV:return Vd.box(e);case V2:return Vd.dome(e)}return Vd.infinite(e)}static infinite(e){return Ct.fromGeometry(e,new sT(e))}static box(e){return Ct.fromGeometry(e,new sT({yOffset:.5}))}static dome(e){const t=new eG({latitudeBands:50,longitudeBands:50});return t.normals=void 0,t.uvs=void 0,Ct.fromGeometry(e,t)}}class tG{destroy(){this.meshInstance&&(this.skyLayer&&this.skyLayer.removeMeshInstances([this.meshInstance]),this.meshInstance.destroy(),this.meshInstance=null)}set depthWrite(e){this._depthWrite=e,this.meshInstance&&(this.meshInstance.material.depthWrite=e)}get depthWrite(){return this._depthWrite}constructor(e,t,s,i,r){this.meshInstance=null,this._depthWrite=!1;const a=new Za({uniqueName:"SkyMaterial",vertexGLSL:Ue.get(e,ot).get("skyboxVS"),fragmentGLSL:Ue.get(e,ot).get("skyboxPS"),vertexWGSL:Ue.get(e,Je).get("skyboxVS"),fragmentWGSL:Ue.get(e,Je).get("skyboxPS"),attributes:{aPosition:He}});a.setDefine("{SKYBOX_DECODE_FNC}",Zn.decodeFunc(i.encoding)),r!==kd&&a.setDefine("SKYMESH",""),i.cubemap&&a.setDefine("SKY_CUBEMAP",""),a.setParameter("skyboxHighlightMultiplier",t.skyboxHighlightMultiplier),i.cubemap?a.setParameter("texture_cubeMap",i):(a.setParameter("texture_envAtlas",i),a.setParameter("mipLevel",t.skyboxMip)),a.cull=Fd,a.depthWrite=this._depthWrite;const o=t.layers.getLayerById(FE);if(o){const h=Vd.create(e,r),u=new lt(h,a,s);this.meshInstance=u,u.cull=!1,u.pick=!1,o.addMeshInstances([u]),this.skyLayer=o}}}class nL{applySettings(e){this.type=e.skyType??kd,this.node.setLocalPosition(new D(e.skyMeshPosition??[0,0,0])),this.node.setLocalEulerAngles(new D(e.skyMeshRotation??[0,0,0])),this.node.setLocalScale(new D(e.skyMeshScale??[1,1,1])),e.skyCenter&&(this._center=new D(e.skyCenter))}set type(e){this._type!==e&&(this._type=e,this.scene.updateShaders=!0,this.updateSkyMesh())}get type(){return this._type}set center(e){this._center.copy(e)}get center(){return this._center}set depthWrite(e){this._depthWrite!==e&&(this._depthWrite=e,this.skyMesh&&(this.skyMesh.depthWrite=e))}get depthWrite(){return this._depthWrite}updateSkyMesh(){const e=this.scene._getSkyboxTex();e&&(this.resetSkyMesh(),this.skyMesh=new tG(this.device,this.scene,this.node,e,this.type),this.skyMesh.depthWrite=this._depthWrite,this.scene.fire("set:skybox",e))}resetSkyMesh(){this.skyMesh?.destroy(),this.skyMesh=null}update(){if(this.type!==kd){const{center:e,centerArray:t}=this,s=new D;this.node.getWorldTransform().transformPoint(e,s),t[0]=s.x,t[1]=s.y,t[2]=s.z,this.projectedSkydomeCenterId.setValue(t)}}constructor(e){this._type=kd,this._center=new D(0,1,0),this.skyMesh=null,this._depthWrite=!1,this.node=new Dt("SkyMeshNode"),this.device=e.device,this.scene=e,this.center=new D(0,1,0),this.centerArray=new Float32Array(3),this.projectedSkydomeCenterId=this.device.scope.resolve("projectedSkydomeCenter")}}const pg=new Dt;pg.worldTransform=fe.IDENTITY;pg._dirtyWorld=pg._dirtyNormal=!1;class sG{addLines(e,t){const s=this.positions,i=e.length;for(let a=0;a<i;a++){const o=e[a];s.push(o.x,o.y,o.z)}const r=this.colors;if(t.length)for(let a=0;a<i;a++){const o=t[a];r.push(o.r,o.g,o.b,o.a)}else for(let a=0;a<i;a++)r.push(t.r,t.g,t.b,t.a)}addLinesArrays(e,t){const s=this.positions;for(let r=0;r<e.length;r+=3)s.push(e[r],e[r+1],e[r+2]);const i=this.colors;if(t.length)for(let r=0;r<t.length;r+=4)i.push(t[r],t[r+1],t[r+2],t[r+3]);else{const r=e.length/3;for(let a=0;a<r;a++)i.push(t.r,t.g,t.b,t.a)}}onPreRender(e,t){this.positions.length>0&&this.material.transparent===t&&(this.mesh.setPositions(this.positions),this.mesh.setColors(this.colors),this.mesh.update(hv,!1),this.meshInstance||(this.meshInstance=new lt(this.mesh,this.material,pg)),e.push(this.meshInstance))}clear(){this.positions.length=0,this.colors.length=0}constructor(e,t,s){this.material=t,this.layer=s,this.positions=[],this.colors=[],this.mesh=new Ct(e),this.meshInstance=null}}class iG{getBatch(e,t){let s=this.map.get(e);return s||(s=new sG(this.device,e,t),this.map.set(e,s)),s}onPreRender(e,t){this.map.forEach(s=>{s.onPreRender(e,t)})}clear(){this.map.forEach(e=>e.clear())}constructor(e){this.device=e,this.map=new Map}}const Bi=[],Bc=new D;class rG{createMaterial(e){const t=new Za({uniqueName:"ImmediateLine",vertexGLSL:Ue.get(this.device,ot).get("immediateLineVS"),fragmentGLSL:Ue.get(this.device,ot).get("immediateLinePS"),vertexWGSL:Ue.get(this.device,Je).get("immediateLineVS"),fragmentWGSL:Ue.get(this.device,Je).get("immediateLinePS"),attributes:{vertex_position:He,vertex_color:Rs}});return t.blendType=jr,t.depthTest=e,t.update(),t}get materialDepth(){return this._materialDepth||(this._materialDepth=this.createMaterial(!0)),this._materialDepth}get materialNoDepth(){return this._materialNoDepth||(this._materialNoDepth=this.createMaterial(!1)),this._materialNoDepth}getBatch(e,t){let s=this.batchesMap.get(e);s||(s=new iG(this.device),this.batchesMap.set(e,s)),this.allBatches.add(s);const i=t?this.materialDepth:this.materialNoDepth;return s.getBatch(i,e)}getShaderDesc(e,t,s){return this.shaderDescs.has(e)||this.shaderDescs.set(e,{uniqueName:`DebugShader:${e}`,vertexGLSL:`
					attribute vec2 vertex_position;
					uniform mat4 matrix_model;
					varying vec2 uv0;
					void main(void) {
						gl_Position = matrix_model * vec4(vertex_position, 0, 1);
						uv0 = vertex_position.xy + 0.5;
					}
				`,vertexWGSL:`
					attribute vertex_position: vec2f;
					uniform matrix_model: mat4x4f;
					varying uv0: vec2f;
					@vertex fn vertexMain(input: VertexInput) -> VertexOutput {
						var output: VertexOutput;
						output.position = uniform.matrix_model * vec4f(input.vertex_position, 0.0, 1.0);
						output.uv0 = input.vertex_position.xy + vec2f(0.5);
						return output;
					}
				`,fragmentGLSL:t,fragmentWGSL:s,attributes:{vertex_position:He}}),this.shaderDescs.get(e)}getTextureShaderDesc(e){const t=Zn.decodeFunc(e);return this.getShaderDesc(`textureShader-${e}`,`
			#include "gammaPS"
			varying vec2 uv0;
			uniform sampler2D colorMap;
			void main (void) {
				vec3 linearColor = ${t}(texture2D(colorMap, uv0));
				gl_FragColor = vec4(gammaCorrectOutput(linearColor), 1);
			}
		`,`
			#include "gammaPS"
			varying uv0: vec2f;
			var colorMap: texture_2d<f32>;
			var colorMapSampler: sampler;
			@fragment fn fragmentMain(input : FragmentInput) -> FragmentOutput {
				var output: FragmentOutput;
				let sampledTex = textureSample(colorMap, colorMapSampler, input.uv0);
				let linearColor: vec3f = ${t}(sampledTex);
				output.color = vec4f(gammaCorrectOutput(linearColor), 1.0);
				return output;
			}
		`)}getUnfilterableTextureShaderDesc(){return this.getShaderDesc("textureShaderUnfilterable",`
			varying vec2 uv0;
			uniform highp sampler2D colorMap;
			void main (void) {
				ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));
				gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);
			}
		`,`
			varying uv0: vec2f;
			var colorMap: texture_2d<uff>;
			@fragment fn fragmentMain(input : FragmentInput) -> FragmentOutput {
				var output: FragmentOutput;
				let uv : vec2<i32> = vec2<i32>(input.uv0 * vec2f(textureDimensions(colorMap, 0)));
				let fetchedColor : vec4f = textureLoad(colorMap, uv, 0);
				output.color = vec4f(fetchedColor.xyz, 1.0);
				return output;
			}
		`)}getDepthTextureShaderDesc(){return this.getShaderDesc("depthTextureShader",`
			#include "screenDepthPS"
			#include "gammaPS"
			varying vec2 uv0;
			void main() {
				float depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;
				gl_FragColor = vec4(gammaCorrectOutput(vec3(depth)), 1.0);
			}
		`,`
			#include "screenDepthPS"
			#include "gammaPS"
			varying uv0: vec2f;
			@fragment fn fragmentMain(input: FragmentInput) -> FragmentOutput {
				var output: FragmentOutput;
				let depth: f32 = getLinearScreenDepth(getImageEffectUV(input.uv0)) * uniform.camera_params.x;
				output.color = vec4f(gammaCorrectOutput(vec3f(depth)), 1.0);
				return output;
			}
		`)}getQuadMesh(){return this.quadMesh||(this.quadMesh=new Ct(this.device),this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]),this.quadMesh.update(zr)),this.quadMesh}drawMesh(e,t,s,i,r){if(!i){const o=this.getGraphNode(t);i=new lt(s,e,o)}let a=this.layerMeshInstances.get(r);a||(a=[],this.layerMeshInstances.set(r,a)),a.push(i)}drawWireAlignedBox(e,t,s,i,r,a){if(a){const h=(u,f,m)=>{Bc.set(u,f,m),a.transformPoint(Bc,Bc),Bi.push(Bc.x,Bc.y,Bc.z)};h(e.x,e.y,e.z),h(e.x,t.y,e.z),h(e.x,t.y,e.z),h(t.x,t.y,e.z),h(t.x,t.y,e.z),h(t.x,e.y,e.z),h(t.x,e.y,e.z),h(e.x,e.y,e.z),h(e.x,e.y,t.z),h(e.x,t.y,t.z),h(e.x,t.y,t.z),h(t.x,t.y,t.z),h(t.x,t.y,t.z),h(t.x,e.y,t.z),h(t.x,e.y,t.z),h(e.x,e.y,t.z),h(e.x,e.y,e.z),h(e.x,e.y,t.z),h(e.x,t.y,e.z),h(e.x,t.y,t.z),h(t.x,t.y,e.z),h(t.x,t.y,t.z),h(t.x,e.y,e.z),h(t.x,e.y,t.z)}else Bi.push(e.x,e.y,e.z,e.x,t.y,e.z,e.x,t.y,e.z,t.x,t.y,e.z,t.x,t.y,e.z,t.x,e.y,e.z,t.x,e.y,e.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,t.z,e.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,t.z,t.x,e.y,t.z,t.x,e.y,t.z,e.x,e.y,t.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,e.z,e.x,t.y,t.z,t.x,t.y,e.z,t.x,t.y,t.z,t.x,e.y,e.z,t.x,e.y,t.z);this.getBatch(r,i).addLinesArrays(Bi,s),Bi.length=0}drawWireSphere(e,t,s,i,r,a){const o=2*Math.PI/i;let h=0;for(let f=0;f<i;f++){const m=Math.sin(h),_=Math.cos(h);h+=o;const g=Math.sin(h),S=Math.cos(h);Bi.push(e.x+t*m,e.y,e.z+t*_),Bi.push(e.x+t*g,e.y,e.z+t*S),Bi.push(e.x+t*m,e.y+t*_,e.z),Bi.push(e.x+t*g,e.y+t*S,e.z),Bi.push(e.x,e.y+t*m,e.z+t*_),Bi.push(e.x,e.y+t*g,e.z+t*S)}this.getBatch(a,r).addLinesArrays(Bi,s),Bi.length=0}getGraphNode(e){const t=new Dt("ImmediateDebug");return t.worldTransform=e,t._dirtyWorld=t._dirtyNormal=!1,t}onPreRenderLayer(e,t,s){if(this.batchesMap.forEach((i,r)=>{r===e&&i.onPreRender(t,s)}),!this.updatedLayers.has(e)){this.updatedLayers.add(e);const i=this.layerMeshInstances.get(e);if(i){for(let r=0;r<i.length;r++)t.push(i[r]);i.length=0}}}onPostRender(){this.allBatches.forEach(e=>e.clear()),this.allBatches.clear(),this.updatedLayers.clear()}constructor(e){this.shaderDescs=new Map,this.device=e,this.quadMesh=null,this.textureShader=null,this.depthTextureShader=null,this.cubeLocalPos=null,this.cubeWorldPos=null,this.batchesMap=new Map,this.allBatches=new Set,this.updatedLayers=new Set,this._materialDepth=null,this._materialNoDepth=null,this.layerMeshInstances=new Map}}const xP=2.399963229728653,$f={circlePoint(c){const e=Math.sqrt(Math.random()),t=Math.random()*2*Math.PI;c.x=e*Math.cos(t),c.y=e*Math.sin(t)},circlePointDeterministic(c,e,t){const s=e*xP,i=Math.sqrt(e/t);c.x=i*Math.cos(s),c.y=i*Math.sin(s)},spherePointDeterministic(c,e,t,s=0,i=1){s=1-2*s,i=1-2*i;const r=J.lerp(s,i,e/t),a=Math.sqrt(1-r*r),o=xP*e;c.x=Math.cos(o)*a,c.y=r,c.z=Math.sin(o)*a},radicalInverse(c){let e=(c<<16|c>>>16)>>>0;return e=((e&1431655765)<<1|(e&2863311530)>>>1)>>>0,e=((e&858993459)<<2|(e&3435973836)>>>2)>>>0,e=((e&252645135)<<4|(e&4042322160)>>>4)>>>0,e=((e&16711935)<<8|(e&4278255360)>>>8)>>>0,e*23283064365386963e-26}},TP=c=>{switch(c){case Wx:return"Cubemap";case GB:return"Octahedral";default:return"Equirect"}},$p=(c,e,t)=>{if(c<=0)e[t+0]=0,e[t+1]=0,e[t+2]=0,e[t+3]=0;else if(c>=1)e[t+0]=255,e[t+1]=0,e[t+2]=0,e[t+3]=0;else{let s=1*c%1,i=255*c%1,r=65025*c%1;const a=16581375*c%1;s-=i/255,i-=r/255,r-=a/255,e[t+0]=Math.min(255,Math.floor(s*256)),e[t+1]=Math.min(255,Math.floor(i*256)),e[t+2]=Math.min(255,Math.floor(r*256)),e[t+3]=Math.min(255,Math.floor(a*256))}},aG=c=>{const e=c.length,t=Math.min(e,512),s=Math.ceil(e/t),i=new Uint8Array(t*s*4);let r=0;for(let a=0;a<e;a+=4)$p(c[a+0]*.5+.5,i,r+0),$p(c[a+1]*.5+.5,i,r+4),$p(c[a+2]*.5+.5,i,r+8),$p(c[a+3]/8,i,r+12),r+=16;return{width:t,height:s,data:i}},nG=(c,e,t,s)=>{const i=t*2*Math.PI,r=Math.pow(1-e,1/(s+1)),a=Math.sqrt(1-r*r);c.set(Math.cos(i)*a,Math.sin(i)*a,r).normalize()},oG=(c,e,t)=>{const s=t*2*Math.PI,i=Math.sqrt(1-e),r=Math.sqrt(e);c.set(Math.cos(s)*r,Math.sin(s)*r,i).normalize()},lG=(c,e,t,s)=>{const i=t*2*Math.PI,r=Math.sqrt((1-e)/(1+(s*s-1)*e)),a=Math.sqrt(1-r*r);c.set(Math.cos(i)*a,Math.sin(i)*a,r).normalize()},cG=(c,e)=>{const t=c*e,s=e/(1-c*c+t*t);return s*s*(1/Math.PI)},hG=(c,e)=>{const t=new D,s=[];for(let i=0;i<c;++i)nG(t,i/c,$f.radicalInverse(i),e),s.push(t.x,t.y,t.z,0);return s},uG=(c,e)=>{const t=e/c,s=new D,i=[];for(let r=0;r<c;++r){oG(s,r/c,$f.radicalInverse(r));const a=s.z/Math.PI,o=.5*Math.log2(t/a);i.push(s.x,s.y,s.z,o)}return i},dG={16:{2:26,8:20,32:17,128:16,512:16},32:{2:53,8:40,32:34,128:32,512:32},128:{2:214,8:163,32:139,128:130,512:128},1024:{2:1722,8:1310,32:1114,128:1041,512:1025}},fG=(c,e)=>{const t=dG[c];return t&&t[e]||c},mG=(c,e,t)=>{const s=t/c,i=1-Math.log2(e)/11,r=i*i,a=new D,o=new D,h=new D(0,0,1),u=[],f=fG(c,e);for(let m=0;m<f;++m){lG(a,m/f,$f.radicalInverse(m),r);const _=a.z;if(o.set(a.x,a.y,a.z).mulScalar(2*_).sub(h),o.z>0){const g=cG(Math.min(1,_),r)/4+.001,S=.5*Math.log2(s/g);u.push(o.x,o.y,o.z,S)}}for(;u.length<c*4;)u.push(0,0,0,0);return u},pG=(c,e,t)=>{const s=aG(t);return new De(c,{name:e,width:s.width,height:s.height,mipmaps:!1,minFilter:ze,magFilter:ze,levels:[s.data]})};class oL{destroy(){this.destroyContent&&this.map.forEach((e,t)=>{e.destroy()})}get(e,t){if(!this.map.has(e)){const s=t();return this.map.set(e,s),s}return this.map.get(e)}constructor(e=!0){this.map=new Map,this.destroyContent=e}}const _G=new oL(!1),gG=new ks,QE=(c,e,t)=>gG.get(c,()=>new oL).get(e,()=>pG(c,e,_G.get(e,t))),vG=(c,e,t)=>{const s=`lambert-samples-${e}-${t}`;return QE(c,s,()=>uG(e,t))},SG=(c,e,t)=>{const s=`phong-samples-${e}-${t}`;return QE(c,s,()=>hG(e,t))},yG=(c,e,t,s)=>{const i=`ggx-samples-${e}-${t}-${s}`;return QE(c,i,()=>mG(e,t,s))};function xa(c,e,t={}){const s=t.seamPixels??0,i=(t.rect?.z??e.width)-s*2,r=(t.rect?.w??e.height)-s*2;if(i<1||r<1)return!1;const a={none:"reproject",lambert:"prefilterSamplesUnweighted",phong:"prefilterSamplesUnweighted",ggx:"prefilterSamples"},o=t.hasOwnProperty("specularPower")?t.specularPower:1,h=t.hasOwnProperty("face")?t.face:null,u=t.hasOwnProperty("distribution")?t.distribution:o===1?"none":"phong",f=a[u]||"reproject",m=f.startsWith("prefilterSamples"),_=Zn.decodeFunc(c.encoding),g=Zn.encodeFunc(e.encoding),S=`sample${TP(c.projection)}`,x=`getDirection${TP(e.projection)}`,T=t.hasOwnProperty("numSamples")?t.numSamples:1024,E=`ReprojectShader:${f}_${_}_${g}_${S}_${x}_${T}`,b=c.device;let C=Ih(b).getCachedShader(E);if(!C){const R=new Map;m&&R.set("USE_SAMPLES_TEX",""),c.cubemap&&R.set("CUBEMAP_SOURCE",""),R.set("{PROCESS_FUNC}",f),R.set("{DECODE_FUNC}",_),R.set("{ENCODE_FUNC}",g),R.set("{SOURCE_FUNC}",S),R.set("{TARGET_FUNC}",x),R.set("{NUM_SAMPLES}",T),R.set("{NUM_SAMPLES_SQRT}",Math.round(Math.sqrt(T)).toFixed(1));const L=b.isWebGPU,B=Ue.get(b,L?Je:ot),G=new Map;G.set("decodePS",B.get("decodePS")),G.set("encodePS",B.get("encodePS")),C=ns.createShader(b,{uniqueName:E,attributes:{vertex_position:He},vertexChunk:"reprojectVS",fragmentChunk:"reprojectPS",fragmentIncludes:G,fragmentDefines:R})}b.setBlendState(ht.NOBLEND),b.scope.resolve(c.cubemap?"sourceCube":"sourceTex").setValue(c);const P=b.scope.resolve("params"),I=b.scope.resolve("uvMod");s>0?I.setValue([(i+s*2)/i,(r+s*2)/r,-s/i,-s/r]):I.setValue([1,1,0,0]);const M=[0,e.width*e.height*(e.cubemap?6:1),c.width*c.height*(c.cubemap?6:1)];if(m){const R=c.width*c.height*(c.cubemap?6:1),L=u==="ggx"?yG(b,T,o,R):u==="lambert"?vG(b,T,R):SG(b,T,o);b.scope.resolve("samplesTex").setValue(L),b.scope.resolve("samplesTexInverseSize").setValue([1/L.width,1/L.height])}for(let R=0;R<(e.cubemap?6:1);R++)if(h===null||R===h){const L=new At({colorBuffer:e,face:R,depth:!1,flipY:b.isWebGPU});M[0]=R,P.setValue(M),gr(b,L,C,t?.rect),L.destroy()}return!0}const X0=(c,e=0)=>1+Math.floor(Math.log2(Math.max(c,e))),xG=c=>c.textureHalfFloatRenderable,TG=c=>c.textureFloatRenderable,EG=c=>xG(c)?kt:TG(c)?fs:Ze,bG=c=>Ze,AG=(c,e,t,s)=>new De(c,{name:`lighting-${e}`,cubemap:!0,width:e,height:e,format:t,type:bh,addressU:Te,addressV:Te,mipmaps:!1});class JE{static generateSkyboxCubemap(e,t){const s=e.device,i=AG(s,t||(e.cubemap?e.width:e.width/4),Ze);return xa(e,i,{numSamples:1024}),i}static generateLightingSource(e,t){const s=e.device,i=EG(s),r=t?.target||new De(s,{name:"lighting-source",cubemap:!0,width:t?.size||128,height:t?.size||128,format:i,type:i===Ze?bh:qr,addressU:Te,addressV:Te,mipmaps:!0});return xa(e,r,{numSamples:e.mipmaps?1:1024}),r}static generateAtlas(e,t){const s=e.device,i=bG(),r=t?.target||new De(s,{name:"envAtlas",width:t?.size||512,height:t?.size||512,format:i,type:bh,projection:q1,addressU:Te,addressV:Te,mipmaps:!1}),a=r.width/512,o=new me(0,0,512*a,256*a),h=X0(256)-X0(4);for(let u=0;u<h;++u)xa(e,r,{numSamples:1,rect:o,seamPixels:a}),o.x+=o.w,o.y+=o.w,o.z=Math.max(1,Math.floor(o.z*.5)),o.w=Math.max(1,Math.floor(o.w*.5));o.set(0,256*a,256*a,128*a);for(let u=1;u<7;++u)xa(e,r,{numSamples:t?.numReflectionSamples||1024,distribution:t?.distribution||"ggx",specularPower:Math.max(1,2048>>u*2),rect:o,seamPixels:a}),o.y+=o.w,o.z=Math.max(1,Math.floor(o.z*.5)),o.w=Math.max(1,Math.floor(o.w*.5));return o.set(128*a,384*a,64*a,32*a),xa(e,r,{numSamples:t?.numAmbientSamples||2048,distribution:"lambert",rect:o,seamPixels:a}),r}static generatePrefilteredAtlas(e,t){const s=e[0].device,i=e[0].format,r=e[0].type,a=t?.target||new De(s,{name:"envPrefilteredAtlas",width:t?.size||512,height:t?.size||512,format:i,type:r,projection:q1,addressU:Te,addressV:Te,mipmaps:!1}),o=a.width/512,h=new me(0,0,512*o,256*o),u=X0(512);for(let f=0;f<u;++f)xa(e[0],a,{numSamples:1,rect:h,seamPixels:o}),h.x+=h.w,h.y+=h.w,h.z=Math.max(1,Math.floor(h.z*.5)),h.w=Math.max(1,Math.floor(h.w*.5));h.set(0,256*o,256*o,128*o);for(let f=1;f<e.length;++f)xa(e[f],a,{numSamples:1,rect:h,seamPixels:o}),h.y+=h.w,h.z=Math.max(1,Math.floor(h.z*.5)),h.w=Math.max(1,Math.floor(h.w*.5));return h.set(128*o,384*o,64*o,32*o),t?.legacyAmbient?xa(e[5],a,{numSamples:1,rect:h,seamPixels:o}):xa(e[0],a,{numSamples:t?.numSamples||2048,distribution:"lambert",rect:h,seamPixels:o}),a}}class wG{constructor(){this.type=Kh,this.color=new ue(0,0,0),this.density=0,this.start=1,this.end=1e3}}class an extends Pe{get defaultDrawLayer(){return this.layers.getLayerById(BE)}set ambientBakeNumSamples(e){this._ambientBakeNumSamples=J.clamp(Math.floor(e),1,255)}get ambientBakeNumSamples(){return this._ambientBakeNumSamples}set ambientBakeSpherePart(e){this._ambientBakeSpherePart=J.clamp(e,.001,1)}get ambientBakeSpherePart(){return this._ambientBakeSpherePart}set clusteredLightingEnabled(e){if(!(this.device.isWebGPU&&!e)){if(!this._clusteredLightingEnabled&&e){console.error("Turning on disabled clustered lighting is not currently supported");return}this._clusteredLightingEnabled=e}}get clusteredLightingEnabled(){return this._clusteredLightingEnabled}set envAtlas(e){e!==this._envAtlas&&(this._envAtlas=e,e&&(e.addressU=Te,e.addressV=Te,e.minFilter=$t,e.magFilter=$t,e.mipmaps=!1),this._prefilteredCubemaps=[],this._internalEnvAtlas&&(this._internalEnvAtlas.destroy(),this._internalEnvAtlas=null),this._resetSkyMesh())}get envAtlas(){return this._envAtlas}set layers(e){const t=this._layers;this._layers=e,this.fire("set:layers",t,e)}get layers(){return this._layers}get sky(){return this._sky}get lighting(){return this._lightingParams}get gsplat(){return this._gsplatParams}get fog(){return this._fogParams}set lightmapFilterRange(e){this._lightmapFilterRange=Math.max(e,.001)}get lightmapFilterRange(){return this._lightmapFilterRange}set lightmapFilterSmoothness(e){this._lightmapFilterSmoothness=Math.max(e,.001)}get lightmapFilterSmoothness(){return this._lightmapFilterSmoothness}set prefilteredCubemaps(e){e=e||[];const t=this._prefilteredCubemaps;(t.length!==e.length||t.some((i,r)=>i!==e[r]))&&(e.length===6&&e.every(r=>!!r)?(this._internalEnvAtlas=JE.generatePrefilteredAtlas(e,{target:this._internalEnvAtlas}),this._envAtlas=this._internalEnvAtlas):(this._internalEnvAtlas&&(this._internalEnvAtlas.destroy(),this._internalEnvAtlas=null),this._envAtlas=null),this._prefilteredCubemaps=e.slice(),this._resetSkyMesh())}get prefilteredCubemaps(){return this._prefilteredCubemaps}set skybox(e){e!==this._skyboxCubeMap&&(this._skyboxCubeMap=e,this._resetSkyMesh())}get skybox(){return this._skyboxCubeMap}set skyboxIntensity(e){e!==this._skyboxIntensity&&(this._skyboxIntensity=e,this._resetSkyMesh())}get skyboxIntensity(){return this._skyboxIntensity}set skyboxLuminance(e){e!==this._skyboxLuminance&&(this._skyboxLuminance=e,this._resetSkyMesh())}get skyboxLuminance(){return this._skyboxLuminance}set skyboxMip(e){e!==this._skyboxMip&&(this._skyboxMip=e,this._resetSkyMesh())}get skyboxMip(){return this._skyboxMip}set skyboxHighlightMultiplier(e){e!==this._skyboxHighlightMultiplier&&(this._skyboxHighlightMultiplier=e,this._resetSkyMesh())}get skyboxHighlightMultiplier(){return this._skyboxHighlightMultiplier}set skyboxRotation(e){if(!this._skyboxRotation.equals(e)){const t=e.equals(pe.IDENTITY);this._skyboxRotation.copy(e),t?this._skyboxRotationMat3.setIdentity():(this._skyboxRotationMat4.setTRS(D.ZERO,e,D.ONE),this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4)),!this._skyboxRotationShaderInclude&&!t&&(this._skyboxRotationShaderInclude=!0,this._resetSkyMesh())}}get skyboxRotation(){return this._skyboxRotation}destroy(){this._resetSkyMesh(),this.root=null,this.off()}drawLine(e,t,s=ue.WHITE,i=!0,r=this.defaultDrawLayer){this.immediate.getBatch(r,i).addLines([e,t],[s,s])}drawLines(e,t,s=!0,i=this.defaultDrawLayer){this.immediate.getBatch(i,s).addLines(e,t)}drawLineArrays(e,t,s=!0,i=this.defaultDrawLayer){this.immediate.getBatch(i,s).addLinesArrays(e,t)}applySettings(e){const t=e.physics,s=e.render;this._gravity.set(t.gravity[0],t.gravity[1],t.gravity[2]),this.ambientLight.set(s.global_ambient[0],s.global_ambient[1],s.global_ambient[2]),this.ambientLuminance=s.ambientLuminance,this.fog.type=s.fog,this.fog.color.set(s.fog_color[0],s.fog_color[1],s.fog_color[2]),this.fog.start=s.fog_start,this.fog.end=s.fog_end,this.fog.density=s.fog_density,this.lightmapSizeMultiplier=s.lightmapSizeMultiplier,this.lightmapMaxResolution=s.lightmapMaxResolution,this.lightmapMode=s.lightmapMode,this.exposure=s.exposure,this._skyboxIntensity=s.skyboxIntensity??1,this._skyboxLuminance=s.skyboxLuminance??2e4,this._skyboxMip=s.skyboxMip??0,s.skyboxRotation&&(this.skyboxRotation=new pe().setFromEulerAngles(s.skyboxRotation[0],s.skyboxRotation[1],s.skyboxRotation[2])),this.sky.applySettings(s),this.clusteredLightingEnabled=s.clusteredLightingEnabled??!1,this.lighting.applySettings(s),["lightmapFilterEnabled","lightmapFilterRange","lightmapFilterSmoothness","ambientBake","ambientBakeNumSamples","ambientBakeSpherePart","ambientBakeOcclusionBrightness","ambientBakeOcclusionContrast"].forEach(i=>{s.hasOwnProperty(i)&&(this[i]=s[i])}),this._resetSkyMesh()}_getSkyboxTex(){const e=this._prefilteredCubemaps;return this._skyboxMip?e[[0,1,3,4,5,6][this._skyboxMip]]||this._envAtlas||e[0]||this._skyboxCubeMap:this._skyboxCubeMap||e[0]||this._envAtlas}_updateSkyMesh(){this.sky.skyMesh||this.sky.updateSkyMesh(),this.sky.update()}_resetSkyMesh(){this.sky.resetSkyMesh(),this.updateShaders=!0}setSkybox(e){e?(this.skybox=e[0]||null,e[1]&&!e[1].cubemap?this.envAtlas=e[1]:this.prefilteredCubemaps=e.slice(1)):(this.skybox=null,this.envAtlas=null)}get lightmapPixelFormat(){return this.lightmapHDR&&this.device.getRenderableHdrFormat()||Ze}constructor(e){super(),this.ambientBake=!1,this.ambientBakeOcclusionBrightness=0,this.ambientBakeOcclusionContrast=0,this.ambientLight=new ue(0,0,0),this.ambientLuminance=0,this.exposure=1,this.lightmapSizeMultiplier=1,this.lightmapMaxResolution=2048,this.lightmapMode=A_,this.lightmapFilterEnabled=!1,this.lightmapHDR=!1,this.root=null,this.physicalUnits=!1,this._envAtlas=null,this._skyboxCubeMap=null,this._fogParams=new wG,this.forcePassThroughSpecular=!1,this.device=e,this._gravity=new D(0,-9.8,0),this._layers=null,this._prefilteredCubemaps=[],this._internalEnvAtlas=null,this._skyboxIntensity=1,this._skyboxLuminance=0,this._skyboxMip=0,this._skyboxHighlightMultiplier=1,this._skyboxRotationShaderInclude=!1,this._skyboxRotation=new pe,this._skyboxRotationMat3=new $i,this._skyboxRotationMat4=new fe,this._ambientBakeNumSamples=1,this._ambientBakeSpherePart=.4,this._lightmapFilterRange=10,this._lightmapFilterSmoothness=.2,this._clusteredLightingEnabled=!0,this._lightingParams=new tL(this.device.supportsAreaLights,this.device.maxTextureSize,()=>{this.updateShaders=!0}),this._gsplatParams=new Z4,this._sky=new nL(this),this._stats={meshInstances:0,lights:0,dynamicLights:0,bakedLights:0,updateShadersTime:0},this.updateShaders=!0,this._shaderVersion=0,this.immediate=new rG(this.device)}}an.EVENT_SETLAYERS="set:layers";an.EVENT_SETSKYBOX="set:skybox";an.EVENT_PRERENDER="prerender";an.EVENT_POSTRENDER="postrender";an.EVENT_PRERENDER_LAYER="prerender:layer";an.EVENT_POSTRENDER_LAYER="postrender:layer";an.EVENT_PRECULL="precull";an.EVENT_POSTCULL="postcull";class lL{constructor(e,t,s){this.device=e,this.inverseBindPose=t,this.boneNames=s}}const CG=[0,0,1,0,0,1,0,0,1,0,0,1],DG=[0,1,3,2,3,1];class PG extends Pe{set frameKeys(e){this._frameKeys=e,this._atlas&&this._frameKeys&&(this._updatingProperties?this._meshesDirty=!0:this._createMeshes()),this.fire("set:frameKeys",e)}get frameKeys(){return this._frameKeys}set atlas(e){e!==this._atlas&&(this._atlas&&(this._atlas.off("set:frames",this._onSetFrames,this),this._atlas.off("set:frame",this._onFrameChanged,this),this._atlas.off("remove:frame",this._onFrameRemoved,this)),this._atlas=e,this._atlas&&this._frameKeys&&(this._atlas.on("set:frames",this._onSetFrames,this),this._atlas.on("set:frame",this._onFrameChanged,this),this._atlas.on("remove:frame",this._onFrameRemoved,this),this._updatingProperties?this._meshesDirty=!0:this._createMeshes()),this.fire("set:atlas",e))}get atlas(){return this._atlas}set pixelsPerUnit(e){this._pixelsPerUnit!==e&&(this._pixelsPerUnit=e,this.fire("set:pixelsPerUnit",e),this._atlas&&this._frameKeys&&this.renderMode===Nr&&(this._updatingProperties?this._meshesDirty=!0:this._createMeshes()))}get pixelsPerUnit(){return this._pixelsPerUnit}set renderMode(e){if(this._renderMode===e)return;const t=this._renderMode;this._renderMode=e,this.fire("set:renderMode",e),(t===Nr||e===Nr)&&this._atlas&&this._frameKeys&&(this._updatingProperties?this._meshesDirty=!0:this._createMeshes())}get renderMode(){return this._renderMode}get meshes(){return this._meshes}_createMeshes(){const e=this._meshes.length;for(let i=0;i<e;i++){const r=this._meshes[i];r&&r.destroy()}const t=this._frameKeys.length;this._meshes=new Array(t);const s=this.renderMode===hs||this._renderMode===us?this._create9SliceMesh:this._createSimpleMesh;for(let i=0;i<t;i++){const r=this._atlas.frames[this._frameKeys[i]];this._meshes[i]=r?s.call(this,r):null}this.fire("set:meshes")}_createSimpleMesh(e){const t=e.rect,s=this._atlas.texture.width,i=this._atlas.texture.height,r=t.z/this._pixelsPerUnit,a=t.w/this._pixelsPerUnit,o=e.pivot.x,h=e.pivot.y,u=[-o*r,-h*a,0,(1-o)*r,-h*a,0,(1-o)*r,(1-h)*a,0,-o*r,(1-h)*a,0],f=t.x/s,m=1-t.y/i,_=(t.x+t.z)/s,g=1-(t.y+t.w)/i,S=[f,m,_,m,_,g,f,g],x=new Rl;return x.positions=u,x.normals=CG,x.uvs=S,x.indices=DG,Ct.fromGeometry(this._device,x)}_create9SliceMesh(){const e=ne.ONE,t=3,s=3,i=[],r=[],a=[],o=[];let h=0;for(let f=0;f<=t;f++){const m=f===0||f===t?0:1;for(let _=0;_<=s;_++){const g=-e.x+2*e.x*(f<=1?0:3)/t,S=0,x=-(-e.y+2*e.y*(_<=1?0:3)/s),T=_===0||_===s?0:1;i.push(-g,S,x),r.push(0,1,0),a.push(m,T),f<t&&_<s&&(o.push(h+s+1,h+1,h),o.push(h+s+1,h+s+2,h+1)),h++}}const u=new Rl;return u.positions=i,u.normals=r,u.uvs=a,u.indices=o,Ct.fromGeometry(this._device,u)}_onSetFrames(e){this._updatingProperties?this._meshesDirty=!0:this._createMeshes()}_onFrameChanged(e,t){const s=this._frameKeys.indexOf(e);s<0||(t?this.renderMode===Nr&&(this._meshes[s]=this._createSimpleMesh(t)):this._meshes[s]=null,this.fire("set:meshes"))}_onFrameRemoved(e){const t=this._frameKeys.indexOf(e);t<0||(this._meshes[t]=null,this.fire("set:meshes"))}startUpdate(){this._updatingProperties=!0,this._meshesDirty=!1}endUpdate(){this._updatingProperties=!1,this._meshesDirty&&this._atlas&&this._frameKeys&&this._createMeshes(),this._meshesDirty=!1}destroy(){for(const e of this._meshes)e&&e.destroy();this._meshes.length=0}constructor(e,t){super(),this._device=e,this._pixelsPerUnit=t&&t.pixelsPerUnit!==void 0?t.pixelsPerUnit:1,this._renderMode=t&&t.renderMode!==void 0?t.renderMode:Nr,this._atlas=t&&t.atlas!==void 0?t.atlas:null,this._frameKeys=t&&t.frameKeys!==void 0?t.frameKeys:null,this._meshes=[],this._updatingProperties=!1,this._meshesDirty=!1,this._atlas&&this._frameKeys&&this._createMeshes()}}class RG extends Pe{set texture(e){this._texture=e,this.fire("set:texture",e)}get texture(){return this._texture}set frames(e){this._frames=e,this.fire("set:frames",e)}get frames(){return this._frames}setFrame(e,t){let s=this._frames[e];s?(s.rect.copy(t.rect),s.pivot.copy(t.pivot),s.border.copy(t.border)):(s={rect:t.rect.clone(),pivot:t.pivot.clone(),border:t.border.clone()},this._frames[e]=s),this.fire("set:frame",e.toString(),s)}removeFrame(e){const t=this._frames[e];t&&(delete this._frames[e],this.fire("remove:frame",e.toString(),t))}destroy(){this._texture&&this._texture.destroy()}constructor(){super(),this._texture=null,this._frames=null}}class EP{constructor(e,t,s,i){this.time=e,this.position=t,this.rotation=s,this.scale=i}}class bP{constructor(){this._name="",this._keys=[]}}class AP{getNode(e){return this._nodeDict[e]}addNode(e){this._nodes.push(e),this._nodeDict[e._name]=e}get nodes(){return this._nodes}constructor(){this.name="",this.duration=0,this._nodes=[],this._nodeDict={}}}class MG{getTarget(){return this._targetNode}setTarget(e){this._targetNode=e}constructor(){this._written=!1,this._name="",this._keyFrames=[],this._quat=new pe,this._pos=new D,this._scale=new D,this._targetNode=null}}class q0{set animation(e){this._animation=e,this.currentTime=0}get animation(){return this._animation}set currentTime(e){this._time=e;const t=this._interpolatedKeys.length;for(let s=0;s<t;s++){const r=this._interpolatedKeys[s]._name;this._currKeyIndices[r]=0}this.addTime(0),this.updateGraph()}get currentTime(){return this._time}get numNodes(){return this._interpolatedKeys.length}addTime(e){if(this._animation!==null){const t=this._animation._nodes,s=this._animation.duration;if(this._time===s&&!this.looping)return;if(this._time+=e,this._time>s){this._time=this.looping?0:s;for(let r=0;r<t.length;r++){const o=t[r]._name;this._currKeyIndices[o]=0}}else if(this._time<0){this._time=this.looping?s:0;for(let r=0;r<t.length;r++){const a=t[r],o=a._name;this._currKeyIndices[o]=a._keys.length-2}}const i=e>=0?1:-1;for(let r=0;r<t.length;r++){const a=t[r],o=a._name,h=a._keys,u=this._interpolatedKeyDict[o];if(u===void 0)continue;let f=!1;if(h.length!==1)for(let m=this._currKeyIndices[o];m<h.length-1&&m>=0;m+=i){const _=h[m],g=h[m+1];if(_.time<=this._time&&g.time>=this._time){const S=(this._time-_.time)/(g.time-_.time);u._pos.lerp(_.position,g.position,S),u._quat.slerp(_.rotation,g.rotation,S),u._scale.lerp(_.scale,g.scale,S),u._written=!0,this._currKeyIndices[o]=m,f=!0;break}}(h.length===1||!f&&this._time===0&&this.looping)&&(u._pos.copy(h[0].position),u._quat.copy(h[0].rotation),u._scale.copy(h[0].scale),u._written=!0)}}}blend(e,t,s){const i=this._interpolatedKeys.length;for(let r=0;r<i;r++){const a=e._interpolatedKeys[r],o=t._interpolatedKeys[r],h=this._interpolatedKeys[r];a._written&&o._written?(h._quat.slerp(a._quat,t._interpolatedKeys[r]._quat,s),h._pos.lerp(a._pos,t._interpolatedKeys[r]._pos,s),h._scale.lerp(a._scale,o._scale,s),h._written=!0):a._written?(h._quat.copy(a._quat),h._pos.copy(a._pos),h._scale.copy(a._scale),h._written=!0):o._written&&(h._quat.copy(o._quat),h._pos.copy(o._pos),h._scale.copy(o._scale),h._written=!0)}}setGraph(e){if(this.graph=e,e)for(let t=0;t<this._interpolatedKeys.length;t++){const s=this._interpolatedKeys[t],i=e.findByName(s._name);this._interpolatedKeys[t].setTarget(i)}else for(let t=0;t<this._interpolatedKeys.length;t++)this._interpolatedKeys[t].setTarget(null)}updateGraph(){if(this.graph)for(let e=0;e<this._interpolatedKeys.length;e++){const t=this._interpolatedKeys[e];if(t._written){const s=t.getTarget();s.localPosition.copy(t._pos),s.localRotation.copy(t._quat),s.localScale.copy(t._scale),s._dirtyLocal||s._dirtifyLocal(),t._written=!1}}}constructor(e){this.looping=!0,this._animation=null,this._time=0,this._interpolatedKeys=[],this._interpolatedKeyDict={},this._currKeyIndices={},this.graph=null;const t=s=>{const i=new MG;i._name=s.name,this._interpolatedKeys.push(i),this._interpolatedKeyDict[s.name]=i,this._currKeyIndices[s.name]=0;for(let r=0;r<s._children.length;r++)t(s._children[r])};t(e)}}const LG=`
@group(0) @binding(0) var<storage, read_write> items: array<u32>;
@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;
struct PrefixSumUniforms {
	elementCount: u32
};
@group(0) @binding(2) var<uniform> uniforms: PrefixSumUniforms;
const WORKGROUP_SIZE_X: u32 = {WORKGROUP_SIZE_X}u;
const WORKGROUP_SIZE_Y: u32 = {WORKGROUP_SIZE_Y}u;
const THREADS_PER_WORKGROUP: u32 = {THREADS_PER_WORKGROUP}u;
const ITEMS_PER_WORKGROUP: u32 = {ITEMS_PER_WORKGROUP}u;
var<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP * 2>;
@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)
fn reduce_downsweep(
	@builtin(workgroup_id) w_id: vec3<u32>,
	@builtin(num_workgroups) w_dim: vec3<u32>,
	@builtin(local_invocation_index) TID: u32,
) {
	let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;
	let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;
	let GID = WID + TID;
	
	let ELM_TID = TID * 2;
	let ELM_GID = GID * 2;
	
	temp[ELM_TID] = select(items[ELM_GID], 0u, ELM_GID >= uniforms.elementCount);
	temp[ELM_TID + 1u] = select(items[ELM_GID + 1u], 0u, ELM_GID + 1u >= uniforms.elementCount);
	var offset: u32 = 1u;
	for (var d: u32 = ITEMS_PER_WORKGROUP >> 1u; d > 0u; d >>= 1u) {
		workgroupBarrier();
		if (TID < d) {
			var ai: u32 = offset * (ELM_TID + 1u) - 1u;
			var bi: u32 = offset * (ELM_TID + 2u) - 1u;
			temp[bi] += temp[ai];
		}
		offset *= 2u;
	}
	if (TID == 0u) {
		let last_offset = ITEMS_PER_WORKGROUP - 1u;
		blockSums[WORKGROUP_ID] = temp[last_offset];
		temp[last_offset] = 0u;
	}
	for (var d: u32 = 1u; d < ITEMS_PER_WORKGROUP; d *= 2u) {
		offset >>= 1u;
		workgroupBarrier();
		if (TID < d) {
			var ai: u32 = offset * (ELM_TID + 1u) - 1u;
			var bi: u32 = offset * (ELM_TID + 2u) - 1u;
			let t: u32 = temp[ai];
			temp[ai] = temp[bi];
			temp[bi] += t;
		}
	}
	workgroupBarrier();
	if (ELM_GID < uniforms.elementCount) {
		items[ELM_GID] = temp[ELM_TID];
	}
	if (ELM_GID + 1u < uniforms.elementCount) {
		items[ELM_GID + 1u] = temp[ELM_TID + 1u];
	}
}
@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)
fn add_block_sums(
	@builtin(workgroup_id) w_id: vec3<u32>,
	@builtin(num_workgroups) w_dim: vec3<u32>,
	@builtin(local_invocation_index) TID: u32,
) {
	let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;
	let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;
	let GID = WID + TID;
	let ELM_ID = GID * 2u;
	if (ELM_ID >= uniforms.elementCount) {
		return;
	}
	let blockSum = blockSums[WORKGROUP_ID];
	items[ELM_ID] += blockSum;
	if (ELM_ID + 1u >= uniforms.elementCount) {
		return;
	}
	items[ELM_ID + 1u] += blockSum;
}
`,cL=16,hL=16,uL=cL*hL,Kp=2*uL;class IG{destroy(){this._destroyPasses(),this._scanShader?.destroy(),this._addBlockShader?.destroy(),this._bindGroupFormat?.destroy(),this._scanShader=null,this._addBlockShader=null,this._bindGroupFormat=null,this._uniformBufferFormat=null}_createFormatsAndShaders(){this._uniformBufferFormat=new uo(this.device,[new Be("elementCount",Qs)]),this._bindGroupFormat=new Vr(this.device,[new Is("items",rs,!1),new Is("blockSums",rs,!1),new io("uniforms",rs)]),this._scanShader=this._createShader("PrefixSumScan","reduce_downsweep"),this._addBlockShader=this._createShader("PrefixSumAddBlock","add_block_sums")}createPassesRecursive(e,t){const s=Math.ceil(t/Kp),{x:i,y:r}=this.findOptimalDispatchSize(s),a=new Fs(this.device,s*4),o=new sf(this.device,this._scanShader,"PrefixSumScan");o.setParameter("items",e),o.setParameter("blockSums",a);const h={scanCompute:o,addBlockCompute:null,blockSumBuffer:a,dispatchX:i,dispatchY:r,count:t,allocatedCount:t};if(this.passes.push(h),s>1){this.createPassesRecursive(a,s);const u=new sf(this.device,this._addBlockShader,"PrefixSumAddBlock");u.setParameter("items",e),u.setParameter("blockSums",a),h.addBlockCompute=u}}_createShader(e,t){const s=new Map;return s.set("{WORKGROUP_SIZE_X}",cL),s.set("{WORKGROUP_SIZE_Y}",hL),s.set("{THREADS_PER_WORKGROUP}",uL),s.set("{ITEMS_PER_WORKGROUP}",Kp),new fo(this.device,{name:e,shaderLanguage:Je,cshader:LG,cdefines:s,computeEntryPoint:t,computeBindGroupFormat:this._bindGroupFormat,computeUniformBufferFormats:{uniforms:this._uniformBufferFormat}})}findOptimalDispatchSize(e){const t=this.device.limits.maxComputeWorkgroupsPerDimension||65535;if(e<=t)return{x:e,y:1};const s=Math.floor(Math.sqrt(e)),i=Math.ceil(e/s);return{x:s,y:i}}resize(e,t){const s=this._countPassesNeeded(t),i=this.passes.length;if(s>i){this._destroyPasses(),this.createPassesRecursive(e,t);return}let r=t;for(let a=0;a<this.passes.length;a++){const o=Math.ceil(r/Kp),{x:h,y:u}=this.findOptimalDispatchSize(o);if(this.passes[a].count=r,this.passes[a].dispatchX=h,this.passes[a].dispatchY=u,r=o,o<=1)break}}_destroyPasses(){for(const e of this.passes)e.blockSumBuffer?.destroy();this.passes.length=0}_countPassesNeeded(e){let t=0,s=e;for(;s>0;){t++;const i=Math.ceil(s/Kp);if(i<=1)break;s=i}return t}dispatch(e){for(let t=0;t<this.passes.length;t++){const s=this.passes[t];s.scanCompute.setParameter("elementCount",s.count),s.scanCompute.setupDispatch(s.dispatchX,s.dispatchY,1),e.computeDispatch([s.scanCompute],"PrefixSumScan")}for(let t=this.passes.length-1;t>=0;t--){const s=this.passes[t];s.addBlockCompute&&(s.addBlockCompute.setParameter("elementCount",s.count),s.addBlockCompute.setupDispatch(s.dispatchX,s.dispatchY,1),e.computeDispatch([s.addBlockCompute],"PrefixSumAddBlock"))}}constructor(e){this.passes=[],this._uniformBufferFormat=null,this._bindGroupFormat=null,this._scanShader=null,this._addBlockShader=null,this.device=e,this._createFormatsAndShaders()}}const OG=`
@group(0) @binding(0) var<storage, read> input: array<u32>;
@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;
@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;
struct RadixSortUniforms {
	workgroupCount: u32,
	elementCount: u32
};
@group(0) @binding(3) var<uniform> uniforms: RadixSortUniforms;
const THREADS_PER_WORKGROUP: u32 = {THREADS_PER_WORKGROUP}u;
const WORKGROUP_SIZE_X: u32 = {WORKGROUP_SIZE_X}u;
const WORKGROUP_SIZE_Y: u32 = {WORKGROUP_SIZE_Y}u;
const CURRENT_BIT: u32 = {CURRENT_BIT}u;
var<workgroup> histogram: array<atomic<u32>, 16>;
var<workgroup> thread_digits: array<u32, 256>;
@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)
fn radix_sort(
	@builtin(workgroup_id) w_id: vec3<u32>,
	@builtin(num_workgroups) w_dim: vec3<u32>,
	@builtin(local_invocation_index) TID: u32,
) {
	let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;
	let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;
	let GID = WID + TID;
	if (TID < 16u) {
		atomicStore(&histogram[TID], 0u);
	}
	workgroupBarrier();
	let is_valid = GID < uniforms.elementCount && WORKGROUP_ID < uniforms.workgroupCount;
	let elm = select(0u, input[GID], is_valid);
	let digit: u32 = select(16u, (elm >> CURRENT_BIT) & 0xFu, is_valid);
	thread_digits[TID] = digit;
	if (is_valid) {
		atomicAdd(&histogram[digit], 1u);
	}
	workgroupBarrier();
	var local_prefix: u32 = 0u;
	if (is_valid) {
		let digit_vec = vec4<u32>(digit, digit, digit, digit);
		let ones = vec4<u32>(1u, 1u, 1u, 1u);
		let zeros = vec4<u32>(0u, 0u, 0u, 0u);
		
		var i: u32 = 0u;
		let limit = TID & ~3u;
		for (; i < limit; i += 4u) {
			let d = vec4<u32>(
				thread_digits[i],
				thread_digits[i + 1u],
				thread_digits[i + 2u],
				thread_digits[i + 3u]
			);
			let matches = select(zeros, ones, d == digit_vec);
			local_prefix += matches.x + matches.y + matches.z + matches.w;
		}
		
		for (; i < TID; i++) {
			local_prefix += select(0u, 1u, thread_digits[i] == digit);
		}
	}
	if (is_valid) {
		local_prefix_sums[GID] = local_prefix;
	}
	if (TID < 16u && WORKGROUP_ID < uniforms.workgroupCount) {
		block_sums[TID * uniforms.workgroupCount + WORKGROUP_ID] = atomicLoad(&histogram[TID]);
	}
}
`,NG=`
@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;
@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;
@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;
@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;
@group(0) @binding(4) var<storage, read> inputValues: array<u32>;
@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;
struct RadixSortUniforms {
	workgroupCount: u32,
	elementCount: u32
};
@group(0) @binding(6) var<uniform> uniforms: RadixSortUniforms;
const THREADS_PER_WORKGROUP: u32 = {THREADS_PER_WORKGROUP}u;
const WORKGROUP_SIZE_X: u32 = {WORKGROUP_SIZE_X}u;
const WORKGROUP_SIZE_Y: u32 = {WORKGROUP_SIZE_Y}u;
const CURRENT_BIT: u32 = {CURRENT_BIT}u;
const IS_FIRST_PASS: u32 = {IS_FIRST_PASS}u;
@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)
fn radix_sort_reorder(
	@builtin(workgroup_id) w_id: vec3<u32>,
	@builtin(num_workgroups) w_dim: vec3<u32>,
	@builtin(local_invocation_index) TID: u32,
) {
	let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;
	let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;
	let GID = WID + TID;
	if (GID >= uniforms.elementCount) {
		return;
	}
	let k = inputKeys[GID];
	let v = select(inputValues[GID], GID, IS_FIRST_PASS == 1u);
	let local_prefix = local_prefix_sum[GID];
	let extract_bits = (k >> CURRENT_BIT) & 0xFu;
	
	let pid = extract_bits * uniforms.workgroupCount + WORKGROUP_ID;
	let sorted_position = prefix_block_sum[pid] + local_prefix;
	outputKeys[sorted_position] = k;
	outputValues[sorted_position] = v;
}
`,Y0=4,wP=16,dL=16,fL=16,CP=dL*fL;class FG{destroy(){this._destroyBuffers(),this._destroyPasses(),this._blockSumBindGroupFormat?.destroy(),this._reorderBindGroupFormat?.destroy(),this._blockSumBindGroupFormat=null,this._reorderBindGroupFormat=null,this._uniformBufferFormat=null}_destroyPasses(){for(const e of this._passes)e.blockSumCompute.shader?.destroy(),e.reorderCompute.shader?.destroy();this._passes.length=0,this._numBits=0}_destroyBuffers(){this._keys0?.destroy(),this._keys1?.destroy(),this._values0?.destroy(),this._values1?.destroy(),this._localPrefixSums?.destroy(),this._blockSums?.destroy(),this._sortedIndices?.destroy(),this._prefixSumKernel?.destroy(),this._keys0=null,this._keys1=null,this._values0=null,this._values1=null,this._localPrefixSums=null,this._blockSums=null,this._sortedIndices=null,this._prefixSumKernel=null,this._workgroupCount=0,this._allocatedWorkgroupCount=0}get sortedIndices(){return this._sortedIndices}_createBindGroupFormats(){const e=this.device;this._uniformBufferFormat=new uo(e,[new Be("workgroupCount",Qs),new Be("elementCount",Qs)]),this._blockSumBindGroupFormat=new Vr(e,[new Is("input",rs,!0),new Is("local_prefix_sums",rs,!1),new Is("block_sums",rs,!1),new io("uniforms",rs)]),this._reorderBindGroupFormat=new Vr(e,[new Is("inputKeys",rs,!0),new Is("outputKeys",rs,!1),new Is("local_prefix_sum",rs,!0),new Is("prefix_block_sum",rs,!0),new Is("inputValues",rs,!0),new Is("outputValues",rs,!1),new io("uniforms",rs)])}_createPasses(e){this._destroyPasses(),this._numBits=e;const t=e/Y0;for(let s=0;s<t;s++){const i=s*Y0,r=s===0,a=this._createShader(`RadixSort4bit-BlockSum-${i}`,OG,"radix_sort",i,!1,this._blockSumBindGroupFormat),o=this._createShader(`RadixSort4bit-Reorder-${i}`,NG,"radix_sort_reorder",i,r,this._reorderBindGroupFormat),h=new sf(this.device,a,`RadixSort4bit-BlockSum-${i}`),u=new sf(this.device,o,`RadixSort4bit-Reorder-${i}`);this._passes.push({blockSumCompute:h,reorderCompute:u})}}_allocateBuffers(e,t){const s=Math.ceil(e/CP),i=s>this._allocatedWorkgroupCount||!this._keys0,r=t!==this._numBits;if(this._workgroupCount=s,this._dispatchSize=this._findOptimalDispatchSize(s),i){this._destroyBuffers(),this._allocatedWorkgroupCount=s,this._workgroupCount=s,this._dispatchSize=this._findOptimalDispatchSize(s);const a=e*4,o=wP*s*4;this._keys0=new Fs(this.device,a,wa|Ns),this._keys1=new Fs(this.device,a,wa|Ns),this._values0=new Fs(this.device,a,wa|Ns),this._values1=new Fs(this.device,a,wa|Ns),this._localPrefixSums=new Fs(this.device,a,wa|Ns),this._blockSums=new Fs(this.device,o,wa|Ns),this._sortedIndices=new Fs(this.device,a,wa|Ns),this._prefixSumKernel=new IG(this.device)}this._prefixSumKernel.resize(this._blockSums,wP*s),r&&this._createPasses(t)}_findOptimalDispatchSize(e){const t=this.device.limits.maxComputeWorkgroupsPerDimension||65535;if(e<=t)return{x:e,y:1};const s=Math.floor(Math.sqrt(e)),i=Math.ceil(e/s);return{x:s,y:i}}_createShader(e,t,s,i,r,a){const o=new Map;return o.set("{WORKGROUP_SIZE_X}",dL),o.set("{WORKGROUP_SIZE_Y}",fL),o.set("{THREADS_PER_WORKGROUP}",CP),o.set("{CURRENT_BIT}",i),o.set("{IS_FIRST_PASS}",r?1:0),new fo(this.device,{name:e,shaderLanguage:Je,cshader:t,cdefines:o,computeEntryPoint:s,computeBindGroupFormat:a,computeUniformBufferFormats:{uniforms:this._uniformBufferFormat}})}sort(e,t,s=16){this._elementCount=t,this._allocateBuffers(t,s);const i=this.device,r=s/Y0;let a=e,o=this._values0,h=this._keys0,u=this._values1;for(let f=0;f<r;f++){const{blockSumCompute:m,reorderCompute:_}=this._passes[f],g=f===r-1;m.setParameter("input",a),m.setParameter("local_prefix_sums",this._localPrefixSums),m.setParameter("block_sums",this._blockSums),m.setParameter("workgroupCount",this._workgroupCount),m.setParameter("elementCount",t),m.setupDispatch(this._dispatchSize.x,this._dispatchSize.y,1),i.computeDispatch([m],"RadixSort-BlockSum"),this._prefixSumKernel.dispatch(i);const S=g?this._sortedIndices:u;if(_.setParameter("inputKeys",a),_.setParameter("outputKeys",h),_.setParameter("local_prefix_sum",this._localPrefixSums),_.setParameter("prefix_block_sum",this._blockSums),_.setParameter("inputValues",o),_.setParameter("outputValues",S),_.setParameter("workgroupCount",this._workgroupCount),_.setParameter("elementCount",t),_.setupDispatch(this._dispatchSize.x,this._dispatchSize.y,1),i.computeDispatch([_],"RadixSort-Reorder"),!g){a=h,h=a===this._keys0?this._keys1:this._keys0;const x=o;o=u,u=x}}return this._sortedIndices}constructor(e){this._elementCount=0,this._workgroupCount=0,this._allocatedWorkgroupCount=0,this._numBits=0,this._keys0=null,this._keys1=null,this._values0=null,this._values1=null,this._localPrefixSums=null,this._blockSums=null,this._sortedIndices=null,this._prefixSumKernel=null,this._dispatchSize={x:1,y:1},this._blockSumBindGroupFormat=null,this._reorderBindGroupFormat=null,this._uniformBufferFormat=null,this._passes=[],this.device=e,this._createBindGroupFormats()}}class BG{constructor(){this.hasTangents=!1,this.shaderChunks=null,this.pass=0,this.alphaTest=!1,this.blendType=qi,this.separateAmbient=!1,this.screenSpace=!1,this.skin=!1,this.batch=!1,this.useInstancing=!1,this.useMorphPosition=!1,this.useMorphNormal=!1,this.useMorphTextureBasedInt=!1,this.nineSlicedMode=0,this.clusteredLightingEnabled=!0,this.clusteredLightingCookiesEnabled=!1,this.clusteredLightingShadowsEnabled=!1,this.clusteredLightingShadowType=0,this.clusteredLightingAreaLightsEnabled=!1,this.vertexColors=!1,this.useVertexColorGamma=!1,this.lightMapEnabled=!1,this.dirLightMapEnabled=!1,this.useHeights=!1,this.useNormals=!1,this.useClearCoatNormals=!1,this.useAo=!1,this.diffuseMapEnabled=!1,this.pixelSnap=!1,this.ambientSH=!1,this.ssao=!1,this.twoSidedLighting=!1,this.occludeDirect=!1,this.occludeSpecular=0,this.occludeSpecularFloat=!1,this.useMsdf=!1,this.msdfTextAttribute=!1,this.alphaToCoverage=!1,this.opacityFadesSpecular=!1,this.opacityDither=Al,this.opacityShadowDither=Al,this.cubeMapProjection=0,this.useSpecular=!1,this.useSpecularityFactor=!1,this.enableGGXSpecular=!1,this.fresnelModel=0,this.useRefraction=!1,this.useClearCoat=!1,this.useSheen=!1,this.useIridescence=!1,this.useMetalness=!1,this.useDynamicRefraction=!1,this.dispersion=!1,this.fog=Kh,this.gamma=Xf,this.toneMap=-1,this.reflectionSource=$n,this.reflectionEncoding=null,this.reflectionCubemapEncoding=null,this.ambientSource="constant",this.ambientEncoding=null,this.skyboxIntensity=1,this.useCubeMapRotation=!1,this.lightMapWithoutAmbient=!1,this.lights=[],this.noShadow=!1,this.lightMaskDynamic=0,this.userAttributes={},this.linearDepth=!1,this.shadowCatcher=!1}}class hr{static update(e,t,s,i,r,a,o){hr.updateSharedOptions(e,t,s,r,a),hr.updateMaterialOptions(e,t),hr.updateEnvOptions(e,t,s,i),hr.updateLightingOptions(e,t,s,r,o)}static updateSharedOptions(e,t,s,i,r){e.shaderChunks=t.shaderChunks,e.pass=r,e.alphaTest=t.alphaTest>0,e.blendType=t.blendType,e.screenSpace=i&&(i&fg)!==0,e.skin=i&&(i&nf)!==0,e.useInstancing=i&&(i&of)!==0,e.useMorphPosition=i&&(i&lf)!==0,e.useMorphNormal=i&&(i&cf)!==0,e.useMorphTextureBasedInt=i&&(i&hf)!==0,e.hasTangents=i&&(i&YE)!==0,e.nineSlicedMode=t.nineSlicedMode||Nr,t.useLighting&&s.clusteredLightingEnabled?(e.clusteredLightingEnabled=!0,e.clusteredLightingCookiesEnabled=s.lighting.cookiesEnabled,e.clusteredLightingShadowsEnabled=s.lighting.shadowsEnabled,e.clusteredLightingShadowType=s.lighting.shadowType,e.clusteredLightingAreaLightsEnabled=s.lighting.areaLightsEnabled):(e.clusteredLightingEnabled=!1,e.clusteredLightingCookiesEnabled=!1,e.clusteredLightingShadowsEnabled=!1,e.clusteredLightingAreaLightsEnabled=!1)}static updateMaterialOptions(e,t){e.separateAmbient=!1,e.pixelSnap=t.pixelSnap,e.ambientSH=t.ambientSH,e.twoSidedLighting=t.twoSidedLighting,e.occludeDirect=t.occludeDirect,e.occludeSpecular=t.occludeSpecular,e.occludeSpecularFloat=t.occludeSpecularIntensity!==1,e.useMsdf=!1,e.msdfTextAttribute=!1,e.alphaToCoverage=t.alphaToCoverage,e.opacityFadesSpecular=t.opacityFadesSpecular,e.opacityDither=t.opacityDither,e.cubeMapProjection=VE,e.useSpecular=t.hasSpecular,e.useSpecularityFactor=t.hasSpecularityFactor,e.enableGGXSpecular=t.ggxSpecular,e.useAnisotropy=!1,e.fresnelModel=t.fresnelModel,e.useRefraction=t.hasRefraction,e.useClearCoat=t.hasClearCoat,e.useSheen=t.hasSheen,e.useIridescence=t.hasIrridescence,e.useMetalness=t.hasMetalness,e.useDynamicRefraction=t.dynamicRefraction,e.dispersion=t.dispersion>0,e.vertexColors=!1,e.lightMapEnabled=t.hasLighting,e.dirLightMapEnabled=t.dirLightMap,e.useHeights=t.hasHeights,e.useNormals=t.hasNormals,e.useClearCoatNormals=t.hasClearCoatNormals,e.useAo=t.hasAo,e.diffuseMapEnabled=t.hasDiffuseMap}static updateEnvOptions(e,t,s,i){e.fog=t.useFog?i.fog:Kh,e.gamma=i.shaderOutputGamma,e.toneMap=t.useTonemap?i.toneMapping:R2,t.useSkybox&&s.envAtlas&&s.skybox?(e.reflectionSource=hg,e.reflectionEncoding=s.envAtlas.encoding,e.reflectionCubemapEncoding=s.skybox.encoding):t.useSkybox&&s.envAtlas?(e.reflectionSource=cg,e.reflectionEncoding=s.envAtlas.encoding):t.useSkybox&&s.skybox?(e.reflectionSource=ug,e.reflectionEncoding=s.skybox.encoding):(e.reflectionSource=$n,e.reflectionEncoding=null),t.ambientSH?(e.ambientSource=HE,e.ambientEncoding=null):e.reflectionSource!==$n&&s.envAtlas?(e.ambientSource=WE,e.ambientEncoding=s.envAtlas.encoding):(e.ambientSource=XE,e.ambientEncoding=null);const r=e.reflectionSource!==$n;e.skyboxIntensity=r,e.useCubeMapRotation=r&&s._skyboxRotationShaderInclude}static updateLightingOptions(e,t,s,i,r){if(e.lightMapWithoutAmbient=!1,t.useLighting){const a=[],o=i?i>>16:Qi;e.lightMaskDynamic=!!(o&Qi),e.lightMapWithoutAmbient=!1,r&&(hr.collectLights(Ne,r[Ne],a,o),s.clusteredLightingEnabled||(hr.collectLights(wt,r[wt],a,o),hr.collectLights(bt,r[bt],a,o))),e.lights=a}else e.lights=[];(e.lights.length===0&&!s.clusteredLightingEnabled||(i&dg)!==0)&&(e.noShadow=!0)}static collectLights(e,t,s,i){for(let r=0;r<t.length;r++){const a=t[r];a.enabled&&a.mask&i&&s.push(a)}}}const j0={vertex_normal:si,vertex_tangent:Xr,vertex_texCoord0:Zi,vertex_texCoord1:Il,vertex_color:Rs,vertex_boneWeights:kr,vertex_boneIndices:yi};class UG{fDefineSet(e,t,s=""){e&&this.fDefines.set(t,s)}generateVertexShader(e,t,s){const{options:i,vDefines:r,attributes:a}=this,o=new Map;if(o.set("vPositionW","vec3"),(i.nineSlicedMode===hs||i.nineSlicedMode===us)&&r.set("NINESLICED",!0),this.options.linearDepth&&(r.set("LINEAR_DEPTH",!0),o.set("vLinearDepth","float")),this.needsNormal&&r.set("NORMALS",!0),this.options.useInstancing){const m=Ue.get(this.device,this.shaderLanguage);this.chunks.get("transformInstancingVS")===m.get("transformInstancingVS")&&(a.instance_line1=gE,a.instance_line2=vE,a.instance_line3=SE,a.instance_line4=Eh)}this.needsNormal&&(a.vertex_normal=si,o.set("vNormalW","vec3"),i.hasTangents&&(i.useHeights||i.useNormals||i.useClearCoatNormals||i.enableGGXSpecular)?(r.set("TANGENTS",!0),a.vertex_tangent=Xr,o.set("vTangentW","vec3"),o.set("vBinormalW","vec3")):i.enableGGXSpecular&&(r.set("GGX_SPECULAR",!0),o.set("vObjectSpaceUpW","vec3")));const h=2;for(let m=0;m<h;m++)e[m]&&(r.set(`UV${m}`,!0),a[`vertex_texCoord${m}`]=`TEXCOORD${m}`),t[m]&&(r.set(`UV${m}_UNMODIFIED`,!0),o.set(`vUv${m}`,"vec2"));let u=0;const f=new Set;s.forEach(m=>{const{id:_,uv:g,name:S}=m,x=_+g*100;if(!f.has(x)){f.add(x),o.set(`vUV${g}_${_}`,"vec2");const T=`texture_${S}MapTransform`;r.set(`{TRANSFORM_NAME_${u}}`,T),r.set(`{TRANSFORM_UV_${u}}`,g),r.set(`{TRANSFORM_ID_${u}}`,_),u++}}),r.set("UV_TRANSFORMS_COUNT",u),i.vertexColors&&(a.vertex_color=Rs,r.set("VERTEX_COLOR",!0),o.set("vVertexColor","vec4"),i.useVertexColorGamma&&r.set("STD_VERTEX_COLOR_GAMMA","")),i.useMsdf&&i.msdfTextAttribute&&(a.vertex_outlineParameters=jd,a.vertex_shadowParameters=$d,r.set("MSDF",!0)),(i.useMorphPosition||i.useMorphNormal)&&(r.set("MORPHING",!0),i.useMorphTextureBasedInt&&r.set("MORPHING_INT",!0),i.useMorphPosition&&r.set("MORPHING_POSITION",!0),i.useMorphNormal&&r.set("MORPHING_NORMAL",!0),a.morph_vertex_id=Eh),i.skin&&(a.vertex_boneIndices=yi,i.batch?r.set("BATCH",!0):(a.vertex_boneWeights=kr,r.set("SKIN",!0))),i.useInstancing&&r.set("INSTANCING",!0),i.screenSpace&&r.set("SCREENSPACE",!0),i.pixelSnap&&r.set("PIXELSNAP",!0),o.forEach((m,_)=>{this.varyingsCode+=`#define VARYING_${_.toUpperCase()}
`,this.varyingsCode+=this.shaderLanguage===Je?`varying ${_}: ${r2.get(m)};
`:`varying ${m} ${_};
`}),this.includes.set("varyingsVS",this.varyingsCode),this.includes.set("varyingsPS",this.varyingsCode),this.vshader=`
						#include "litMainVS"
				`}_setupLightingDefines(e,t){const s=this.fDefines,i=this.options;if(this.fDefines.set("LIGHT_COUNT",i.lights.length),e&&s.set("AREA_LIGHTS",!0),t&&this.lighting&&(s.set("LIT_CLUSTERED_LIGHTS",!0),i.clusteredLightingCookiesEnabled&&s.set("CLUSTER_COOKIES",!0),i.clusteredLightingAreaLightsEnabled&&s.set("CLUSTER_AREALIGHTS",!0),i.lightMaskDynamic&&s.set("CLUSTER_MESH_DYNAMIC_LIGHTS",!0),i.clusteredLightingShadowsEnabled&&!i.noShadow)){const r=Xa.get(i.clusteredLightingShadowType);s.set("CLUSTER_SHADOWS",!0),s.set(`SHADOW_KIND_${r.kind}`,!0),s.set(`CLUSTER_SHADOW_TYPE_${r.kind}`,!0)}for(let r=0;r<i.lights.length;r++){const a=i.lights[r],o=a._type;if(t&&o!==Ne)continue;const h=e&&a._shape?a._shape:_r,u=a._shadowType,f=a.castShadows&&!i.noShadow,m=Xa.get(u);s.set(`LIGHT${r}`,!0),s.set(`LIGHT${r}TYPE`,`${wD[o]}`),s.set(`LIGHT${r}SHADOWTYPE`,`${m.name}`),s.set(`LIGHT${r}SHAPE`,`${kk[h]}`),s.set(`LIGHT${r}FALLOFF`,`${Vk[a._falloffMode]}`),a.affectSpecularity&&s.set(`LIGHT${r}AFFECT_SPECULARITY`,!0),a._cookie&&(o===bt&&!a._cookie._cubemap||o===wt&&a._cookie._cubemap)&&(s.set(`LIGHT${r}COOKIE`,!0),s.set(`{LIGHT${r}COOKIE_CHANNEL}`,a._cookieChannel),o===bt&&(a._cookieTransform&&s.set(`LIGHT${r}COOKIE_TRANSFORM`,!0),a._cookieFalloff&&s.set(`LIGHT${r}COOKIE_FALLOFF`,!0))),f&&(s.set(`LIGHT${r}CASTSHADOW`,!0),m.pcf&&s.set(`LIGHT${r}SHADOW_PCF`,!0),a._normalOffsetBias&&!a._isVsm&&s.set(`LIGHT${r}_SHADOW_SAMPLE_NORMAL_OFFSET`,!0),o===Ne&&(s.set(`LIGHT${r}_SHADOW_SAMPLE_ORTHO`,!0),a.cascadeBlend>0&&s.set(`LIGHT${r}_SHADOW_CASCADE_BLEND`,!0),a.numCascades>1&&s.set(`LIGHT${r}_SHADOW_CASCADES`,!0)),(m.pcf||m.pcss||this.device.isWebGPU)&&s.set(`LIGHT${r}_SHADOW_SAMPLE_SOURCE_ZBUFFER`,!0),o===wt&&s.set(`LIGHT${r}_SHADOW_SAMPLE_POINT`,!0)),f&&(s.set(`SHADOW_KIND_${m.kind}`,!0),o===Ne&&s.set("SHADOW_DIRECTIONAL",!0))}}prepareForwardPass(e){const{options:t}=this,i=t.clusteredLightingEnabled&&t.clusteredLightingAreaLightsEnabled||t.lights.some(o=>o._shape&&o._shape!==_r),r=!t.lightMapEnabled||t.lightMapWithoutAmbient,a=this.needsNormal&&(t.useNormals||t.useClearCoatNormals||t.enableGGXSpecular&&!t.useHeights);t.useSpecular&&(this.fDefineSet(!0,"LIT_SPECULAR"),this.fDefineSet(this.reflections,"LIT_REFLECTIONS"),this.fDefineSet(t.useClearCoat,"LIT_CLEARCOAT"),this.fDefineSet(t.fresnelModel>0,"LIT_SPECULAR_FRESNEL"),this.fDefineSet(t.useSheen,"LIT_SHEEN"),this.fDefineSet(t.useIridescence,"LIT_IRIDESCENCE")),this.fDefineSet(this.lighting&&t.useSpecular||this.reflections,"LIT_SPECULAR_OR_REFLECTION"),this.fDefineSet(this.needsSceneColor,"LIT_SCENE_COLOR"),this.fDefineSet(this.needsScreenSize,"LIT_SCREEN_SIZE"),this.fDefineSet(this.needsTransforms,"LIT_TRANSFORMS"),this.fDefineSet(this.needsNormal,"LIT_NEEDS_NORMAL"),this.fDefineSet(this.lighting,"LIT_LIGHTING"),this.fDefineSet(t.useMetalness,"LIT_METALNESS"),this.fDefineSet(t.enableGGXSpecular,"LIT_GGX_SPECULAR"),this.fDefineSet(t.useAnisotropy,"LIT_ANISOTROPY"),this.fDefineSet(t.useSpecularityFactor,"LIT_SPECULARITY_FACTOR"),this.fDefineSet(t.useCubeMapRotation,"CUBEMAP_ROTATION"),this.fDefineSet(t.occludeSpecularFloat,"LIT_OCCLUDE_SPECULAR_FLOAT"),this.fDefineSet(t.separateAmbient,"LIT_SEPARATE_AMBIENT"),this.fDefineSet(t.twoSidedLighting,"LIT_TWO_SIDED_LIGHTING"),this.fDefineSet(t.lightMapEnabled,"LIT_LIGHTMAP"),this.fDefineSet(t.dirLightMapEnabled,"LIT_DIR_LIGHTMAP"),this.fDefineSet(t.skyboxIntensity>0,"LIT_SKYBOX_INTENSITY"),this.fDefineSet(t.clusteredLightingShadowsEnabled,"LIT_CLUSTERED_SHADOWS"),this.fDefineSet(t.clusteredLightingAreaLightsEnabled,"LIT_CLUSTERED_AREA_LIGHTS"),this.fDefineSet(a,"LIT_TBN"),this.fDefineSet(r,"LIT_ADD_AMBIENT"),this.fDefineSet(t.hasTangents,"LIT_TANGENTS"),this.fDefineSet(t.useNormals,"LIT_USE_NORMALS"),this.fDefineSet(t.useClearCoatNormals,"LIT_USE_CLEARCOAT_NORMALS"),this.fDefineSet(t.useRefraction,"LIT_REFRACTION"),this.fDefineSet(t.useDynamicRefraction,"LIT_DYNAMIC_REFRACTION"),this.fDefineSet(t.dispersion,"LIT_DISPERSION"),this.fDefineSet(t.useHeights,"LIT_HEIGHTS"),this.fDefineSet(t.opacityFadesSpecular,"LIT_OPACITY_FADES_SPECULAR"),this.fDefineSet(t.alphaToCoverage,"LIT_ALPHA_TO_COVERAGE"),this.fDefineSet(t.alphaTest,"LIT_ALPHA_TEST"),this.fDefineSet(t.useMsdf,"LIT_MSDF"),this.fDefineSet(t.ssao,"LIT_SSAO"),this.fDefineSet(t.useAo,"LIT_AO"),this.fDefineSet(t.occludeDirect,"LIT_OCCLUDE_DIRECT"),this.fDefineSet(t.msdfTextAttribute,"LIT_MSDF_TEXT_ATTRIBUTE"),this.fDefineSet(t.diffuseMapEnabled,"LIT_DIFFUSE_MAP"),this.fDefineSet(t.shadowCatcher,"LIT_SHADOW_CATCHER"),this.fDefineSet(!0,"LIT_FRESNEL_MODEL",Uk[t.fresnelModel]),this.fDefineSet(!0,"LIT_NONE_SLICE_MODE",Qk[t.nineSlicedMode]),this.fDefineSet(!0,"LIT_BLEND_TYPE",S2[t.blendType]),this.fDefineSet(!0,"LIT_CUBEMAP_PROJECTION",Yk[t.cubeMapProjection]),this.fDefineSet(!0,"LIT_OCCLUDE_SPECULAR",$k[t.occludeSpecular]),this.fDefineSet(!0,"LIT_REFLECTION_SOURCE",Kk[t.reflectionSource]),this.fDefineSet(!0,"LIT_AMBIENT_SOURCE",Zk[t.ambientSource]),this.fDefineSet(!0,"{lightingUv}",e??""),this.fDefineSet(!0,"{reflectionDecode}",Zn.decodeFunc(t.reflectionEncoding)),this.fDefineSet(!0,"{reflectionCubemapDecode}",Zn.decodeFunc(t.reflectionCubemapEncoding)),this.fDefineSet(!0,"{ambientDecode}",Zn.decodeFunc(t.ambientEncoding)),this._setupLightingDefines(i,t.clusteredLightingEnabled)}prepareShadowPass(){const{options:e}=this,t=this.shaderPassInfo.lightType,s=this.shaderPassInfo.shadowType,i=Xa.get(s),r=t===Ne||!i.vsm&&t===bt;this.fDefineSet(r,"PERSPECTIVE_DEPTH"),this.fDefineSet(!0,"LIGHT_TYPE",`${wD[t]}`),this.fDefineSet(!0,"SHADOW_TYPE",`${i.name}`),this.fDefineSet(e.alphaTest,"LIT_ALPHA_TEST")}generateFragmentShader(e,t,s){const i=this.options;this.includes.set("frontendDeclPS",e??""),this.includes.set("frontendCodePS",t??""),i.pass===qf||i.pass===Rv||(this.shadowPass?this.prepareShadowPass():this.prepareForwardPass(s)),this.fshader=`
						#include "litMainPS"
				`}constructor(e,t,s=!0){this.varyingsCode="",this.vDefines=new Map,this.fDefines=new Map,this.includes=new Map,this.chunks=null,this.device=e,this.options=t;const i=t.shaderChunks;if(this.shaderLanguage=e.isWebGPU&&s&&(!i||i.useWGSL)?Je:ot,e.isWebGPU&&this.shaderLanguage===ot&&e.hasTranspilers,this.attributes={vertex_position:He},t.userAttributes)for(const[a,o]of Object.entries(t.userAttributes))this.attributes[o]=a;const r=Ue.get(e,this.shaderLanguage);this.chunks=new Map(r),i&&(this.shaderLanguage===ot?i.glsl:i.wgsl).forEach((o,h)=>{for(const u in j0)j0.hasOwnProperty(u)&&o.indexOf(u)>=0&&(this.attributes[u]=j0[u]);this.chunks.set(h,o)}),this.shaderPassInfo=Gr.get(this.device).getByIndex(t.pass),this.shadowPass=this.shaderPassInfo.isShadow,this.lighting=t.lights.length>0||t.dirLightMapEnabled||t.clusteredLightingEnabled,this.reflections=t.reflectionSource!==$n,this.needsNormal=this.lighting||this.reflections||t.useSpecular||t.ambientSH||t.useHeights||t.enableGGXSpecular||t.clusteredLightingEnabled&&!this.shadowPass||t.useClearCoatNormals,this.needsNormal=this.needsNormal&&!this.shadowPass,this.needsSceneColor=t.useDynamicRefraction,this.needsScreenSize=t.useDynamicRefraction,this.needsTransforms=t.useDynamicRefraction,this.vshader=null,this.fshader=null}}const mL={generateKey(c){return`lit${Object.keys(c).sort().map(e=>e==="shaderChunks"?c.shaderChunks?.key??"":e==="lights"?mL.generateLightsKey(c):e+c[e]).join(`
`)}`},generateLightsKey(c){return`lights:${c.lights.map(e=>!c.clusteredLightingEnabled||e._type===Ne?`${e.key},`:"").join("")}`}};class _g{get pass(){return this.litOptions.pass}constructor(){this.defines=new Map,this.forceUv1=!1,this.specularTint=!1,this.metalnessTint=!1,this.glossTint=!1,this.emissiveEncoding="linear",this.lightMapEncoding="linear",this.vertexColorGamma=!1,this.packedNormal=!1,this.normalDetailPackedNormal=!1,this.clearCoatPackedNormal=!1,this.glossInvert=!1,this.sheenGlossInvert=!1,this.clearCoatGlossInvert=!1,this.useAO=!1,this.litOptions=new BG}}const Sh=[],$0=c=>Object.keys(c).filter(e=>e!=="litOptions").sort();class zG extends wl{generateKey(e){let t;return e===this.optionsContextMin?(this.propsMin||(this.propsMin=$0(e)),t=this.propsMin):e===this.optionsContext?(this.props||(this.props=$0(e)),t=this.props):t=$0(e),`standard:
${wl.definesHash(e.defines)}
${t.map(r=>r+e[r]).join(`
`)}${mL.generateKey(e.litOptions)}`}_getUvSourceExpression(e,t,s){const i=s[e],r=s[t],a=s.litOptions.pass===Zh;let o;return a&&s.litOptions.nineSlicedMode===hs||a&&s.litOptions.nineSlicedMode===us?o="nineSlicedUv":(i===0?o=`vUv${r}`:o=`vUV${r}_${i}`,s.heightMap&&e!=="heightMapTransform"&&(o+=" + dUvOffset")),o}_validateMapChunk(e,t,s,i){}_addMapDefines(e,t,s,i,r,a,o=null){const h=`${t}Map`,u=t.toUpperCase(),f=`${h}Uv`,m=`${h}Identifier`,_=`${h}Transform`,g=`${h}Channel`,S=`${t}VertexColorChannel`,x=`${t}Tint`,T=`${t}VertexColor`,E=`${t}Mode`,b=`${t}Invert`,C=i[x],w=i[T],P=i[h],I=i[m],M=i[E],R=r.get(s);if(P){e.set(`STD_${u}_TEXTURE`,"");const L=this._getUvSourceExpression(_,f,i);e.set(`{STD_${u}_TEXTURE_UV}`,L),e.set(`{STD_${u}_TEXTURE_CHANNEL}`,i[g]);const B=`{STD_${u}_TEXTURE_NAME}`;if(R.includes(B)){let G=`texture_${h}`;const H=a[I];H?G=H:(a[I]=G,e.set(`STD_${u}_TEXTURE_ALLOCATE`,"")),e.set(B,G)}if(o){const G=i[g]==="aaa"?"passThrough":Zn.decodeFunc(o);e.set(`{STD_${u}_TEXTURE_DECODE}`,G)}}w&&(e.set(`STD_${u}_VERTEX`,""),e.set(`{STD_${u}_VERTEX_CHANNEL}`,i[S])),M&&e.set(`{STD_${u}_DETAILMODE}`,M),C&&e.set(`STD_${u}_CONSTANT`,""),i[b]&&e.set(`STD_${u}_INVERT`,"")}_correctChannel(e,t,s){if(s[e]>0){if(s[e]<t.length)return t.substring(0,s[e]);if(s[e]>t.length){let i=t;const r=i.charAt(i.length-1),a=s[e]-i.length;for(let o=0;o<a;o++)i+=r;return i}return t}}createVertexShader(e,t){const s=[],i=[],r=[];for(const o in Sh){const h=`${o}Map`;if(t[`${o}VertexColor`]){const u=`${o}VertexColorChannel`;t[u]=this._correctChannel(o,t[u],Sh)}if(t[h]){const u=`${h}Channel`,f=`${h}Transform`,m=`${h}Uv`;t[m]=Math.min(t[m],1),t[u]=this._correctChannel(o,t[u],Sh);const _=t[m];s[_]=!0,i[_]=i[_]||t[h]&&!t[f],t[f]&&r.push({name:o,id:t[f],uv:t[m]})}}t.forceUv1&&(s[1]=!0,i[1]=i[1]!==void 0?i[1]:!0),e.generateVertexShader(s,i,r)}prepareFragmentDefines(e,t,s){const i=(r,a,o="")=>{r&&t.set(a,o)};i(e.lightMap,"STD_LIGHTMAP",""),i(e.lightVertexColor,"STD_LIGHT_VERTEX_COLOR",""),i(e.dirLightMap&&e.litOptions.useSpecular,"STD_LIGHTMAP_DIR",""),i(e.heightMap,"STD_HEIGHT_MAP",""),i(e.useSpecularColor,"STD_SPECULAR_COLOR",""),i(e.aoMap||e.aoVertexColor||e.useAO,"STD_AO",""),i(!0,"STD_OPACITY_DITHER",oV[s.isForward?e.litOptions.opacityDither:e.litOptions.opacityShadowDither])}createShaderDefinition(e,t){const s=Gr.get(e).getByIndex(t.litOptions.pass),i=s.isForward,r=new UG(e,t.litOptions);this.createVertexShader(r,t);const a={};t.litOptions.fresnelModel=t.litOptions.fresnelModel===0?NE:t.litOptions.fresnelModel;const o=r.fDefines;this.prepareFragmentDefines(t,o,s);let h="";if(i){if(t.heightMap&&this._addMapDefines(o,"height","parallaxPS",t,r.chunks,a),(t.litOptions.blendType!==qi||t.litOptions.alphaTest||t.litOptions.alphaToCoverage||t.litOptions.opacityDither!==Al)&&this._addMapDefines(o,"opacity","opacityPS",t,r.chunks,a),r.needsNormal){if((t.normalMap||t.clearCoatNormalMap)&&!t.litOptions.hasTangents){const _=t.normalMap?"normalMap":"clearCoatNormalMap";h=this._getUvSourceExpression(`${_}Transform`,`${_}Uv`,t)}this._addMapDefines(o,"normalDetail","normalMapPS",t,r.chunks,a,t.normalDetailPackedNormal?"xy":"xyz"),this._addMapDefines(o,"normal","normalMapPS",t,r.chunks,a,t.packedNormal?"xy":"xyz")}t.diffuseDetail&&this._addMapDefines(o,"diffuseDetail","diffusePS",t,r.chunks,a,t.diffuseDetailEncoding),this._addMapDefines(o,"diffuse","diffusePS",t,r.chunks,a,t.diffuseEncoding),t.litOptions.useRefraction&&(this._addMapDefines(o,"refraction","transmissionPS",t,r.chunks,a),this._addMapDefines(o,"thickness","thicknessPS",t,r.chunks,a)),t.litOptions.useIridescence&&(this._addMapDefines(o,"iridescence","iridescencePS",t,r.chunks,a),this._addMapDefines(o,"iridescenceThickness","iridescenceThicknessPS",t,r.chunks,a)),(r.lighting&&t.litOptions.useSpecular||r.reflections)&&(t.litOptions.useSheen&&(this._addMapDefines(o,"sheen","sheenPS",t,r.chunks,a,t.sheenEncoding),this._addMapDefines(o,"sheenGloss","sheenGlossPS",t,r.chunks,a)),t.litOptions.useMetalness&&(this._addMapDefines(o,"metalness","metalnessPS",t,r.chunks,a),this._addMapDefines(o,"ior","iorPS",t,r.chunks,a)),t.litOptions.useSpecularityFactor&&this._addMapDefines(o,"specularityFactor","specularityFactorPS",t,r.chunks,a),t.useSpecularColor&&this._addMapDefines(o,"specular","specularPS",t,r.chunks,a,t.specularEncoding),this._addMapDefines(o,"gloss","glossPS",t,r.chunks,a)),t.aoDetail&&this._addMapDefines(o,"aoDetail","aoPS",t,r.chunks,a),(t.aoMap||t.aoVertexColor||t.useAO)&&this._addMapDefines(o,"ao","aoPS",t,r.chunks,a),this._addMapDefines(o,"emissive","emissivePS",t,r.chunks,a,t.emissiveEncoding),t.litOptions.useClearCoat&&(this._addMapDefines(o,"clearCoat","clearCoatPS",t,r.chunks,a),this._addMapDefines(o,"clearCoatGloss","clearCoatGlossPS",t,r.chunks,a),this._addMapDefines(o,"clearCoatNormal","clearCoatNormalPS",t,r.chunks,a,t.clearCoatPackedNormal?"xy":"xyz")),t.litOptions.enableGGXSpecular&&this._addMapDefines(o,"anisotropy","anisotropyPS",t,r.chunks,a),(t.lightMap||t.lightVertexColor)&&this._addMapDefines(o,"light","lightmapPS",t,r.chunks,a,t.lightMapEncoding)}else{const _=t.litOptions.opacityShadowDither;(t.litOptions.alphaTest||_)&&this._addMapDefines(o,"opacity","opacityPS",t,r.chunks,a)}r.generateFragmentShader(r.chunks.get("stdDeclarationPS"),r.chunks.get("stdFrontEndPS"),h);const u=mg.merge(r.chunks,r.includes),f=r.vDefines;t.defines.forEach((_,g)=>f.set(g,_)),t.defines.forEach((_,g)=>o.set(g,_));const m=Os.createDefinition(e,{name:"StandardShader",attributes:r.attributes,shaderLanguage:r.shaderLanguage,vertexCode:r.vshader,fragmentCode:r.fshader,vertexIncludes:u,fragmentIncludes:u,fragmentDefines:o,vertexDefines:f});return r.shaderPassInfo.isForward&&(m.tag=BB),m}constructor(...e){super(...e),this.optionsContext=new _g,this.optionsContextMin=new _g}}const K0=new zG,DP=(c,e)=>{if(c.length!==e.length)return!1;for(let t=0;t<c.length;++t)if(c[t]!==e[t])return!1;return!0},kG=c=>c.r!==1||c.g!==1||c.b!==1,VG=c=>c.r!==0||c.g!==0||c.b!==0;class GG{updateMinRef(e,t,s,i,r,a){this._updateSharedOptions(e,t,s,i,r),this._updateMinOptions(e,s,r),this._updateUVOptions(e,s,i,!0)}updateRef(e,t,s,i,r,a,o){this._updateSharedOptions(e,t,i,r,a),this._updateEnvOptions(e,i,t,s),this._updateMaterialOptions(e,i,t),e.litOptions.hasTangents=r&&(r&YE)!==0,this._updateLightOptions(e,t,i,r,o),this._updateUVOptions(e,i,r,!1,s)}_updateSharedOptions(e,t,s,i,r){e.forceUv1=s.forceUv1,s.userAttributes&&(e.litOptions.userAttributes=Object.fromEntries(s.userAttributes.entries())),e.litOptions.shaderChunks=s.shaderChunks,e.litOptions.pass=r,e.litOptions.alphaTest=s.alphaTest>0,e.litOptions.blendType=s.blendType,e.litOptions.screenSpace=i&&(i&fg)!==0,e.litOptions.skin=i&&(i&nf)!==0,e.litOptions.batch=i&&(i&b_)!==0,e.litOptions.useInstancing=i&&(i&of)!==0,e.litOptions.useMorphPosition=i&&(i&lf)!==0,e.litOptions.useMorphNormal=i&&(i&cf)!==0,e.litOptions.useMorphTextureBasedInt=i&&(i&hf)!==0,e.litOptions.nineSlicedMode=s.nineSlicedMode||0,t.clusteredLightingEnabled&&s.useLighting?(e.litOptions.clusteredLightingEnabled=!0,e.litOptions.clusteredLightingCookiesEnabled=t.lighting.cookiesEnabled,e.litOptions.clusteredLightingShadowsEnabled=t.lighting.shadowsEnabled,e.litOptions.clusteredLightingShadowType=t.lighting.shadowType,e.litOptions.clusteredLightingAreaLightsEnabled=t.lighting.areaLightsEnabled):(e.litOptions.clusteredLightingEnabled=!1,e.litOptions.clusteredLightingCookiesEnabled=!1,e.litOptions.clusteredLightingShadowsEnabled=!1,e.litOptions.clusteredLightingAreaLightsEnabled=!1)}_updateUVOptions(e,t,s,i,r){let a=!1,o=!1,h=!1;s&&(a=(s&qE)!==0,o=(s&N2)!==0,h=(s&F2)!==0),e.litOptions.vertexColors=!1,this._mapXForms=[];const u={};for(const f in Sh)this._updateTexOptions(e,t,f,a,o,h,i,u);this._mapXForms=null,e.litOptions.ssao=r?.ssaoEnabled,e.useAO=e.litOptions.ssao,e.litOptions.lightMapEnabled=e.lightMap,e.litOptions.dirLightMapEnabled=e.dirLightMap,e.litOptions.useHeights=e.heightMap,e.litOptions.useNormals=e.normalMap,e.litOptions.useClearCoatNormals=e.clearCoatNormalMap,e.litOptions.useAo=e.aoMap||e.aoVertexColor||e.litOptions.ssao,e.litOptions.diffuseMapEnabled=e.diffuseMap}_updateTexOptions(e,t,s,i,r,a,o,h){const u=s==="opacity";if(!o||u){const f=`${s}Map`,m=`${s}VertexColor`,_=`${s}VertexColorChannel`,g=`${f}Channel`,S=`${f}Transform`,x=`${f}Uv`,T=`${f}Identifier`;if(s!=="light"&&(e[f]=!1,e[T]=void 0,e[g]="",e[S]=0,e[x]=0),e[m]=!1,e[_]="",u&&t.blendType===qi&&t.alphaTest===0&&!t.alphaToCoverage&&t.opacityDither===Al)return;if(s!=="height"&&t[m]&&a&&(e[m]=t[m],e[_]=t[_],e.litOptions.vertexColors=!0),t[f]){let E=!0;if(t[x]===0&&!i&&(E=!1),t[x]===1&&!r&&(E=!1),E){const b=t[f].id;let C=h[b];C===void 0&&(h[b]=s,C=s),e[f]=!!t[f],e[T]=C,e[S]=this._getMapTransformID(t.getUniform(S),t[x]),e[g]=t[g],e[x]=t[x]}}}}_updateMinOptions(e,t,s){const i=s===Rv;e.litOptions.opacityShadowDither=i?t.opacityDither:t.opacityShadowDither,e.litOptions.linearDepth=i,e.litOptions.lights=[]}_updateMaterialOptions(e,t,s){const i=!!(t.useMetalness||t.specularMap||t.sphereMap||t.cubeMap||VG(t.specular)||t.specularityFactor>0&&t.useMetalness||t.enableGGXSpecular||t.clearCoat>0),r=!t.useMetalness||t.useMetalnessSpecularColor,a=i&&(t.specularTint||!t.specularMap&&!t.specularVertexColor)&&kG(t.specular),o=i&&t.useMetalnessSpecularColor&&(t.specularityFactorTint||t.specularityFactor<1&&!t.specularityFactorMap),h=f=>f?f.format===kh||f.type===yE:!1,u=(f,m)=>Math.abs(f-m)<1e-4;e.specularTint=a,e.specularityFactorTint=o,e.metalnessTint=t.useMetalness&&t.metalness<1,e.glossTint=!0,e.diffuseEncoding=t.diffuseMap?.encoding,e.diffuseDetailEncoding=t.diffuseDetailMap?.encoding,e.emissiveEncoding=t.emissiveMap?.encoding,e.lightMapEncoding=t.lightMap?.encoding,e.packedNormal=h(t.normalMap),e.refractionTint=!u(t.refraction,1),e.refractionIndexTint=!u(t.refractionIndex,1/1.5),e.thicknessTint=t.useDynamicRefraction&&t.thickness!==1,e.specularEncoding=t.specularMap?.encoding,e.sheenEncoding=t.sheenMap?.encoding,e.aoMapUv=t.aoUvSet,e.aoDetail=!!t.aoDetailMap,e.diffuseDetail=!!t.diffuseDetailMap,e.normalDetail=!!t.normalMap,e.normalDetailPackedNormal=h(t.normalDetailMap),e.diffuseDetailMode=t.diffuseDetailMode,e.aoDetailMode=t.aoDetailMode,e.clearCoatGloss=!!t.clearCoatGloss,e.clearCoatPackedNormal=h(t.clearCoatNormalMap),e.iorTint=!u(t.refractionIndex,1/1.5),s.forcePassThroughSpecular&&(e.specularEncoding="linear",e.sheenEncoding="linear"),e.iridescenceTint=t.iridescence!==1,e.glossInvert=t.glossInvert,e.sheenGlossInvert=t.sheenGlossInvert,e.clearCoatGlossInvert=t.clearCoatGlossInvert,e.useSpecularColor=r,e.litOptions.separateAmbient=!1,e.litOptions.pixelSnap=t.pixelSnap,e.litOptions.ambientSH=!!t.ambientSH,e.litOptions.twoSidedLighting=t.twoSidedLighting,e.litOptions.occludeSpecular=t.occludeSpecular,e.litOptions.occludeSpecularFloat=t.occludeSpecularIntensity!==1,e.litOptions.useMsdf=!!t.msdfMap,e.litOptions.msdfTextAttribute=!!t.msdfTextAttribute,e.litOptions.alphaToCoverage=t.alphaToCoverage,e.litOptions.opacityFadesSpecular=t.opacityFadesSpecular,e.litOptions.opacityDither=t.opacityDither,e.litOptions.cubeMapProjection=t.cubeMapProjection,e.litOptions.occludeDirect=t.occludeDirect,e.litOptions.useSpecular=i,e.litOptions.useSpecularityFactor=(o||!!t.specularityFactorMap)&&t.useMetalnessSpecularColor,e.litOptions.enableGGXSpecular=t.enableGGXSpecular,e.litOptions.useAnisotropy=t.enableGGXSpecular&&(t.anisotropyIntensity>0||!!t.anisotropyMap),e.litOptions.fresnelModel=t.fresnelModel,e.litOptions.useRefraction=(t.refraction||!!t.refractionMap)&&(t.useDynamicRefraction||e.litOptions.reflectionSource!==$n),e.litOptions.useClearCoat=!!t.clearCoat,e.litOptions.useSheen=t.useSheen,e.litOptions.useIridescence=t.useIridescence&&t.iridescence!==0,e.litOptions.useMetalness=t.useMetalness,e.litOptions.useDynamicRefraction=t.useDynamicRefraction,e.litOptions.dispersion=t.dispersion>0,e.litOptions.shadowCatcher=t.shadowCatcher,e.litOptions.useVertexColorGamma=t.vertexColorGamma}_updateEnvOptions(e,t,s,i){e.litOptions.fog=t.useFog?i.fog:Kh,e.litOptions.gamma=i.shaderOutputGamma,e.litOptions.toneMap=t.useTonemap?i.toneMapping:R2;let r=!1;if(t.envAtlas&&t.cubeMap?(e.litOptions.reflectionSource=hg,e.litOptions.reflectionEncoding=t.envAtlas.encoding,e.litOptions.reflectionCubemapEncoding=t.cubeMap.encoding):t.envAtlas?(e.litOptions.reflectionSource=cg,e.litOptions.reflectionEncoding=t.envAtlas.encoding):t.cubeMap?(e.litOptions.reflectionSource=ug,e.litOptions.reflectionEncoding=t.cubeMap.encoding):t.sphereMap?(e.litOptions.reflectionSource=O2,e.litOptions.reflectionEncoding=t.sphereMap.encoding):t.useSkybox&&s.envAtlas&&s.skybox?(e.litOptions.reflectionSource=hg,e.litOptions.reflectionEncoding=s.envAtlas.encoding,e.litOptions.reflectionCubemapEncoding=s.skybox.encoding,r=!0):t.useSkybox&&s.envAtlas?(e.litOptions.reflectionSource=cg,e.litOptions.reflectionEncoding=s.envAtlas.encoding,r=!0):t.useSkybox&&s.skybox?(e.litOptions.reflectionSource=ug,e.litOptions.reflectionEncoding=s.skybox.encoding,r=!0):(e.litOptions.reflectionSource=$n,e.litOptions.reflectionEncoding=null),t.ambientSH)e.litOptions.ambientSource=HE,e.litOptions.ambientEncoding=null;else{const a=t.envAtlas||(t.useSkybox&&s.envAtlas?s.envAtlas:null);a&&!t.sphereMap?(e.litOptions.ambientSource=WE,e.litOptions.ambientEncoding=a.encoding):(e.litOptions.ambientSource=XE,e.litOptions.ambientEncoding=null)}e.litOptions.skyboxIntensity=r,e.litOptions.useCubeMapRotation=r&&s._skyboxRotationShaderInclude}_updateLightOptions(e,t,s,i,r){if(e.lightMap=!1,e.lightMapChannel="",e.lightMapUv=0,e.lightMapTransform=0,e.litOptions.lightMapWithoutAmbient=!1,e.dirLightMap=!1,i&&(e.litOptions.noShadow=(i&dg)!==0,(i&Kx)!==0&&(e.lightMapEncoding=t.lightmapPixelFormat===Ze?"rgbm":"linear",e.lightMap=!0,e.lightMapChannel="rgb",e.lightMapUv=1,e.lightMapTransform=0,e.litOptions.lightMapWithoutAmbient=!s.lightMap,(i&B2)!==0&&(e.dirLightMap=!0),(i&U2)!==0&&(e.litOptions.lightMapWithoutAmbient=!1))),s.useLighting){const a=[],o=i?i>>16:Qi;e.litOptions.lightMaskDynamic=!!(o&Qi),r&&(hr.collectLights(Ne,r[Ne],a,o),t.clusteredLightingEnabled||(hr.collectLights(wt,r[wt],a,o),hr.collectLights(bt,r[bt],a,o))),e.litOptions.lights=a}else e.litOptions.lights=[];e.litOptions.lights.length===0&&!t.clusteredLightingEnabled&&(e.litOptions.noShadow=!0)}_getMapTransformID(e,t){if(!e)return 0;let s=this._mapXForms[t];s||(s=[],this._mapXForms[t]=s);for(let i=0;i<s.length;i++)if(DP(s[i][0].value,e[0].value)&&DP(s[i][1].value,e[1].value))return i+1;return s.push(e)}constructor(){this._mapXForms=null}}function Ut(c,e=!0,t=!0){const s={};return s[`${c}Map`]="texture",s[`${c}MapTiling`]="vec2",s[`${c}MapOffset`]="vec2",s[`${c}MapRotation`]="number",s[`${c}MapUv`]="number",e&&(s[`${c}MapChannel`]="string",t&&(s[`${c}VertexColor`]="boolean",s[`${c}VertexColorChannel`]="string")),s}const Oh={name:"string",chunks:"chunks",mappingFormat:"string",_engine:"boolean",ambient:"rgb",...Ut("ao"),...Ut("aoDetail",!0,!1),aoDetailMode:"string",aoIntensity:"number",diffuse:"rgb",...Ut("diffuse"),...Ut("diffuseDetail",!0,!1),diffuseDetailMode:"string",vertexColorGamma:"boolean",specular:"rgb",specularTint:"boolean",...Ut("specular"),occludeSpecular:"enum:occludeSpecular",specularityFactor:"number",specularityFactorTint:"boolean",...Ut("specularityFactor"),useMetalness:"boolean",metalness:"number",enableGGXSpecular:"boolean",metalnessTint:"boolean",...Ut("metalness"),useMetalnessSpecularColor:"boolean",anisotropyIntensity:"number",anisotropyRotation:"number",...Ut("anisotropy"),shininess:"number",gloss:"number",glossInvert:"boolean",...Ut("gloss"),clearCoat:"number",...Ut("clearCoat"),clearCoatGloss:"number",clearCoatGlossInvert:"boolean",...Ut("clearCoatGloss"),clearCoatBumpiness:"number",...Ut("clearCoatNormal",!1),useSheen:"boolean",sheen:"rgb",...Ut("sheen"),sheenGloss:"number",sheenGlossInvert:"boolean",...Ut("sheenGloss"),fresnelModel:"number",emissive:"rgb",...Ut("emissive"),emissiveIntensity:"number",...Ut("normal",!1),bumpiness:"number",...Ut("normalDetail",!1),normalDetailMapBumpiness:"number",...Ut("height",!0,!1),heightMapFactor:"number",alphaToCoverage:"boolean",alphaTest:"number",alphaFade:"number",opacity:"number",...Ut("opacity"),opacityFadesSpecular:"boolean",opacityDither:"string",opacityShadowDither:"string",reflectivity:"number",refraction:"number",refractionTint:"boolean",...Ut("refraction"),refractionIndex:"number",dispersion:"number",thickness:"number",thicknessTint:"boolean",...Ut("thickness"),attenuation:"rgb",attenuationDistance:"number",useDynamicRefraction:"boolean",sphereMap:"texture",cubeMap:"cubemap",cubeMapProjection:"number",cubeMapProjectionBox:"boundingbox",useIridescence:"boolean",iridescence:"number",iridescenceTint:"boolean",...Ut("iridescence"),iridescenceThicknessTint:"boolean",iridescenceThicknessMin:"number",iridescenceThicknessMax:"number",iridescenceRefractionIndex:"number",...Ut("iridescenceThickness"),...Ut("light"),depthTest:"boolean",depthFunc:"enum:depthFunc",depthWrite:"boolean",depthBias:"number",slopeDepthBias:"number",cull:"enum:cull",blendType:"enum:blendType",useFog:"boolean",useLighting:"boolean",useSkybox:"boolean",useTonemap:"boolean",envAtlas:"texture",twoSidedLighting:"boolean",shadowCatcher:"boolean"},Iv=[];for(const c in Oh)Oh[c]==="texture"&&Iv.push(c);const eb=[];for(const c in Oh)Oh[c]==="cubemap"&&eb.push(c);const HG={aoMapVertexColor:"boolean",diffuseMapTint:"boolean",diffuseMapVertexColor:"boolean",emissiveMapTint:"boolean",emissiveMapVertexColor:"boolean",glossMapVertexColor:"boolean",metalnessMapVertexColor:"boolean",opacityMapVertexColor:"boolean",specularAntialias:"boolean",specularMapTint:"boolean",specularMapVertexColor:"boolean",ambientTint:"boolean",emissiveTint:"boolean",diffuseTint:"boolean",sheenTint:"boolean",conserveEnergy:"boolean",useGamma:"boolean",useGammaTonemap:"boolean",sheenGlossTint:"boolean",anisotropy:"boolean"},D_={},pL={};let dd=new Set;const Zp=new ue;class vr extends Dl{reset(){Object.keys(D_).forEach(e=>{this[`_${e}`]=D_[e].value()}),this._uniformCache={}}copy(e){return super.copy(e),Object.keys(D_).forEach(t=>{this[t]=e[t]}),this.userAttributes=new Map(e.userAttributes),this}setAttribute(e,t){this.userAttributes.set(t,e)}_setParameter(e,t){dd.add(e),this.setParameter(e,t)}_setParameters(e){e.forEach(t=>{this._setParameter(t.name,t.value)})}_processParameters(e){const t=this[e];t.forEach(s=>{dd.has(s)||delete this.parameters[s]}),this[e]=dd,dd=t,dd.clear()}_updateMap(e){const t=`${e}Map`,s=this[t];if(s){this._setParameter(`texture_${t}`,s);const i=`${t}Transform`,r=this.getUniform(i);r&&this._setParameters(r)}}_allocUniform(e,t){let s=this._uniformCache[e];return s||(s=t(),this._uniformCache[e]=s),s}getUniform(e,t,s){return pL[e](this,t,s)}updateUniforms(e,t){const s=i=>this.getUniform(i,e,t);this._setParameter("material_ambient",s("ambient")),this._setParameter("material_diffuse",s("diffuse")),this._setParameter("material_aoIntensity",this.aoIntensity),this.useMetalness?((!this.metalnessMap||this.metalness<1)&&this._setParameter("material_metalness",this.metalness),(!this.specularMap||this.specularTint)&&this._setParameter("material_specular",s("specular")),(!this.specularityFactorMap||this.specularityFactorTint)&&this._setParameter("material_specularityFactor",this.specularityFactor),this._setParameter("material_sheen",s("sheen")),this._setParameter("material_sheenGloss",this.sheenGloss),this._setParameter("material_refractionIndex",this.refractionIndex)):(!this.specularMap||this.specularTint)&&this._setParameter("material_specular",s("specular")),this.enableGGXSpecular&&(this._setParameter("material_anisotropyIntensity",this.anisotropyIntensity),this._setParameter("material_anisotropyRotation",[Math.cos(this.anisotropyRotation*J.DEG_TO_RAD),Math.sin(this.anisotropyRotation*J.DEG_TO_RAD)])),this.clearCoat>0&&(this._setParameter("material_clearCoat",this.clearCoat),this._setParameter("material_clearCoatGloss",this.clearCoatGloss),this._setParameter("material_clearCoatBumpiness",this.clearCoatBumpiness)),this._setParameter("material_gloss",this.gloss),this._setParameter("material_emissive",s("emissive")),this._setParameter("material_emissiveIntensity",this.emissiveIntensity),this.refraction>0&&this._setParameter("material_refraction",this.refraction),this.dispersion>0&&this._setParameter("material_dispersion",this.dispersion),this.useDynamicRefraction&&(this._setParameter("material_thickness",this.thickness),this._setParameter("material_attenuation",s("attenuation")),this._setParameter("material_invAttenuationDistance",this.attenuationDistance===0?0:1/this.attenuationDistance)),this.useIridescence&&(this._setParameter("material_iridescence",this.iridescence),this._setParameter("material_iridescenceRefractionIndex",this.iridescenceRefractionIndex),this._setParameter("material_iridescenceThicknessMin",this.iridescenceThicknessMin),this._setParameter("material_iridescenceThicknessMax",this.iridescenceThicknessMax)),this._setParameter("material_opacity",this.opacity),this.opacityFadesSpecular===!1&&this._setParameter("material_alphaFade",this.alphaFade),this.occludeSpecular&&this._setParameter("material_occludeSpecularIntensity",this.occludeSpecularIntensity),this.cubeMapProjection===P2&&this._setParameter(s("cubeMapProjectionBox"));for(const i in Sh)this._updateMap(i);this.ambientSH&&this._setParameter("ambientSH[0]",this.ambientSH),this.normalMap&&this._setParameter("material_bumpiness",this.bumpiness),this.normalMap&&this.normalDetailMap&&this._setParameter("material_normalDetailMapBumpiness",this.normalDetailMapBumpiness),this.heightMap&&this._setParameter("material_heightMapFactor",s("heightMapFactor")),this.envAtlas&&this.cubeMap?(this._setParameter("texture_envAtlas",this.envAtlas),this._setParameter("texture_cubeMap",this.cubeMap)):this.envAtlas?this._setParameter("texture_envAtlas",this.envAtlas):this.cubeMap?this._setParameter("texture_cubeMap",this.cubeMap):this.sphereMap&&this._setParameter("texture_sphereMap",this.sphereMap),this._setParameter("material_reflectivity",this.reflectivity),this._processParameters("_activeParams"),super.updateUniforms(e,t)}updateEnvUniforms(e,t){!(this.envAtlas||this.cubeMap||this.sphereMap)&&this.useSkybox&&(t.envAtlas&&t.skybox?(this._setParameter("texture_envAtlas",t.envAtlas),this._setParameter("texture_cubeMap",t.skybox)):t.envAtlas?this._setParameter("texture_envAtlas",t.envAtlas):t.skybox&&this._setParameter("texture_cubeMap",t.skybox)),this._processParameters("_activeLightingParams")}getShaderVariant(e){const{device:t,scene:s,pass:i,objDefs:r,sortedLights:a,cameraShaderParams:o}=e;this.updateEnvUniforms(t,s);const h=Gr.get(t).getByIndex(i),u=i===qf||i===Rv||h.isShadow;let f=u?K0.optionsContextMin:K0.optionsContext;f.defines=ns.getCoreDefines(this,e),u?this.shaderOptBuilder.updateMinRef(f,s,this,r,i,a):this.shaderOptBuilder.updateRef(f,s,o,this,r,i,a),this.useFog||f.defines.set("FOG","NONE"),f.defines.set("TONEMAP",M2[f.litOptions.toneMap]),this.onUpdateShader&&(f=this.onUpdateShader(f));const m=new Mv(e.viewUniformFormat,e.viewBindGroupFormat,e.vertexFormat),_=Ih(t);_.register("standard",K0);const g=_.getProgram("standard",f,m,this.userId);return this._dirtyShader=!1,g}destroy(){for(const e in this._assetReferences)this._assetReferences[e]._unbind();this._assetReferences=null,super.destroy()}constructor(){super(),this.userAttributes=new Map,this._assetReferences={},this._activeParams=new Set,this._activeLightingParams=new Set,this.shaderOptBuilder=new GG,this.reset()}}vr.TEXTURE_PARAMETERS=Iv;vr.CUBEMAP_PARAMETERS=eb;const Ov=(c,e)=>{pL[c]=e},tb=(c,e,t,s)=>{Object.defineProperty(vr.prototype,c,{get:s||function(){return this[`_${c}`]},set:t}),D_[c]={value:e}},WG=c=>{const e=`_${c.name}`,t=c.dirtyShaderFunc||(()=>!0),s=function(i){const r=this[e];r!==i&&(this._dirtyShader=this._dirtyShader||t(r,i),this[e]=i)};tb(c.name,()=>c.defaultValue,s,c.getterFunc)},XG=c=>{const e=`_${c.name}`,t=c.dirtyShaderFunc||(()=>!0),s=function(i){const r=this[e];r.equals(i)||(this._dirtyShader=this._dirtyShader||t(r,i),this[e]=r.copy(i))};tb(c.name,()=>c.defaultValue.clone(),s,c.getterFunc)},zi=c=>c.defaultValue&&c.defaultValue.clone?XG(c):WG(c);function Ot(c,e="rgb",t=!0,s=0){Sh[c]=e.length||-1,zi({name:`${c}Map`,defaultValue:null,dirtyShaderFunc:(h,u)=>!!h!=!!u||h&&(h.type!==u.type||h.format!==u.format)}),zi({name:`${c}MapTiling`,defaultValue:new ne(1,1)}),zi({name:`${c}MapOffset`,defaultValue:new ne(0,0)}),zi({name:`${c}MapRotation`,defaultValue:0}),zi({name:`${c}MapUv`,defaultValue:s}),e&&(zi({name:`${c}MapChannel`,defaultValue:e}),t&&(zi({name:`${c}VertexColor`,defaultValue:!1}),zi({name:`${c}VertexColorChannel`,defaultValue:e})));const i=`${c}MapTiling`,r=`${c}MapOffset`,a=`${c}MapRotation`,o=`${c}MapTransform`;Ov(o,(h,u,f)=>{const m=h[i],_=h[r],g=h[a];if(m.x===1&&m.y===1&&_.x===0&&_.y===0&&g===0)return null;const S=h._allocUniform(o,()=>[{name:`texture_${o}0`,value:new Float32Array(3)},{name:`texture_${o}1`,value:new Float32Array(3)}]),x=Math.cos(g*J.DEG_TO_RAD),T=Math.sin(g*J.DEG_TO_RAD),E=S[0].value;E[0]=x*m.x,E[1]=-T*m.y,E[2]=_.x;const b=S[1].value;return b[0]=T*m.x,b[1]=x*m.y,b[2]=1-m.y-_.y,S})}function Uc(c,e){zi({name:c,defaultValue:e,getterFunc:function(){return this._dirtyShader=!0,this[`_${c}`]}}),Ov(c,(t,s,i)=>{const r=t._allocUniform(c,()=>new Float32Array(3)),a=t[c];return Zp.linear(a),r[0]=Zp.r,r[1]=Zp.g,r[2]=Zp.b,r})}function mt(c,e,t){zi({name:c,defaultValue:e,dirtyShaderFunc:(s,i)=>(s===0||s===1)!=(i===0||i===1)}),Ov(c,t)}function fd(c,e){zi({name:c,defaultValue:null,dirtyShaderFunc:(t,s)=>!!t==!!s}),Ov(c,e)}function nt(c,e){zi({name:c,defaultValue:e})}function qG(){Uc("ambient",new ue(1,1,1)),Uc("diffuse",new ue(1,1,1)),Uc("specular",new ue(0,0,0)),Uc("emissive",new ue(0,0,0)),Uc("sheen",new ue(1,1,1)),Uc("attenuation",new ue(1,1,1)),mt("emissiveIntensity",1),mt("specularityFactor",1),mt("sheenGloss",0),mt("gloss",.25),mt("aoIntensity",1),mt("heightMapFactor",1,(s,i,r)=>s.heightMapFactor*.025),mt("opacity",1),mt("alphaFade",1),mt("alphaTest",0),mt("bumpiness",1),mt("normalDetailMapBumpiness",1),mt("reflectivity",1),mt("occludeSpecularIntensity",1),mt("refraction",0),mt("refractionIndex",1/1.5,(s,i,r)=>Math.max(.001,s.refractionIndex)),mt("dispersion",0),mt("thickness",0),mt("attenuationDistance",0),mt("metalness",1),mt("anisotropyIntensity",0),mt("anisotropyRotation",0),mt("clearCoat",0),mt("clearCoatGloss",1),mt("clearCoatBumpiness",1),mt("aoUvSet",0,null),mt("iridescence",0),mt("iridescenceRefractionIndex",1/1.5),mt("iridescenceThicknessMin",0),mt("iridescenceThicknessMax",0),fd("ambientSH"),fd("cubeMapProjectionBox",(s,i,r)=>{const a=s._allocUniform("cubeMapProjectionBox",()=>[{name:"envBoxMin",value:new Float32Array(3)},{name:"envBoxMax",value:new Float32Array(3)}]),o=s.cubeMapProjectionBox.getMin(),h=a[0].value;h[0]=o.x,h[1]=o.y,h[2]=o.z;const u=s.cubeMapProjectionBox.getMax(),f=a[1].value;return f[0]=u.x,f[1]=u.y,f[2]=u.z,a}),nt("specularTint",!1),nt("specularityFactorTint",!1),nt("useMetalness",!1),nt("useMetalnessSpecularColor",!1),nt("useSheen",!1),nt("enableGGXSpecular",!1),nt("occludeDirect",!1),nt("opacityFadesSpecular",!0),nt("occludeSpecular",Pv),nt("fresnelModel",NE),nt("useDynamicRefraction",!1),nt("cubeMapProjection",VE),nt("useFog",!0),nt("useLighting",!0),nt("useTonemap",!0),nt("useSkybox",!0),nt("forceUv1",!1),nt("pixelSnap",!1),nt("twoSidedLighting",!1),nt("nineSlicedMode",void 0),nt("msdfTextAttribute",!1),nt("useIridescence",!1),nt("glossInvert",!1),nt("sheenGlossInvert",!1),nt("clearCoatGlossInvert",!1),nt("opacityDither",Al),nt("opacityShadowDither",Al),nt("shadowCatcher",!1),nt("vertexColorGamma",!1),Ot("diffuse"),Ot("specular"),Ot("emissive"),Ot("thickness","g"),Ot("specularityFactor","g"),Ot("normal",""),Ot("metalness","g"),Ot("gloss","g"),Ot("opacity","a"),Ot("refraction","g"),Ot("height","g",!1),Ot("ao","g"),Ot("light","rgb",!0,1),Ot("msdf",""),Ot("diffuseDetail","rgb",!1),Ot("normalDetail",""),Ot("aoDetail","g",!1),Ot("clearCoat","g"),Ot("clearCoatGloss","g"),Ot("clearCoatNormal",""),Ot("sheen","rgb"),Ot("sheenGloss","g"),Ot("iridescence","g"),Ot("iridescenceThickness","g"),Ot("anisotropy",""),nt("diffuseDetailMode",CD),nt("aoDetailMode",CD),fd("cubeMap"),fd("sphereMap"),fd("envAtlas");const c=function(){return this._prefilteredCubemaps},e=function(s){const i=this._prefilteredCubemaps;s=s||[];let r=!1,a=!0;for(let o=0;o<6;++o){const h=s[o]||null;i[o]!==h&&(i[o]=h,r=!0),a=a&&!!i[o]}r&&(a?this.envAtlas=JE.generatePrefilteredAtlas(i,{target:this.envAtlas}):this.envAtlas&&(this.envAtlas.destroy(),this.envAtlas=null),this._dirtyShader=!0)},t=[null,null,null,null,null,null];tb("prefilteredCubemaps",()=>t.slice(),e,c)}qG();const lr=8/64,Mr=1-lr*2;class sb extends Rl{constructor(e,t,s,i,r,a){super();const o=new D,h=new D,u=new D,f=new D,m=new D,_=new D,g=[],S=[],x=[],T=[],E=[];let b;if(s>0)for(let C=0;C<=i;C++)for(let w=0;w<=r;w++){const P=w/r*2*Math.PI-Math.PI,I=Math.sin(P),M=Math.cos(P);m.set(I*e,-s/2,M*e),f.set(I*t,s/2,M*t),o.lerp(m,f,C/i),h.sub2(f,m).normalize(),_.set(M,0,-I),u.cross(_,h).normalize(),g.push(o.x,o.y,o.z),S.push(u.x,u.y,u.z);let R=w/r,L=C/i;x.push(R,1-L);const B=L;if(L=R,R=B,R=R*Mr+lr,L=L*Mr+lr,R/=3,T.push(R,1-L),C<i&&w<r){const G=C*(r+1)+w,H=C*(r+1)+(w+1),ee=(C+1)*(r+1)+w,j=(C+1)*(r+1)+(w+1);E.push(G,H,ee),E.push(H,j,ee)}}if(a){const C=Math.floor(r/2),w=r,P=s/2;for(let I=0;I<=C;I++){const M=I*Math.PI*.5/C,R=Math.sin(M),L=Math.cos(M);for(let B=0;B<=w;B++){const G=B*2*Math.PI/w-Math.PI/2,H=Math.sin(G),j=Math.cos(G)*R,ae=L,k=H*R;let O=1-B/w,z=1-I/C;g.push(j*t,ae*t+P,k*t),S.push(j,ae,k),x.push(O,1-z),O=O*Mr+lr,z=z*Mr+lr,O/=3,z/=3,O+=1/3,T.push(O,1-z)}}b=(i+1)*(r+1);for(let I=0;I<C;++I)for(let M=0;M<w;++M){const R=I*(w+1)+M,L=R+w+1;E.push(b+R+1,b+L,b+R),E.push(b+R+1,b+L+1,b+L)}for(let I=0;I<=C;I++){const M=Math.PI*.5+I*Math.PI*.5/C,R=Math.sin(M),L=Math.cos(M);for(let B=0;B<=w;B++){const G=B*2*Math.PI/w-Math.PI/2,H=Math.sin(G),j=Math.cos(G)*R,ae=L,k=H*R;let O=1-B/w,z=1-I/C;g.push(j*t,ae*t-P,k*t),S.push(j,ae,k),x.push(O,1-z),O=O*Mr+lr,z=z*Mr+lr,O/=3,z/=3,O+=2/3,T.push(O,1-z)}}b=(i+1)*(r+1)+(w+1)*(C+1);for(let I=0;I<C;++I)for(let M=0;M<w;++M){const R=I*(w+1)+M,L=R+w+1;E.push(b+R+1,b+L,b+R),E.push(b+R+1,b+L+1,b+L)}}else{if(b=(i+1)*(r+1),e>0)for(let C=0;C<r;C++){const w=C/r*2*Math.PI,P=Math.sin(w),I=-s/2,M=Math.cos(w);let R=1-(P+1)/2,L=(M+1)/2;g.push(P*e,I,M*e),S.push(0,-1,0),x.push(R,1-L),R=R*Mr+lr,L=L*Mr+lr,R/=3,L/=3,R+=1/3,T.push(R,1-L),C>1&&E.push(b,b+C,b+C-1)}if(b+=r,t>0)for(let C=0;C<r;C++){const w=C/r*2*Math.PI,P=Math.sin(w),I=s/2,M=Math.cos(w);let R=1-(P+1)/2,L=(M+1)/2;g.push(P*t,I,M*t),S.push(0,1,0),x.push(R,1-L),R=R*Mr+lr,L=L*Mr+lr,R/=3,L/=3,R+=2/3,T.push(R,1-L),C>1&&E.push(b,b+C-1,b+C)}}this.positions=g,this.normals=S,this.uvs=x,this.uvs1=T,this.indices=E}}class YG extends sb{constructor(e={}){const t=e.radius??.3,s=e.height??1,i=e.heightSegments??1,r=e.sides??20;super(t,t,s-2*t,i,r,!0),e.calculateTangents&&(this.tangents=mo(this.positions,this.normals,this.uvs,this.indices))}}class jG extends sb{constructor(e={}){const t=e.baseRadius??.5,s=e.peakRadius??0,i=e.height??1,r=e.heightSegments??5,a=e.capSegments??18;super(t,s,i,r,a,!1),e.calculateTangents&&(this.tangents=mo(this.positions,this.normals,this.uvs,this.indices))}}class $G extends sb{constructor(e={}){const t=e.radius??.5,s=e.height??1,i=e.heightSegments??5,r=e.capSegments??20;super(t,t,s,i,r,!1),e.calculateTangents&&(this.tangents=mo(this.positions,this.normals,this.uvs,this.indices))}}class KG extends Rl{constructor(e={}){super();const t=e.halfExtents??new ne(.5,.5),s=e.widthSegments??5,i=e.lengthSegments??5,r=[],a=[],o=[],h=[];let u=0;for(let f=0;f<=s;f++)for(let m=0;m<=i;m++){const _=-t.x+2*t.x*f/s,g=0,S=-(-t.y+2*t.y*m/i),x=f/s,T=m/i;r.push(_,g,S),a.push(0,1,0),o.push(x,1-T),f<s&&m<i&&(h.push(u+i+1,u+1,u),h.push(u+i+1,u+i+2,u+1)),u++}this.positions=r,this.normals=a,this.uvs=o,this.uvs1=o,this.indices=h,e.calculateTangents&&(this.tangents=mo(r,a,o,h))}}class ZG extends Rl{constructor(e={}){super();const t=e.tubeRadius??.2,s=e.ringRadius??.3,i=(e.sectorAngle??360)*J.DEG_TO_RAD,r=e.segments??30,a=e.sides??20,o=[],h=[],u=[],f=[];for(let m=0;m<=a;m++)for(let _=0;_<=r;_++){const g=Math.cos(i*_/r)*(s+t*Math.cos(2*Math.PI*m/a)),S=Math.sin(2*Math.PI*m/a)*t,x=Math.sin(i*_/r)*(s+t*Math.cos(2*Math.PI*m/a)),T=Math.cos(i*_/r)*Math.cos(2*Math.PI*m/a),E=Math.sin(2*Math.PI*m/a),b=Math.sin(i*_/r)*Math.cos(2*Math.PI*m/a),C=m/a,w=1-_/r;if(o.push(g,S,x),h.push(T,E,b),u.push(C,1-w),m<a&&_<r){const P=m*(r+1)+_,I=(m+1)*(r+1)+_,M=m*(r+1)+(_+1),R=(m+1)*(r+1)+(_+1);f.push(P,I,M),f.push(I,R,M)}}this.positions=o,this.normals=h,this.uvs=u,this.uvs1=u,this.indices=f,e.calculateTangents&&(this.tangents=mo(o,h,u,f))}}class QG{destroy(){this.clearCache()}register(e,t){this._generators.has(e)||this._generators.set(e,t)}unregister(e){this._generators.has(e)&&this._generators.delete(e)}isRegistered(e){return this._generators.has(e)}generateShaderDefinition(e,t,s,i){let r=this.definitionsCache.get(s);if(!r){let a;i.litOptions?.lights&&(a=i.litOptions.lights,i.litOptions.lights=a.map(h=>{const u=h.clone?h.clone():h;return u.key=h.key,u})),this.storeNewProgram(t,i),i.litOptions?.lights&&(i.litOptions.lights=a),this._precached;const o=this._device;r=e.createShaderDefinition(o,i),r.name=r.name??(i.pass?`${t}-pass:${i.pass}`:t),this.definitionsCache.set(s,r)}return r}getCachedShader(e){return this.processedCache.get(e)}setCachedShader(e,t){this.processedCache.set(e,t)}getProgram(e,t,s,i){const r=this._generators.get(e);if(!r)return null;const a=r.generateKey(t),o=Fr(a),h=s.generateKey(this._device),u=Fr(h),f=`${o}#${u}`;let m=this.getCachedShader(f);if(!m){const _=this.generateShaderDefinition(r,e,o,t);let g="",S;t.pass!==void 0&&(S=Gr.get(this._device).getByIndex(t.pass),g=`-${S.name}`),this._device.fire("shader:generate",{userMaterialId:i,shaderPassInfo:S,definition:_});const x={name:`${_.name}${g}-proc`,attributes:_.attributes,vshader:_.vshader,vincludes:_.vincludes,fincludes:_.fincludes,fshader:_.fshader,processingOptions:s,shaderLanguage:_.shaderLanguage,meshUniformBufferFormat:_.meshUniformBufferFormat,meshBindGroupFormat:_.meshBindGroupFormat};m=new fo(this._device,x),this.setCachedShader(f,m)}return m}storeNewProgram(e,t){let s={};if(e==="standard"){const i=this._getDefaultStdMatOptions(t.pass);for(const r in t)(t.hasOwnProperty(r)&&i[r]!==t[r]||r==="pass")&&(s[r]=t[r]);for(const r in t.litOptions)s[r]=t.litOptions[r]}else s=t;this._programsCollection.push(JSON.stringify({name:e,options:s}))}dumpPrograms(){let e=`let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;
`;e+="let shaders = [",this._programsCollection[0]&&(e+=`
	${this._programsCollection[0]}`);for(let s=1;s<this._programsCollection.length;++s)e+=`,
	${this._programsCollection[s]}`;e+=`
];
`,e+=`pc.getProgramLibrary(device).precompile(shaders);
`,e+=`if (pc.version != "${LM}" || pc.revision != "${YF}")
`,e+='	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';const t=document.createElement("a");t.setAttribute("href",`data:text/plain;charset=utf-8,${encodeURIComponent(e)}`),t.setAttribute("download","precompile-shaders.js"),t.style.display="none",document.body.appendChild(t),t.click(),document.body.removeChild(t)}clearCache(){this._isClearingCache=!0,this.processedCache.forEach(e=>{e.destroy()}),this.processedCache.clear(),this._isClearingCache=!1}removeFromCache(e){this._isClearingCache||this.processedCache.forEach((t,s)=>{e===t&&this.processedCache.delete(s)})}_getDefaultStdMatOptions(e){const t=Gr.get(this._device).getByIndex(e);return e===qf||e===Rv||t.isShadow?this._defaultStdMatOptionMin:this._defaultStdMatOption}precompile(e){if(e){const t=new Array(e.length);for(let s=0;s<e.length;s++){if(e[s].name==="standard"){const i=e[s].options,r=this._getDefaultStdMatOptions(i.pass);for(const a in r)r.hasOwnProperty(a)&&i[a]===void 0&&(i[a]=r[a])}t[s]=this.getProgram(e[s].name,e[s].options)}}this._precached=!0}constructor(e,t){this.processedCache=new Map,this.definitionsCache=new Map,this._generators=new Map,this._device=e,this._isClearingCache=!1,this._precached=!1,this._programsCollection=[],this._defaultStdMatOption=new _g,this._defaultStdMatOptionMin=new _g;const s=new Y2;t.shaderOptBuilder.updateRef(this._defaultStdMatOption,{},s,t,null,[],Zh,null),t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin,{},t,null,z2,null),e.on("destroy:shader",i=>{this.removeFromCache(i)})}}const zc=new fe,PP=new pe,Z0=new Ge,RP=new Ge,JG=new ue(1,1,0,.4),Q0=.28209479177387814;class eH{constructor(e,t,s,i,r){const a=e.getProp("x"),o=e.getProp("y"),h=e.getProp("z"),u=e.getProp("rot_1"),f=e.getProp("rot_2"),m=e.getProp("rot_3"),_=e.getProp("rot_0"),g=e.getProp("scale_0"),S=e.getProp("scale_1"),x=e.getProp("scale_2"),T=e.getProp("f_dc_0"),E=e.getProp("f_dc_1"),b=e.getProp("f_dc_2"),C=e.getProp("opacity"),w=P=>{if(P>0)return 1/(1+Math.exp(-P));const I=Math.exp(P);return I/(1+I)};this.read=P=>{t&&(t.x=a[P],t.y=o[P],t.z=h[P]),s&&s.set(u[P],f[P],m[P],_[P]),i&&i.set(Math.exp(g[P]),Math.exp(S[P]),Math.exp(x[P])),r&&r.set(.5+T[P]*Q0,.5+E[P]*Q0,.5+b[P]*Q0,w(C[P]))}}}const MP=(c,e,t)=>{PP.set(t.x,t.y,t.z,t.w).normalize(),c.setTRS(e,PP,D.ONE)};class Ml{static calcSplatAabb(e,t,s,i){MP(zc,t,s),Z0.center.set(0,0,0),Z0.halfExtents.set(i.x*2,i.y*2,i.z*2),e.setFromTransformedAabb(Z0,zc)}getProp(e,t="vertex"){return this.getElement(t)?.properties.find(s=>s.name===e)?.storage}getElement(e){return this.elements.find(t=>t.name===e)}addProp(e,t){this.getElement("vertex").properties.push({type:"float",name:e,storage:t,byteSize:4})}createIter(e,t,s,i){return new eH(this,e,t,s,i)}calcAabb(e,t){let s,i,r,a,o,h,u=!0;const f=this.getProp("x"),m=this.getProp("y"),_=this.getProp("z"),g=this.getProp("scale_0"),S=this.getProp("scale_1"),x=this.getProp("scale_2");for(let T=0;T<this.numSplats;++T){if(t&&!t(T))continue;const E=f[T],b=m[T],C=_[T],w=Math.max(g[T],S[T],x[T]);if(!isFinite(E)||!isFinite(b)||!isFinite(C)||!isFinite(w))continue;const P=2*Math.exp(w);u?(u=!1,s=E-P,i=b-P,r=C-P,a=E+P,o=b+P,h=C+P):(s=Math.min(s,E-P),i=Math.min(i,b-P),r=Math.min(r,C-P),a=Math.max(a,E+P),o=Math.max(o,b+P),h=Math.max(h,C+P))}return u||(e.center.set((s+a)*.5,(i+o)*.5,(r+h)*.5),e.halfExtents.set((a-s)*.5,(o-i)*.5,(h-r)*.5)),!u}calcAabbExact(e,t){const s=new D,i=new pe,r=new D,a=this.createIter(s,i,r);let o=!0;for(let h=0;h<this.numSplats;++h)t&&!t(h)||(a.read(h),o?(o=!1,Ml.calcSplatAabb(e,s,i,r)):(Ml.calcSplatAabb(RP,s,i,r),e.add(RP)));return!o}getCenters(){const e=this.getProp("x"),t=this.getProp("y"),s=this.getProp("z"),i=new Float32Array(this.numSplats*3);for(let r=0;r<this.numSplats;++r)i[r*3+0]=e[r],i[r*3+1]=t[r],i[r*3+2]=s[r];return i}calcFocalPoint(e,t){const s=this.getProp("x"),i=this.getProp("y"),r=this.getProp("z"),a=this.getProp("scale_0"),o=this.getProp("scale_1"),h=this.getProp("scale_2");e.x=0,e.y=0,e.z=0;let u=0;for(let f=0;f<this.numSplats;++f){if(t&&!t(f))continue;const m=s[f],_=i[f],g=r[f];if(!isFinite(m)||!isFinite(_)||!isFinite(g))continue;const S=1/(1+Math.exp(Math.max(a[f],o[f],h[f])));e.x+=m*S,e.y+=_*S,e.z+=g*S,u+=S}e.mulScalar(1/u)}renderWireframeBounds(e,t){const s=new D,i=new pe,r=new D,a=new D,o=new D,h=this.createIter(s,i,r);for(let u=0;u<this.numSplats;++u)h.read(u),MP(zc,s,i),zc.mul2(t,zc),a.set(r.x*-2,r.y*-2,r.z*-2),o.set(r.x*2,r.y*2,r.z*2),e.immediate.drawWireAlignedBox(a,o,JG,!0,e.defaultDrawLayer,zc)}get isCompressed(){return!1}get shBands(){return{9:1,24:2,45:3}[(()=>{for(let s=0;s<45;++s)if(!this.getProp(`f_rest_${s}`))return s;return 45})()]??0}calcMortonOrder(){const e=C=>{let w=C[0],P=C[0];for(let I=1;I<C.length;I++)C[I]<w&&(w=C[I]),C[I]>P&&(P=C[I]);return{min:w,max:P}},t=(C,w,P)=>{const I=M=>(M&=1023,M=(M^M<<16)&4278190335,M=(M^M<<8)&50393103,M=(M^M<<4)&51130563,M=(M^M<<2)&153391689,M);return(I(P)<<2)+(I(w)<<1)+I(C)},s=this.getProp("x"),i=this.getProp("y"),r=this.getProp("z"),{min:a,max:o}=e(s),{min:h,max:u}=e(i),{min:f,max:m}=e(r),_=a===o?0:1024/(o-a),g=h===u?0:1024/(u-h),S=f===m?0:1024/(m-f),x=new Map;for(let C=0;C<this.numSplats;C++){const w=Math.min(1023,Math.floor((s[C]-a)*_)),P=Math.min(1023,Math.floor((i[C]-h)*g)),I=Math.min(1023,Math.floor((r[C]-f)*S)),M=t(w,P,I),R=x.get(M);R?R.push(C):x.set(M,[C])}const T=Array.from(x.keys()).sort((C,w)=>C-w),E=new Uint32Array(this.numSplats);let b=0;for(let C=0;C<T.length;++C){const w=x.get(T[C]);for(let P=0;P<w.length;++P)E[b++]=w[P]}return E}reorder(e){const t=new Map,s=a=>{if(t.has(a)){const o=t.get(a);return t.delete(a),o}return new ArrayBuffer(a)},i=a=>{t.set(a.byteLength,a)},r=a=>{const o=new a.constructor(s(a.byteLength));for(let h=0;h<e.length;h++)o[h]=a[e[h]];return i(a.buffer),o};this.elements.forEach(a=>{a.properties.forEach(o=>{o.storage&&(o.storage=r(o.storage))})})}reorderData(){this.reorder(this.calcMortonOrder())}constructor(e,t=[]){this.elements=e,this.numSplats=this.getElement("vertex").count,this.comments=t}}class tH{destroy(){this._deviceLostEvent?.off(),this._deviceLostEvent=null,this.impl?.destroy(),this.impl=null}upload(e,t,s=0,i=e.length){this.impl?.upload(e,t,s,i)}_onDeviceLost(){this.impl?._onDeviceLost?.()}constructor(e,t=!1){this._deviceLostEvent=null,this.device=e,this.useSingleBuffer=t,this.impl=e.createUploadStreamImpl(this),this._deviceLostEvent=this.device.on("devicelost",this._onDeviceLost,this)}}var sH=`
#define GSPLAT_CENTER_NOPROJ
#include "gsplatStructsVS"
#include "gsplatCenterVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatSourceFormatVS"
uniform int uStartLine;
uniform int uViewportWidth;
#ifdef GSPLAT_LOD
	uniform usampler2D uIntervalsTexture;
#endif
uniform vec3 uColorMultiply;
uniform int uActiveSplats;
uniform vec3 model_scale;
uniform vec4 model_rotation;
void main(void) {
	ivec2 localFragCoords = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y) - uStartLine);
	int targetIndex = localFragCoords.y * uViewportWidth + localFragCoords.x;
	if (targetIndex >= uActiveSplats) {
		#ifdef GSPLAT_COLOR_UINT
			pcFragColor0 = uvec4(0u);
		#else
			pcFragColor0 = vec4(0.0);
		#endif
		#ifndef GSPLAT_COLOR_ONLY
			pcFragColor1 = uvec4(0u);
			pcFragColor2 = uvec2(0u);
		#endif
	} else {
		#ifdef GSPLAT_LOD
			int intervalsSize = int(textureSize(uIntervalsTexture, 0).x);
			ivec2 intervalUV = ivec2(targetIndex % intervalsSize, targetIndex / intervalsSize);
			uint originalIndex = texelFetch(uIntervalsTexture, intervalUV, 0).r;
		#else
			uint originalIndex = uint(targetIndex);
		#endif
		
		#if defined(GSPLAT_SOGS_DATA) || defined(GSPLAT_COMPRESSED_DATA)
			uint srcSize = uint(textureSize(packedTexture, 0).x);
		#else
			uint srcSize = uint(textureSize(splatColor, 0).x);
		#endif
		
		SplatSource source;
		source.id = uint(originalIndex);
		source.uv = ivec2(source.id % srcSize, source.id / srcSize);
		vec3 modelCenter = readCenter(source);
		vec3 worldCenter = (matrix_model * vec4(modelCenter, 1.0)).xyz;
		SplatCenter center;
		initCenter(modelCenter, center);
		vec4 srcRotation = getRotation().yzwx;
		vec3 srcScale = getScale();
		vec4 worldRotation = quatMul(model_rotation, srcRotation);
		if (worldRotation.w < 0.0) {
			worldRotation = -worldRotation;
		}
		vec3 worldScale = model_scale * srcScale;
		vec4 color = readColor(source);
		#if SH_BANDS > 0
			vec3 dir = normalize(center.view * mat3(center.modelView));
			vec3 sh[SH_COEFFS];
			float scale;
			readSHData(source, sh, scale);
			color.xyz += evalSH(sh, dir) * scale;
		#endif
		color.xyz *= uColorMultiply;
		#ifdef GSPLAT_COLOR_UINT
			uint packed_rg = packHalf2x16(color.rg);
			uint packed_ba = packHalf2x16(color.ba);
			pcFragColor0 = uvec4(
				packed_rg & 0xFFFFu,
				packed_rg >> 16u,
				packed_ba & 0xFFFFu,
				packed_ba >> 16u
			);
		#else
			pcFragColor0 = color;
		#endif
		#ifndef GSPLAT_COLOR_ONLY
			pcFragColor1 = uvec4(floatBitsToUint(worldCenter.x), floatBitsToUint(worldCenter.y), floatBitsToUint(worldCenter.z), packHalf2x16(worldRotation.xy));
			pcFragColor2 = uvec2(packHalf2x16(vec2(worldRotation.z, worldScale.x)), packHalf2x16(worldScale.yz));
		#endif
	}
}
`,iH=`
#define GSPLAT_CENTER_NOPROJ
#include "gsplatStructsVS"
#include "gsplatCenterVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatSourceFormatVS"
uniform uStartLine: i32;
uniform uViewportWidth: i32;
#ifdef GSPLAT_LOD
	var uIntervalsTexture: texture_2d<u32>;
#endif
uniform uColorMultiply: vec3f;
uniform uActiveSplats: i32;
uniform model_scale: vec3f;
uniform model_rotation: vec4f;
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	
	let localFragCoords = vec2i(i32(input.position.x), i32(input.position.y) - uniform.uStartLine);
	let targetIndex = localFragCoords.y * uniform.uViewportWidth + localFragCoords.x;
	
	if (targetIndex >= uniform.uActiveSplats) {
		output.color = vec4f(0.0);
		#ifndef GSPLAT_COLOR_ONLY
			output.color1 = vec4u(0u);
			output.color2 = vec2u(0u);
		#endif
	} else {
		#ifdef GSPLAT_LOD
			let intervalsSize = i32(textureDimensions(uIntervalsTexture, 0).x);
			let intervalUV = vec2i(targetIndex % intervalsSize, targetIndex / intervalsSize);
			let originalIndex = textureLoad(uIntervalsTexture, intervalUV, 0).r;
		#else
			let originalIndex = targetIndex;
		#endif
		
		var srcSize: u32;
		#if defined(GSPLAT_SOGS_DATA) || defined(GSPLAT_COMPRESSED_DATA)
			srcSize = u32(textureDimensions(packedTexture, 0).x);
		#else
			srcSize = u32(textureDimensions(splatColor, 0).x);
		#endif
		
		var source: SplatSource;
		source.id = u32(originalIndex);
		source.uv = vec2i(i32(source.id % srcSize), i32(source.id / srcSize));
		var modelCenter = readCenter(&source);
		let worldCenter = (uniform.matrix_model * vec4f(modelCenter, 1.0)).xyz;
		var center: SplatCenter;
		initCenter(modelCenter, &center);
		let srcRotation = getRotation().yzwx;
		let srcScale = getScale();
		var worldRotation = quatMul(uniform.model_rotation, srcRotation);
		if (worldRotation.w < 0.0) {
			worldRotation = -worldRotation;
		}
		let worldScale = uniform.model_scale * srcScale;
		var color = readColor(&source);
		#if SH_BANDS > 0
			let dir = normalize(center.view * mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));
			var sh: array<vec3f, SH_COEFFS>;
			var scale: f32;
			readSHData(&source, &sh, &scale);
			color = vec4f(color.xyz + evalSH(&sh, dir) * scale, color.w);
		#endif
		color = vec4f(color.xyz * uniform.uColorMultiply, color.w);
		output.color = color;
		#ifndef GSPLAT_COLOR_ONLY
			output.color1 = vec4u(bitcast<u32>(worldCenter.x), bitcast<u32>(worldCenter.y), bitcast<u32>(worldCenter.z), pack2x16float(worldRotation.xy));
			output.color2 = vec2u(pack2x16float(vec2f(worldRotation.z, worldScale.x)), pack2x16float(worldScale.yz));
		#endif
	}
	
	return output;
}
`;const rH=new fe,Qp=new D,Xo=new pe,aH=[1,1,1];class LP extends ii{init(e){super.init(e),this.colorOps.clear=!1,this.depthStencilOps.clearDepth=!1}update(e,t,s){this.splats.length=0,this.colorsByLod=s;for(let i=0;i<e.length;i++){const r=e[i];r.activeSplats>0&&this.splats.push(r)}return this.cameraNode=t,this.splats.length>0}execute(){const{device:e,splats:t,cameraNode:s}=this;e.setBlendState(ht.NOBLEND),e.setCullMode(Ft),e.setDepthState(Gt.NODEPTH),e.setStencilState();const i=s.getWorldTransform(),r=rH.copy(i).invert();e.scope.resolve("matrix_view").setValue(r.data);for(let a=0;a<t.length;a++)this.renderSplat(t[a])}renderSplat(e){const{device:t,resource:s}=e,i=t.scope,{intervals:r,activeSplats:a,lineStart:o,viewport:h,intervalTexture:u}=e,f=s.getWorkBufferRenderInfo(r.length>0,this.workBuffer.colorTextureFormat,this.colorOnly);f.material.setParameters(t),u&&i.resolve("uIntervalsTexture").setValue(u.texture),i.resolve("uActiveSplats").setValue(a),i.resolve("uStartLine").setValue(o),i.resolve("uViewportWidth").setValue(h.z);const m=this.colorsByLod?.[e.lodIndex]??this.colorsByLod?.[0]??aH;i.resolve("uColorMultiply").setValue(m);const _=e.node.getWorldTransform();_.getScale(Qp),Xo.setFromMat4(_),Xo.w<0&&Xo.mulScalar(-1),this._modelScaleData[0]=Qp.x,this._modelScaleData[1]=Qp.y,this._modelScaleData[2]=Qp.z,this._modelRotationData[0]=Xo.x,this._modelRotationData[1]=Xo.y,this._modelRotationData[2]=Xo.z,this._modelRotationData[3]=Xo.w,i.resolve("matrix_model").setValue(_.data),i.resolve("model_scale").setValue(this._modelScaleData),i.resolve("model_rotation").setValue(this._modelRotationData),f.quadRender.render(h)}destroy(){this.splats.length=0,super.destroy()}constructor(e,t,s=!1){super(e),this.splats=[],this.colorsByLod=void 0,this.cameraNode=null,this._modelScaleData=new Float32Array(3),this._modelRotationData=new Float32Array(4),this.workBuffer=t,this.colorOnly=s}}let nH=0;class oH{destroy(){this.material?.destroy(),this.quadRender?.destroy()}constructor(e,t,s,i,r){this.device=e,this.material=s;const a=new Map(s.defines),o=i===lo,h=o?"uvec4":"vec4";o&&a.set("GSPLAT_COLOR_UINT",""),r&&a.set("GSPLAT_COLOR_ONLY","");const u=ns.createShader(this.device,{uniqueName:`SplatCopyToWorkBuffer:${t}`,attributes:{vertex_position:He},vertexDefines:a,fragmentDefines:a,vertexChunk:"fullscreenQuadVS",fragmentGLSL:sH,fragmentWGSL:iH,fragmentOutputTypes:r?[h]:[h,"uvec4","uvec2"]});this.quadRender=new uf(u)}}class lH{destroy(){this.renderPass?.destroy(),this.colorRenderPass?.destroy(),this.colorTexture?.destroy(),this.splatTexture0?.destroy(),this.splatTexture1?.destroy(),this.orderTexture?.destroy(),this.orderBuffer?.destroy(),this.renderTarget?.destroy(),this.colorRenderTarget?.destroy(),this.uploadStream.destroy()}get textureSize(){return this._textureSize}setOrderData(e){this.device.isWebGPU?this.uploadStream.upload(e,this.orderBuffer,0,e.length):this.uploadStream.upload(e,this.orderTexture,0,e.length)}createTexture(e,t,s,i){return new De(this.device,{name:e,width:s,height:i,format:t,cubemap:!1,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te})}resize(e){if(this.renderTarget.resize(e,e),this.colorRenderTarget.resize(e,e),this._textureSize=e,this.device.isWebGPU){const t=e*e*4;this.orderBuffer.byteSize<t&&(this.orderBuffer.destroy(),this.orderBuffer=new Fs(this.device,t,Ns))}else this.orderTexture.resize(e,e)}render(e,t,s){this.renderPass.update(e,t,s)&&this.renderPass.render()}renderColor(e,t,s){this.colorRenderPass.update(e,t,s)&&this.colorRenderPass.render()}constructor(e){this.id=nH++,this._textureSize=1,this.device=e,this.colorTextureFormat=e.getRenderableHdrFormat([kt])||lo,this.colorTexture=this.createTexture("splatColor",this.colorTextureFormat,1,1),this.splatTexture0=this.createTexture("splatTexture0",Ps,1,1),this.splatTexture1=this.createTexture("splatTexture1",Hh,1,1),this.renderTarget=new At({name:`GsplatWorkBuffer-MRT-${this.id}`,colorBuffers:[this.colorTexture,this.splatTexture0,this.splatTexture1],depth:!1,flipY:!0}),this.colorRenderTarget=new At({name:`GsplatWorkBuffer-Color-${this.id}`,colorBuffer:this.colorTexture,depth:!1,flipY:!0}),this.uploadStream=new tH(e),e.isWebGPU?this.orderBuffer=new Fs(e,4,Ns):this.orderTexture=this.createTexture("SplatGlobalOrder",oo,1,1),this.renderPass=new LP(e,this),this.renderPass.init(this.renderTarget),this.colorRenderPass=new LP(e,this,!0),this.colorRenderPass.init(this.colorRenderTarget)}}let cH=0;const kc=new Map;class Js{destroy(){this.mesh?.destroy(),this.instanceIndices?.destroy(),this.workBufferRenderInfos.forEach(e=>e.destroy()),this.workBufferRenderInfos.clear()}incRefCount(){this._refCount++}decRefCount(){this._refCount--}get refCount(){return this._refCount}ensureMesh(){this.mesh||(this.mesh=Js.createMesh(this.device),this.mesh.aabb.copy(this.aabb),this.instanceIndices=Js.createInstanceIndices(this.device,this.gsplatData.numSplats)),this._meshRefCount++}releaseMesh(){this._meshRefCount--,this._meshRefCount<1&&(this.mesh=null,this.instanceIndices?.destroy(),this.instanceIndices=null)}getWorkBufferRenderInfo(e,t,s=!1){this.configureMaterialDefines(kc),e&&kc.set("GSPLAT_LOD",""),s&&kc.set("GSPLAT_COLOR_ONLY","");const i=Array.from(kc.entries()).map(([a,o])=>`${a}=${o}`).join(";");let r=this.workBufferRenderInfos.get(i);if(!r){const a=new Za;this.configureMaterial(a),kc.forEach((o,h)=>a.setDefine(h,o)),r=new oH(this.device,i,a,t,s),this.workBufferRenderInfos.set(i,r)}return kc.clear(),r}static createMesh(e){const t=Js.instanceSize,s=new Float32Array(12*t),i=new Uint32Array(6*t);for(let a=0;a<t;++a){s.set([-1,-1,a,1,-1,a,1,1,a,-1,1,a],a*12);const o=a*4;i.set([0+o,1+o,2+o,0+o,2+o,3+o],a*6)}const r=new Ct(e);return r.setPositions(s,3),r.setIndices(i),r.update(),r}static createInstanceIndices(e,t){const s=Js.instanceSize,r=Math.ceil(t/s)*s/s,a=new Uint32Array(r);for(let u=0;u<r;++u)a[u]=u*s;const o=new Ti(e,[{semantic:uv,components:1,type:Xh,asInt:!0}]);return new Yr(e,o,r,{usage:Hi,data:a.buffer})}static get instanceSize(){return 128}get numSplats(){return this.gsplatData.numSplats}configureMaterial(e){}configureMaterialDefines(e){}evalTextureSize(e){return ne.ZERO}createTexture(e,t,s,i){return new De(this.device,{name:e,width:s.x,height:s.y,format:t,cubemap:!1,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te,...i?{levels:[i]}:{}})}instantiate(){}constructor(e,t){this.mesh=null,this.instanceIndices=null,this.id=cH++,this.workBufferRenderInfos=new Map,this._refCount=0,this._meshRefCount=0,this.device=e,this.gsplatData=t,this.centers=t.getCenters(),this.aabb=new Ge,t.calcAabb(this.aabb)}}const hH=(c,e)=>{const t=[];for(let s=0;s<e;++s)t.push(c.getProp(`f_rest_${s}`));return t};class ib extends Js{destroy(){this.colorTexture?.destroy(),this.transformATexture?.destroy(),this.transformBTexture?.destroy(),this.sh1to3Texture?.destroy(),this.sh4to7Texture?.destroy(),this.sh8to11Texture?.destroy(),this.sh12to15Texture?.destroy(),super.destroy()}configureMaterialDefines(e){e.set("SH_BANDS",this.shBands)}configureMaterial(e){this.configureMaterialDefines(e.defines),e.setParameter("splatColor",this.colorTexture),e.setParameter("transformA",this.transformATexture),e.setParameter("transformB",this.transformBTexture),this.sh1to3Texture&&e.setParameter("splatSH_1to3",this.sh1to3Texture),this.sh4to7Texture&&e.setParameter("splatSH_4to7",this.sh4to7Texture),this.sh8to11Texture&&e.setParameter("splatSH_8to11",this.sh8to11Texture),this.sh12to15Texture&&e.setParameter("splatSH_12to15",this.sh12to15Texture)}evalTextureSize(e){const t=Math.ceil(Math.sqrt(e)),s=Math.ceil(e/t);return new ne(t,s)}updateColorData(e){const t=this.colorTexture;if(!t)return;const s=pl.float2Half,i=t.lock(),r=e.getProp("f_dc_0"),a=e.getProp("f_dc_1"),o=e.getProp("f_dc_2"),h=e.getProp("opacity"),u=.28209479177387814;for(let f=0;f<this.numSplats;++f){const m=r[f]*u+.5,_=a[f]*u+.5,g=o[f]*u+.5,S=1/(1+Math.exp(-h[f]));i[f*4+0]=s(m),i[f*4+1]=s(_),i[f*4+2]=s(g),i[f*4+3]=s(S)}t.unlock()}updateTransformData(e){const t=pl.float2Half;if(!this.transformATexture)return;const s=this.transformATexture.lock(),i=new Float32Array(s.buffer),r=this.transformBTexture.lock(),a=new D,o=new pe,h=new D,u=e.createIter(a,o,h);for(let f=0;f<this.numSplats;f++)u.read(f),o.normalize(),o.w<0&&o.mulScalar(-1),i[f*4+0]=a.x,i[f*4+1]=a.y,i[f*4+2]=a.z,s[f*4+3]=t(o.x)|t(o.y)<<16,r[f*4+0]=t(h.x),r[f*4+1]=t(h.y),r[f*4+2]=t(h.z),r[f*4+3]=t(o.z);this.transformATexture.unlock(),this.transformBTexture.unlock()}updateSHData(e){const t=this.sh1to3Texture.lock(),s=this.sh4to7Texture?.lock(),i=this.sh8to11Texture?.lock(),r=this.sh12to15Texture?.lock(),a={1:3,2:8,3:15}[this.shBands],o=hH(e,a*3),h=2047,u=1023,f=new Float32Array(1),m=new Uint32Array(f.buffer),_=new Array(a*3).fill(0);for(let g=0;g<e.numSplats;++g){for(let x=0;x<a;++x)_[x*3]=o[x][g],_[x*3+1]=o[x+a][g],_[x*3+2]=o[x+a*2][g];let S=_[0];for(let x=1;x<a*3;++x)S=Math.max(S,Math.abs(_[x]));if(S!==0){for(let x=0;x<a;++x)_[x*3+0]=Math.max(0,Math.min(h,Math.floor((_[x*3+0]/S*.5+.5)*h+.5))),_[x*3+1]=Math.max(0,Math.min(u,Math.floor((_[x*3+1]/S*.5+.5)*u+.5))),_[x*3+2]=Math.max(0,Math.min(h,Math.floor((_[x*3+2]/S*.5+.5)*h+.5)));f[0]=S,t[g*4+0]=m[0],t[g*4+1]=_[0]<<21|_[1]<<11|_[2],t[g*4+2]=_[3]<<21|_[4]<<11|_[5],t[g*4+3]=_[6]<<21|_[7]<<11|_[8],this.shBands>1&&(s[g*4+0]=_[9]<<21|_[10]<<11|_[11],s[g*4+1]=_[12]<<21|_[13]<<11|_[14],s[g*4+2]=_[15]<<21|_[16]<<11|_[17],s[g*4+3]=_[18]<<21|_[19]<<11|_[20],this.shBands>2?(i[g*4+0]=_[21]<<21|_[22]<<11|_[23],i[g*4+1]=_[24]<<21|_[25]<<11|_[26],i[g*4+2]=_[27]<<21|_[28]<<11|_[29],i[g*4+3]=_[30]<<21|_[31]<<11|_[32],r[g*4+0]=_[33]<<21|_[34]<<11|_[35],r[g*4+1]=_[36]<<21|_[37]<<11|_[38],r[g*4+2]=_[39]<<21|_[40]<<11|_[41],r[g*4+3]=_[42]<<21|_[43]<<11|_[44]):i[g]=_[21]<<21|_[22]<<11|_[23])}}this.sh1to3Texture.unlock(),this.sh4to7Texture?.unlock(),this.sh8to11Texture?.unlock(),this.sh12to15Texture?.unlock()}constructor(e,t){super(e,t);const s=t.numSplats,i=this.evalTextureSize(s);this.colorTexture=this.createTexture("splatColor",kt,i),this.transformATexture=this.createTexture("transformA",Ps,i),this.transformBTexture=this.createTexture("transformB",kt,i),this.updateColorData(t),this.updateTransformData(t),this.shBands=t.shBands,this.shBands>0&&(this.sh1to3Texture=this.createTexture("splatSH_1to3",Ps,i),this.shBands>1&&(this.sh4to7Texture=this.createTexture("splatSH_4to7",Ps,i),this.shBands>2?(this.sh8to11Texture=this.createTexture("splatSH_8to11",Ps,i),this.sh12to15Texture=this.createTexture("splatSH_12to15",Ps,i)):this.sh8to11Texture=this.createTexture("splatSH_8to11",oo,i)),this.updateSHData(t))}}const uH=`
	attribute vec2 vertex_position;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.0, 1.0);
	}
`,dH=`
	#include "gsplatEvalSHVS"
	vec4 packRgb(vec3 v) {
		uvec3 vb = uvec3(clamp(v, vec3(0.0), vec3(1.0)) * vec3(2047.0, 2047.0, 1023.0));
		uint bits = (vb.x << 21) | (vb.y << 10) | vb.z;
		return vec4((uvec4(bits) >> uvec4(24, 16, 8, 0)) & uvec4(0xff)) / vec4(255.0);
	}
	uniform mediump vec3 dir;
	uniform mediump sampler2D centroids;
	uniform mediump float shN_mins;
	uniform mediump float shN_maxs;
	void main(void) {
		ivec2 uv = ivec2(gl_FragCoord.xy) * ivec2(SH_COEFFS, 1);
		mediump vec3 coefficients[SH_COEFFS];
		for (int i = 0; i < SH_COEFFS; i++) {
			vec3 s = texelFetch(centroids, ivec2(uv.x + i, uv.y), 0).xyz;
			coefficients[i] = mix(vec3(shN_mins), vec3(shN_maxs), s);
		}
		gl_FragColor = packRgb(evalSH(coefficients, dir) * 0.25 + 0.5);
	}
`,fH=`
	attribute vertex_position: vec2f;
	@vertex
	fn vertexMain(input: VertexInput) -> VertexOutput {
		var output: VertexOutput;
		output.position = vec4f(vertex_position, 0.0, 1.0);
		return output;
	}
`,mH=`
	#include "gsplatEvalSHVS"
	fn packRgb(v: vec3f) -> vec4f {
		let vb = vec3u(clamp(v, vec3f(0.0), vec3f(1.0)) * vec3f(2047.0, 2047.0, 1023.0));
		let bits = dot(vb, vec3u(1 << 21, 1 << 10, 1));
		return vec4f((vec4u(bits) >> vec4u(24, 16, 8, 0)) & vec4u(0xff)) / vec4f(255.0);
	}
	uniform dir: vec3f;
	uniform shN_mins: f32;
	uniform shN_maxs: f32;
	var centroids: texture_2d<f32>;
	@fragment
	fn fragmentMain(input: FragmentInput) -> FragmentOutput {
		var output: FragmentOutput;
		var uv = vec2i(input.position.xy) * vec2i(SH_COEFFS, 1);
		var coefficients: array<vec3f, SH_COEFFS>;
		for (var i: i32 = 0; i < SH_COEFFS; i++) {
			let s: vec3f = textureLoad(centroids, vec2i(uv.x + i, uv.y), 0).xyz;
			coefficients[i] = mix(vec3f(uniform.shN_mins), vec3f(uniform.shN_maxs), s);
		}
		output.color = packRgb(evalSH(&coefficients, uniform.dir) * 0.25 + 0.5);
		return output;
	}
`,pH=`
	uniform mediump sampler2D sh0;
	uniform highp sampler2D sh_labels;
	uniform mediump sampler2D sh_result;
	uniform vec4 sh0_mins;
	uniform vec4 sh0_maxs;
	float SH_C0 = 0.28209479177387814;
	vec3 unpackRgb(vec4 v) {
		uvec4 uv = uvec4(v * 255.0);
		uint bits = (uv.x << 24) | (uv.y << 16) | (uv.z << 8) | uv.w;
		uvec3 vb = (uvec3(bits) >> uvec3(21, 10, 0)) & uvec3(0x7ffu, 0x7ffu, 0x3ffu);
		return vec3(vb) / vec3(2047.0, 2047.0, 1023.0);
	}
	vec4 readColor(in SplatSource source) {
		vec4 baseSample = mix(sh0_mins, sh0_maxs, texelFetch(sh0, source.uv, 0));
		vec4 base = vec4(vec3(0.5) + baseSample.xyz * SH_C0, 1.0 / (1.0 + exp(-baseSample.w)));
		ivec2 labelSample = ivec2(texelFetch(sh_labels, source.uv, 0).xy * 255.0);
		int n = labelSample.x + labelSample.y * 256;
		vec4 shSample = texelFetch(sh_result, ivec2(n % 64, n / 64), 0);
		vec3 sh = (unpackRgb(shSample) - vec3(0.5)) * 4.0;
		return vec4(base.xyz + sh, base.w);
	}
`,_H=`
	var sh0: texture_2d<f32>;
	var sh_labels: texture_2d<f32>;
	var sh_result: texture_2d<f32>;
	uniform sh0_mins: vec4f;
	uniform sh0_maxs: vec4f;
	const SH_C0: f32 = 0.28209479177387814;
	fn unpackRgb(v: vec4f) -> vec3f {
		let bits = dot(vec4u(v * 255.0), vec4u(1u << 24, 1u << 16, 1u << 8, 1u));
		let vb = (vec3u(bits) >> vec3u(21, 10, 0)) & vec3u(0x7ffu, 0x7ffu, 0x3ffu);
		return vec3f(vb) / vec3f(2047.0, 2047.0, 1023.0);
	}
	fn readColor(source: ptr<function, SplatSource>) -> vec4f {
		let baseSample: vec4f = mix(uniform.sh0_mins, uniform.sh0_maxs, textureLoad(sh0, source.uv, 0));
		let base = vec4f(vec3f(0.5) + baseSample.xyz * SH_C0, 1.0 / (1.0 + exp(-baseSample.w)));
		let labelSample: vec2i = vec2i(textureLoad(sh_labels, source.uv, 0).xy * 255.0);
		let n = labelSample.x + labelSample.y * 256;
		let shSample: vec4f = textureLoad(sh_result, vec2i(n % 64, n / 64), 0);
		let sh: vec3f = (unpackRgb(shSample) - vec3f(0.5)) * 4.0;
		return vec4f(base.xyz + sh, base.w);
	}
`,gH=(c,e)=>{for(const t in e)c.resolve(t).setValue(e[t])};class vH extends ii{execute(){this.executeCallback?.()}constructor(...e){super(...e),this.executeCallback=null}}const IP=new fe,md=new D;class SH{destroy(){const{gsplatInstance:e}=this,{material:t}=e;t.setDefine("SH_BANDS",e.resource.gsplatData.shBands.toString());const{shaderChunks:s}=t;s.glsl.delete("gsplatSogsColorVS"),s.wgsl.delete("gsplatSogsColorVS"),t.update(),this.quadRender.destroy(),this.renderPass.destroy(),this.renderTarget.destroy(),this.texture.destroy(),this.shader.destroy()}render(e,t){const{prevDir:s,updateMode:i}=this;if(i==="disable"||(IP.invert(t),IP.transformVector(e.forward,md),md.normalize(),i==="enable"&&md.equalsApprox(s,.001)))return;s.copy(md);const r=()=>{const{device:a}=this,{sh_centroids:o,meta:h}=this.gsplatInstance.resource.gsplatData;gH(a.scope,{dir:md.toArray(),centroids:o,shN_mins:h.shN.mins,shN_maxs:h.shN.maxs}),a.setCullMode(Ft),a.setDepthState(Gt.NODEPTH),a.setStencilState(null,null),a.setBlendState(ht.NOBLEND),this.quadRender.render()};this.renderPass.executeCallback=r,this.renderPass.render()}constructor(e,t){this.prevDir=new D,this.updateMode="enable",this.device=e,this.gsplatInstance=t;const{resource:s}=t,i=new Map(Ue.get(e,e.isWebGPU?"wgsl":"glsl"));this.shader=ns.createShader(e,{uniqueName:"gsplatResolveSH",vertexGLSL:uH,fragmentGLSL:dH,vertexWGSL:fH,fragmentWGSL:mH,vertexIncludes:i,fragmentIncludes:i,fragmentDefines:new Map([["SH_BANDS",s.gsplatData.shBands.toString()]]),attributes:{vertex_position:He}}),this.texture=s.createTexture("centroids",Ze,new ne(64,1024)),this.renderTarget=new At({colorBuffer:this.texture,depth:!1}),this.renderPass=new vH(e),this.renderPass.init(this.renderTarget,{}),this.renderPass.colorOps.clear=!0,this.quadRender=new uf(this.shader);const{material:r}=t;r.setDefine("SH_BANDS","0");const{shaderChunks:a}=r;a.glsl.set("gsplatSogsColorVS",pH),a.wgsl.set("gsplatSogsColorVS",_H),r.update(),e.scope.resolve("sh_result").setValue(this.texture)}}function yH(){const c=typeof self<"u"&&self||require("node:worker_threads").parentPort;let e,t,s,i,r,a,o=!1;const h={x:0,y:0,z:0},u={x:0,y:0,z:0},f={x:0,y:0,z:0},m={x:0,y:0,z:0};let _,g;const S=32,x=new Array(S).fill(0),T=new Array(S).fill(0),E=new Array(S).fill(0),b=(w,P,I)=>{for(;w<=P;){const M=P+w>>1,R=I(M);if(R>0)w=M+1;else if(R<0)P=M-1;else return M}return~w},C=()=>{if(!e||!t||t.length===0||!r||!a)return;const w=performance.now(),P=r.x,I=r.y,M=r.z,R=a.x,L=a.y,B=a.z,G=.001;if(!o&&Math.abs(P-h.x)<G&&Math.abs(I-h.y)<G&&Math.abs(M-h.z)<G&&Math.abs(R-u.x)<G&&Math.abs(L-u.y)<G&&Math.abs(B-u.z)<G)return;o=!1,h.x=P,h.y=I,h.z=M,u.x=R,u.y=L,u.z=B;let H,ee;for(let U=0;U<8;++U){const K=U&1?f.x:m.x,se=U&2?f.y:m.y,le=U&4?f.z:m.z,re=K*R+se*L+le*B;U===0?H=ee=re:(H=Math.min(H,re),ee=Math.max(ee,re))}const j=t.length/3,k=2**Math.max(10,Math.min(20,Math.round(Math.log2(j/4))))+1;_?.length!==j&&(_=new Uint32Array(j)),!g||g.length!==k?g=new Uint32Array(k):g.fill(0);const O=ee-H;if(O<1e-6)for(let U=0;U<j;++U)_[U]=0,g[0]++;else{const U=s.length/4;x.fill(0);for(let re=0;re<U;++re){const de=s[re*4+0],ye=s[re*4+1],Me=s[re*4+2],et=s[re*4+3],Qe=de*R+ye*L+Me*B-H,ls=Math.max(0,Math.floor((Qe-et)*S/O)),xr=Math.min(S,Math.ceil((Qe+et)*S/O));for(let ms=ls;ms<xr;++ms)x[ms]++}const K=x.reduce((re,de)=>re+de,0);for(let re=0;re<S;++re)E[re]=x[re]/K*k>>>0;for(let re=0;re<S;++re)T[re]=re===0?0:T[re-1]+E[re-1];const se=O/S;let le=0;for(let re=0;re<j;++re){const de=t[le++],ye=t[le++],Me=t[le++],et=(de*R+ye*L+Me*B-H)/se,Qe=et>>>0,ls=T[Qe]+E[Qe]*(et-Qe)>>>0;_[re]=ls,g[ls]++}}for(let U=1;U<k;U++)g[U]+=g[U-1];for(let U=0;U<j;U++){const K=_[U],se=--g[K];e[se]=U}const z=P*R+I*L+M*B,X=U=>{let K=e[U]*3;return t[K++]*R+t[K++]*L+t[K]*B-z},Y=()=>{const U=b(0,j-1,K=>-X(K));return Math.min(j,Math.abs(U))},F=X(j-1)>=0?Y():j;if(i)for(let U=0;U<j;++U)e[U]=i[e[U]];c.postMessage({order:e.buffer,count:F,sortTime:performance.now()-w},[e.buffer]),e=null};c.addEventListener("message",w=>{const P=w.data??w;if(P.order&&(e=new Uint32Array(P.order)),P.centers)if(t=new Float32Array(P.centers),o=!0,P.chunks){const I=new Float32Array(P.chunks);s=new Float32Array(P.chunks,0,I.length*4/6),f.x=I[0],f.y=I[1],f.z=I[2],m.x=I[3],m.y=I[4],m.z=I[5];for(let M=0;M<I.length/6;++M){const R=I[M*6+0],L=I[M*6+1],B=I[M*6+2],G=I[M*6+3],H=I[M*6+4],ee=I[M*6+5];s[M*4+0]=(R+G)*.5,s[M*4+1]=(L+H)*.5,s[M*4+2]=(B+ee)*.5,s[M*4+3]=Math.sqrt((G-R)**2+(H-L)**2+(ee-B)**2)*.5,R<f.x&&(f.x=R),L<f.y&&(f.y=L),B<f.z&&(f.z=B),G>m.x&&(m.x=G),H>m.y&&(m.y=H),ee>m.z&&(m.z=ee)}}else{const I=t.length/3,M=Math.ceil(I/256);s=new Float32Array(M*4),f.x=f.y=f.z=1/0,m.x=m.y=m.z=-1/0;let R,L,B,G,H,ee;for(let j=0;j<M;++j){R=L=B=1/0,G=H=ee=-1/0;const ae=j*256,k=Math.min(I,(j+1)*256);for(let O=ae;O<k;++O){const z=t[O*3+0],X=t[O*3+1],Y=t[O*3+2],F=Number.isFinite(z),U=Number.isFinite(X),K=Number.isFinite(Y);F||(t[O*3+0]=0),U||(t[O*3+1]=0),K||(t[O*3+2]=0),!(!F||!U||!K)&&(z<R?R=z:z>G&&(G=z),X<L?L=X:X>H&&(H=X),Y<B?B=Y:Y>ee&&(ee=Y),z<f.x?f.x=z:z>m.x&&(m.x=z),X<f.y?f.y=X:X>m.y&&(m.y=X),Y<f.z?f.z=Y:Y>m.z&&(m.z=Y))}s[j*4+0]=(R+G)*.5,s[j*4+1]=(L+H)*.5,s[j*4+2]=(B+ee)*.5,s[j*4+3]=Math.sqrt((G-R)**2+(H-L)**2+(ee-B)**2)*.5}}P.hasOwnProperty("mapping")&&(i=P.mapping?new Uint32Array(P.mapping):null,o=!0),P.cameraPosition&&(r=P.cameraPosition),P.cameraDirection&&(a=P.cameraDirection),C()})}class xH extends Pe{destroy(){this.worker.terminate(),this.worker=null}init(e,t,s){this.orderTexture=e,this.centers=t.slice();const i=this.orderTexture.lock({mode:WM}).slice();this.orderTexture.unlock();for(let o=0;o<i.length;++o)i[o]=o;const r={order:i.buffer,centers:t.buffer,chunks:s?.buffer},a=[i.buffer,t.buffer].concat(s?[s.buffer]:[]);this.worker.postMessage(r,a)}setMapping(e){if(e){const t=new Float32Array(e.length*3);for(let s=0;s<e.length;++s){const i=e[s]*3,r=s*3;t[r+0]=this.centers[i+0],t[r+1]=this.centers[i+1],t[r+2]=this.centers[i+2]}this.worker.postMessage({centers:t.buffer,mapping:e.buffer},[t.buffer,e.buffer])}else{const t=this.centers.slice();this.worker.postMessage({centers:t.buffer,mapping:null},[t.buffer])}}setCamera(e,t){this.worker.postMessage({cameraPosition:{x:e.x,y:e.y,z:e.z},cameraDirection:{x:t.x,y:t.y,z:t.z}})}constructor(e){super(),this.scene=e??null;const t=i=>{const r=i.data??i;this.scene&&r.sortTime!==void 0&&this.scene.fire("gsplat:sorted",r.sortTime);const a=r.order,o=this.orderTexture._levels[0].buffer;this.worker.postMessage({order:o},[o]),this.orderTexture._levels[0]=new Uint32Array(a),this.orderTexture.upload(),this.fire("updated",r.count)},s=`(${yH.toString()})()`;Ve.environment==="node"?(this.worker=new Worker(s,{eval:!0}),this.worker.on("message",t)):(this.worker=new Worker(URL.createObjectURL(new Blob([s],{type:"application/javascript"}))),this.worker.addEventListener("message",t))}}var TH=`
#include "gsplatPackingPS"
uniform highp sampler2D means_l;
uniform highp sampler2D means_u;
uniform highp sampler2D quats;
uniform highp sampler2D scales;
uniform highp sampler2D sh0;
uniform highp sampler2D sh_labels;
uniform highp uint numSplats;
#ifdef REORDER_V1
	float sigmoid(float x) { return 1.0 / (1.0 + exp(-x)); }
	vec3 vmin(vec3 v) { return vec3(min(min(v.x, v.y), v.z)); }
	vec3 vmax(vec3 v) { return vec3(max(max(v.x, v.y), v.z)); }
	vec3 resolve(vec3 m, vec3 M, vec3 v) { return (mix(m, M, v) - vmin(m)) / (vmax(M) - vmin(m)); }
	
	uniform vec3 scalesMins;
	uniform vec3 scalesMaxs;
	uniform vec4 sh0Mins;
	uniform vec4 sh0Maxs;
#else
	uniform vec4 scales_codebook[64];
	uniform vec4 sh0_codebook[64];
#endif
void main(void) {
	int w = int(textureSize(means_l, 0).x);
	ivec2 uv = ivec2(gl_FragCoord.xy);
	if (uint(uv.x + uv.y * w) >= numSplats) {
		discard;
	}
	vec3 meansLSample   = texelFetch(means_l, uv, 0).xyz;
	vec3 meansUSample   = texelFetch(means_u, uv, 0).xyz;
	vec4 quatsSample	= texelFetch(quats, uv, 0);
	vec3 scalesSample   = texelFetch(scales, uv, 0).xyz;
	vec4 sh0Sample	  = texelFetch(sh0, uv, 0);
	vec2 shLabelsSample = texelFetch(sh_labels, uv, 0).xy;
	#ifdef REORDER_V1
		uint scale = pack101010(resolve(scalesMins, scalesMaxs, scalesSample));
		uint sh0 = pack111110(resolve(sh0Mins.xyz, sh0Maxs.xyz, sh0Sample.xyz));
		float alpha = sigmoid(mix(sh0Mins.w, sh0Maxs.w, sh0Sample.w));
	#else
		uint scale = pack101010(resolveCodebook(scalesSample, scales_codebook));
		uint sh0 = pack111110(resolveCodebook(sh0Sample.xyz, sh0_codebook));
		float alpha = sh0Sample.w;
	#endif
	uint qmode = uint(quatsSample.w * 255.0) - 252u;
	pcFragColor0 = uvec4(
		pack8888(vec4(meansLSample, shLabelsSample.x)),
		pack8888(vec4(meansUSample, shLabelsSample.y)),
		pack8888(vec4(quatsSample.xyz, alpha)),
		(scale << 2u) | qmode
	);
	pcFragColor1 = unpack8888(sh0);
}
`,EH=`
#include "gsplatPackingPS"
var means_l: texture_2d<f32>;
var means_u: texture_2d<f32>;
var quats: texture_2d<f32>;
var scales: texture_2d<f32>;
var sh0: texture_2d<f32>;
var sh_labels: texture_2d<f32>;
uniform numSplats: u32;
#ifdef REORDER_V1
	fn sigmoid(x: f32) -> f32 { return 1.0 / (1.0 + exp(-x)); }
	fn vmin(v: vec3f) -> vec3f { return vec3f(min(min(v.x, v.y), v.z)); }
	fn vmax(v: vec3f) -> vec3f { return vec3f(max(max(v.x, v.y), v.z)); }
	fn resolve(m: vec3f, M: vec3f, v: vec3f) -> vec3f { return (mix(m, M, v) - vmin(m)) / (vmax(M) - vmin(m)); }
	uniform scalesMins: vec3f;
	uniform scalesMaxs: vec3f;
	uniform sh0Mins: vec4f;
	uniform sh0Maxs: vec4f;
#else
	uniform scales_codebook: array<vec4f, 64>;
	uniform sh0_codebook: array<vec4f, 64>;
#endif
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	let w: u32 = textureDimensions(means_l, 0).x;
	let uv: vec2<u32> = vec2<u32>(input.position.xy);
	if (uv.x + uv.y * w >= uniform.numSplats) {
		discard;
		return output;
	}
	let meansLSample: vec3<f32> = textureLoad(means_l, uv, 0).xyz;
	let meansUSample: vec3<f32> = textureLoad(means_u, uv, 0).xyz;
	let quatsSample: vec4<f32> = textureLoad(quats, uv, 0);
	let scalesSample: vec3<f32> = textureLoad(scales, uv, 0).xyz;
	let sh0Sample: vec4f = textureLoad(sh0, uv, 0);
	let shLabelsSample: vec2<f32> = textureLoad(sh_labels, uv, 0).xy;
	#ifdef REORDER_V1
		let scale = pack101010(resolve(uniform.scalesMins, uniform.scalesMaxs, scalesSample));
		let sh0 = pack111110(resolve(uniform.sh0Mins.xyz, uniform.sh0Maxs.xyz, sh0Sample.xyz));
		let alpha = sigmoid(mix(uniform.sh0Mins.w, uniform.sh0Maxs.w, sh0Sample.w));
	#else
		let scale = pack101010(resolveCodebook(scalesSample, &uniform.scales_codebook));
		let sh0 = pack111110(resolveCodebook(sh0Sample.xyz, &uniform.sh0_codebook));
		let alpha = sh0Sample.w;
	#endif
	let qmode = u32(quatsSample.w * 255.0) - 252u;
	output.color = vec4u(
		pack8888(vec4f(meansLSample, shLabelsSample.x)),
		pack8888(vec4f(meansUSample, shLabelsSample.y)),
		pack8888(vec4f(quatsSample.xyz, alpha)),
		(scale << 2u) | qmode
	);
	output.color1 = unpack8888(sh0);
	return output;
}
`,bH=`
#include "gsplatPackingPS"
uniform highp sampler2D sh_centroids;
uniform vec4 shN_codebook[64];
void main(void) {
	ivec2 uv = ivec2(gl_FragCoord.xy);
	vec3 shNSample = texelFetch(sh_centroids, uv, 0).xyz;
#ifdef REORDER_V1
	pcFragColor0 = unpack8888(pack111110(shNSample));
#else
	pcFragColor0 = unpack8888(pack111110(resolveCodebook(shNSample, shN_codebook)));
#endif
}
`,P_=`
uint pack8888(vec4 v) {
	uvec4 t = uvec4(v * 255.0) << uvec4(24u, 16u, 8u, 0u);
	return t.x | t.y | t.z | t.w;
}
uint pack101010(vec3 v) {
	uvec3 t = uvec3(v * 1023.0) << uvec3(20u, 10u, 0u);
	return t.x | t.y | t.z;
}
uint pack111110(vec3 v) {
	uvec3 t = uvec3(v * vec3(2047.0, 2047.0, 1023.0)) << uvec3(21u, 10u, 0u);
	return t.x | t.y | t.z;
}
vec4 unpack8888(uint v) {
	return vec4((uvec4(v) >> uvec4(24u, 16u, 8u, 0u)) & 0xffu) / 255.0;
}
vec3 unpack101010(uint v) {
	return vec3((uvec3(v) >> uvec3(20u, 10u, 0u)) & 0x3ffu) / 1023.0;
}
vec3 unpack111110(uint v) {
	return vec3((uvec3(v) >> uvec3(21u, 10u, 0u)) & uvec3(0x7ffu, 0x7ffu, 0x3ffu)) / vec3(2047.0, 2047.0, 1023.0);
}
vec3 resolveCodebook(vec3 s, vec4 codebook[64]) {
	uvec3 idx = uvec3(s * 255.0);
	vec3 v = vec3(
		codebook[idx.x >> 2u][idx.x & 3u],
		codebook[idx.y >> 2u][idx.y & 3u],
		codebook[idx.z >> 2u][idx.z & 3u]
	);
	return (v - codebook[0].x) / (codebook[63].w - codebook[0].x);
}
`,AH=`
#include "gsplatPackingPS"
var sh_centroids: texture_2d<f32>;
uniform shN_codebook: array<vec4f, 64>;
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	var uv = vec2i(input.position.xy);
	var shNSample = textureLoad(sh_centroids, uv, 0).xyz;
#ifdef REORDER_V1
	output.color = unpack8888(pack111110(shNSample));
#else
	output.color = unpack8888(pack111110(resolveCodebook(shNSample, &uniform.shN_codebook)));
#endif
	return output;
}
`,R_=`
fn pack8888(v: vec4f) -> u32 {
	let t = vec4u(v * 255.0) << vec4u(24u, 16u, 8u, 0u);
	return t.x | t.y | t.z | t.w;
}
fn pack101010(v: vec3f) -> u32 {
	let t = vec3u(v * vec3f(1023.0, 1023.0, 1023.0)) << vec3u(20u, 10u, 0u);
	return t.x | t.y | t.z;
}
fn pack111110(v: vec3f) -> u32 {
	let t = vec3u(v * vec3f(2047.0, 2047.0, 1023.0)) << vec3u(21u, 10u, 0u);
	return t.x | t.y | t.z;
}
fn unpack8888(v: u32) -> vec4f {
	return vec4f((vec4u(v) >> vec4u(24u, 16u, 8u, 0u)) & vec4u(0xffu)) / 255.0;
}
fn unpack101010(v: u32) -> vec3f {
	return vec3f((vec3u(v) >> vec3u(20u, 10u, 0u)) & vec3u(0x3ffu)) / 1023.0;
}
fn unpack111110(v: u32) -> vec3f {
	return vec3f((vec3u(v) >> vec3u(21u, 10u, 0u)) & vec3u(0x7ffu, 0x7ffu, 0x3ffu)) / vec3f(2047.0, 2047.0, 1023.0);
}
fn resolveCodebook(s: vec3f, codebook: ptr<uniform, array<vec4f, 64>>) -> vec3f {
	let idx = vec3u(s * 255.0);
	let v = vec3f(
		codebook[idx.x >> 2u][idx.x & 3u],
		codebook[idx.y >> 2u][idx.y & 3u],
		codebook[idx.z >> 2u][idx.z & 3u]
	);
	return (v - codebook[0].x) / (codebook[63].w - codebook[0].x);
}
`,wH=`
#include "gsplatPackingPS"
uniform highp sampler2D means_l;
uniform highp sampler2D means_u;
uniform highp uint numSplats;
uniform highp vec3 means_mins;
uniform highp vec3 means_maxs;
void main(void) {
	int w = int(textureSize(means_l, 0).x);
	ivec2 uv = ivec2(gl_FragCoord.xy);
	if (uint(uv.x + uv.y * w) >= numSplats) {
		discard;
	}
	vec3 l = texelFetch(means_l, uv, 0).xyz;
	vec3 u = texelFetch(means_u, uv, 0).xyz;
	vec3 n = (l + u * 256.0) / 257.0;
	vec3 v = mix(means_mins, means_maxs, n);
	vec3 center = sign(v) * (exp(abs(v)) - 1.0);
	pcFragColor0 = uvec4(floatBitsToUint(center), 0u);
}
`,CH=`
var means_l: texture_2d<f32>;
var means_u: texture_2d<f32>;
uniform numSplats: u32;
uniform means_mins: vec3f;
uniform means_maxs: vec3f;
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	let w: u32 = textureDimensions(means_l, 0).x;
	let uv: vec2<i32> = vec2<i32>(input.position.xy);
	if (u32(uv.x + uv.y * i32(w)) >= uniform.numSplats) {
		discard;
		return output;
	}
	let l: vec3f = textureLoad(means_l, uv, 0).xyz;
	let u: vec3f = textureLoad(means_u, uv, 0).xyz;
	let n: vec3f = (l + u * 256.0) / 257.0;
	let v: vec3f = mix(uniform.means_mins, uniform.means_maxs, n);
	let center: vec3f = sign(v) * (exp(abs(v)) - 1.0);
	let packed: vec4<u32> = bitcast<vec4<u32>>(vec4f(center, 0.0));
	output.color = packed;
	return output;
}
`;const La=.28209479177387814,Un=c=>c.device.isNull?new Promise(e=>{e(new Uint8Array(c.width*c.height*4))}):c.read(0,0,c.width,c.height,{mipLevel:0,face:0,immediate:!0}),J0=(c,e)=>{for(const t in e)c.resolve(t).setValue(e[t])};class DH{constructor(e,t,s,i,r,a){const o=(M,R,L)=>M*(1-L)+R*L,{meta:h,shBands:u}=e,{means:f,scales:m,sh0:_,shN:g}=h,S=t&&e.means_l._levels[0],x=t&&e.means_u._levels[0],T=s&&e.quats._levels[0],E=i&&e.scales._levels[0],b=r&&e.sh0._levels[0],C=a&&e.sh_labels._levels[0],w=a&&e.sh_centroids._levels[0],P=Math.SQRT2,I={1:3,2:8,3:15}[u]??0;this.read=M=>{if(t){const R=o(f.mins[0],f.maxs[0],((x[M*4+0]<<8)+S[M*4+0])/65535),L=o(f.mins[1],f.maxs[1],((x[M*4+1]<<8)+S[M*4+1])/65535),B=o(f.mins[2],f.maxs[2],((x[M*4+2]<<8)+S[M*4+2])/65535);t.x=Math.sign(R)*(Math.exp(Math.abs(R))-1),t.y=Math.sign(L)*(Math.exp(Math.abs(L))-1),t.z=Math.sign(B)*(Math.exp(Math.abs(B))-1)}if(s){const R=(T[M*4+0]/255-.5)*P,L=(T[M*4+1]/255-.5)*P,B=(T[M*4+2]/255-.5)*P,G=Math.sqrt(Math.max(0,1-(R*R+L*L+B*B)));switch(T[M*4+3]-252){case 0:s.set(R,L,B,G);break;case 1:s.set(G,L,B,R);break;case 2:s.set(L,G,B,R);break;case 3:s.set(L,B,G,R);break}}if(i)if(h.version===2){const R=m.codebook[E[M*4+0]],L=m.codebook[E[M*4+1]],B=m.codebook[E[M*4+2]];i.set(R,L,B)}else{const R=o(m.mins[0],m.maxs[0],E[M*4+0]/255),L=o(m.mins[1],m.maxs[1],E[M*4+1]/255),B=o(m.mins[2],m.maxs[2],E[M*4+2]/255);i.set(R,L,B)}if(r)if(h.version===2){const R=_.codebook[b[M*4+0]],L=_.codebook[b[M*4+1]],B=_.codebook[b[M*4+2]],G=b[M*4+3]/255;r.set(.5+R*La,.5+L*La,.5+B*La,G)}else{const R=o(_.mins[0],_.maxs[0],b[M*4+0]/255),L=o(_.mins[1],_.maxs[1],b[M*4+1]/255),B=o(_.mins[2],_.maxs[2],b[M*4+2]/255),G=o(_.mins[3],_.maxs[3],b[M*4+3]/255);r.set(.5+R*La,.5+L*La,.5+B*La,1/(1+Math.exp(-G)))}if(a){const R=C[M*4+0]+(C[M*4+1]<<8),L=R%64*I,B=Math.floor(R/64);if(h.version===2)for(let G=0;G<3;++G)for(let H=0;H<I;++H)a[G*15+H]=g.codebook[w[(L+H)*4+G+B*e.sh_centroids.width*4]];else for(let G=0;G<3;++G)for(let H=0;H<I;++H)a[G*15+H]=o(g.mins,g.maxs,w[(L+H)*4+G+B*e.sh_centroids.width*4]/255)}}}}class mf{_destroyGpuResources(){this.means_l?.destroy(),this.means_u?.destroy(),this.quats?.destroy(),this.scales?.destroy(),this.sh0?.destroy(),this.sh_centroids?.destroy(),this.sh_labels?.destroy(),this.packedTexture?.destroy(),this.packedSh0?.destroy(),this.packedShN?.destroy()}static calcBands(e){return{192:1,512:2,960:3}[e]??0}destroy(){this.deviceRestoredEvent?.off(),this.deviceRestoredEvent=null,this.destroyed=!0,this._destroyGpuResources()}createIter(e,t,s,i,r){return new DH(this,e,t,s,i,r)}calcAabb(e){const{mins:t,maxs:s}=this.meta.means,i=r=>Math.sign(r)*(Math.exp(Math.abs(r))-1);e.center.set((i(t[0])+i(s[0]))*.5,(i(t[1])+i(s[1]))*.5,(i(t[2])+i(s[2]))*.5),e.halfExtents.set((i(s[0])-i(t[0]))*.5,(i(s[1])-i(t[1]))*.5,(i(s[2])-i(t[2]))*.5)}getCenters(){const e=this._centers;return this._centers=null,e}calcFocalPoint(e,t){const{mins:s,maxs:i}=this.meta.means,r=a=>Math.sign(a)*(Math.exp(Math.abs(a))-1);e.set((r(s[0])+r(i[0]))*.5,(r(s[1])+r(i[1]))*.5,(r(s[2])+r(i[2]))*.5)}get isSogs(){return!0}async decompress(){const e=["x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3"],{shBands:t}=this,{means_l:s,means_u:i,quats:r,scales:a,sh0:o,sh_labels:h,sh_centroids:u}=this;if(s._levels[0]=await Un(s),i._levels[0]=await Un(i),r._levels[0]=await Un(r),a._levels[0]=await Un(a),o._levels[0]=await Un(o),t>0){h._levels[0]=await Un(h),u._levels[0]=await Un(u);const E=[];for(let b=0;b<45;++b)E.push(`f_rest_${b}`);e.splice(e.indexOf("f_dc_0")+1,0,...E)}const f={};e.forEach(E=>{f[E]=new Float32Array(this.numSplats)});const m=new D,_=new pe,g=new D,S=new me,x=t>0?new Float32Array(45):null,T=this.createIter(m,_,g,S,x);for(let E=0;E<this.numSplats;++E)if(T.read(E),f.x[E]=m.x,f.y[E]=m.y,f.z[E]=m.z,f.rot_1[E]=_.x,f.rot_2[E]=_.y,f.rot_3[E]=_.z,f.rot_0[E]=_.w,f.scale_0[E]=g.x,f.scale_1[E]=g.y,f.scale_2[E]=g.z,f.f_dc_0[E]=(S.x-.5)/La,f.f_dc_1[E]=(S.y-.5)/La,f.f_dc_2[E]=(S.z-.5)/La,f.opacity[E]=S.w<=0?-40:S.w>=1?40:-Math.log(1/S.w-1),x)for(let b=0;b<45;++b)f[`f_rest_${b}`][E]=x[b];return new Ml([{name:"vertex",count:this.numSplats,properties:e.map(E=>({name:E,type:"float",byteSize:4,storage:f[E]}))}])}async generateCenters(){const{device:e,width:t,height:s}=this.means_l,{scope:i}=e,r=new De(e,{name:"sogsCentersTexture",width:t,height:s,format:Ps,mipmaps:!1}),a=ns.createShader(e,{uniqueName:"GsplatSogsCentersShader",attributes:{vertex_position:He},vertexChunk:"fullscreenQuadVS",fragmentGLSL:wH,fragmentWGSL:CH,fragmentOutputTypes:["uvec4"],fragmentIncludes:new Map([["gsplatPackingPS",e.isWebGPU?R_:P_]])}),o=new At({colorBuffer:r,depth:!1,mipLevel:0});e.setCullMode(Ft),e.setBlendState(ht.NOBLEND),e.setDepthState(Gt.NODEPTH),J0(i,{means_l:this.means_l,means_u:this.means_u,numSplats:this.numSplats,means_mins:this.meta.means.mins,means_maxs:this.meta.means.maxs}),gr(e,o,a),o.destroy();const h=await Un(r);if(this.destroyed||e._destroyed){r.destroy();return}const u=new Float32Array(h.buffer),f=new Float32Array(this.numSplats*3);for(let m=0;m<this.numSplats;m++){const _=m*4;f[m*3+0]=u[_+0],f[m*3+1]=u[_+1],f[m*3+2]=u[_+2]}this._centers=f,r.destroy()}packGpuMemory(){const{meta:e,means_l:t,means_u:s,quats:i,scales:r,sh0:a,sh_labels:o,numSplats:h}=this,{device:u}=t,{scope:f}=u,m=e.version===2?"v2":"v1",_=ns.createShader(u,{uniqueName:`GsplatSogsReorderShader-${m}`,attributes:{vertex_position:He},vertexChunk:"fullscreenQuadVS",fragmentGLSL:TH,fragmentWGSL:EH,fragmentOutputTypes:["uvec4","vec4"],fragmentIncludes:new Map([["gsplatPackingPS",u.isWebGPU?R_:P_]]),fragmentDefines:e.version===2?void 0:new Map([["REORDER_V1","1"]])}),g=new At({colorBuffers:[this.packedTexture,this.packedSh0],depth:!1,mipLevel:0});u.setCullMode(Ft),u.setBlendState(ht.NOBLEND),u.setDepthState(Gt.NODEPTH),J0(f,{means_l:t,means_u:s,quats:i,scales:r,sh0:a,sh_labels:o??t,numSplats:h,"scales_codebook[0]":this.meta.scales.codebook,"sh0_codebook[0]":this.meta.sh0.codebook,scalesMins:e.scales.mins,scalesMaxs:e.scales.maxs,sh0Mins:e.sh0.mins,sh0Maxs:e.sh0.maxs}),gr(u,g,_),g.destroy()}packShMemory(){const{meta:e,sh_centroids:t}=this,{device:s}=t,{scope:i}=s,r=e.version===2?"v2":"v1",a=ns.createShader(s,{uniqueName:`GsplatSogsReorderShShader-${r}`,attributes:{vertex_position:He},vertexChunk:"fullscreenQuadVS",fragmentGLSL:bH,fragmentWGSL:AH,fragmentIncludes:new Map([["gsplatPackingPS",s.isWebGPU?R_:P_]]),fragmentDefines:e.version===2?void 0:new Map([["REORDER_V1","1"]])}),o=new At({colorBuffer:this.packedShN,depth:!1,mipLevel:0});s.setCullMode(Ft),s.setBlendState(ht.NOBLEND),s.setDepthState(Gt.NODEPTH),J0(i,{sh_centroids:t,"shN_codebook[0]":this.meta.shN.codebook}),gr(s,o,a),o.destroy()}async prepareGpuData(){let e=this.means_l.device;const{height:t,width:s}=this.means_l;if(this.destroyed||!e||e._destroyed)return;const i=this.url?`_${this.url}`:"";if(this.packedTexture=new De(e,{name:`sogsPackedTexture${i}`,width:s,height:t,format:Ps,mipmaps:!1}),this.packedSh0=new De(e,{name:`sogsPackedSh0${i}`,width:s,height:t,format:Ze,mipmaps:!1}),this.packedShN=this.sh_centroids&&new De(e,{name:`sogsPackedShN${i}`,width:this.sh_centroids.width,height:this.sh_centroids.height,format:Ze,mipmaps:!1}),this.minimalMemory||(this.deviceRestoredEvent=e.on("devicerestored",()=>{this.packGpuMemory(),this.packedShN&&this.packShMemory()})),["scales","sh0","shN"].forEach(r=>{const a=this.meta[r]?.codebook;a?.[0]===null&&(a[0]=a[1]+(a[1]-a[255])/255)}),e=this.means_l?.device,!(this.destroyed||!e||e._destroyed)&&(await this.generateCenters(),e=this.means_l?.device,!(this.destroyed||!e||e._destroyed))){if(this.packGpuMemory(),this.packedShN){if(e=this.means_l?.device,this.destroyed||!e||e._destroyed)return;this.packShMemory()}this.minimalMemory&&(this.means_l?.destroy(),this.means_u?.destroy(),this.quats?.destroy(),this.scales?.destroy(),this.sh0?.destroy(),this.sh_centroids?.destroy(),this.sh_labels?.destroy(),this.means_l=null,this.means_u=null,this.quats=null,this.scales=null,this.sh0=null,this.sh_centroids=null,this.sh_labels=null)}}reorderData(){return this.prepareGpuData()}constructor(){this.url="",this.minimalMemory=!1,this.deviceRestoredEvent=null,this._centers=null,this.destroyed=!1,this.shBands=0}}const PH=new fe,Vc=new D,Gc=new D;class _L{destroy(){this.resource?.releaseMesh(),this.orderTexture?.destroy(),this.resolveSH?.destroy(),this.material?.destroy(),this.meshInstance?.destroy(),this.sorter?.destroy()}setMaterialOrderTexture(e){e.setParameter("splatOrder",this.orderTexture),e.setParameter("splatTextureSize",this.orderTexture.width)}set material(e){this._material!==e&&(this._material=e,this.setMaterialOrderTexture(this._material),this.meshInstance&&(this.meshInstance.material=e))}get material(){return this._material}configureMaterial(e,t={}){this.resource.configureMaterial(e),e.setParameter("numSplats",0),this.setMaterialOrderTexture(e),e.setParameter("alphaClip",.3),e.setDefine(`DITHER_${t.dither?"BLUENOISE":"NONE"}`,""),e.cull=Ft,e.blendType=t.dither?qi:ro,e.depthWrite=!!t.dither}sort(e){if(this.sorter){const t=e.getWorldTransform();t.getTranslation(Vc),t.getZ(Gc);const s=this.meshInstance.node.getWorldTransform(),i=PH.invert(s);i.transformPoint(Vc,Vc),i.transformVector(Gc,Gc),(!Vc.equalsApprox(this.lastCameraPosition)||!Gc.equalsApprox(this.lastCameraDirection))&&(this.lastCameraPosition.copy(Vc),this.lastCameraDirection.copy(Gc),this.sorter.setCamera(Vc,Gc))}}update(){if(this.cameras.length>0){const e=this.cameras[0];this.sort(e._node),this.resolveSH?.render(e._node,this.meshInstance.node.getWorldTransform()),this.cameras.length=0}}setHighQualitySH(e){const{resource:t}=this,{gsplatData:s}=t;s instanceof mf&&s.shBands>0&&e===!!this.resolveSH&&(this.resolveSH?(this.resolveSH.destroy(),this.resolveSH=null):this.resolveSH=new SH(t.device,this))}constructor(e,t={}){this.options={},this.sorter=null,this.lastCameraPosition=new D,this.lastCameraDirection=new D,this.resolveSH=null,this.cameras=[],this.resource=e,this.orderTexture=e.createTexture("splatOrder",oo,e.evalTextureSize(e.numSplats)),t.material?(this._material=t.material,this.setMaterialOrderTexture(this._material)):(this._material=new Za({uniqueName:"SplatMaterial",vertexGLSL:'#include "gsplatVS"',fragmentGLSL:'#include "gsplatPS"',vertexWGSL:'#include "gsplatVS"',fragmentWGSL:'#include "gsplatPS"',attributes:{vertex_position:He,vertex_id_attrib:uv}}),this.configureMaterial(this._material),this._material.update()),e.ensureMesh(),this.meshInstance=new lt(e.mesh,this._material),this.meshInstance.setInstancing(e.instanceIndices,!0),this.meshInstance.gsplatInstance=this,this.meshInstance.instancingCount=0;const s=e.centers.slice(),i=e.chunks?.slice();this.sorter=new xH(t.scene),this.sorter.init(this.orderTexture,s,i),this.sorter.on("updated",r=>{this.meshInstance.instancingCount=Math.ceil(r/Js.instanceSize),this.material.setParameter("numSplats",r)}),this.setHighQualitySH(t.highQualitySH??!1)}}class gL extends Js{destroy(){this.gsplatData.destroy(),super.destroy()}configureMaterialDefines(e){e.set("GSPLAT_SOGS_DATA",!0),e.set("SH_BANDS",this.gsplatData.shBands)}configureMaterial(e){const{gsplatData:t}=this,{meta:s}=t;this.configureMaterialDefines(e.defines),["packedTexture","packedSh0","packedShN"].forEach(i=>{t[i]&&e.setParameter(i,t[i])}),["means"].forEach(i=>{const r=s[i];r&&(e.setParameter(`${i}_mins`,r.mins),e.setParameter(`${i}_maxs`,r.maxs))}),s.version===2?["scales","sh0","shN"].forEach(i=>{const r=s[i];r&&(e.setParameter(`${i}_mins`,r.codebook[0]),e.setParameter(`${i}_maxs`,r.codebook[255]))}):(["scales","sh0"].forEach(i=>{const r=s[i];r&&(e.setParameter(`${i}_mins`,Math.min(...r.mins.slice(0,3))),e.setParameter(`${i}_maxs`,Math.max(...r.maxs.slice(0,3))))}),["shN"].forEach(i=>{const r=s[i];r&&(e.setParameter(`${i}_mins`,r.mins),e.setParameter(`${i}_maxs`,r.maxs))}))}evalTextureSize(e){return new ne(this.gsplatData.means_l.width,this.gsplatData.means_l.height)}}const M_="NONE",iT="FILL_WINDOW",gg="KEEP_ASPECT",yh="AUTO",rT="FIXED";let vL;function fl(){return vL}function aT(c){vL=c}class RH{addRenderPass(e){e.frameUpdate();const t=e.beforePasses;for(let i=0;i<t.length;i++){const r=t[i];r.enabled&&this.addRenderPass(r)}e.enabled&&this.renderPasses.push(e);const s=e.afterPasses;for(let i=0;i<s.length;i++){const r=s[i];r.enabled&&this.addRenderPass(r)}}reset(){this.renderPasses.length=0}compile(){const e=this.renderTargetMap,t=this.renderPasses;for(let r=0;r<t.length;r++){const a=t[r],o=a.renderTarget;if(o!==void 0){const h=e.get(o);if(h){const u=a.colorArrayOps.length;for(let f=0;f<u;f++)a.colorArrayOps[f].clear||(h.colorArrayOps[f].store=!0);a.depthStencilOps.clearDepth||(h.depthStencilOps.storeDepth=!0),a.depthStencilOps.clearStencil||(h.depthStencilOps.storeStencil=!0)}e.set(o,a)}}for(let r=0;r<t.length-1;r++){const a=t[r],o=a.renderTarget,h=t[r+1],u=h.renderTarget;o!==u||o===void 0||h.depthStencilOps.clearDepth||h.depthStencilOps.clearStencil||h.colorArrayOps.some(f=>f.clear)||a.afterPasses.length>0||h.beforePasses.length>0||(a._skipEnd=!0,h._skipStart=!0)}let s=null,i=null;for(let r=0;r<t.length;r++){const a=t[r],o=a.renderTarget,h=o?.colorBuffer;if(h?.cubemap){if(s===h){const u=i.colorArrayOps.length;for(let f=0;f<u;f++)i.colorArrayOps[f].mipmaps=!1}s=o.colorBuffer,i=a}else a.requiresCubemaps&&(s=null,i=null)}e.clear()}render(e){this.compile();const t=this.renderPasses;for(let s=0;s<t.length;s++)t[s].render()}constructor(){this.renderPasses=[],this.renderTargetMap=new Map}}class MH{destroy(){this.texture0?.destroy(),this.texture1?.destroy()}constructor(e,t){this.texture0=e,this.texture1=t}}const OP=new ks;class nl{static createTexture(e,t,s,i=""){return new De(e,{name:`AreaLightLUT${i}`,width:s,height:s,format:t,addressU:Te,addressV:Te,type:qr,magFilter:$t,minFilter:ze,anisotropy:1,mipmaps:!1})}static applyTextures(e,t,s){OP.remove(e),OP.get(e,()=>new MH(t,t===s?null:s)),e.scope.resolve("areaLightsLutTex1").setValue(t),e.scope.resolve("areaLightsLutTex2").setValue(s)}static createPlaceholder(e){const t=nl.createTexture(e,kt,2,"placeholder");t.lock().fill(0),t.unlock(),nl.applyTextures(e,t,t)}static set(e,t,s){function i(_,g,S){const x=nl.createTexture(_,S,64);return x.lock().set(g),x.unlock(),x}function r(_){const g=_.length,S=new Uint16Array(g),x=pl.float2Half;for(let T=0;T<g;T++)S[T]=x(_[T]);return S}const a=t,o=s,h=r(a),u=r(o),f=i(e,h,kt),m=i(e,u,kt);nl.applyTextures(e,f,m)}}const vg="en-US",Sg={en:"en-US",es:"en-ES",zh:"zh-CN","zh-HK":"zh-TW","zh-TW":"zh-HK","zh-MO":"zh-HK",fr:"fr-FR",de:"de-DE",it:"it-IT",ru:"ru-RU",ja:"ja-JP"},rb={};function po(c,e){for(let t=0,s=c.length;t<s;t++)rb[c[t]]=e}function Ca(c){const e=c.indexOf("-");return e!==-1?c.substring(0,e):c}function LH(c,e){const t=c.indexOf("-");return t!==-1?e+c.substring(t):e}function SL(c,e){if(e[c])return c;let t=Sg[c];if(t&&e[t])return t;const s=Ca(c);return t=Sg[s],e[t]?t:e[s]?s:vg}po(["ja","ko","th","vi","zh","id"],c=>0);po(["fa","hi"],c=>c>=0&&c<=1?0:1);po(["fr","pt"],c=>c>=0&&c<2?0:1);po(["da"],c=>c===1||!Number.isInteger(c)&&c>=0&&c<=1?0:1);po(["de","en","it","el","es","tr","fi","sv","nb","no","ur"],c=>c===1?0:1);po(["ru","uk"],c=>{if(Number.isInteger(c)){const e=c%10,t=c%100;if(e===1&&t!==11)return 0;if(e>=2&&e<=4&&(t<12||t>14))return 1;if(e===0||e>=5&&e<=9||t>=11&&t<=14)return 2}return 3});po(["pl"],c=>{if(Number.isInteger(c)){if(c===1)return 0;const e=c%10,t=c%100;if(e>=2&&e<=4&&(t<12||t>14))return 1;if(e>=0&&e<=1||e>=5&&e<=9||t>=12&&t<=14)return 2}return 3});po(["ar"],c=>{if(c===0)return 0;if(c===1)return 1;if(c===2)return 2;if(Number.isInteger(c)){const e=c%100;if(e>=3&&e<=10)return 3;if(e>=11&&e<=99)return 4}return 5});const IH=rb[Ca(vg)];function ex(c){return rb[c]||IH}const Nh=new RegExp("^\\s*(?:(?:[a-z]+[a-z0-9\\-+.]*:)?//|data:|blob:)","i");class OH{equals(e){return this.url===e.url&&this.filename===e.filename&&this.hash===e.hash&&this.size===e.size&&this.opt===e.opt&&this.contents===e.contents}constructor(e="",t="",s=null,i=null,r=null,a=null){this.url=e,this.filename=t,this.hash=s,this.size=i,this.opt=r,this.contents=a}}let NH=-1;const FH={pvr:"extCompressedTexturePVRTC",dxt:"extCompressedTextureS3TC",etc2:"extCompressedTextureETC",etc1:"extCompressedTextureETC1",basis:"canvas"},NP=["pvr","dxt","etc2","etc1","basis"];class Ee extends Pe{set name(e){if(this._name===e)return;const t=this._name;this._name=e,this.fire("name",this,this._name,t)}get name(){return this._name}set file(e){if(e&&e.variants&&["texture","textureatlas","bundle"].indexOf(this.type)!==-1){const i=this.registry?._loader?._app||fl(),r=i?.graphicsDevice;if(r)for(let a=0,o=NP.length;a<o;a++){const h=NP[a];if(e.variants[h]&&r[FH[h]]){e=e.variants[h];break}if(i.enableBundles){const u=i.bundles.listBundlesForAsset(this);if(u&&u.find(f=>f?.file?.variants[h]))break}}}const t=this._file,s=e?new OH(e.url,e.filename,e.hash,e.size,e.opt,e.contents):null;(!!s!=!!t||s&&!s.equals(t))&&(this._file=s,this.fire("change",this,"file",s,t),this.reload())}get file(){return this._file}set data(e){const t=this._data;this._data=e,e!==t&&(this.fire("change",this,"data",e,t),this.loaded&&this.registry._loader.patch(this,this.registry))}get data(){return this._data}set resource(e){const t=this._resources[0];this._resources[0]=e,this.fire("change",this,"resource",e,t)}get resource(){return this._resources[0]}set resources(e){const t=this._resources;this._resources=e,this.fire("change",this,"resources",e,t)}get resources(){return this._resources}set preload(e){e=!!e,this._preload!==e&&(this._preload=e,this._preload&&!this.loaded&&!this.loading&&this.registry&&this.registry.load(this))}get preload(){return this._preload}set loadFaces(e){e=!!e,(!this.hasOwnProperty("_loadFaces")||e!==this._loadFaces)&&(this._loadFaces=e,this.loaded&&this.registry._loader.patch(this,this.registry))}get loadFaces(){return this._loadFaces}getFileUrl(){const e=this.file;if(!e||!e.url)return null;let t=e.url;if(this.registry&&this.registry.prefix&&!Nh.test(t)&&(t=this.registry.prefix+t),this.type!=="script"&&e.hash){const s=t.indexOf("?")!==-1?"&":"?";t+=`${s}t=${e.hash}`}return t}getAbsoluteUrl(e){if(e.startsWith("blob:")||e.startsWith("data:"))return e;const t=Re.getDirectory(this.file.url);return Re.join(t,e)}getLocalizedAssetId(e){return e=SL(e,this._i18n),this._i18n[e]||null}addLocalizedAssetId(e,t){this._i18n[e]=t,this.fire("add:localized",e,t)}removeLocalizedAssetId(e){const t=this._i18n[e];t&&(delete this._i18n[e],this.fire("remove:localized",e,t))}ready(e,t){t=t||this,this.loaded?e.call(t,this):this.once("load",s=>{e.call(t,s)})}reload(){this.loaded&&(this.loaded=!1,this.registry.load(this))}unload(){if(!this.loaded&&this._resources.length===0)return;this.fire("unload",this),this.registry.fire(`unload:${this.id}`,this);const e=this._resources;this.urlObject&&(URL.revokeObjectURL(this.urlObject),this.urlObject=null),this.resources=[],this.loaded=!1,this.file&&this.registry._loader.clearCache(this.getFileUrl(),this.type);for(let t=0;t<e.length;++t)e[t]?.destroy?.()}static fetchArrayBuffer(e,t,s,i=0){s?.file?.contents?setTimeout(()=>{t(null,s.file.contents)}):Pt.get(e,{cache:!0,responseType:"arraybuffer",retry:i>0,maxRetries:i,progress:s},t)}constructor(e,t,s,i={},r={}){super(),this._file=null,this._i18n={},this._preload=!1,this._resources=[],this.id=NH--,this.loaded=!1,this.loading=!1,this.options={},this.registry=null,this.tags=new xf(this),this.urlObject=null,this._name=e||"",this.type=t,this._data=i||{},this.options=r||{},s&&(this.file=s)}}Ee.EVENT_LOAD="load";Ee.EVENT_UNLOAD="unload";Ee.EVENT_REMOVE="remove";Ee.EVENT_ERROR="error";Ee.EVENT_CHANGE="change";Ee.EVENT_PROGRESS="progress";Ee.EVENT_ADDLOCALIZED="add:localized";Ee.EVENT_REMOVELOCALIZED="remove:localized";class BH{addItem(e){const t=e.tags._list;for(const s of t)this.add(s,e)}removeItem(e){const t=e.tags._list;for(const s of t)this.remove(s,e)}add(e,t){this._index[e]&&this._index[e].list.indexOf(t)!==-1||(this._index[e]||(this._index[e]={list:[]},this._key&&(this._index[e].keys={})),this._index[e].list.push(t),this._key&&(this._index[e].keys[t[this._key]]=t))}remove(e,t){if(!this._index[e]||this._key&&!this._index[e].keys[t[this._key]])return;const s=this._index[e].list.indexOf(t);s!==-1&&(this._index[e].list.splice(s,1),this._key&&delete this._index[e].keys[t[this._key]],this._index[e].list.length===0&&delete this._index[e])}find(e){const t={},s=[];let i,r,a,o,h;const u=(f,m)=>this._index[f].list.length-this._index[m].list.length;for(let f=0;f<e.length;f++){if(r=e[f],r instanceof Array){if(r.length===0)continue;if(r.length===1)r=r[0];else{h=!1;for(let m=0;m<r.length;m++)if(!this._index[r[m]]){h=!0;break}if(h)continue;a=r.slice(0).sort(u),o=a.slice(1),o.length===1&&(o=o[0]);for(let m=0;m<this._index[a[0]].list.length;m++)i=this._index[a[0]].list[m],(this._key?!t[i[this._key]]:s.indexOf(i)===-1)&&i.tags.has(o)&&(this._key&&(t[i[this._key]]=!0),s.push(i));continue}}if(r&&typeof r=="string"&&this._index[r])for(let m=0;m<this._index[r].list.length;m++)i=this._index[r].list[m],this._key?t[i[this._key]]||(t[i[this._key]]=!0,s.push(i)):s.indexOf(i)===-1&&s.push(i)}return s}constructor(e=null){this._index={},this._key=e}}class Kf extends Pe{get loader(){return this._loader}list(e={}){const t=Array.from(this._assets);return e.preload!==void 0?t.filter(s=>s.preload===e.preload):t}add(e){this._assets.has(e)||(this._assets.add(e),this._idToAsset.set(e.id,e),e.file?.url&&this._urlToAsset.set(e.file.url,e),this._nameToAsset.has(e.name)||this._nameToAsset.set(e.name,new Set),this._nameToAsset.get(e.name).add(e),e.on("name",this._onNameChange,this),e.registry=this,this._tags.addItem(e),e.tags.on("add",this._onTagAdd,this),e.tags.on("remove",this._onTagRemove,this),this.fire("add",e),this.fire(`add:${e.id}`,e),e.file?.url&&this.fire(`add:url:${e.file.url}`,e),e.preload&&this.load(e))}remove(e){if(!this._assets.has(e))return!1;if(this._assets.delete(e),this._idToAsset.delete(e.id),e.file?.url&&this._urlToAsset.delete(e.file.url),e.off("name",this._onNameChange,this),this._nameToAsset.has(e.name)){const t=this._nameToAsset.get(e.name);t.delete(e),t.size===0&&this._nameToAsset.delete(e.name)}return this._tags.removeItem(e),e.tags.off("add",this._onTagAdd,this),e.tags.off("remove",this._onTagRemove,this),e.fire("remove",e),this.fire("remove",e),this.fire(`remove:${e.id}`,e),e.file?.url&&this.fire(`remove:url:${e.file.url}`,e),!0}get(e){return this._idToAsset.get(Number(e))}getByUrl(e){return this._urlToAsset.get(e)}load(e,t){if((e.loading||e.loaded)&&!t?.force)return;const s=e.file,i=()=>{this.fire("load",e),this.fire(`load:${e.id}`,e),s&&s.url&&this.fire(`load:url:${s.url}`,e),e.fire("load",e)},r=o=>{if(o instanceof Array?e.resources=o:e.resource=o,this._loader.patch(e,this),e.type==="bundle"){const h=e.data.assets;for(let u=0;u<h.length;u++){const f=this._idToAsset.get(h[u]);f&&!f.loaded&&this.load(f,{force:!0})}e.resource.loaded?i():(this.fire("load:start",e),this.fire(`load:start:${e.id}`,e),s&&s.url&&this.fire(`load:start:url:${s.url}`,e),e.fire("load:start",e),e.resource.on("load",i))}else i()},a=(o,h,u)=>{if(e.loaded=!0,e.loading=!1,o)this.fire("error",o,e),this.fire(`error:${e.id}`,o,e),e.fire("error",o,e);else{if(e.type==="script"){const f=this._loader.getHandler("script");f._cache[e.id]&&f._cache[e.id].parentNode===document.head&&document.head.removeChild(f._cache[e.id]),u&&(f._cache[e.id]=u)}r(h)}};if(s||e.type==="cubemap"){this.fire("load:start",e),this.fire(`load:${e.id}:start`,e),e.loading=!0;const o=e.getFileUrl();if(e.type==="bundle"){const h=e.data.assets;for(let u=0;u<h.length;u++){const f=this._idToAsset.get(h[u]);f&&(f.loaded||f.resource||f.loading||(f.loading=!0))}}this._loader.load(o,e.type,a,e,t)}else{const o=this._loader.open(e.type,e.data);e.loaded=!0,r(o)}}loadFromUrl(e,t,s){this.loadFromUrlAndFilename(e,null,t,s)}loadFromUrlAndFilename(e,t,s,i){const r=Re.getBasename(t||e),a={filename:t||r,url:e};let o=this.getByUrl(e);if(!o)o=new Ee(r,s,a),this.add(o);else if(o.loaded){i(o.loadFromUrlError||null,o);return}const h=u=>{u.once("load",f=>{s==="material"?this._loadTextures(f,(m,_)=>{i(m,f)}):i(null,f)}),u.once("error",f=>{f&&(this.loadFromUrlError=f),i(f,u)}),this.load(u)};o.resource?i(null,o):s==="model"?this._loadModel(o,h):h(o)}_loadModel(e,t){const s=e.getFileUrl(),i=Re.getExtension(s);if(i===".json"||i===".glb"){const r=Re.getDirectory(s),a=Re.getBasename(s),o=Re.join(r,a.replace(i,".mapping.json"));this._loader.load(o,"json",(h,u)=>{h?(e.data={mapping:[]},t(e)):this._loadMaterials(e,u,(f,m)=>{e.data=u,t(e)})})}else t(e)}_loadMaterials(e,t,s){const i=[];let r=0;const a=(o,h)=>{this._loadTextures(h,(u,f)=>{i.push(h),i.length===r&&s(null,i)})};for(let o=0;o<t.mapping.length;o++){const h=t.mapping[o].path;if(h){r++;const u=e.getAbsoluteUrl(h);this.loadFromUrl(u,"material",a)}}r===0&&s(null,i)}_loadTextures(e,t){const s=[];let i=0;const r=e.data;if(r.mappingFormat!=="path"){t(null,s);return}const a=(h,u)=>{h&&console.error(h),s.push(u),s.length===i&&t(null,s)},o=Iv;for(let h=0;h<o.length;h++){const u=r[o[h]];if(u&&typeof u=="string"){i++;const f=e.getAbsoluteUrl(u);this.loadFromUrl(f,"texture",a)}}i===0&&t(null,s)}_onTagAdd(e,t){this._tags.add(e,t)}_onTagRemove(e,t){this._tags.remove(e,t)}_onNameChange(e,t,s){if(this._nameToAsset.has(s)){const i=this._nameToAsset.get(s);i.delete(e),i.size===0&&this._nameToAsset.delete(s)}this._nameToAsset.has(e.name)||this._nameToAsset.set(e.name,new Set),this._nameToAsset.get(e.name).add(e)}findByTag(...e){return this._tags.find(e)}filter(e){return Array.from(this._assets).filter(t=>e(t))}find(e,t){const s=this._nameToAsset.get(e);if(!s)return null;for(const i of s)if(!t||i.type===t)return i;return null}findAll(e,t){const s=this._nameToAsset.get(e);if(!s)return[];const i=Array.from(s);return t?i.filter(r=>r.type===t):i}log(){}constructor(e){super(),this._assets=new Set,this._idToAsset=new Map,this._urlToAsset=new Map,this._nameToAsset=new Map,this._tags=new BH("id"),this.prefix=null,this.bundles=null,this._loader=e}}Kf.EVENT_LOAD="load";Kf.EVENT_ADD="add";Kf.EVENT_REMOVE="remove";Kf.EVENT_ERROR="error";class UH{_onAssetAdd(e){if(e.type==="bundle"){this._idToBundle.set(e.id,e),this._assets.on(`load:start:${e.id}`,this._onBundleLoadStart,this),this._assets.on(`load:${e.id}`,this._onBundleLoad,this),this._assets.on(`error:${e.id}`,this._onBundleError,this);const t=e.data.assets;for(let s=0;s<t.length;s++)this._indexAssetInBundle(t[s],e)}else this._assetToBundles.has(e.id)&&this._indexAssetFileUrls(e)}_unbindAssetEvents(e){this._assets.off(`load:start:${e}`,this._onBundleLoadStart,this),this._assets.off(`load:${e}`,this._onBundleLoad,this),this._assets.off(`error:${e}`,this._onBundleError,this)}_indexAssetInBundle(e,t){let s=this._assetToBundles.get(e);s||(s=new Set,this._assetToBundles.set(e,s)),s.add(t);const i=this._assets.get(e);i&&this._indexAssetFileUrls(i)}_indexAssetFileUrls(e){const t=this._getAssetFileUrls(e);if(t)for(let s=0;s<t.length;s++){const i=this._assetToBundles.get(e.id);i&&this._urlsToBundles.set(t[s],i)}}_getAssetFileUrls(e){let t=e.getFileUrl();if(!t)return null;t=t.split("?")[0];const s=[t];if(e.type==="font"){const i=e.data.info.maps.length;for(let r=1;r<i;r++)s.push(t.replace(".png",`${r}.png`))}return s}_onAssetRemove(e){if(e.type==="bundle"){this._idToBundle.delete(e.id),this._unbindAssetEvents(e.id);const t=e.data.assets;for(let s=0;s<t.length;s++){const i=this._assetToBundles.get(t[s]);if(i&&(i.delete(e),i.size===0)){this._assetToBundles.delete(t[s]);for(const[r,a]of this._urlsToBundles)a===i&&this._urlsToBundles.delete(r)}}this._onBundleError(`Bundle ${e.id} was removed`)}else{if(!this._assetToBundles.get(e.id))return;this._assetToBundles.delete(e.id);const s=this._getAssetFileUrls(e);if(!s)return;for(let i=0;i<s.length;i++)this._urlsToBundles.delete(s[i])}}_onBundleLoadStart(e){e.resource.on("add",(t,s)=>{const i=this._fileRequests.get(t);if(i){for(let r=0;r<i.length;r++)i[r](null,s);this._fileRequests.delete(t)}})}_onBundleLoad(e){if(!e.resource){this._onBundleError(`Bundle ${e.id} failed to load`);return}if(this._fileRequests)for(const[t,s]of this._fileRequests){const i=this._urlsToBundles.get(t);if(!i||!i.has(e))continue;const r=decodeURIComponent(t);let a,o;if(e.resource.has(r))o=e.resource.get(r);else if(e.resource.loaded)a=`Bundle ${e.id} does not contain URL ${t}`;else continue;for(let h=0;h<s.length;h++)s[h](a,a||o);this._fileRequests.delete(t)}}_onBundleError(e){for(const[t,s]of this._fileRequests)if(!this._findLoadedOrLoadingBundleForUrl(t)){for(let r=0;r<s.length;r++)s[r](e);this._fileRequests.delete(t)}}_findLoadedOrLoadingBundleForUrl(e){const t=this._urlsToBundles.get(e);if(!t)return null;let s=null;for(const i of t){if(i.loaded&&i.resource)return i;i.loading&&(s=i)}return s}listBundlesForAsset(e){const t=this._assetToBundles.get(e.id);return t?Array.from(t):null}list(){return Array.from(this._idToBundle.values())}hasUrl(e){return this._urlsToBundles.has(e)}urlIsLoadedOrLoading(e){return!!this._findLoadedOrLoadingBundleForUrl(e)}loadUrl(e,t){const s=this._findLoadedOrLoadingBundleForUrl(e);if(!s){t(`URL ${e} not found in any bundles`);return}if(s.loaded){const r=decodeURIComponent(e);if(s.resource.has(r)){t(null,s.resource.get(r));return}else if(s.resource.loaded){t(`Bundle ${s.id} does not contain URL ${e}`);return}}let i=this._fileRequests.get(e);i||(i=[],this._fileRequests.set(e,i)),i.push(t)}destroy(){this._assets.off("add",this._onAssetAdd,this),this._assets.off("remove",this._onAssetRemove,this);for(const e of this._idToBundle.keys())this._unbindAssetEvents(e);this._assets=null,this._idToBundle.clear(),this._idToBundle=null,this._assetToBundles.clear(),this._assetToBundles=null,this._urlsToBundles.clear(),this._urlsToBundles=null,this._fileRequests.clear(),this._fileRequests=null}constructor(e){this._idToBundle=new Map,this._assetToBundles=new Map,this._urlsToBundles=new Map,this._fileRequests=new Map,this._assets=e,this._assets.bundles=this,this._assets.on("add",this._onAssetAdd,this),this._assets.on("remove",this._onAssetRemove,this)}}class zH extends Pe{add(e){const t=e.id;if(this[t])throw new Error(`ComponentSystem name '${t}' already registered or not allowed`);this[t]=e,this.list.push(e)}remove(e){const t=e.id;if(!this[t])throw new Error(`No ComponentSystem named '${t}' registered`);delete this[t];const s=this.list.indexOf(this[t]);s!==-1&&this.list.splice(s,1)}destroy(){this.off();for(let e=0;e<this.list.length;e++)this.list[e].destroy()}constructor(){super(),this.list=[]}}class ab extends Pe{addFile(e,t){this._index.has(e)||(this._index.set(e,t),this.fire("add",e,t))}has(e){return this._index.has(e)}get(e){return this._index.get(e)||null}destroy(){this._index.clear()}set loaded(e){!e||this._loaded||(this._loaded=!0,this.fire("load"))}get loaded(){return this._loaded}constructor(...e){super(...e),this._index=new Map,this._loaded=!1}}ab.EVENT_ADD="add";ab.EVENT_LOAD="load";class kH extends Pe{pump(e,t){if(e)return this.fire("done"),null;this.bytesReceived+=t.byteLength;const s=new Uint8Array(this.data.length+t.length);for(s.set(this.data),s.set(t,this.data.length),this.data=s;this.readFile(););return this.reader.read().then(i=>{this.pump(i.done,i.value)}).catch(i=>{this.fire("error",i)})}readFile(){if(!this.headerRead&&this.bytesReceived>this.bytesRead+this.headerSize){this.headerRead=!0;const e=new DataView(this.data.buffer,this.bytesRead,this.headerSize);this.decoder??(this.decoder=new TextDecoder("windows-1252"));const t=this.decoder.decode(e);if(this.fileName=t.substring(0,100).replace(/\0/g,""),this.fileSize=parseInt(t.substring(124,136),8),this.fileType=t.substring(156,157),this.ustarFormat=t.substring(257,263),this.ustarFormat.indexOf("ustar")!==-1){const s=t.substring(345,500).replace(/\0/g,"");s.length>0&&(this.fileName=s.trim()+this.fileName.trim())}this.bytesRead+=512}if(this.headerRead){if(this.bytesReceived<this.bytesRead+this.fileSize)return!1;if(this.fileType===""||this.fileType==="0"){const t=new DataView(this.data.buffer,this.bytesRead,this.fileSize),s={name:this.prefix+this.fileName,size:this.fileSize,data:t};this.fire("file",s)}this.bytesRead+=this.fileSize,this.headerRead=!1;const e=this.bytesRead%this.paddingSize;return e!==0&&(this.bytesRead+=this.paddingSize-e),!0}return!1}constructor(e,t=""){super(),this.headerSize=512,this.paddingSize=512,this.bytesRead=0,this.bytesReceived=0,this.headerRead=!1,this.reader=null,this.data=new Uint8Array(0),this.decoder=null,this.prefix="",this.fileName="",this.fileSize=0,this.fileType="",this.ustarFormat="",this.prefix=t||"",this.reader=e.body.getReader(),this.reader.read().then(s=>{this.pump(s.done,s.value)}).catch(s=>{this.fire("error",s)})}}class Rt{set maxRetries(e){this._maxRetries=e}get maxRetries(){return this._maxRetries}load(e,t,s){}open(e,t,s){return t}patch(e,t){}constructor(e,t){this.handlerType="",this._maxRetries=0,this._app=e,this.handlerType=t}}class VH extends Rt{_fetchRetries(e,t,s=0){return new Promise((i,r)=>{const a=()=>{fetch(e,t).then(i).catch(o=>{s++,s<this.maxRetries?a():r(o)})};a()})}load(e,t){typeof e=="string"&&(e={load:e,original:e}),this._fetchRetries(e.load,{mode:"cors"},this.maxRetries).then(s=>{const i=new ab;t(null,i);const r=new kH(s,this._assets.prefix);r.on("file",a=>{i.addFile(a.name,a.data)}),r.on("done",()=>{i.loaded=!0}),r.on("error",a=>{t(a)})}).catch(s=>{t(s)})}open(e,t){return t}constructor(e){super(e,"bundle"),this._assets=e.assets}}class xh{addHandler(e,t){this._handlers[e]=t,t._loader=this}removeHandler(e){delete this._handlers[e]}getHandler(e){return this._handlers[e]}static makeKey(e,t){return`${e}-${t}`}load(e,t,s,i,r){const a=this._handlers[t];if(!a){const h=`No resource handler for asset type: '${t}' when loading [${e}]`;s(h);return}if(!e){this._loadNull(a,s,i);return}const o=xh.makeKey(e,t);if(this._cache[o]!==void 0)s(null,this._cache[o]);else if(this._requests[o])this._requests[o].push(s);else{this._requests[o]=[s];const h=this,u=function(m,_){if(m){h._onFailure(o,m);return}if(_.load instanceof DataView){if(a.openBinary){if(!h._requests[o])return;try{const g=a.openBinary(_.load);h._onSuccess(o,g)}catch(g){h._onFailure(o,g)}return}_.load=URL.createObjectURL(new Blob([_.load])),i&&(i.urlObject&&URL.revokeObjectURL(i.urlObject),i.urlObject=_.load)}a.load(_,(g,S,x)=>{if(h._requests[o]){if(g){h._onFailure(o,g);return}try{h._onSuccess(o,a.open(_.original,S,i),x)}catch(T){h._onFailure(o,T)}}},i)},f=e.split("?")[0];if(this._app.enableBundles&&this._app.bundles.hasUrl(f)&&!(r&&r.bundlesIgnore)){if(!this._app.bundles.urlIsLoadedOrLoading(f)){const m=this._app.bundles.listBundlesForAsset(i);let _;r&&r.bundlesFilter&&(_=r.bundlesFilter(m)),_||(m?.sort((g,S)=>g.file.size-S.file.size),_=m?.[0]),_&&this._app.assets?.load(_)}this._app.bundles.loadUrl(f,(m,_)=>{u(m,{load:_,original:f})})}else u(null,{load:e,original:i&&i.file.filename||e})}}_loadNull(e,t,s){const i=function(r,a,o){if(r)t(r);else try{t(null,e.open(null,a,s),o)}catch(h){t(h)}};e.load(null,i,s)}_onSuccess(e,t,s){t!==null?this._cache[e]=t:delete this._cache[e];for(let i=0;i<this._requests[e].length;i++)this._requests[e][i](null,t,s);delete this._requests[e]}_onFailure(e,t){if(console.error(t),this._requests[e]){for(let s=0;s<this._requests[e].length;s++)this._requests[e][s](t);delete this._requests[e]}}open(e,t){const s=this._handlers[e];return s?s.open(null,t):(console.warn(`No resource handler found for: ${e}`),t)}patch(e,t){const s=this._handlers[e.type];if(!s){console.warn(`No resource handler found for: ${e.type}`);return}s.patch&&s.patch(e,t)}clearCache(e,t){const s=xh.makeKey(e,t);delete this._cache[s]}getFromCache(e,t){const s=xh.makeKey(e,t);if(this._cache[s])return this._cache[s]}enableRetry(e=5){e=Math.max(0,e)||0;for(const t in this._handlers)this._handlers[t].maxRetries=e}disableRetry(){for(const e in this._handlers)this._handlers[e].maxRetries=0}destroy(){this._handlers={},this._requests={},this._cache={}}constructor(e){this._handlers={},this._requests={},this._cache={},this._app=e}}class GH{_validate(e){if(!e.header)throw new Error('pc.I18n#addData: Missing "header" field');if(!e.header.version)throw new Error('pc.I18n#addData: Missing "header.version" field');if(e.header.version!==1)throw new Error('pc.I18n#addData: Invalid "header.version" field');if(e.data){if(!Array.isArray(e.data))throw new Error('pc.I18n#addData: "data" field must be an array')}else throw new Error('pc.I18n#addData: Missing "data" field');for(let t=0,s=e.data.length;t<s;t++){const i=e.data[t];if(!i.info)throw new Error(`pc.I18n#addData: missing "data[${t}].info" field`);if(!i.info.locale)throw new Error(`pc.I18n#addData: missing "data[${t}].info.locale" field`);if(typeof i.info.locale!="string")throw new Error(`pc.I18n#addData: "data[${t}].info.locale" must be a string`);if(!i.messages)throw new Error(`pc.I18n#addData: missing "data[${t}].messages" field`)}}parse(e){return e.data}}class ao extends Pe{set assets(e){const t={};for(let i=0,r=e.length;i<r;i++){const a=e[i]instanceof Ee?e[i].id:e[i];t[a]=!0}let s=this._assets.length;for(;s--;){const i=this._assets[s];if(!t[i]){this._app.assets.off(`add:${i}`,this._onAssetAdd,this);const r=this._app.assets.get(i);r&&this._onAssetRemove(r),this._assets.splice(s,1)}}for(const i in t){const r=parseInt(i,10);if(this._assets.indexOf(r)!==-1)continue;this._assets.push(r);const a=this._app.assets.get(r);a?this._onAssetAdd(a):this._app.assets.once(`add:${r}`,this._onAssetAdd,this)}}get assets(){return this._assets}set locale(e){if(this._locale===e)return;let t=Ca(e);if(t==="in"&&(t="id",e=LH(e,t),this._locale===e))return;const s=this._locale;this._locale=e,this._lang=t,this._pluralFn=ex(this._lang),this.fire(ao.EVENT_CHANGE,e,s)}get locale(){return this._locale}static findAvailableLocale(e,t){return SL(e,t)}findAvailableLocale(e){if(this._translations[e])return e;const t=Ca(e);return this._findFallbackLocale(e,t)}getText(e,t){let s=e,i;t||(t=this._locale,i=this._lang);let r=this._translations[t];return r||(i||(i=Ca(t)),t=this._findFallbackLocale(t,i),r=this._translations[t]),r&&r.hasOwnProperty(e)&&(s=r[e],Array.isArray(s)&&(s=s[0]),s==null&&(s=e)),s}getPluralText(e,t,s){let i=e,r,a;s?(r=Ca(s),a=ex(r)):(s=this._locale,r=this._lang,a=this._pluralFn);let o=this._translations[s];if(o||(s=this._findFallbackLocale(s,r),r=Ca(s),a=ex(r),o=this._translations[s]),o&&o[e]&&a){const h=a(t);i=o[e][h],i==null&&(i=e)}return i}addData(e){let t;try{t=this._parser.parse(e)}catch(s){console.error(s);return}for(let s=0,i=t.length;s<i;s++){const r=t[s],a=r.info.locale,o=r.messages;if(!this._translations[a]){this._translations[a]={};const h=Ca(a);this._availableLangs[h]||(this._availableLangs[h]=a)}Object.assign(this._translations[a],o),this.fire("data:add",a,o)}}removeData(e){let t;try{t=this._parser.parse(e)}catch(s){console.error(s);return}for(let s=0,i=t.length;s<i;s++){const r=t[s],a=r.info.locale,o=this._translations[a];if(!o)continue;const h=r.messages;for(const u in h)delete o[u];Object.keys(o).length===0&&(delete this._translations[a],delete this._availableLangs[Ca(a)]),this.fire("data:remove",a,h)}}destroy(){this._translations=null,this._availableLangs=null,this._assets=null,this._parser=null,this.off()}_findFallbackLocale(e,t){let s=Sg[e];return s&&this._translations[s]||(s=Sg[t],s&&this._translations[s])||(s=this._availableLangs[t],s&&this._translations[s])?s:vg}_onAssetAdd(e){e.on("load",this._onAssetLoad,this),e.on("change",this._onAssetChange,this),e.on("remove",this._onAssetRemove,this),e.on("unload",this._onAssetUnload,this),e.resource&&this._onAssetLoad(e)}_onAssetLoad(e){this.addData(e.resource)}_onAssetChange(e){e.resource&&this.addData(e.resource)}_onAssetRemove(e){e.off("load",this._onAssetLoad,this),e.off("change",this._onAssetChange,this),e.off("remove",this._onAssetRemove,this),e.off("unload",this._onAssetUnload,this),e.resource&&this.removeData(e.resource),this._app.assets.once(`add:${e.id}`,this._onAssetAdd,this)}_onAssetUnload(e){e.resource&&this.removeData(e.resource)}constructor(e){super(),this.locale=vg,this._translations={},this._availableLangs={},this._app=e,this._assets=[],this._parser=new GH}}ao.EVENT_CHANGE="change";class HH extends Pe{destroy(){this.app=null,this.off()}addSchema(e,t){t&&this._scriptSchemas.set(e,t)}getSchema(e){return this._scriptSchemas.get(e)}add(e){const t=e.__name;return this._scripts.hasOwnProperty(t)?(setTimeout(()=>{if(e.prototype.swap){const s=this._scripts[t],i=this._list.indexOf(s);this._list[i]=e,this._scripts[t]=e,this.fire("swap",t,e),this.fire(`swap:${t}`,e)}else console.warn(`script registry already has '${t}' script, define 'swap' method for new script type to enable code hot swapping`)}),!1):(this._scripts[t]=e,this._list.push(e),this.fire("add",t,e),this.fire(`add:${t}`,e),setTimeout(()=>{if(!this._scripts.hasOwnProperty(t)||!this.app||!this.app.systems||!this.app.systems.script)return;const s=this.app.systems.script._components;let i;const r=[],a=[];for(s.loopIndex=0;s.loopIndex<s.length;s.loopIndex++){const o=s.items[s.loopIndex];if(o._scriptsIndex[t]&&o._scriptsIndex[t].awaiting){o._scriptsData&&o._scriptsData[t]&&(i=o._scriptsData[t].attributes);const h=o.create(t,{preloading:!0,ind:o._scriptsIndex[t].ind,attributes:i});h&&r.push(h);for(const u of o.scripts)o.initializeAttributes(u)}}for(let o=0;o<r.length;o++)r[o].enabled&&(r[o]._initialized=!0,a.push(r[o]),r[o].initialize&&r[o].initialize());for(let o=0;o<a.length;o++)!a[o].enabled||a[o]._postInitialized||(a[o]._postInitialized=!0,a[o].postInitialize&&a[o].postInitialize())}),!0)}remove(e){let t=e,s=e;if(typeof s!="string"?s=t.__name:t=this.get(s),this.get(s)!==t)return!1;delete this._scripts[s];const i=this._list.indexOf(t);return this._list.splice(i,1),this.fire("remove",s,t),this.fire(`remove:${s}`,t),!0}get(e){return this._scripts[e]||null}has(e){if(typeof e=="string")return this._scripts.hasOwnProperty(e);if(!e)return!1;const t=e.__name;return this._scripts[t]===e}list(){return this._list}constructor(e){super(),this._scripts={},this._list=[],this._scriptSchemas=new Map,this.app=e}}const WH=(c,e)=>c.constructor.order-e.constructor.order,XH=c=>c.sort(WH),pd=[],yL=[],qH=()=>yL.pop()??[],FP=c=>{c.length=0,yL.push(c)};let Nt=class xL extends Dt{addComponent(e,t){const s=this._app.systems[e];return!s||this.c[e]?null:s.addComponent(this,t)}removeComponent(e){const t=this._app.systems[e];t&&this.c[e]&&t.removeComponent(this)}findComponent(e){const t=this.findOne(s=>s.c?.[e]);return t&&t.c[e]}findComponents(e){return this.find(t=>t.c?.[e]).map(t=>t.c[e])}findScript(e){return this.findOne(s=>s.c?.script?.has(e))?.c.script.get(e)}findScripts(e){return this.find(s=>s.c?.script?.has(e)).map(s=>s.c.script.get(e))}getGuid(){return this._guid||this.setGuid(jF.create()),this._guid}setGuid(e){const t=this._app._entityIndex;this._guid&&delete t[this._guid],this._guid=e,t[this._guid]=this}_notifyHierarchyStateChanged(e,t){let s=!1;e===this&&pd.length===0&&(s=!0),e._beingEnabled=!0,e._onHierarchyStateChanged(t),e._onHierarchyStatePostChanged&&pd.push(e);const i=e._children;for(let r=0,a=i.length;r<a;r++)i[r]._enabled&&this._notifyHierarchyStateChanged(i[r],t);if(e._beingEnabled=!1,s){for(let r=0;r<pd.length;r++)pd[r]._onHierarchyStatePostChanged();pd.length=0}}_onHierarchyStateChanged(e){super._onHierarchyStateChanged(e);const t=this._getSortedComponents();for(let s=0;s<t.length;s++){const i=t[s];i.enabled&&(e?i.onEnable():i.onDisable())}FP(t)}_onHierarchyStatePostChanged(){const e=this._getSortedComponents();for(let t=0;t<e.length;t++)e[t].onPostStateChange();FP(e)}findByGuid(e){if(this._guid===e)return this;const t=this._app._entityIndex[e];return t&&(t===this||t.isDescendantOf(this))?t:null}destroy(){this._destroying=!0;for(const e in this.c)this.c[e].enabled=!1;for(const e in this.c)this.c[e].system.removeComponent(this);super.destroy(),this._guid&&delete this._app._entityIndex[this._guid],this._destroying=!1}clone(){const e={},t=this._cloneRecursively(e);return e[this.getGuid()]=t,TL(this,this,t,e),t}_getSortedComponents(){const e=this.c,t=qH();let s=0;for(const i in e)if(e.hasOwnProperty(i)){const r=e[i];s|=r.constructor.order!==0,t.push(r)}return s&&t.length>1&&XH(t),t}_cloneRecursively(e){const t=new this.constructor(void 0,this._app);super._cloneInternal(t);for(const s in this.c)this.c[s].system.cloneComponent(this,t);for(let s=0;s<this._children.length;s++){const i=this._children[s];if(i instanceof xL){const r=i._cloneRecursively(e);t.addChild(r),e[i.getGuid()]=r}}return t}constructor(e,t=fl()){super(e),this.c={},this._destroying=!1,this._guid=null,this._template=!1,this._app=t}};Nt.EVENT_DESTROY="destroy";function TL(c,e,t,s){if(e instanceof Nt){const i=e.c;for(const o in i){const h=i[o],u=h.system.getPropertiesOfType("entity");for(let f=0,m=u.length;f<m;f++){const g=u[f].name,S=h[g];if(!!c.findByGuid(S)){const T=s[S].getGuid();T&&(t.c[o][g]=T)}}}i.script&&t.script.resolveDuplicatedEntityReferenceProperties(i.script,s),i.render&&t.render.resolveDuplicatedEntityReferenceProperties(i.render,s),i.button&&t.button.resolveDuplicatedEntityReferenceProperties(i.button,s),i.scrollview&&t.scrollview.resolveDuplicatedEntityReferenceProperties(i.scrollview,s),i.scrollbar&&t.scrollbar.resolveDuplicatedEntityReferenceProperties(i.scrollbar,s),i.anim&&t.anim.resolveDuplicatedEntityReferenceProperties(i.anim,s);const r=e.children.filter(o=>o instanceof Nt),a=t.children.filter(o=>o instanceof Nt);for(let o=0,h=r.length;o<h;o++)TL(c,r[o],a[o],s)}}class BP{get loaded(){return!!this.data}get loading(){return this._loading}constructor(e,t){this.data=null,this._loading=!1,this._onLoadedCallbacks=[],this.name=e,this.url=t}}class YH{destroy(){this._app=null}list(){return this._list}add(e,t){if(this._index.hasOwnProperty(e))return!1;const s=new BP(e,t),i=this._list.push(s);return this._index[s.name]=i-1,this._urlIndex[s.url]=i-1,!0}find(e){return this._index.hasOwnProperty(e)?this._list[this._index[e]]:null}findByUrl(e){return this._urlIndex.hasOwnProperty(e)?this._list[this._urlIndex[e]]:null}remove(e){if(this._index.hasOwnProperty(e)){const t=this._index[e];let s=this._list[t];delete this._urlIndex[s.url],delete this._index[e],this._list.splice(t,1);for(let i=0;i<this._list.length;i++)s=this._list[i],this._index[s.name]=i,this._urlIndex[s.url]=i}}_loadSceneData(e,t,s){const i=this._app;let r=e;if(typeof e=="string"&&(e=this.findByUrl(r)||this.find(r)||new BP("Untitled",r)),r=e.url,!r){s("Cannot find scene to load");return}if(e.loaded){s(null,e);return}i.assets&&i.assets.prefix&&!Nh.test(r)&&(r=Re.join(i.assets.prefix,r)),e._onLoadedCallbacks.push(s),e._loading||i.loader.getHandler("hierarchy").load(r,(o,h)=>{e.data=h,e._loading=!1;for(let u=0;u<e._onLoadedCallbacks.length;u++)e._onLoadedCallbacks[u](o,e);t||(e.data=null),e._onLoadedCallbacks.length=0}),e._loading=!0}loadSceneData(e,t){this._loadSceneData(e,!0,t)}unloadSceneData(e){typeof e=="string"&&(e=this.findByUrl(e)),e&&(e.data=null)}_loadSceneHierarchy(e,t,s){this._loadSceneData(e,!1,(i,r)=>{if(i){s&&s(i);return}t&&t(r);const a=this._app,o=()=>{const h=a.loader.getHandler("hierarchy");a.systems.script.preloading=!0;const u=h.open(r.url,r.data);a.systems.script.preloading=!1,a.loader.clearCache(r.url,"hierarchy"),a.root.addChild(u),a.systems.fire("initialize",u),a.systems.fire("postInitialize",u),a.systems.fire("postPostInitialize",u),s&&s(null,u)};a._preloadScripts(r.data,o)})}loadSceneHierarchy(e,t){this._loadSceneHierarchy(e,null,t)}loadSceneSettings(e,t){this._loadSceneData(e,!1,(s,i)=>{s?t&&t(s):(this._app.applySceneSettings(i.data.settings),t&&t(null))})}changeScene(e,t){const s=this._app,i=r=>{const{children:a}=s.root;for(;a.length;)a[0].destroy();s.applySceneSettings(r.data.settings)};this._loadSceneHierarchy(e,i,t)}loadScene(e,t){const s=this._app,i=s.loader.getHandler("scene");s.assets&&s.assets.prefix&&!Nh.test(e)&&(e=Re.join(s.assets.prefix,e)),i.load(e,(r,a)=>{if(r)t&&t(r);else{const o=()=>{s.systems.script.preloading=!0;const h=i.open(e,a),u=this.findByUrl(e);u&&!u.loaded&&(u.data=a),s.systems.script.preloading=!1,s.loader.clearCache(e,"scene"),s.loader.patch({resource:h,type:"scene"},s.assets),s.root.addChild(h.root),s.systems.rigidbody&&typeof Ammo<"u"&&s.systems.rigidbody.gravity.set(h._gravity.x,h._gravity.y,h._gravity.z),t&&t(null,h)};s._preloadScripts(a,o)}})}constructor(e){this._list=[],this._index={},this._urlIndex={},this._app=e}}class jH{get scene(){return fl().scene._stats}get lightmapper(){return fl().lightmapper?.stats}get batcher(){const e=fl()._batcher;return e?e._stats:null}frameEnd(){this.frame.gsplatSort=0}constructor(e){this.frame={fps:0,ms:0,dt:0,updateStart:0,updateTime:0,renderStart:0,renderTime:0,physicsStart:0,physicsTime:0,scriptUpdateStart:0,scriptUpdate:0,scriptPostUpdateStart:0,scriptPostUpdate:0,animUpdateStart:0,animUpdate:0,cullTime:0,sortTime:0,skinTime:0,morphTime:0,instancingTime:0,triangles:0,gsplats:0,gsplatSort:0,otherPrimitives:0,shaders:0,materials:0,cameras:0,shadowMapUpdates:0,shadowMapTime:0,depthMapTime:0,forwardTime:0,lightClustersTime:0,lightClusters:0,_timeToCountFrames:0,_fpsAccum:0},this.drawCalls={forward:0,depth:0,shadow:0,immediate:0,misc:0,total:0,skinned:0,instanced:0,removedByInstancing:0},this.misc={renderTargetCreationTime:0},this.particles={updatesPerFrame:0,_updatesPerFrame:0,frameTime:0,_frameTime:0},this.shaders=e._shaderStats,this.vram=e._vram,this.gpu=e.gpuProfiler?.passTimings??new Map,Object.defineProperty(this.vram,"totalUsed",{get:function(){return this.tex+this.vb+this.ib}}),Object.defineProperty(this.vram,"geom",{get:function(){return this.vb+this.ib}})}}var $H=`
uniform float alpha_ref;
void alphaTest(float a) {
	if (a < alpha_ref) discard;
}
`,KH=`
#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH
	uniform vec3 ambientSH[9];
#endif
#if LIT_AMBIENT_SOURCE == ENVALATLAS
	#include "envAtlasPS"
	#ifndef ENV_ATLAS
	#define ENV_ATLAS
		uniform sampler2D texture_envAtlas;
	#endif
#endif
void addAmbient(vec3 worldNormal) {
	#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH
		vec3 n = cubeMapRotate(worldNormal);
		vec3 color =
			ambientSH[0] +
			ambientSH[1] * n.x +
			ambientSH[2] * n.y +
			ambientSH[3] * n.z +
			ambientSH[4] * n.x * n.z +
			ambientSH[5] * n.z * n.y +
			ambientSH[6] * n.y * n.x +
			ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
			ambientSH[8] * (n.x * n.x - n.y * n.y);
		dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
	#endif
	#if LIT_AMBIENT_SOURCE == ENVALATLAS
		vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));
		vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);
		vec4 raw = texture2D(texture_envAtlas, uv);
		vec3 linear = {ambientDecode}(raw);
		dDiffuseLight += processEnvironment(linear);
	#endif
	#if LIT_AMBIENT_SOURCE == CONSTANT
		dDiffuseLight += light_globalAmbient;
	#endif
}
`,ZH=`
#ifdef LIT_GGX_SPECULAR
	uniform float material_anisotropyIntensity;
	uniform vec2 material_anisotropyRotation;
#endif
void getAnisotropy() {
	dAnisotropy = 0.0;
	dAnisotropyRotation = vec2(1.0, 0.0);
#ifdef LIT_GGX_SPECULAR
	dAnisotropy = material_anisotropyIntensity;
	dAnisotropyRotation = material_anisotropyRotation;
#endif
	#ifdef STD_ANISOTROPY_TEXTURE
	vec3 anisotropyTex = texture2DBias({STD_ANISOTROPY_TEXTURE_NAME}, {STD_ANISOTROPY_TEXTURE_UV}, textureBias).rgb;
	dAnisotropy *= anisotropyTex.b;
	vec2 anisotropyRotationFromTex = anisotropyTex.rg * 2.0 - vec2(1.0);
	mat2 rotationMatrix = mat2(dAnisotropyRotation.x, dAnisotropyRotation.y, -dAnisotropyRotation.y, dAnisotropyRotation.x);
	dAnisotropyRotation = rotationMatrix * anisotropyRotationFromTex;
	#endif
	
	dAnisotropy = clamp(dAnisotropy, 0.0, 1.0);
}
`,QH=`
#if defined(STD_AO_TEXTURE) || defined(STD_AO_VERTEX)
	uniform float material_aoIntensity;
#endif
#ifdef STD_AODETAIL_TEXTURE
	#include "detailModesPS"
#endif
void getAO() {
	dAo = 1.0;
	#ifdef STD_AO_TEXTURE
		float aoBase = texture2DBias({STD_AO_TEXTURE_NAME}, {STD_AO_TEXTURE_UV}, textureBias).{STD_AO_TEXTURE_CHANNEL};
		#ifdef STD_AODETAIL_TEXTURE
			float aoDetail = texture2DBias({STD_AODETAIL_TEXTURE_NAME}, {STD_AODETAIL_TEXTURE_UV}, textureBias).{STD_AODETAIL_TEXTURE_CHANNEL};
			aoBase = detailMode_{STD_AODETAIL_DETAILMODE}(vec3(aoBase), vec3(aoDetail)).r;
		#endif
		dAo *= aoBase;
	#endif
	#ifdef STD_AO_VERTEX
		dAo *= saturate(vVertexColor.{STD_AO_VERTEX_CHANNEL});
	#endif
	#if defined(STD_AO_TEXTURE) || defined(STD_AO_VERTEX)
		dAo = mix(1.0, dAo, material_aoIntensity);
	#endif
}
`,JH=`
void occludeDiffuse(float ao) {
	dDiffuseLight *= ao;
}
`,e5=`
#if LIT_OCCLUDE_SPECULAR != NONE
	#ifdef LIT_OCCLUDE_SPECULAR_FLOAT
		uniform float material_occludeSpecularIntensity;
	#endif
#endif
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
	#if LIT_OCCLUDE_SPECULAR == AO
		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT
			float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);
		#else
			float specOcc = ao;
		#endif
	#endif
	#if LIT_OCCLUDE_SPECULAR == GLOSSDEPENDENT
		float specPow = exp2(gloss * 11.0);
		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01 * specPow) - 1.0 + ao);
		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT
			specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);
		#endif
	#endif
	#if LIT_OCCLUDE_SPECULAR != NONE
		dSpecularLight *= specOcc;
		dReflection *= specOcc;
		#ifdef LIT_SHEEN
			sSpecularLight *= specOcc;
			sReflection *= specOcc;
		#endif
	#endif
}
`,t5=`
	vec4 dirLm = texture2D(texture_dirLightMap, vUv1);
	if (bakeDir > 0.5) {
		if (dAtten > 0.00001) {
			dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
			dAtten = saturate(dAtten);
			gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
			gl_FragColor.a = dirLm.w + dAtten;
			gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
		} else {
			gl_FragColor = dirLm;
		}
	} else {
		gl_FragColor.rgb = dirLm.xyz;
		gl_FragColor.a = max(dirLm.w, dAtten > 0.00001 ? (1.0/255.0) : 0.0);
	}
`,s5=`
#ifdef LIT_LIGHTMAP_BAKING_ADD_AMBIENT
	dDiffuseLight = ((dDiffuseLight - 0.5) * max(ambientBakeOcclusionContrast + 1.0, 0.0)) + 0.5;
	dDiffuseLight += vec3(ambientBakeOcclusionBrightness);
	dDiffuseLight = saturate(dDiffuseLight);
	dDiffuseLight *= dAmbientLight;
#endif
#ifdef LIGHTMAP_RGBM
	gl_FragColor.rgb = dDiffuseLight;
	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
	gl_FragColor.rgb /= 8.0;
	gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
	gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
	gl_FragColor.rgb /= gl_FragColor.a;
#else
	gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`,i5=`
uniform vec3 view_position;
uniform vec3 light_globalAmbient;
float square(float x) {
	return x*x;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 saturate(vec3 x) {
	return clamp(x, vec3(0.0), vec3(1.0));
}
`,r5=`
#define NINESLICED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`,a5=`
#define NINESLICED
#define NINESLICETILED
varying vec2 vMask;
varying vec2 vTiledUv;
uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
vec2 nineSlicedUv;
`,n5=`
float bayer2(vec2 p) {
	return mod(2.0 * p.y + p.x + 1.0, 4.0);
}
float bayer4(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	return 4.0 * bayer2(p1) + bayer2(p2);
}
float bayer8(vec2 p) {
	vec2 p1 = mod(p, 2.0);
	vec2 p2 = floor(0.5 * mod(p, 4.0));
	vec2 p4 = floor(0.25 * mod(p, 8.0));
	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);
}
`,o5=`
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
#ifdef GAUSS
	uniform float weight[{SAMPLES}];
#endif
void main(void) {
	vec3 moments = vec3(0.0);
	vec2 uv = vUv0 - pixelOffset * (float({SAMPLES}) * 0.5);
	for (int i = 0; i < {SAMPLES}; i++) {
		vec4 c = texture2D(source, uv + pixelOffset * float(i));
		#ifdef GAUSS
			moments += c.xyz * weight[i];
		#else
			moments += c.xyz;
		#endif
	}
	#ifndef GAUSS
		moments *= 1.0 / float({SAMPLES});
	#endif
	gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
}
`,l5=`
uniform float material_clearCoat;
void getClearCoat() {
	ccSpecularity = material_clearCoat;
	#ifdef STD_CLEARCOAT_TEXTURE
	ccSpecularity *= texture2DBias({STD_CLEARCOAT_TEXTURE_NAME}, {STD_CLEARCOAT_TEXTURE_UV}, textureBias).{STD_CLEARCOAT_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_CLEARCOAT_VERTEX
	ccSpecularity *= saturate(vVertexColor.{STD_CLEARCOAT_VERTEX_CHANNEL});
	#endif
}
`,c5=`
uniform float material_clearCoatGloss;
void getClearCoatGlossiness() {
	ccGlossiness = material_clearCoatGloss;
	#ifdef STD_CLEARCOATGLOSS_TEXTURE
	ccGlossiness *= texture2DBias({STD_CLEARCOATGLOSS_TEXTURE_NAME}, {STD_CLEARCOATGLOSS_TEXTURE_UV}, textureBias).{STD_CLEARCOATGLOSS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_CLEARCOATGLOSS_VERTEX
	ccGlossiness *= saturate(vVertexColor.{STD_CLEARCOATGLOSS_VERTEX_CHANNEL});
	#endif
	#ifdef STD_CLEARCOATGLOSS_INVERT
	ccGlossiness = 1.0 - ccGlossiness;
	#endif
	ccGlossiness += 0.0000001;
}
`,h5=`
#ifdef STD_CLEARCOATNORMAL_TEXTURE
uniform float material_clearCoatBumpiness;
#endif
void getClearCoatNormal() {
#ifdef STD_CLEARCOATNORMAL_TEXTURE
	vec3 normalMap = {STD_CLEARCOATNORMAL_TEXTURE_DECODE}(texture2DBias({STD_CLEARCOATNORMAL_TEXTURE_NAME}, {STD_CLEARCOATNORMAL_TEXTURE_UV}, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
	ccNormalW = normalize(dTBN * normalMap);
#else
	ccNormalW = dVertexNormalW;
#endif
}
`,u5=`
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
	vec3 vAbs = abs(dir);
	float ma;
	vec2 uv;
	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {
		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
		ma = 0.5 / vAbs.z;
		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);
		tileOffset.x = 2.0;
		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;
	} else if(vAbs.y >= vAbs.x) {
		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
		ma = 0.5 / vAbs.y;
		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);
		tileOffset.x = 1.0;
		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;
	} else {
		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
		ma = 0.5 / vAbs.x;
		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);
		tileOffset.x = 0.0;
		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;
	}
	return uv * ma + 0.5;
}
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {
	float faceIndex;
	vec2 tileOffset;
	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);
	float atlasFaceSize = omniAtlasViewport.z;
	float tileSize = shadowTextureResolution * atlasFaceSize;
	float offset = shadowEdgePixels / tileSize;
	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);
	uv *= atlasFaceSize;
	uv += tileOffset * atlasFaceSize;
	uv += omniAtlasViewport.xy;
	return uv;
}
`,d5=`
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, vec4 cookieChannel) {
	vec4 pixel = mix(vec4(1.0), texture2DLod(tex, uv, 0.0), intensity);
	bool isRgb = dot(cookieChannel.rgb, vec3(1.0)) == 3.0;
	return isRgb ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, vec4 cookieChannel) {
	vec4 projPos = transform * vec4(worldPosition, 1.0);
	return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, cookieChannel);
}
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
	return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, cookieChannel);
}
`,f5=`
vec3 _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
	vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
	projPos.xyz /= projPos.w;
	return projPos.xyz;
}
vec3 getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {
	vec3 wPos = vPositionW + normal * shadowParams.y;
	return _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}
vec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
	float distScale = length(lightDir);
	vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
	vec3 dir = wPos - lightPos;
	return dir;
}
#if defined(CLUSTER_SHADOW_TYPE_PCF1)
float getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
	float shadowTextureResolution = shadowParams.x;
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	return textureShadow(shadowMap, vec3(uv, shadowZ));
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF3)
float getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
	float shadowTextureResolution = shadowParams.x;
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 shadowCoord = vec3(uv, shadowZ);
	return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF5)
float getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {
	float shadowTextureResolution = shadowParams.x;
	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 shadowCoord = vec3(uv, shadowZ);
	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF1)
float getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF3)
float getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF5)
float getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
}
#endif
`,m5=`
#include "lightBufferDefinesPS"
#include "clusteredLightUtilsPS"
#ifdef CLUSTER_COOKIES
	#include "clusteredLightCookiesPS"
#endif
#ifdef CLUSTER_SHADOWS
	#include "clusteredLightShadowsPS"
#endif
uniform highp usampler2D clusterWorldTexture;
uniform highp sampler2D lightsTexture;
#ifdef CLUSTER_SHADOWS
	uniform sampler2DShadow shadowAtlasTexture;
#endif
#ifdef CLUSTER_COOKIES
	uniform sampler2D cookieAtlasTexture;
#endif
uniform int clusterMaxCells;
uniform int numClusteredLights;
uniform int clusterTextureWidth;
uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform ivec3 clusterCellsDot;
uniform ivec3 clusterCellsMax;
uniform vec2 shadowAtlasParams;
struct ClusterLightData {
	uint flags;
	vec3 halfWidth;
	bool isSpot;
	vec3 halfHeight;
	int lightIndex;
	vec3 position;
	uint shape;
	vec3 direction;
	bool falloffModeLinear;
	vec3 color;
	float shadowIntensity;
	vec3 omniAtlasViewport;
	float range;
	vec4 cookieChannelMask;
	float biasesData;
	uint colorBFlagsData;
	float shadowBias;
	float shadowNormalBias;
	float anglesData;
	float innerConeAngleCos;
	float outerConeAngleCos;
	float cookieIntensity;
	bool isDynamic;
	bool isLightmapped;
};
mat4 lightProjectionMatrix;
vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
	return texelFetch(lightsTexture, ivec2(index, clusterLightData.lightIndex), 0);
}
void decodeClusterLightCore(inout ClusterLightData clusterLightData, int lightIndex) {
	clusterLightData.lightIndex = lightIndex;
	vec4 halfData = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_COLOR_ANGLES_BIAS});
	clusterLightData.anglesData = halfData.z;
	clusterLightData.biasesData = halfData.w;
	clusterLightData.colorBFlagsData = floatBitsToUint(halfData.y);
	vec2 colorRG = unpackHalf2x16(floatBitsToUint(halfData.x));
	vec2 colorB_flags = unpackHalf2x16(clusterLightData.colorBFlagsData);
	clusterLightData.color = vec3(colorRG, colorB_flags.x) * {LIGHT_COLOR_DIVIDER};
	vec4 lightPosRange = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_POSITION_RANGE});
	clusterLightData.position = lightPosRange.xyz;
	clusterLightData.range = lightPosRange.w;
	vec4 lightDir_Flags = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_DIRECTION_FLAGS});
	clusterLightData.direction = lightDir_Flags.xyz;
	clusterLightData.flags = floatBitsToUint(lightDir_Flags.w);
	clusterLightData.isSpot = (clusterLightData.flags & (1u << 30u)) != 0u;
	clusterLightData.shape = (clusterLightData.flags >> 28u) & 0x3u;
	clusterLightData.falloffModeLinear = (clusterLightData.flags & (1u << 27u)) == 0u;
	clusterLightData.shadowIntensity = float((clusterLightData.flags >> 0u) & 0xFFu) / 255.0;
	clusterLightData.cookieIntensity = float((clusterLightData.flags >> 8u) & 0xFFu) / 255.0;
	clusterLightData.isDynamic = (clusterLightData.flags & (1u << 22u)) != 0u;
	clusterLightData.isLightmapped = (clusterLightData.flags & (1u << 21u)) != 0u;
}
void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {
	uint angleFlags = (clusterLightData.colorBFlagsData >> 16u) & 0xFFFFu;
	vec2 angleValues = unpackHalf2x16(floatBitsToUint(clusterLightData.anglesData));
	float innerVal = angleValues.x;
	float outerVal = angleValues.y;
	float innerIsVersine = float(angleFlags & 1u);
	float outerIsVersine = float((angleFlags >> 1u) & 1u);
	clusterLightData.innerConeAngleCos = mix(innerVal, 1.0 - innerVal, innerIsVersine);
	clusterLightData.outerConeAngleCos = mix(outerVal, 1.0 - outerVal, outerIsVersine);
}
void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
	clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_PROJ_MAT_0}).xyz;
}
void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
	clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_AREA_DATA_WIDTH}).xyz;
	clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_AREA_DATA_HEIGHT}).xyz;
}
void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
	
	vec4 m0 = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_PROJ_MAT_0});
	vec4 m1 = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_PROJ_MAT_1});
	vec4 m2 = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_PROJ_MAT_2});
	vec4 m3 = sampleLightTextureF(clusterLightData, {CLUSTER_TEXTURE_PROJ_MAT_3});
	lightProjectionMatrix = mat4(m0, m1, m2, m3);
}
void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
	
	vec2 biases = unpackHalf2x16(floatBitsToUint(clusterLightData.biasesData));
	clusterLightData.shadowBias = biases.x;
	clusterLightData.shadowNormalBias = biases.y;
}
void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {
	uint cookieFlags = (clusterLightData.flags >> 23u) & 0x0Fu;
	clusterLightData.cookieChannelMask = vec4(uvec4(cookieFlags) & uvec4(1u, 2u, 4u, 8u));
	clusterLightData.cookieChannelMask = step(1.0, clusterLightData.cookieChannelMask);
}
void evaluateLight(
	ClusterLightData light, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir,
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	vec3 cookieAttenuation = vec3(1.0);
	float diffuseAttenuation = 1.0;
	float falloffAttenuation = 1.0;
	vec3 lightDirW = evalOmniLight(light.position);
	vec3 lightDirNormW = normalize(lightDirW);
	#ifdef CLUSTER_AREALIGHTS
	if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {
		decodeClusterLightAreaData(light);
		if (light.shape == {LIGHTSHAPE_RECT}) {
			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
		} else if (light.shape == {LIGHTSHAPE_DISK}) {
			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
		} else {
			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
		}
		falloffAttenuation = getFalloffWindow(light.range, lightDirW);
	} else
	#endif
	{
		if (light.falloffModeLinear)
			falloffAttenuation = getFalloffLinear(light.range, lightDirW);
		else
			falloffAttenuation = getFalloffInvSquared(light.range, lightDirW);
	}
	if (falloffAttenuation > 0.00001) {
		#ifdef CLUSTER_AREALIGHTS
		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {
			if (light.shape == {LIGHTSHAPE_RECT}) {
				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;
			} else if (light.shape == {LIGHTSHAPE_DISK}) {
				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;
			} else {
				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;
			}
		} else
		#endif
		{
			falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, lightDirNormW); 
		}
		if (light.isSpot) {
			decodeClusterLightSpot(light);
			falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, lightDirNormW);
		}
		#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)
		if (falloffAttenuation > 0.00001) {
			if (light.shadowIntensity > 0.0 || light.cookieIntensity > 0.0) {
				if (light.isSpot) {
					decodeClusterLightProjectionMatrixData(light);
				} else {
					decodeClusterLightOmniAtlasViewport(light);
				}
				float shadowTextureResolution = shadowAtlasParams.x;
				float shadowEdgePixels = shadowAtlasParams.y;
				#ifdef CLUSTER_COOKIES
				if (light.cookieIntensity > 0.0) {
					decodeClusterLightCookieData(light);
					if (light.isSpot) {
						cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, light.cookieChannelMask);
					} else {
						cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), lightDirW, light.cookieIntensity, light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
					}
				}
				#endif
				#ifdef CLUSTER_SHADOWS
				if (light.shadowIntensity > 0.0) {
					decodeClusterLightShadowData(light);
					vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);
					if (light.isSpot) {
						vec3 shadowCoord = getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
						
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
							float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					} else {
						vec3 dir = normalOffsetPointShadow(shadowParams, light.position, lightDirW, lightDirNormW, geometricNormal);
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#endif
						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
					}
				}
				#endif
			}
		}
		#endif
		#ifdef CLUSTER_AREALIGHTS
		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {
			{
				vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;
				#if defined(LIT_SPECULAR)
					areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
				#endif
				dDiffuseLight += areaDiffuse;
			}
			#ifdef LIT_SPECULAR
				float areaLightSpecular;
				if (light.shape == {LIGHTSHAPE_RECT}) {
					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
				} else if (light.shape == {LIGHTSHAPE_DISK}) {
					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
				} else {
					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
				}
				dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;
				#ifdef LIT_CLEARCOAT
					float areaLightSpecularCC;
					if (light.shape == {LIGHTSHAPE_RECT}) {
						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
					} else if (light.shape == {LIGHTSHAPE_DISK}) {
						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
					} else {
						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
					}
					ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;
				#endif
			#endif
		} else
		#endif
		{
			{
				vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;
				#if defined(CLUSTER_AREALIGHTS)
				#if defined(LIT_SPECULAR)
					punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);
				#endif
				#endif
				dDiffuseLight += punctualDiffuse;
			}
	 
			#ifdef LIT_SPECULAR
				vec3 halfDir = normalize(-lightDirNormW + viewDir);
				
				#ifdef LIT_SPECULAR_FRESNEL
					dSpecularLight += 
						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * 
						getFresnel(
							dot(viewDir, halfDir), 
							gloss, 
							specularity
						#if defined(LIT_IRIDESCENCE)
							, iridescenceFresnel,
							iridescence_intensity
						#endif
							);
				#else
					dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
				#endif
				#ifdef LIT_CLEARCOAT
					#ifdef LIT_SPECULAR_FRESNEL
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
					#else
						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; 
					#endif
				#endif
				#ifdef LIT_SHEEN
					sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, lightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
				#endif
			#endif
		}
	}
	dAtten = falloffAttenuation;
	dLightDirNormW = lightDirNormW;
}
void evaluateClusterLight(
	int lightIndex, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	ClusterLightData clusterLightData;
	decodeClusterLightCore(clusterLightData, lightIndex);
	#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
		bool acceptLightMask = clusterLightData.isDynamic;
	#else
		bool acceptLightMask = clusterLightData.isLightmapped;
	#endif
	if (acceptLightMask)
		evaluateLight(
			clusterLightData, 
			worldNormal, 
			viewDir, 
			reflectionDir, 
#if defined(LIT_CLEARCOAT)
			clearcoatReflectionDir, 
#endif
			gloss, 
			specularity, 
			geometricNormal, 
			tbn, 
#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel,
#endif
			clearcoat_worldNormal,
			clearcoat_gloss,
			sheen_gloss,
			iridescence_intensity
		);
}
void addClusteredLights(
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
	vec3 clearcoatReflectionDir,
#endif
	float gloss, 
	vec3 specularity, 
	vec3 geometricNormal, 
	mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel,
#endif
	vec3 clearcoat_worldNormal,
	float clearcoat_gloss,
	float sheen_gloss,
	float iridescence_intensity
) {
	if (numClusteredLights <= 1)
		return;
	ivec3 cellCoords = ivec3(floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize));
	if (!(any(lessThan(cellCoords, ivec3(0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {
		int cellIndex = cellCoords.x * clusterCellsDot.x + cellCoords.y * clusterCellsDot.y + cellCoords.z * clusterCellsDot.z;
		int clusterV = cellIndex / clusterTextureWidth;
		int clusterU = cellIndex - clusterV * clusterTextureWidth;
		for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {
			uint lightIndex = texelFetch(clusterWorldTexture, ivec2(clusterU + lightCellIndex, clusterV), 0).x;
			if (lightIndex == 0u)
				break;
			evaluateClusterLight(
				int(lightIndex), 
				worldNormal, 
				viewDir, 
				reflectionDir,
#if defined(LIT_CLEARCOAT)
				clearcoatReflectionDir,
#endif
				gloss, 
				specularity, 
				geometricNormal, 
				tbn, 
#if defined(LIT_IRIDESCENCE)
				iridescenceFresnel,
#endif
				clearcoat_worldNormal,
				clearcoat_gloss,
				sheen_gloss,
				iridescence_intensity
			); 
		}
	}
}
`,p5=`
vec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {
	vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
	ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;
#else
	ret += albedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
	ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
	ret += dReflection.rgb * dReflection.a;
#endif
#ifdef LIT_SHEEN
	float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
	ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
#endif
#ifdef LIT_CLEARCOAT
	float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;
	ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection) * clearcoatSpecularity;
#endif
	return ret;
}
`,_5=`
	varying vec2 uv0;
	uniform sampler2D blitTexture;
	void main(void) {
		gl_FragColor = texture2D(blitTexture, uv0);
	}
`,g5=`
	varying vec2 uv0;
	uniform samplerCube blitTexture;
	uniform mat4 invViewProj;
	void main(void) {
		vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
		vec4 worldPos = invViewProj * projPos;
		gl_FragColor = textureCube(blitTexture, worldPos.xyz);
	}
`,v5=`
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
		#ifndef WEBGPU
			uv0.y = 1.0 - uv0.y;
		#endif
	}
`,S5=`
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}
vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
	vec4 projPos = transform * vec4(vPositionW, 1.0);
	projPos.xy /= projPos.w;
	projPos.xy += cookieOffset;
	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
	return mix(vec4(1.0), texture2D(tex, uv), intensity);
}
vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
	return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`,y5=`
#if LIT_CUBEMAP_PROJECTION == BOX
	uniform vec3 envBoxMin;
	uniform vec3 envBoxMax;
#endif
vec3 cubeMapProject(vec3 nrdir) {
	#if LIT_CUBEMAP_PROJECTION == NONE
		return cubeMapRotate(nrdir);
	#endif
	#if LIT_CUBEMAP_PROJECTION == BOX
		nrdir = cubeMapRotate(nrdir);
		vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
		vec3 rbmin = (envBoxMin - vPositionW) / nrdir;
		vec3 rbminmax = mix(rbmin, rbmax, vec3(greaterThan(nrdir, vec3(0.0))));
		float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
		vec3 posonbox = vPositionW + nrdir * fa;
		vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
		return normalize(posonbox - envBoxPos);
	#endif
}
`,x5=`
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif
vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
	return refDir * cubeMapRotationMatrix;
#else
	return refDir;
#endif
}
`,T5=`
#ifdef DEBUG_ALBEDO_PASS
gl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);
#endif
#ifdef DEBUG_UV0_PASS
gl_FragColor = vec4(litArgs_albedo , 1.0);
#endif
#ifdef DEBUG_WORLD_NORMAL_PASS
gl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif
#ifdef DEBUG_OPACITY_PASS
gl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);
#endif
#ifdef DEBUG_SPECULARITY_PASS
gl_FragColor = vec4(litArgs_specularity, 1.0);
#endif
#ifdef DEBUG_GLOSS_PASS
gl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);
#endif
#ifdef DEBUG_METALNESS_PASS
gl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);
#endif
#ifdef DEBUG_AO_PASS
gl_FragColor = vec4(vec3(litArgs_ao) , 1.0);
#endif
#ifdef DEBUG_EMISSION_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`,E5=`
#ifdef DEBUG_LIGHTING_PASS
litArgs_albedo = vec3(0.5);
#endif
#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
litArgs_albedo = vec3(vUv0, 0);
#else
litArgs_albedo = vec3(0);
#endif
#endif
`,b5=`
#ifndef _DECODE_INCLUDED_
#define _DECODE_INCLUDED_
vec3 decodeLinear(vec4 raw) {
	return raw.rgb;
}
float decodeGamma(float raw) {
	return pow(raw, 2.2);
}
vec3 decodeGamma(vec3 raw) {
	return pow(raw, vec3(2.2));
}
vec3 decodeGamma(vec4 raw) {
	return pow(raw.xyz, vec3(2.2));
}
vec3 decodeRGBM(vec4 raw) {
	vec3 color = (8.0 * raw.a) * raw.rgb;
	return color * color;
}
vec3 decodeRGBP(vec4 raw) {
	vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
	return color * color;
}
vec3 decodeRGBE(vec4 raw) {
	if (raw.a == 0.0) {
		return vec3(0.0, 0.0, 0.0);
	} else {
		return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
	}
}
vec4 passThrough(vec4 raw) {
	return raw;
}
vec3 unpackNormalXYZ(vec4 nmap) {
	return nmap.xyz * 2.0 - 1.0;
}
vec3 unpackNormalXY(vec4 nmap) {
	vec3 normal;
	normal.xy = nmap.wy * 2.0 - 1.0;
	normal.z = sqrt(1.0 - clamp(dot(normal.xy, normal.xy), 0.0, 1.0));
	return normal;
}
#endif
`,A5=`
#ifndef _DETAILMODES_INCLUDED_
#define _DETAILMODES_INCLUDED_
vec3 detailMode_mul(vec3 c1, vec3 c2) {
	return c1 * c2;
}
vec3 detailMode_add(vec3 c1, vec3 c2) {
	return c1 + c2;
}
vec3 detailMode_screen(vec3 c1, vec3 c2) {
	return 1.0 - (1.0 - c1)*(1.0 - c2);
}
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
	return mix(1.0 - 2.0 * (1.0 - c1)*(1.0 - c2), 2.0 * c1 * c2, step(c1, vec3(0.5)));
}
vec3 detailMode_min(vec3 c1, vec3 c2) {
	return min(c1, c2);
}
vec3 detailMode_max(vec3 c1, vec3 c2) {
	return max(c1, c2);
}
#endif
`,w5=`
uniform vec3 material_diffuse;
#ifdef STD_DIFFUSEDETAIL_TEXTURE
	#include "detailModesPS"
#endif
void getAlbedo() {
	dAlbedo = material_diffuse.rgb;
	#ifdef STD_DIFFUSE_TEXTURE
		vec3 albedoTexture = {STD_DIFFUSE_TEXTURE_DECODE}(texture2DBias({STD_DIFFUSE_TEXTURE_NAME}, {STD_DIFFUSE_TEXTURE_UV}, textureBias)).{STD_DIFFUSE_TEXTURE_CHANNEL};
		#ifdef STD_DIFFUSEDETAIL_TEXTURE
			vec3 albedoDetail = {STD_DIFFUSEDETAIL_TEXTURE_DECODE}(texture2DBias({STD_DIFFUSEDETAIL_TEXTURE_NAME}, {STD_DIFFUSEDETAIL_TEXTURE_UV}, textureBias)).{STD_DIFFUSEDETAIL_TEXTURE_CHANNEL};
			albedoTexture = detailMode_{STD_DIFFUSEDETAIL_DETAILMODE}(albedoTexture, albedoDetail);
		#endif
		dAlbedo *= albedoTexture;
	#endif
	#ifdef STD_DIFFUSE_VERTEX
		dAlbedo *= saturate(vVertexColor.{STD_DIFFUSE_VERTEX_CHANNEL});
	#endif
}
`,C5=`
uniform vec3 material_emissive;
uniform float material_emissiveIntensity;
void getEmission() {
	dEmission = material_emissive * material_emissiveIntensity;
	#ifdef STD_EMISSIVE_TEXTURE
	dEmission *= {STD_EMISSIVE_TEXTURE_DECODE}(texture2DBias({STD_EMISSIVE_TEXTURE_NAME}, {STD_EMISSIVE_TEXTURE_UV}, textureBias)).{STD_EMISSIVE_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_EMISSIVE_VERTEX
	dEmission *= saturate(vVertexColor.{STD_EMISSIVE_VERTEX_CHANNEL});
	#endif
}
`,D5=`
vec4 encodeLinear(vec3 source) {
	return vec4(source, 1.0);
}
vec4 encodeGamma(vec3 source) {
	return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}
vec4 encodeRGBM(vec3 source) {
	vec4 result;
	result.rgb = pow(source.rgb, vec3(0.5));
	result.rgb *= 1.0 / 8.0;
	result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
	result.a = ceil(result.a * 255.0) / 255.0;
	result.rgb /= result.a;
	return result;
}
vec4 encodeRGBP(vec3 source) {
	vec3 gamma = pow(source, vec3(0.5));
	float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));
	float v = 1.0 - ((maxVal - 1.0) / 7.0);
	v = ceil(v * 255.0) / 255.0;
	return vec4(gamma / (-v * 7.0 + 8.0), v);	
}
vec4 encodeRGBE(vec3 source) {
	float maxVal = max(source.x, max(source.y, source.z));
	if (maxVal < 1e-32) {
		return vec4(0, 0, 0, 0);
	} else {
		float e = ceil(log2(maxVal));
		return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
	}
}
`,P5=`
	gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);
	gl_FragColor.rgb += litArgs_emission;
	gl_FragColor.rgb = addFog(gl_FragColor.rgb);
	gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
	gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
`,R5=`
#ifndef _ENVATLAS_INCLUDED_
#define _ENVATLAS_INCLUDED_
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;
vec2 mapUv(vec2 uv, vec4 rect) {
	return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
				mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}
vec2 mapRoughnessUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}
vec2 mapShinyUv(vec2 uv, float level) {
	float t = 1.0 / exp2(level);
	return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
#endif
`,M5=`
#ifdef LIT_SKYBOX_INTENSITY
	uniform float skyboxIntensity;
#endif
vec3 processEnvironment(vec3 color) {
	#ifdef LIT_SKYBOX_INTENSITY
		return color * skyboxIntensity;
	#else
		return color;
	#endif
}
`,L5=`
float getFalloffWindow(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float invRadius = 1.0 / lightRadius;
	return square(saturate(1.0 - square(sqrDist * square(invRadius))));
}
float getFalloffInvSquared(float lightRadius, vec3 lightDir) {
	float sqrDist = dot(lightDir, lightDir);
	float falloff = 1.0 / (sqrDist + 1.0);
	float invRadius = 1.0 / lightRadius;
	falloff *= 16.0;
	falloff *= square(saturate(1.0 - square(sqrDist * square(invRadius))));
	return falloff;
}
`,I5=`
float getFalloffLinear(float lightRadius, vec3 lightDir) {
	float d = length(lightDir);
	return max(((lightRadius - d) / lightRadius), 0.0);
}
`,O5=`
#ifndef FLOAT_AS_UINT
#define FLOAT_AS_UINT
vec4 float2uint(float value) {
	uint intBits = floatBitsToUint(value);
	return vec4(
		float((intBits >> 24u) & 0xFFu) / 255.0,
		float((intBits >> 16u) & 0xFFu) / 255.0,
		float((intBits >> 8u) & 0xFFu) / 255.0,
		float(intBits & 0xFFu) / 255.0
	);
}
float uint2float(vec4 value) {
	uint intBits = 
		(uint(value.r * 255.0) << 24u) |
		(uint(value.g * 255.0) << 16u) |
		(uint(value.b * 255.0) << 8u) |
		uint(value.a * 255.0);
	return uintBitsToFloat(intBits);
}
vec4 float2vec4(float value) {
	#if defined(CAPS_TEXTURE_FLOAT_RENDERABLE)
		return vec4(value, 1.0, 1.0, 1.0);
	#else
		return float2uint(value);
	#endif
}
#endif
`,N5=`
float dBlendModeFogFactor = 1.0;
#if (FOG != NONE)
	uniform vec3 fog_color;
	#if (FOG == LINEAR)
		uniform float fog_start;
		uniform float fog_end;
	#else
		uniform float fog_density;
	#endif
#endif
float getFogFactor() {
	float depth = gl_FragCoord.z / gl_FragCoord.w;
	float fogFactor = 0.0;
	#if (FOG == LINEAR)
		fogFactor = (fog_end - depth) / (fog_end - fog_start);
	#elif (FOG == EXP)
		fogFactor = exp(-depth * fog_density);
	#elif (FOG == EXP2)
		fogFactor = exp(-depth * depth * fog_density * fog_density);
	#endif
	return clamp(fogFactor, 0.0, 1.0);
}
vec3 addFog(vec3 color) {
	#if (FOG != NONE)
		return mix(fog_color * dBlendModeFogFactor, color, getFogFactor());
	#endif
	return color;
}
`,F5=`
vec3 getFresnel(
		float cosTheta, 
		float gloss, 
		vec3 specularity
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
	) {
	float fresnel = pow(1.0 - saturate(cosTheta), 5.0);
	float glossSq = gloss * gloss;
	float specIntensity = max(specularity.r, max(specularity.g, specularity.b));
	vec3 ret = specularity + (max(vec3(glossSq * specIntensity), specularity) - specularity) * fresnel;
#if defined(LIT_IRIDESCENCE)
	return mix(ret, iridescenceFresnel, iridescenceIntensity);
#else
	return ret;
#endif	
}
float getFresnelCC(float cosTheta) {
	float fresnel = pow(1.0 - saturate(cosTheta), 5.0);
	return 0.04 + (1.0 - 0.04) * fresnel;
}
`,B5=`
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = vertex_position.xy * 0.5 + 0.5;
}
`,U5=`
#include "decodePS"
#if (GAMMA == SRGB)
	float gammaCorrectInput(float color) {
		return decodeGamma(color);
	}
	vec3 gammaCorrectInput(vec3 color) {
		return decodeGamma(color);
	}
	vec4 gammaCorrectInput(vec4 color) {
		return vec4(decodeGamma(color.xyz), color.w);
	}
	vec3 gammaCorrectOutput(vec3 color) {
		return pow(color + 0.0000001, vec3(1.0 / 2.2));
	}
#else
	float gammaCorrectInput(float color) {
		return color;
	}
	vec3 gammaCorrectInput(vec3 color) {
		return color;
	}
	vec4 gammaCorrectInput(vec4 color) {
		return color;
	}
	vec3 gammaCorrectOutput(vec3 color) {
		return color;
	}
#endif
`,z5=`
#ifdef STD_GLOSS_CONSTANT
uniform float material_gloss;
#endif
void getGlossiness() {
	dGlossiness = 1.0;
	#ifdef STD_GLOSS_CONSTANT
	dGlossiness *= material_gloss;
	#endif
	#ifdef STD_GLOSS_TEXTURE
	dGlossiness *= texture2DBias({STD_GLOSS_TEXTURE_NAME}, {STD_GLOSS_TEXTURE_UV}, textureBias).{STD_GLOSS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_GLOSS_VERTEX
	dGlossiness *= saturate(vVertexColor.{STD_GLOSS_VERTEX_CHANNEL});
	#endif
	#ifdef STD_GLOSS_INVERT
	dGlossiness = 1.0 - dGlossiness;
	#endif
	dGlossiness += 0.0000001;
}
`,k5=`
	attribute vec2 aPosition;
	varying vec2 uv0;
	void main(void)
	{
		gl_Position = vec4(aPosition, 0.0, 1.0);
		uv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
	}
`,V5=`
		#include "gammaPS"
		varying vec4 color;
		void main(void) {
			gl_FragColor = vec4(gammaCorrectOutput(decodeGamma(color.rgb)), color.a);
		}
`,G5=`
	attribute vec4 vertex_position;
	attribute vec4 vertex_color;
	uniform mat4 matrix_model;
	uniform mat4 matrix_viewProjection;
	varying vec4 color;
	void main(void) {
		color = vertex_color;
		gl_Position = matrix_viewProjection * matrix_model * vertex_position;
	}
`,H5=`
uniform float material_iridescenceRefractionIndex;
float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}
vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
	return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}
vec3 iridescence_fresnelToIor(vec3 f0) {
	vec3 sqrtF0 = sqrt(f0);
	return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}
vec3 iridescence_sensitivity(float opd, vec3 shift) {
	float PI = 3.141592653589793;
	float phase = 2.0 * PI * opd * 1.0e-9;
	const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
	const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
	const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
	vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
	xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
	xyz /= vec3(1.0685e-07);
	const mat3 XYZ_TO_REC709 = mat3(
		3.2404542, -0.9692660,  0.0556434,
	   -1.5371385,  1.8760108, -0.2040259,
	   -0.4985314,  0.0415560,  1.0572252
	);
	return XYZ_TO_REC709 * xyz;
}
float iridescence_fresnel(float cosTheta, float f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2;
	return f0 + (1.0 - f0) * x5;
} 
vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
	float x = clamp(1.0 - cosTheta, 0.0, 1.0);
	float x2 = x * x;
	float x5 = x * x2 * x2; 
	return f0 + (vec3(1.0) - f0) * x5;
}
vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {
	float PI = 3.141592653589793;
	float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
	float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
	float cosTheta2Sq = 1.0 - sinTheta2Sq;
	if (cosTheta2Sq < 0.0) {
		return vec3(1.0);
	}
	float cosTheta2 = sqrt(cosTheta2Sq);
	float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
	float r12 = iridescence_fresnel(cosTheta, r0);
	float r21 = r12;
	float t121 = 1.0 - r12;
	float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
	float phi21 = PI - phi12;
	vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
	vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
	vec3 r23 = iridescence_fresnel(cosTheta2, r1);
	vec3 phi23 = vec3(0.0);
	if (baseIor[0] < iridescenceIor) phi23[0] = PI;
	if (baseIor[1] < iridescenceIor) phi23[1] = PI;
	if (baseIor[2] < iridescenceIor) phi23[2] = PI;
	float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
	vec3 phi = vec3(phi21) + phi23; 
	vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
	vec3 r123 = sqrt(r123Sq);
	vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);
	vec3 c0 = r12 + rs;
	vec3 i = c0;
	vec3 cm = rs - t121;
	for (int m = 1; m <= 2; m++) {
		cm *= r123;
		vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
		i += cm * sm;
	}
	return max(i, vec3(0.0));
}
vec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {
	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`,W5=`
#ifdef STD_IRIDESCENCE_CONSTANT
uniform float material_iridescence;
#endif
void getIridescence() {
	float iridescence = 1.0;
	#ifdef STD_IRIDESCENCE_CONSTANT
	iridescence *= material_iridescence;
	#endif
	#ifdef STD_IRIDESCENCE_TEXTURE
	iridescence *= texture2DBias({STD_IRIDESCENCE_TEXTURE_NAME}, {STD_IRIDESCENCE_TEXTURE_UV}, textureBias).{STD_IRIDESCENCE_TEXTURE_CHANNEL};
	#endif
	dIridescence = iridescence; 
}
`,X5=`
uniform float material_iridescenceThicknessMax;
#ifdef STD_IRIDESCENCETHICKNESS_TEXTURE
uniform float material_iridescenceThicknessMin;
#endif
void getIridescenceThickness() {
	#ifdef STD_IRIDESCENCETHICKNESS_TEXTURE
		float blend = texture2DBias({STD_IRIDESCENCETHICKNESS_TEXTURE_NAME}, {STD_IRIDESCENCETHICKNESS_TEXTURE_UV}, textureBias).{STD_IRIDESCENCETHICKNESS_TEXTURE_CHANNEL};
		float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
	#else
		float iridescenceThickness = material_iridescenceThicknessMax;
	#endif
	dIridescenceThickness = iridescenceThickness; 
}
`,q5=`
#ifdef STD_IOR_CONSTANT
uniform float material_refractionIndex;
#endif
void getIor() {
#ifdef STD_IOR_CONSTANT
	dIor = material_refractionIndex;
#else
	dIor = 1.0 / 1.5;
#endif
}
`,Y5=`
#if defined(LIGHT{i})
	uniform vec3 light{i}_color;
	#if LIGHT{i}TYPE == DIRECTIONAL
		uniform vec3 light{i}_direction;
	#else
		#define LIT_CODE_LIGHTS_POINT
		uniform vec3 light{i}_position;
		uniform float light{i}_radius;
		#if LIGHT{i}TYPE == SPOT
			#define LIT_CODE_LIGHTS_SPOT
			uniform vec3 light{i}_direction;
			uniform float light{i}_innerConeAngle;
			uniform float light{i}_outerConeAngle;
		#endif
	#endif
	#if LIGHT{i}SHAPE != PUNCTUAL
		#define LIT_CODE_FALLOFF_SQUARED
		#if LIGHT{i}TYPE == DIRECTIONAL
			uniform vec3 light{i}_position;
		#endif
		uniform vec3 light{i}_halfWidth;
		uniform vec3 light{i}_halfHeight;
	#else
		#if LIGHT{i}FALLOFF == LINEAR
			#define LIT_CODE_FALLOFF_LINEAR
		#endif
		#if LIGHT{i}FALLOFF == INVERSESQUARED
			#define LIT_CODE_FALLOFF_SQUARED
		#endif
	#endif
	#if defined(LIGHT{i}CASTSHADOW)
		#if LIGHT{i}TYPE != OMNI
			uniform mat4 light{i}_shadowMatrix;
		#endif
		uniform float light{i}_shadowIntensity;
		uniform vec4 light{i}_shadowParams;
		#if LIGHT{i}SHADOWTYPE == PCSS_32F
			uniform float light{i}_shadowSearchArea;
			uniform vec4 light{i}_cameraParams;
			#if LIGHT{i}TYPE == DIRECTIONAL
				uniform vec4 light{i}_softShadowParams;
			#endif
		#endif
		#if LIGHT{i}TYPE == DIRECTIONAL
			uniform mat4 light{i}_shadowMatrixPalette[4];
			uniform vec4 light{i}_shadowCascadeDistances;
			uniform int light{i}_shadowCascadeCount;
			uniform float light{i}_shadowCascadeBlend;
		#endif
		#if LIGHT{i}TYPE == OMNI
			#if defined(LIGHT{i}SHADOW_PCF)
				uniform samplerCubeShadow light{i}_shadowMap;
			#else
				uniform samplerCube light{i}_shadowMap;
			#endif
		#else
			#if defined(LIGHT{i}SHADOW_PCF)
				uniform sampler2DShadow light{i}_shadowMap;
			#else
				uniform sampler2D light{i}_shadowMap;
			#endif
		#endif
	#endif
	#if defined(LIGHT{i}COOKIE)
		#define LIT_CODE_COOKIE
		#if LIGHT{i}TYPE == OMNI
			uniform samplerCube light{i}_cookie;
			uniform float light{i}_cookieIntensity;
			uniform mat4 light{i}_shadowMatrix;
		#endif
		#if LIGHT{i}TYPE == SPOT
			uniform sampler2D light{i}_cookie;
			uniform float light{i}_cookieIntensity;
			#if !defined(LIGHT{i}CASTSHADOW)
				uniform mat4 light{i}_shadowMatrix;
			#endif
			#if defined(LIGHT{i}COOKIE_TRANSFORM)
				uniform vec4 light{i}_cookieMatrix;
				uniform vec2 light{i}_cookieOffset;
			#endif
		#endif
	#endif
#endif
`,j5=`
float getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm) {
	return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`,$5=`
vec3 evalOmniLight(vec3 lightPosW) {
	return vPositionW - lightPosW;
}
`,K5=`
#if defined(LIGHT{i})
	evaluateLight{i}(
		#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel
		#endif
	);
#endif
`,Z5=`
#if defined(LIGHT{i})
void evaluateLight{i}(
	#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel
	#endif
) {
	vec3 lightColor = light{i}_color;
	#if LIGHT{i}TYPE == DIRECTIONAL && !defined(LIT_SHADOW_CATCHER)
		if (all(equal(lightColor, vec3(0.0)))) {
			return;
		}
	#endif
	#if LIGHT{i}TYPE == DIRECTIONAL
		dLightDirNormW = light{i}_direction;
		dAtten = 1.0;
	#else
		
		vec3 lightDirW = evalOmniLight(light{i}_position);
		dLightDirNormW = normalize(lightDirW);
		#if defined(LIGHT{i}COOKIE)
			#if LIGHT{i}TYPE == SPOT
				#ifdef LIGHT{i}COOKIE_FALLOFF
					#ifdef LIGHT{i}COOKIE_TRANSFORM
						vec3 cookieAttenuation = getCookie2DXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};
					#else
						vec3 cookieAttenuation = getCookie2D(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};
					#endif
				#else
					#ifdef LIGHT{i}COOKIE_TRANSFORM
						vec3 cookieAttenuation = getCookie2DClipXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};
					#else
						vec3 cookieAttenuation = getCookie2DClip(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};
					#endif
				#endif
			#endif
			#if LIGHT{i}TYPE == OMNI
				vec3 cookieAttenuation = getCookieCube(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};
			#endif
			lightColor *= cookieAttenuation;
		#endif
		#if LIGHT{i}SHAPE == PUNCTUAL
			#if LIGHT{i}FALLOFF == LINEAR
				dAtten = getFalloffLinear(light{i}_radius, lightDirW);
			#else
				dAtten = getFalloffInvSquared(light{i}_radius, lightDirW);
			#endif
		#else
			dAtten = getFalloffWindow(light{i}_radius, lightDirW);
		#endif
		#if LIGHT{i}TYPE == SPOT
			#if !defined(LIGHT{i}COOKIE) || defined(LIGHT{i}COOKIE_FALLOFF)
				dAtten *= getSpotEffect(light{i}_direction, light{i}_innerConeAngle, light{i}_outerConeAngle, dLightDirNormW);
			#endif
		#endif
	#endif
	if (dAtten < 0.00001) {
		return;
	}
	#if LIGHT{i}SHAPE != PUNCTUAL
		#if LIGHT{i}SHAPE == RECT
			calcRectLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);
		#elif LIGHT{i}SHAPE == DISK
			calcDiskLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);
		#elif LIGHT{i}SHAPE == SPHERE
			calcSphereLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);
		#endif
	#endif
	#if LIGHT{i}SHAPE != PUNCTUAL
		#if LIGHT{i}TYPE == DIRECTIONAL
			float attenDiffuse = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirNormW);
		#else
			#if LIGHT{i}SHAPE == RECT
				float attenDiffuse = getRectLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;
			#elif LIGHT{i}SHAPE == DISK
				float attenDiffuse = getDiskLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;
			#elif LIGHT{i}SHAPE == SPHERE
				float attenDiffuse = getSphereLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;
			#endif
		#endif
	#else
		dAtten *= getLightDiffuse(litArgs_worldNormal, vec3(0.0), dLightDirNormW);
	#endif
	#ifdef LIGHT{i}CASTSHADOW
		#if LIGHT{i}TYPE == DIRECTIONAL
			float shadow = getShadow{i}(vec3(0.0));
		#else
			float shadow = getShadow{i}(lightDirW);
		#endif
		shadow = mix(1.0, shadow, light{i}_shadowIntensity);
		dAtten *= shadow;
		#if defined(LIT_SHADOW_CATCHER) && LIGHT{i}TYPE == DIRECTIONAL
			dShadowCatcher *= shadow;
		#endif			
	#endif
	#if LIGHT{i}SHAPE != PUNCTUAL
		#ifdef LIT_SPECULAR
			dDiffuseLight += ((attenDiffuse * dAtten) * lightColor) * (1.0 - dLTCSpecFres);
		#else
			dDiffuseLight += (attenDiffuse * dAtten) * lightColor;
		#endif						
	#else
		#if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)
			dDiffuseLight += (dAtten * lightColor) * (1.0 - litArgs_specularity);
		#else
			dDiffuseLight += dAtten * lightColor;
		#endif
	#endif
	#ifdef LIGHT{i}AFFECT_SPECULARITY
		#if LIGHT{i}SHAPE != PUNCTUAL
			#ifdef LIT_CLEARCOAT
				#if LIGHT{i}SHAPE == RECT
					ccSpecularLight += ccLTCSpecFres * getRectLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;
				#elif LIGHT{i}SHAPE == DISK
					ccSpecularLight += ccLTCSpecFres * getDiskLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;
				#elif LIGHT{i}SHAPE == SPHERE
					ccSpecularLight += ccLTCSpecFres * getSphereLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;
				#endif
			#endif
			#ifdef LIT_SPECULAR
				#if LIGHT{i}SHAPE == RECT
					dSpecularLight += dLTCSpecFres * getRectLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;
				#elif LIGHT{i}SHAPE == DISK
					dSpecularLight += dLTCSpecFres * getDiskLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;
				#elif LIGHT{i}SHAPE == SPHERE
					dSpecularLight += dLTCSpecFres * getSphereLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;
				#endif
			#endif
		#else
			#if LIGHT{i}TYPE == DIRECTIONAL && LIT_FRESNEL_MODEL != NONE
				#define LIGHT{i}FRESNEL
			#endif
			#ifdef LIT_SPECULAR
				vec3 halfDirW = normalize(-dLightDirNormW + dViewDirW);
			#endif
			#ifdef LIT_CLEARCOAT
				vec3 lightspecularCC = getLightSpecular(halfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * lightColor;
				#ifdef LIGHT{i}FRESNEL
					lightspecularCC *= getFresnelCC(dot(dViewDirW, halfDirW));
				#endif
				ccSpecularLight += lightspecularCC;
			#endif
			#ifdef LIT_SHEEN
				sSpecularLight += getLightSpecularSheen(halfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * lightColor;
			#endif
			#ifdef LIT_SPECULAR
				vec3 lightSpecular = getLightSpecular(halfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * lightColor;
				#ifdef LIGHT{i}FRESNEL
					#if defined(LIT_IRIDESCENCE)
						lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity, iridescenceFresnel, litArgs_iridescence_intensity);
					#else
						lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity);
					#endif
				#else
					lightSpecular *= litArgs_specularity;
				#endif
				
				dSpecularLight += lightSpecular;
			#endif
		#endif
	#endif
}
#endif
`,Q5=`
#ifdef LIGHT{i}CASTSHADOW
	#ifdef LIGHT{i}_SHADOW_SAMPLE_POINT
		vec3 getShadowSampleCoordOmni{i}(vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
			#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET
				float distScale = length(lightDir);
				vec3 surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				lightDir = surfacePosition - lightPos;
			#endif
			return lightDir;
		}
	#endif
	#ifndef LIGHT{i}_SHADOW_SAMPLE_POINT
		vec3 getShadowSampleCoord{i}(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
			vec3 surfacePosition = worldPosition;
			#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER
				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET
					surfacePosition = surfacePosition + normal * shadowParams.y;
				#endif
			#else
				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET
					#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO
						float distScale = 1.0;
					#else
						float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));
					#endif
					surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				#endif
			#endif
			vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);
			#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO
				positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
			#else
				#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER
					positionInShadowSpace.xyz /= positionInShadowSpace.w;
				#else
					positionInShadowSpace.xy /= positionInShadowSpace.w;
					positionInShadowSpace.z = length(lightDir) * shadowParams.w;
				#endif
			#endif
			return positionInShadowSpace.xyz;
		}
	#endif
	float getShadow{i}(vec3 lightDirW) {
		#if LIGHT{i}TYPE == OMNI
			vec3 shadowCoord = getShadowSampleCoordOmni{i}(light{i}_shadowParams, vPositionW, light{i}_position, lightDirW, dLightDirNormW, dVertexNormalW);
		#else
			#ifdef LIGHT{i}_SHADOW_CASCADES
				int cascadeIndex = getShadowCascadeIndex(light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount);
				#ifdef LIGHT{i}_SHADOW_CASCADE_BLEND
					cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount, light{i}_shadowCascadeBlend);
				#endif
				mat4 shadowMatrix = light{i}_shadowMatrixPalette[cascadeIndex];
			#else
				mat4 shadowMatrix = light{i}_shadowMatrix;
			#endif
			#if LIGHT{i}TYPE == DIRECTIONAL
				vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, vec3(0.0), lightDirW, dLightDirNormW, dVertexNormalW);
			#else
				vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, light{i}_position, lightDirW, dLightDirNormW, dVertexNormalW);
			#endif
		#endif
		#if LIGHT{i}TYPE == DIRECTIONAL
			shadowCoord = fadeShadow(shadowCoord, light{i}_shadowCascadeDistances);
		#endif
		#if LIGHT{i}TYPE == DIRECTIONAL
			#if LIGHT{i}SHADOWTYPE == VSM_16F
				return getShadowVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54);
			#endif
			#if LIGHT{i}SHADOWTYPE == VSM_32F
				return getShadowVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCSS_32F
				#if LIGHT{i}SHAPE != PUNCTUAL
					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;
					return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);
				#else
					return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, light{i}_softShadowParams, lightDirW);
				#endif
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F
				return getShadowPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F
				return getShadowPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F
				return getShadowPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);
			#endif
		#endif
		#if LIGHT{i}TYPE == SPOT
			#if LIGHT{i}SHADOWTYPE == VSM_16F
				return getShadowSpotVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54, lightDirW);
			#endif
			#if LIGHT{i}SHADOWTYPE == VSM_32F
				return getShadowSpotVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0, lightDirW);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCSS_32F
				#if LIGHT{i}SHAPE != PUNCTUAL
					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;
				#else
					vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);
				#endif
				return getShadowSpotPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F
				return getShadowSpotPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F
				return getShadowSpotPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F
				return getShadowSpotPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);
			#endif
		#endif
		#if LIGHT{i}TYPE == OMNI
			#if LIGHT{i}SHADOWTYPE == PCSS_32F
				#if LIGHT{i}SHAPE != PUNCTUAL
					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;
				#else
					vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);
				#endif
				return getShadowOmniPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F
				return getShadowOmniPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F
				return getShadowOmniPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);
			#endif
		#endif
	}
#endif
`,J5=`
#ifdef LIT_CLUSTERED_LIGHTS
	#define LIT_CODE_FALLOFF_LINEAR
	#define LIT_CODE_FALLOFF_SQUARED
	#define LIT_CODE_LIGHTS_POINT
	#define LIT_CODE_LIGHTS_SPOT
#endif
#ifdef AREA_LIGHTS
	uniform highp sampler2D areaLightsLutTex1;
	uniform highp sampler2D areaLightsLutTex2;
#endif
#ifdef LIT_LIGHTING
	#include "lightDiffuseLambertPS"
	#if defined(AREA_LIGHTS) || defined(LIT_CLUSTERED_AREA_LIGHTS)
		#include "ltcPS"
	#endif
#endif
#ifdef SHADOW_DIRECTIONAL
	#include "shadowCascadesPS"
#endif
#if defined(SHADOW_KIND_PCF1)
	#include "shadowPCF1PS"
#endif
#if defined(SHADOW_KIND_PCF3)
	#include "shadowPCF3PS"
#endif
#if defined(SHADOW_KIND_PCF5)
	#include "shadowPCF5PS"
#endif
#if defined(SHADOW_KIND_PCSS)
	#include "linearizeDepthPS"
	#include "shadowPCSSPS"
	#include "shadowSoftPS"
#endif
#if defined(SHADOW_KIND_VSM)
	#include "shadowEVSMPS"
#endif
#ifdef LIT_CODE_FALLOFF_LINEAR
	#include "falloffLinearPS"
#endif
#ifdef LIT_CODE_FALLOFF_SQUARED
	#include "falloffInvSquaredPS"
#endif
#ifdef LIT_CODE_LIGHTS_POINT
	#include "lightDirPointPS"
#endif
#ifdef LIT_CODE_LIGHTS_SPOT
	#include "spotPS"
#endif
#ifdef LIT_CODE_COOKIE
	#include "cookiePS"
#endif
#ifdef LIT_CLUSTERED_LIGHTS
	#include "clusteredLightPS"
#endif
#ifdef LIGHT_COUNT > 0
	#include "lightFunctionShadowPS, LIGHT_COUNT"
	#include "lightFunctionLightPS, LIGHT_COUNT"
#endif
`,eW=`
void addLightMap(
	vec3 lightmap, 
	vec3 dir, 
	vec3 worldNormal, 
	vec3 viewDir, 
	vec3 reflectionDir, 
	float gloss, 
	vec3 specularity, 
	vec3 vertexNormal, 
	mat3 tbn
#if defined(LIT_IRIDESCENCE)
	vec3 iridescenceFresnel, 
	float iridescenceIntensity
#endif
) {
	#if defined(LIT_SPECULAR) && defined(LIT_DIR_LIGHTMAP)
		if (dot(dir, dir) < 0.0001) {
				dDiffuseLight += lightmap;
		} else {
			float vlight = saturate(dot(dir, -vertexNormal));
			float flight = saturate(dot(dir, -worldNormal));
			float nlight = (flight / max(vlight, 0.01)) * 0.5;
			dDiffuseLight += lightmap * nlight * 2.0;
			vec3 halfDir = normalize(-dir + viewDir);
			vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);
			#ifdef LIT_SPECULAR_FRESNEL
				specularLight *= 
					getFresnel(dot(viewDir, halfDir), 
					gloss, 
					specularity
				#if defined(LIT_IRIDESCENCE)
					, iridescenceFresnel,
					iridescenceIntensity
				#endif
					);
			#endif
			dSpecularLight += specularLight;
		}
	#else
		dDiffuseLight += lightmap;
	#endif
}
`,tW=`
#ifdef STD_LIGHTMAP_DIR
	vec3 dLightmapDir;
	uniform sampler2D texture_dirLightMap;
#endif
void getLightMap() {
	dLightmap = vec3(1.0);
	#ifdef STD_LIGHT_TEXTURE
		dLightmap *= {STD_LIGHT_TEXTURE_DECODE}(texture2DBias({STD_LIGHT_TEXTURE_NAME}, {STD_LIGHT_TEXTURE_UV}, textureBias)).{STD_LIGHT_TEXTURE_CHANNEL};
		#ifdef STD_LIGHTMAP_DIR
			vec3 dir = texture2DBias(texture_dirLightMap, {STD_LIGHT_TEXTURE_UV}, textureBias).xyz * 2.0 - 1.0;
			float dirDot = dot(dir, dir);
			dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
		#endif
	#endif
	#ifdef STD_LIGHT_VERTEX
		dLightmap *= saturate(vVertexColor.{STD_LIGHT_VERTEX_CHANNEL});
	#endif
}
`,sW=`
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {
	float PI = 3.141592653589793;
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	float alphaRoughness = roughness * roughness;
	float anisotropy = dAnisotropy;
	vec2 direction = dAnisotropyRotation;
	float at = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
	float ab = clamp(alphaRoughness, 0.001, 1.0);
	vec3 anisotropicT = normalize(tbn * vec3(direction, 0.0));
	vec3 anisotropicB = normalize(cross(tbn[2], anisotropicT));
	float NoH = dot(worldNormal, h);
	float ToH = dot(anisotropicT, h);
	float BoH = dot(anisotropicB, h);
	float a2 = at * ab;
	vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
	float v2 = dot(v, v);
	float w2 = a2 / v2;
	float D = a2 * w2 * w2 * (1.0 / PI);
	float ToV = dot(anisotropicT, viewDir);
	float BoV = dot(anisotropicB, viewDir);
	float ToL = dot(anisotropicT, -lightDirNorm);
	float BoL = dot(anisotropicB, -lightDirNorm);
	float NoV = dot(worldNormal, viewDir);
	float NoL = dot(worldNormal, -lightDirNorm);
	float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
	float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
	float G = 0.5 / (lambdaV + lambdaL);
	return D * G;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`,iW=`
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm) {
	const float PI = 3.141592653589793;
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	float alpha = roughness * roughness;
	float NoH = max(dot(worldNormal, h), 0.0);
	float NoV = max(dot(worldNormal, viewDir), 0.0);
	float NoL = max(dot(worldNormal, -lightDirNorm), 0.0);
	float NoH2 = NoH * NoH;
	float denom = NoH2 * (alpha - 1.0) + 1.0;
	float D = alpha / (PI * denom * denom);
	float alpha2 = alpha * alpha;
	float lambdaV = NoL * sqrt(NoV * NoV * (1.0 - alpha2) + alpha2);
	float lambdaL = NoV * sqrt(NoL * NoL * (1.0 - alpha2) + alpha2);
	float G = 0.5 / max(lambdaV + lambdaL, 0.00001);
	return D * G;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm);
}
`,rW=`
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {
	float nh = max( dot( h, worldNormal ), 0.0 );
	float specPow = exp2(gloss * 11.0);
	specPow = max(specPow, 0.0001);
	return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}
float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
	return calcLightSpecular(gloss, worldNormal, h);
}
`,aW=`
float sheenD(vec3 normal, vec3 h, float roughness) {
	const float PI = 3.141592653589793;
	float invR = 1.0 / (roughness * roughness);
	float cos2h = max(dot(normal, h), 0.0);
	cos2h *= cos2h;
	float sin2h = max(1.0 - cos2h, 0.0078125);
	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}
float sheenV(vec3 normal, vec3 viewDir, vec3 light) {
	float NoV = max(dot(normal, viewDir), 0.000001);
	float NoL = max(dot(normal, light), 0.000001);
	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}
float getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {
	float D = sheenD(worldNormal, h, sheenGloss);
	float V = sheenV(worldNormal, viewDir, -lightDirNorm);
	return D * V;
}
`,nW=`
#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH
float linearizeDepthWithParams(float z, vec4 cameraParams) {
	if (cameraParams.w == 0.0)
		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
	else
		return cameraParams.z + z * (cameraParams.y - cameraParams.z);
}
#ifndef CAMERAPLANES
	#define CAMERAPLANES
	uniform vec4 camera_params;
#endif
float linearizeDepth(float z) {
	return linearizeDepthWithParams(z, camera_params);
}
#endif
`,oW=`
void evaluateBackend() {
	#ifdef LIT_SSAO
		litArgs_ao *= texture2DLod(ssaoTexture, gl_FragCoord.xy * ssaoTextureSizeInv, 0.0).r;
	#endif
	#ifdef LIT_NEEDS_NORMAL
		#ifdef LIT_SPECULAR
			getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);
		#endif
		#ifdef LIT_CLEARCOAT
			ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));
		#endif
	#endif
	#ifdef LIT_SPECULAR_OR_REFLECTION
		#ifdef LIT_METALNESS
			float f0 = 1.0 / litArgs_ior;
			f0 = (f0 - 1.0) / (f0 + 1.0);
			f0 *= f0;
			#ifdef LIT_SPECULARITY_FACTOR
				litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0, litArgs_specularityFactor);
			#else
				litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0, 1.0);
			#endif
			litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);
		#endif
		#ifdef LIT_IRIDESCENCE
			vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);
		#endif
	#endif
	#ifdef LIT_ADD_AMBIENT
		addAmbient(litArgs_worldNormal);
		#ifdef LIT_SPECULAR
			dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);
		#endif
		#ifdef LIT_SEPARATE_AMBIENT
			vec3 dAmbientLight = dDiffuseLight;
			dDiffuseLight = vec3(0);
		#endif
	#endif
	#ifndef LIT_OLD_AMBIENT
		dDiffuseLight *= material_ambient;
	#endif
	#ifdef LIT_AO
		#ifndef LIT_OCCLUDE_DIRECT
			occludeDiffuse(litArgs_ao);
		#endif
	#endif
	#ifdef LIT_LIGHTMAP
		addLightMap(
			litArgs_lightmap, 
			litArgs_lightmapDir, 
			litArgs_worldNormal, 
			dViewDirW, 
			dReflDirW, 
			litArgs_gloss, 
			litArgs_specularity, 
			dVertexNormalW,
			dTBN
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			litArgs_iridescence_intensity
		#endif
		);
	#endif
	#ifdef LIT_LIGHTING || LIT_REFLECTIONS
		#ifdef LIT_REFLECTIONS
			#ifdef LIT_CLEARCOAT
				addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);
			
				#ifdef LIT_SPECULAR_FRESNEL
					ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));
					ccReflection *= ccFresnel;
				#else
					ccFresnel = 0.0;
				#endif
			#endif
			#ifdef LIT_SPECULARITY_FACTOR
				ccReflection *= litArgs_specularityFactor;
			#endif
			#ifdef LIT_SHEEN
				addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);
			#endif
			addReflection(dReflDirW, litArgs_gloss);
			#ifdef LIT_FRESNEL_MODEL
				dReflection.rgb *= getFresnel(
					dot(dViewDirW, litArgs_worldNormal), 
					litArgs_gloss, 
					litArgs_specularity
				#if defined(LIT_IRIDESCENCE)
					, iridescenceFresnel,
					litArgs_iridescence_intensity
				#endif
					);
			#else
				dReflection.rgb *= litArgs_specularity;
			#endif
		#endif
		#ifdef AREA_LIGHTS
			dSpecularLight *= litArgs_specularity;
			#ifdef LIT_SPECULAR
				calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);
			#endif
		#endif
		
		#ifdef LIGHT_COUNT > 0
			#include "lightEvaluationPS, LIGHT_COUNT"
		#endif
		#ifdef LIT_CLUSTERED_LIGHTS
			addClusteredLights(litArgs_worldNormal, dViewDirW, dReflDirW,
				#if defined(LIT_CLEARCOAT)
						ccReflDirW,
				#endif
						litArgs_gloss, litArgs_specularity, dVertexNormalW, dTBN, 
				#if defined(LIT_IRIDESCENCE)
						iridescenceFresnel,
				#endif
						litArgs_clearcoat_worldNormal, litArgs_clearcoat_gloss, litArgs_sheen_gloss, litArgs_iridescence_intensity
			);
		#endif
		#ifdef AREA_LIGHTS
			#ifdef LIT_CLEARCOAT
				litArgs_clearcoat_specularity = 1.0;
			#endif
			#ifdef LIT_SPECULAR
				litArgs_specularity = vec3(1);
			#endif
		#endif
		#ifdef LIT_REFRACTION
			addRefraction(
				litArgs_worldNormal, 
				dViewDirW, 
				litArgs_thickness, 
				litArgs_gloss, 
				litArgs_specularity, 
				litArgs_albedo, 
				litArgs_transmission,
				litArgs_ior,
				litArgs_dispersion
				#if defined(LIT_IRIDESCENCE)
					, iridescenceFresnel, 
					litArgs_iridescence_intensity
				#endif
			);
		#endif
	#endif
	#ifdef LIT_AO
		#ifdef LIT_OCCLUDE_DIRECT
			occludeDiffuse(litArgs_ao);
		#endif
		#if LIT_OCCLUDE_SPECULAR != NONE
			occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);
		#endif
	#endif
	#if !defined(LIT_OPACITY_FADES_SPECULAR)
		#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED
			float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));
			#ifdef LIT_CLEARCOAT
				specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));
			#endif
			litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);
		#endif
		litArgs_opacity *= material_alphaFade;
	#endif
	#ifdef LIT_LIGHTMAP_BAKING
		#ifdef LIT_LIGHTMAP_BAKING_COLOR
			#include "bakeLmEndPS"
		#endif
		#ifdef LIT_LIGHTMAP_BAKING_DIR
			#include "bakeDirLmEndPS"
		#endif
	#else
		#include "endPS"
		#include "outputAlphaPS"
	#endif
	#ifdef LIT_MSDF
		gl_FragColor = applyMsdf(gl_FragColor);
	#endif
	#include "outputPS"
	#include "debugOutputPS"
	#ifdef LIT_SHADOW_CATCHER
		gl_FragColor.rgb = vec3(dShadowCatcher);
	#endif
}
`,lW=`
vec3 sReflection;
vec3 dVertexNormalW;
vec3 dTangentW;
vec3 dBinormalW;
vec3 dViewDirW;
vec3 dReflDirW;
vec3 ccReflDirW;
vec3 dLightDirNormW;
float dAtten;
mat3 dTBN;
vec4 dReflection;
vec3 dDiffuseLight;
vec3 dSpecularLight;
float ccFresnel;
vec3 ccReflection;
vec3 ccSpecularLight;
float ccSpecularityNoFres;
vec3 sSpecularLight;
#ifdef LIT_DISPERSION
	uniform float material_dispersion;
#endif
#ifndef LIT_OPACITY_FADES_SPECULAR
	uniform float material_alphaFade;
#endif
#ifdef LIT_SSAO
	uniform sampler2D ssaoTexture;
	uniform vec2 ssaoTextureSizeInv;
#endif
#ifdef LIT_SHADOW_CATCHER
	float dShadowCatcher = 1.0;
#endif
#if LIGHT_COUNT > 0
	#include "lightDeclarationPS, LIGHT_COUNT"
#endif
#ifdef LIT_SPECULAR
	#if LIT_FRESNEL_MODEL == NONE && !defined(LIT_REFLECTIONS) && !defined(LIT_DIFFUSE_MAP) 
		#define LIT_OLD_AMBIENT
	#endif
#endif
#ifdef STD_LIGHTMAP_DIR
	uniform float bakeDir;
#endif
#ifdef LIT_LIGHTMAP_BAKING_ADD_AMBIENT
	uniform float ambientBakeOcclusionContrast;
	uniform float ambientBakeOcclusionBrightness;
#endif
`,cW=`
void main(void) {
	#include "litUserMainStartPS"
	dReflection = vec4(0);
	#ifdef LIT_CLEARCOAT
		ccSpecularLight = vec3(0);
		ccReflection = vec3(0);
	#endif
	#if LIT_NONE_SLICE_MODE == SLICED
		#include "startNineSlicedPS"
	#elif LIT_NONE_SLICE_MODE == TILED
		#include "startNineSlicedTiledPS"
	#endif
	#ifdef LIT_NEEDS_NORMAL
		dVertexNormalW = normalize(vNormalW);
		#ifdef LIT_TANGENTS
			#if defined(LIT_HEIGHTS) || defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS) || defined(LIT_GGX_SPECULAR)
				dTangentW = vTangentW;
				dBinormalW = vBinormalW;
			#endif
		#endif
		getViewDir();
		#ifdef LIT_TBN
			getTBN(dTangentW, dBinormalW, dVertexNormalW);
			#ifdef LIT_TWO_SIDED_LIGHTING
				handleTwoSidedLighting();
			#endif
		#endif
	#endif
	evaluateFrontend();
	#include "debugProcessFrontendPS"
	evaluateBackend();
	#include "litUserMainEndPS"
}
`,hW=`
#ifdef LIT_NEEDS_NORMAL
	#include "cubeMapRotatePS"
	#include "cubeMapProjectPS"
	#include "envProcPS"
#endif
#ifdef LIT_SPECULAR_OR_REFLECTION
	#ifdef LIT_METALNESS
		#include "metalnessModulatePS"
	#endif
	#if LIT_FRESNEL_MODEL == SCHLICK
		#include "fresnelSchlickPS"
	#endif
	#ifdef LIT_IRIDESCENCE
		#include "iridescenceDiffractionPS"
	#endif
#endif
#ifdef LIT_AO
	#include "aoDiffuseOccPS"
	#include "aoSpecOccPS"
#endif
#if LIT_REFLECTION_SOURCE == ENVATLASHQ
	#include "envAtlasPS"
	#include "reflectionEnvHQPS"
#elif LIT_REFLECTION_SOURCE == ENVATLAS
	#include "envAtlasPS"
	#include "reflectionEnvPS"
#elif LIT_REFLECTION_SOURCE == CUBEMAP
	#include "reflectionCubePS"
#elif LIT_REFLECTION_SOURCE == SPHEREMAP
	#include "reflectionSpherePS"
#endif
#ifdef LIT_REFLECTIONS
	#ifdef LIT_CLEARCOAT
		#include "reflectionCCPS"
	#endif
	#ifdef LIT_SHEEN
		#include "reflectionSheenPS"
	#endif
#endif
#ifdef LIT_REFRACTION
	#if defined(LIT_DYNAMIC_REFRACTION)
		#include "refractionDynamicPS"
	#elif defined(LIT_REFLECTIONS)
		#include "refractionCubePS"
	#endif
#endif
#ifdef LIT_SHEEN
	#include "lightSheenPS"
#endif
uniform vec3 material_ambient;
#ifdef LIT_SPECULAR
	#ifdef LIT_LIGHTING
		#ifdef LIT_GGX_SPECULAR
			#ifdef LIT_ANISOTROPY
				#include "lightSpecularAnisoGGXPS"
			#else
				#include "lightSpecularGGXPS"
			#endif
		#else
			#include "lightSpecularBlinnPS"
		#endif
	#endif
#endif
#include "combinePS"
#ifdef LIT_LIGHTMAP
	#include "lightmapAddPS"
#endif
#ifdef LIT_ADD_AMBIENT
	#include "ambientPS"
#endif
#ifdef LIT_MSDF
	#include "msdfPS"
#endif
#ifdef LIT_NEEDS_NORMAL
	#include "viewDirPS"
	#ifdef LIT_SPECULAR
		#ifdef LIT_ANISOTROPY
			#include "reflDirAnisoPS"
		#else
			#include "reflDirPS"
		#endif
	#endif
#endif
#include "lightingPS"
`,uW=`
#include "basePS"
#include "sphericalPS"
#include "decodePS"
#include "gammaPS"
#include "tonemappingPS"
#include "fogPS"
#if LIT_NONE_SLICE_MODE == SLICED
	#include "baseNineSlicedPS"
#elif LIT_NONE_SLICE_MODE == TILED
	#include "baseNineSlicedTiledPS"
#endif
#ifdef LIT_TBN
	#include "TBNPS"
	#ifdef LIT_TWO_SIDED_LIGHTING
		#include "twoSidedLightingPS"
	#endif
#endif
`,dW=`
#include "varyingsPS"
#include "litUserDeclarationPS"
#include "frontendDeclPS"
#if defined(PICK_PASS) || defined(PREPASS_PASS)
	#include "frontendCodePS"
	#include "litUserCodePS"
	#include "litOtherMainPS"
#elif defined(SHADOW_PASS)
	#include "frontendCodePS"
	#include "litUserCodePS"
	#include "litShadowMainPS"
#else
	#include "litForwardDeclarationPS"
	#include "litForwardPreCodePS"
	#include "frontendCodePS"
	#include "litForwardPostCodePS"
	#include "litForwardBackendPS"
	#include "litUserCodePS"
	#include "litForwardMainPS"
#endif
`,fW=`
#include "varyingsVS"
#include  "litUserDeclarationVS"
#ifdef VERTEX_COLOR
	attribute vec4 vertex_color;
#endif
#ifdef NINESLICED
	varying vec2 vMask;
	varying vec2 vTiledUv;
	uniform mediump vec4 innerOffset;
	uniform mediump vec2 outerScale;
	uniform mediump vec4 atlasRect;
#endif
vec3 dPositionW;
mat4 dModelMatrix;
#include "transformCoreVS"
#ifdef UV0
	attribute vec2 vertex_texCoord0;
	#include "uv0VS"
#endif
#ifdef UV1
	attribute vec2 vertex_texCoord1;
	#include "uv1VS"
#endif
#ifdef LINEAR_DEPTH
	#ifndef VIEWMATRIX
	#define VIEWMATRIX
		uniform mat4 matrix_view;
	#endif
#endif
#include "transformVS"
#ifdef NORMALS
	#include "normalCoreVS"
	#include "normalVS"
#endif
#ifdef TANGENTS
	attribute vec4 vertex_tangent;
#endif
#include "uvTransformUniformsPS, UV_TRANSFORMS_COUNT"
#ifdef MSDF
	#include "msdfVS"
#endif
#include  "litUserCodeVS"
#ifdef VERTEX_COLOR
	vec3 decodeGamma(vec3 raw) {
		return pow(raw, vec3(2.2));
	}
	vec4 gammaCorrectInput(vec4 color) {
		return vec4(decodeGamma(color.xyz), color.w);
	}
#endif
void main(void) {
	#include "litUserMainStartVS"
	gl_PointSize = 1.0;
	gl_Position = getPosition();
	vPositionW = getWorldPosition();
	#ifdef NORMALS
		vNormalW = getNormal();
	#endif
	#ifdef TANGENTS
		vTangentW = normalize(dNormalMatrix * vertex_tangent.xyz);
		vBinormalW = cross(vNormalW, vTangentW) * vertex_tangent.w;
	#elif defined(GGX_SPECULAR)
		vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));
	#endif
	#ifdef UV0
		vec2 uv0 = getUv0();
		#ifdef UV0_UNMODIFIED
			vUv0 = uv0;
		#endif
	#endif
	#ifdef UV1
		vec2 uv1 = getUv1();
		#ifdef UV1_UNMODIFIED
			vUv1 = uv1;
		#endif
	#endif
	#include "uvTransformVS, UV_TRANSFORMS_COUNT"
	#ifdef VERTEX_COLOR
		#ifdef STD_VERTEX_COLOR_GAMMA
			vVertexColor = gammaCorrectInput(vertex_color);
		#else
			vVertexColor = vertex_color;
		#endif
	#endif
	#ifdef LINEAR_DEPTH
		vLinearDepth = -(matrix_view * vec4(vPositionW, 1.0)).z;
	#endif
	#ifdef MSDF
		unpackMsdfParams();
	#endif
	#include "litUserMainEndVS"
}
`,mW=`
#ifdef PICK_PASS
	#include "pickPS"
#endif
#ifdef PREPASS_PASS
	#include "floatAsUintPS"
#endif
void main(void) {
	#include "litUserMainStartPS"
	evaluateFrontend();
	#ifdef PICK_PASS
		pcFragColor0 = getPickOutput();
		#ifdef DEPTH_PICK_PASS
			pcFragColor1 = getPickDepth();
		#endif
	#endif
	#ifdef PREPASS_PASS
		gl_FragColor = float2vec4(vLinearDepth);
	#endif
	#include "litUserMainEndPS"
}
`,pW=`
vec3 litArgs_albedo;
float litArgs_opacity;
vec3 litArgs_emission;
vec3 litArgs_worldNormal;
float litArgs_ao;
vec3 litArgs_lightmap;
vec3 litArgs_lightmapDir;
float litArgs_metalness;
vec3 litArgs_specularity;
float litArgs_specularityFactor;
float litArgs_gloss;
float litArgs_sheen_gloss;
vec3 litArgs_sheen_specularity;
float litArgs_transmission;
float litArgs_thickness;
float litArgs_ior;
float litArgs_dispersion;
float litArgs_iridescence_intensity;
float litArgs_iridescence_thickness;
vec3 litArgs_clearcoat_worldNormal;
float litArgs_clearcoat_specularity;
float litArgs_clearcoat_gloss;
`,_W=`
	#if LIT_NONE_SLICE_MODE == TILED
		const float textureBias = -1000.0;
	#else
		uniform float textureBias;
	#endif
	#include "litShaderArgsPS"
`,gW=`
#if LIGHT_TYPE != DIRECTIONAL
	uniform vec3 view_position;
	uniform float light_radius;
#endif
#if SHADOW_TYPE == PCSS_32F
	#include "linearizeDepthPS"
#endif
void main(void) {
	#include "litUserMainStartPS"
	evaluateFrontend();
	#ifdef PERSPECTIVE_DEPTH
		float depth = gl_FragCoord.z;
		#if SHADOW_TYPE == PCSS_32F
			#if LIGHT_TYPE != DIRECTIONAL
				depth = linearizeDepthWithParams(depth, camera_params);
			#endif
		#endif
	#else
		float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);
		#define MODIFIED_DEPTH
	#endif
	#if SHADOW_TYPE == VSM_16F || SHADOW_TYPE == VSM_32F
		#if SHADOW_TYPE == VSM_32F
			float exponent = 15.0;
		#else
			float exponent = 5.54;
		#endif
		depth = 2.0 * depth - 1.0;
		depth =  exp(exponent * depth);
		gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
	#else
		#if SHADOW_TYPE == PCSS_32F
			gl_FragColor.r = depth;
		#else
			#ifdef MODIFIED_DEPTH
				gl_FragDepth = depth;
			#endif
			gl_FragColor = vec4(1.0);
		#endif
	#endif
	#include "litUserMainEndPS"
}
`,vW=`
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
struct Coords {
	vec3 coord0;
	vec3 coord1;
	vec3 coord2;
	vec3 coord3;
};
float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
	vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
	vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
	
	vec3 lightNormal = cross( v1, v2 );
	float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 =  factor * cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords.coord0 - P );
	coords[ 1 ] = mat * ( rectCoords.coord1 - P );
	coords[ 2 ] = mat * ( rectCoords.coord2 - P );
	coords[ 3 ] = mat * ( rectCoords.coord3 - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return result;
}
Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	Coords coords;
	coords.coord0 = lightPos + halfWidth - halfHeight;
	coords.coord1 = lightPos - halfWidth - halfHeight;
	coords.coord2 = lightPos - halfWidth + halfHeight;
	coords.coord3 = lightPos + halfWidth + halfHeight;
	return coords;
}
float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
	dSphereRadius = max(length(halfWidth), length(halfHeight));
	vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
	vec3 w = normalize(cross(f, halfHeight));
	vec3 h = normalize(cross(f, w));
	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
	vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)
{
	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	return LTC_Uv( worldNormal, viewDir, roughness );
}
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
	vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)
{
	vec4 t2 = texture2DLod(areaLightsLutTex2, uv, 0.0);
	return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;
}
void calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)
{
	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); 
#ifdef LIT_CLEARCOAT
	ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
	ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));
#endif
}
void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight) {
	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight) {
	calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight) {
	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}
vec3 SolveCubic(vec4 Coefficient)
{
	float pi = 3.14159;
	Coefficient.xyz /= Coefficient.w;
	Coefficient.yz /= 3.0;
	float A = Coefficient.w;
	float B = Coefficient.z;
	float C = Coefficient.y;
	float D = Coefficient.x;
	vec3 Delta = vec3(
		-Coefficient.z * Coefficient.z + Coefficient.y,
		-Coefficient.y * Coefficient.z + Coefficient.x,
		dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
	);
	float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);
	vec2 xlc, xsc;
	{
		float A_a = 1.0;
		float C_a = Delta.x;
		float D_a = -2.0 * B * Delta.x + Delta.y;
		float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;
		float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
		float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);
		float xl;
		if ((x_1a + x_3a) > 2.0 * B)
			xl = x_1a;
		else
			xl = x_3a;
		xlc = vec2(xl - B, A);
	}
	{
		float A_d = D;
		float C_d = Delta.z;
		float D_d = -D * Delta.y + 2.0 * C * Delta.z;
		float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;
		float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
		float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);
		float xs;
		if (x_1d + x_3d < 2.0 * C)
			xs = x_1d;
		else
			xs = x_3d;
		xsc = vec2(-D, xs + C);
	}
	float E =  xlc.y * xsc.y;
	float F = -xlc.x * xsc.y - xlc.y * xsc.x;
	float G =  xlc.x * xsc.x;
	vec2 xmc = vec2(C * F - B * G, -B * F + C * E);
	vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);
	if (Root.x < Root.y && Root.x < Root.z)
		Root.xyz = Root.yxz;
	else if (Root.z < Root.x && Root.z < Root.y)
		Root.xyz = Root.xzy;
	return Root;
}
float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
	vec3 T1 = normalize(V - N * dot(V, N));
	vec3 T2 = cross(N, T1);
	mat3 R = transposeMat3( mat3( T1, T2, N ) );
	vec3 L_[ 3 ];
	L_[ 0 ] = R * ( points.coord0 - P );
	L_[ 1 ] = R * ( points.coord1 - P );
	L_[ 2 ] = R * ( points.coord2 - P );
	vec3 C  = 0.5 * (L_[0] + L_[2]);
	vec3 V1 = 0.5 * (L_[1] - L_[2]);
	vec3 V2 = 0.5 * (L_[1] - L_[0]);
	C  = Minv * C;
	V1 = Minv * V1;
	V2 = Minv * V2;
	float a, b;
	float d11 = dot(V1, V1);
	float d22 = dot(V2, V2);
	float d12 = dot(V1, V2);
	if (abs(d12) / sqrt(d11 * d22) > 0.0001)
	{
		float tr = d11 + d22;
		float det = -d12 * d12 + d11 * d22;
		det = sqrt(det);
		float u = 0.5 * sqrt(tr - 2.0 * det);
		float v = 0.5 * sqrt(tr + 2.0 * det);
		float e_max = (u + v) * (u + v);
		float e_min = (u - v) * (u - v);
		vec3 V1_, V2_;
		if (d11 > d22)
		{
			V1_ = d12 * V1 + (e_max - d11) * V2;
			V2_ = d12 * V1 + (e_min - d11) * V2;
		}
		else
		{
			V1_ = d12*V2 + (e_max - d22)*V1;
			V2_ = d12*V2 + (e_min - d22)*V1;
		}
		a = 1.0 / e_max;
		b = 1.0 / e_min;
		V1 = normalize(V1_);
		V2 = normalize(V2_);
	}
	else
	{
		a = 1.0 / dot(V1, V1);
		b = 1.0 / dot(V2, V2);
		V1 *= sqrt(a);
		V2 *= sqrt(b);
	}
	vec3 V3 = normalize(cross(V1, V2));
	if (dot(C, V3) < 0.0)
		V3 *= -1.0;
	float L  = dot(V3, C);
	float x0 = dot(V1, C) / L;
	float y0 = dot(V2, C) / L;
	float E1 = inversesqrt(a);
	float E2 = inversesqrt(b);
	a *= L * L;
	b *= L * L;
	float c0 = a * b;
	float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
	float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
	float c3 = 1.0;
	vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
	float e1 = roots.x;
	float e2 = roots.y;
	float e3 = roots.z;
	vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);
	mat3 rotate = mat3(V1, V2, V3);
	avgDir = rotate * avgDir;
	avgDir = normalize(avgDir);
	float L1 = sqrt(-e2 / e3);
	float L2 = sqrt(-e2 / e1);
	float formFactor = max(0.0, L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));
	
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
	uv = uv*LUT_SCALE + LUT_BIAS;
	float scale = texture2DLod(areaLightsLutTex2, uv, 0.0).w;
	return formFactor*scale;
}
float FixNan(float value) {
	#ifdef WEBGPU
		return value != value ? 0.0 : value;
	#else
		return isnan(value) ? 0.0 : value;
	#endif
}
float getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}
float getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	return FixNan(LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords ));
}
float getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
	float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
	return FixNan(getLightDiffuse(worldNormal, viewDir, lightDirNorm) * falloff);
}
mat3 getLTCLightInvMat(vec2 uv)
{
	vec4 t1 = texture2DLod(areaLightsLutTex1, uv, 0.0);
	return mat3(
		vec3( t1.x, 0, t1.y ),
		vec3(	0, 1,	0 ),
		vec3( t1.z, 0, t1.w )
	);
}
float calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}
float calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
	mat3 mInv = getLTCLightInvMat(uv);
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
float getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
float getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`,SW=`
#ifdef STD_METALNESS_CONSTANT
uniform float material_metalness;
#endif
void getMetalness() {
	float metalness = 1.0;
	#ifdef STD_METALNESS_CONSTANT
	metalness *= material_metalness;
	#endif
	#ifdef STD_METALNESS_TEXTURE
	metalness *= texture2DBias({STD_METALNESS_TEXTURE_NAME}, {STD_METALNESS_TEXTURE_UV}, textureBias).{STD_METALNESS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_METALNESS_VERTEX
	metalness *= saturate(vVertexColor.{STD_METALNESS_VERTEX_CHANNEL});
	#endif
	dMetalness = metalness;
}
`,yW=`
uniform sampler2D texture_msdfMap;
float median(float r, float g, float b) {
	return max(min(r, g), min(max(r, g), b));
}
float map (float min, float max, float v) {
	return (v - min) / (max - min);
}
uniform float font_sdfIntensity;
uniform float font_pxrange;
uniform float font_textureWidth;
#ifndef LIT_MSDF_TEXT_ATTRIBUTE
	uniform vec4 outline_color;
	uniform float outline_thickness;
	uniform vec4 shadow_color;
	uniform vec2 shadow_offset;
#else
	varying vec4 outline_color;
	varying float outline_thickness;
	varying vec4 shadow_color;
	varying vec2 shadow_offset;
#endif
vec4 applyMsdf(vec4 color) {
	color.rgb = gammaCorrectInput(color.rgb);
	vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
	vec2 uvShdw = vUv0 - shadow_offset;
	vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
	float sigDist = median(tsample.r, tsample.g, tsample.b);
	float sigDistShdw = median(ssample.r, ssample.g, ssample.b);
	float smoothingMax = 0.2;
	vec2 w = fwidth(vUv0);
	float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
	float mapMin = 0.05;
	float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);
	float sigDistInner = map(mapMin, mapMax, sigDist);
	float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);
	float center = 0.5;
	float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
	float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
	float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);
	vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
	tcolor = mix(tcolor, color, inside);
	vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
	tcolor = mix(scolor, tcolor, outline);
	tcolor.rgb = gammaCorrectOutput(tcolor.rgb);
	
	return tcolor;
}
`,xW=`
vec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0, in float specularityFactor) {
	vec3 dielectricF0 = f0 * specularity * specularityFactor;
	return mix(dielectricF0, albedo, metalness);
}
vec3 getAlbedoModulate(in vec3 albedo, in float metalness) {
	return albedo * (1.0 - metalness);
}
`,TW=`
	varying vec2 uv0;
	uniform sampler2DArray morphTexture;
	uniform highp float morphFactor[{MORPH_TEXTURE_MAX_COUNT}];
	uniform highp uint morphIndex[{MORPH_TEXTURE_MAX_COUNT}];
	uniform int count;
	#ifdef MORPH_INT
		uniform vec3 aabbSize;
		uniform vec3 aabbMin;
	#endif
	void main (void) {
		highp vec3 color = vec3(0, 0, 0);
		ivec2 pixelCoords = ivec2(uv0 * vec2(textureSize(morphTexture, 0).xy));
		
		for (int i = 0; i < count; i++) {
			uint textureIndex = morphIndex[i];
			vec3 delta = texelFetch(morphTexture, ivec3(pixelCoords, int(textureIndex)), 0).xyz;
			color += morphFactor[i] * delta;
		}
		#ifdef MORPH_INT
			color = (color - aabbMin) / aabbSize * 65535.0;
			gl_FragColor = uvec4(color, 1u);
		#else
			gl_FragColor = vec4(color, 1.0);
		#endif
	}
`,EW=`
	attribute vec2 vertex_position;
	varying vec2 uv0;
	void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		uv0 = vertex_position.xy * 0.5 + 0.5;
	}
`,bW=`
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
void unpackMsdfParams() {
	vec3 little = mod(vertex_outlineParameters, 256.);
	vec3 big = (vertex_outlineParameters - little) / 256.;
	outline_color.rb = little.xy / 255.;
	outline_color.ga = big.xy / 255.;
	outline_thickness = little.z / 255. * 0.2;
	little = mod(vertex_shadowParameters, 256.);
	big = (vertex_shadowParameters - little) / 256.;
	shadow_color.rb = little.xy / 255.;
	shadow_color.ga = big.xy / 255.;
	shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`,AW=`
mat3 dNormalMatrix;
vec3 getNormal() {
	dNormalMatrix = getNormalMatrix(dModelMatrix);
	vec3 localNormal = getLocalNormal(vertex_normal);
	return normalize(dNormalMatrix * localNormal);
}
`,wW=`
attribute vec3 vertex_normal;
uniform mat3 matrix_normal;
#ifdef MORPHING_NORMAL
	#ifdef MORPHING_INT
		uniform highp usampler2D morphNormalTex;
	#else
		uniform highp sampler2D morphNormalTex;
	#endif
#endif
vec3 getLocalNormal(vec3 vertexNormal) {
	vec3 localNormal = vertex_normal;
	#ifdef MORPHING_NORMAL
		ivec2 morphUV = getTextureMorphCoords();
		#ifdef MORPHING_INT
			vec3 morphNormal = vec3(texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz) / 65535.0 * 2.0 - 1.0;
		#else
			vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;
		#endif
		localNormal += morphNormal;
	#endif
	return localNormal;
}
#if defined(SKIN) || defined(BATCH)
	mat3 getNormalMatrix(mat4 modelMatrix) {
		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);
	}
#elif defined(INSTANCING)
	mat3 getNormalMatrix(mat4 modelMatrix) {
		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);
	}
#else
	mat3 getNormalMatrix(mat4 modelMatrix) {
		return matrix_normal;
	}
#endif
`,CW=`
#ifdef STD_NORMAL_TEXTURE
	uniform float material_bumpiness;
#endif
#ifdef STD_NORMALDETAIL_TEXTURE
	uniform float material_normalDetailMapBumpiness;
	vec3 blendNormals(vec3 n1, vec3 n2) {
		n1 += vec3(0, 0, 1);
		n2 *= vec3(-1, -1, 1);
		return n1 * dot(n1, n2) / n1.z - n2;
	}
#endif
void getNormal() {
#ifdef STD_NORMAL_TEXTURE
	vec3 normalMap = {STD_NORMAL_TEXTURE_DECODE}(texture2DBias({STD_NORMAL_TEXTURE_NAME}, {STD_NORMAL_TEXTURE_UV}, textureBias));
	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
	#ifdef STD_NORMALDETAIL_TEXTURE
		vec3 normalDetailMap = {STD_NORMALDETAIL_TEXTURE_DECODE}(texture2DBias({STD_NORMALDETAIL_TEXTURE_NAME}, {STD_NORMALDETAIL_TEXTURE_UV}, textureBias));
		normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
		normalMap = blendNormals(normalMap, normalDetailMap);
	#endif
	dNormalW = normalize(dTBN * normalMap);
#else
	dNormalW = dVertexNormalW;
#endif
}
`,DW=`
uniform float material_opacity;
void getOpacity() {
	dAlpha = material_opacity;
	#ifdef STD_OPACITY_TEXTURE
	dAlpha *= texture2DBias({STD_OPACITY_TEXTURE_NAME}, {STD_OPACITY_TEXTURE_UV}, textureBias).{STD_OPACITY_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_OPACITY_VERTEX
	dAlpha *= clamp(vVertexColor.{STD_OPACITY_VERTEX_CHANNEL}, 0.0, 1.0);
	#endif
}
`,PW=`
#if STD_OPACITY_DITHER == BAYER8
	#include "bayerPS"
#endif
uniform vec4 blueNoiseJitter;
#if STD_OPACITY_DITHER == BLUENOISE
	uniform sampler2D blueNoiseTex32;
#endif
void opacityDither(float alpha, float id) {
	#if STD_OPACITY_DITHER == BAYER8
		float noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;
	#else
		#if STD_OPACITY_DITHER == BLUENOISE
			vec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);
			float noise = texture2DLod(blueNoiseTex32, uv, 0.0).y;
		#endif
		#if STD_OPACITY_DITHER == IGNNOISE
			vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
			float noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));
		#endif
	#endif
	noise = pow(noise, 2.2);
	if (alpha < noise)
		discard;
}
`,RW=`
`,MW=`
#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == ADDITIVEALPHA || defined(LIT_ALPHA_TO_COVERAGE)
	gl_FragColor.a = litArgs_opacity;
#elif LIT_BLEND_TYPE == PREMULTIPLIED
	gl_FragColor.rgb *= litArgs_opacity;
	gl_FragColor.a = litArgs_opacity;
#else
	gl_FragColor.a = 1.0;
#endif
`,LW=`
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
	gl_FragColor = texture2D(source, vUv0);
}
`,IW=`
uniform vec3 material_sheen;
void getSheen() {
	vec3 sheenColor = material_sheen;
	#ifdef STD_SHEEN_TEXTURE
	sheenColor *= {STD_SHEEN_TEXTURE_DECODE}(texture2DBias({STD_SHEEN_TEXTURE_NAME}, {STD_SHEEN_TEXTURE_UV}, textureBias)).{STD_SHEEN_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SHEEN_VERTEX
	sheenColor *= saturate(vVertexColor.{STD_SHEEN_VERTEX_CHANNEL});
	#endif
	sSpecularity = sheenColor;
}
`,OW=`
uniform float material_sheenGloss;
void getSheenGlossiness() {
	float sheenGlossiness = material_sheenGloss;
	#ifdef STD_SHEENGLOSS_TEXTURE
	sheenGlossiness *= texture2DBias({STD_SHEENGLOSS_TEXTURE_NAME}, {STD_SHEENGLOSS_TEXTURE_UV}, textureBias).{STD_SHEENGLOSS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SHEENGLOSS_VERTEX
	sheenGlossiness *= saturate(vVertexColor.{STD_SHEENGLOSS_VERTEX_CHANNEL});
	#endif
	#ifdef STD_SHEENGLOSS_INVERT
	sheenGlossiness = 1.0 - sheenGlossiness;
	#endif
	sGlossiness = sheenGlossiness + 0.0000001;
}
`,NW=`
uniform float material_heightMapFactor;
void getParallax() {
	float parallaxScale = material_heightMapFactor;
	float height = texture2DBias({STD_HEIGHT_TEXTURE_NAME}, {STD_HEIGHT_TEXTURE_UV}, textureBias).{STD_HEIGHT_TEXTURE_CHANNEL};
	height = height * parallaxScale - parallaxScale * 0.5;
	vec3 viewDirT = dViewDirW * dTBN;
	viewDirT.z += 0.42;
	dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`,FW=`
uniform uint meshInstanceId;
vec4 getPickOutput() {
	const vec4 inv = vec4(1.0 / 255.0);
	const uvec4 shifts = uvec4(16, 8, 0, 24);
	uvec4 col = (uvec4(meshInstanceId) >> shifts) & uvec4(0xff);
	return vec4(col) * inv;
}
#ifdef DEPTH_PICK_PASS
	#include "floatAsUintPS"
	vec4 getPickDepth() {
		return float2uint(gl_FragCoord.z);
	}
#endif
`,BW=`
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`,UW=`
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
	float roughness = sqrt(1.0 - min(gloss, 1.0));
	vec2 direction = dAnisotropyRotation;
	vec3 anisotropicT = normalize(tbn * vec3(direction, 0.0));
	vec3 anisotropicB = normalize(cross(tbn[2], anisotropicT));
	float anisotropy = dAnisotropy;
	vec3 anisotropicDirection = anisotropicB;
	vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);
	vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
	float bendFactor = 1.0 - anisotropy * (1.0 - roughness);
	float bendFactor4 = bendFactor * bendFactor * bendFactor * bendFactor;
	vec3 bentNormal = normalize(mix(normalize(anisotropicNormal), normalize(worldNormal), bendFactor4));
	dReflDirW = reflect(-viewDir, bentNormal);
}
`,zW=`
#ifdef LIT_CLEARCOAT
void addReflectionCC(vec3 reflDir, float gloss) {
	ccReflection += calcReflection(reflDir, gloss);
}
#endif
`,kW=`
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 lookupVec = cubeMapProject(reflDir);
	lookupVec.x *= -1.0;
	return {reflectionDecode}(textureCube(texture_cubeMap, lookupVec));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,VW=`
#ifndef ENV_ATLAS
	#define ENV_ATLAS
	uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float flevel = level - ilevel;
	vec3 sharp = {reflectionCubemapDecode}(textureCube(texture_cubeMap, dir));
	vec3 roughA = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
	vec3 roughB = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,GW=`
#ifndef ENV_ATLAS
#define ENV_ATLAS
	uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;
float shinyMipLevel(vec2 uv) {
	vec2 dx = dFdx(uv);
	vec2 dy = dFdy(uv);
	vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
	vec2 dx2 = dFdx(uv2);
	vec2 dy2 = dFdy(uv2);
	float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));
	return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
	vec2 uv = toSphericalUv(dir);
	float level = saturate(1.0 - gloss) * 5.0;
	float ilevel = floor(level);
	float level2 = shinyMipLevel(uv * atlasSize);
	float ilevel2 = floor(level2);
	vec2 uv0, uv1;
	float weight;
	if (ilevel == 0.0) {
		uv0 = mapShinyUv(uv, ilevel2);
		uv1 = mapShinyUv(uv, ilevel2 + 1.0);
		weight = level2 - ilevel2;
	} else {
		uv0 = uv1 = mapRoughnessUv(uv, ilevel);
		weight = 0.0;
	}
	vec3 linearA = {reflectionDecode}(texture2D(texture_envAtlas, uv0));
	vec3 linearB = {reflectionDecode}(texture2D(texture_envAtlas, uv1));
	vec3 linear0 = mix(linearA, linearB, weight);
	vec3 linear1 = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(linear0, linear1, level - ilevel));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,HW=`
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;
vec3 calcReflection(vec3 reflDir, float gloss) {
	vec3 reflDirV = (mat3(matrix_view) * reflDir);
	float m = 2.0 * sqrt(dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z + 1.0) * (reflDirV.z + 1.0));
	vec2 sphereMapUv = reflDirV.xy / m + 0.5;
	return {reflectionDecode}(texture2D(texture_sphereMap, sphereMapUv));
}
void addReflection(vec3 reflDir, float gloss) {   
	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,WW=`
void addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {
	float NoV = dot(worldNormal, viewDir);
	float alphaG = gloss * gloss;
	float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;
	float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;
	float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );
	sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);
}
`,XW=`
vec3 refract2(vec3 viewVec, vec3 normal, float IOR) {
	float vn = dot(viewVec, normal);
	float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
	vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
	return refrVec;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex,
	float dispersion
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif 
) {
	vec4 tmpRefl = dReflection;
	vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);
	dReflection = vec4(0);
	addReflection(reflectionDir, gloss);
	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
	dReflection = tmpRefl;
}
`,qW=`
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;
vec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {
	vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);
	vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;
	vec2 uv = getGrabScreenPos(projectionPoint);
	float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
	float refractionLod = log2(uScreenSize.x) * iorToRoughness;
	vec3 refraction = texture2DLod(uSceneColorMap, uv, refractionLod).rgb;
	#ifdef SCENE_COLORMAP_GAMMA
		refraction = decodeGamma(refraction);
	#endif
	return refraction;
}
void addRefraction(
	vec3 worldNormal, 
	vec3 viewDir, 
	float thickness, 
	float gloss, 
	vec3 specularity, 
	vec3 albedo, 
	float transmission,
	float refractionIndex,
	float dispersion
#if defined(LIT_IRIDESCENCE)
	, vec3 iridescenceFresnel,
	float iridescenceIntensity
#endif
) {
	vec3 modelScale;
	modelScale.x = length(vec3(matrix_model[0].xyz));
	modelScale.y = length(vec3(matrix_model[1].xyz));
	modelScale.z = length(vec3(matrix_model[2].xyz));
	vec3 scale = thickness * modelScale;
	vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;
	vec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);
	#ifdef LIT_DISPERSION
		float halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;
		float refractionIndexR = refractionIndex - halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;
		refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;
		float refractionIndexB = refractionIndex + halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;
		refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;
	#endif
	vec3 transmittance;
	if (material_invAttenuationDistance != 0.0)
	{
		vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
		transmittance = exp(-attenuation * length(refractionVector));
	}
	else
	{
		transmittance = vec3(1.0);
	}
	vec3 fresnel = vec3(1.0) - 
		getFresnel(
			dot(viewDir, worldNormal), 
			gloss, 
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
		);
	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`,YW=`
varying vec2 vUv0;
#ifdef CUBEMAP_SOURCE
	uniform samplerCube sourceCube;
#else
	uniform sampler2D sourceTex;
#endif
#ifdef USE_SAMPLES_TEX
	uniform sampler2D samplesTex;
	uniform vec2 samplesTexInverseSize;
#endif
uniform vec3 params;
float targetFace() { return params.x; }
float targetTotalPixels() { return params.y; }
float sourceTotalPixels() { return params.z; }
float PI = 3.141592653589793;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
#include "decodePS"
#include "encodePS"
vec3 modifySeams(vec3 dir, float scale) {
	vec3 adir = abs(dir);
	float M = max(max(adir.x, adir.y), adir.z);
	return dir / M * vec3(
		adir.x == M ? 1.0 : scale,
		adir.y == M ? 1.0 : scale,
		adir.z == M ? 1.0 : scale
	);
}
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec3 fromSpherical(vec2 uv) {
	return vec3(cos(uv.y) * sin(uv.x),
				sin(uv.y),
				cos(uv.y) * cos(uv.x));
}
vec3 getDirectionEquirect() {
	return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}
float signNotZero(float k){
	return(k >= 0.0) ? 1.0 : -1.0;
}
vec2 signNotZero(vec2 v) {
	return vec2(signNotZero(v.x), signNotZero(v.y));
}
vec3 octDecode(vec2 o) {
	vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
	if (v.y < 0.0) {
		v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
	}
	return normalize(v);
}
vec3 getDirectionOctahedral() {
	return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}
vec2 octEncode(in vec3 v) {
	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	vec2 result = v.xz * (1.0 / l1norm);
	if (v.y < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
	}
	return result;
}
#ifdef CUBEMAP_SOURCE
	vec4 sampleCubemap(vec3 dir) {
		return textureCube(sourceCube, modifySeams(dir, 1.0));
	}
	vec4 sampleCubemap(vec2 sph) {
		return sampleCubemap(fromSpherical(sph));
	}
	vec4 sampleCubemap(vec3 dir, float mipLevel) {
		return textureCubeLod(sourceCube, modifySeams(dir, 1.0), mipLevel);
	}
	vec4 sampleCubemap(vec2 sph, float mipLevel) {
		return sampleCubemap(fromSpherical(sph), mipLevel);
	}
#else
	vec4 sampleEquirect(vec2 sph) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleEquirect(vec3 dir) {
		return sampleEquirect(toSpherical(dir));
	}
	vec4 sampleEquirect(vec2 sph, float mipLevel) {
		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
		return texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleEquirect(vec3 dir, float mipLevel) {
		return sampleEquirect(toSpherical(dir), mipLevel);
	}
	vec4 sampleOctahedral(vec3 dir) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
	}
	vec4 sampleOctahedral(vec2 sph) {
		return sampleOctahedral(fromSpherical(sph));
	}
	vec4 sampleOctahedral(vec3 dir, float mipLevel) {
		vec2 uv = octEncode(dir) * 0.5 + 0.5;
		return texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
	}
	vec4 sampleOctahedral(vec2 sph, float mipLevel) {
		return sampleOctahedral(fromSpherical(sph), mipLevel);
	}
#endif
vec3 getDirectionCubemap() {
	vec2 st = vUv0 * 2.0 - 1.0;
	float face = targetFace();
	vec3 vec;
	if (face == 0.0) {
		vec = vec3(1, -st.y, -st.x);
	} else if (face == 1.0) {
		vec = vec3(-1, -st.y, st.x);
	} else if (face == 2.0) {
		vec = vec3(st.x, 1, st.y);
	} else if (face == 3.0) {
		vec = vec3(st.x, -1, -st.y);
	} else if (face == 4.0) {
		vec = vec3(st.x, -st.y, 1);
	} else {
		vec = vec3(-st.x, -st.y, -1);
	}
	return normalize(modifySeams(vec, 1.0));
}
mat3 matrixFromVector(vec3 n) {
	float a = 1.0 / (1.0 + n.z);
	float b = -n.x * n.y * a;
	vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
	vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
	return mat3(b1, b2, n);
}
mat3 matrixFromVectorSlow(vec3 n) {
	vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
	vec3 x = normalize(cross(up, n));
	vec3 y = cross(n, x);
	return mat3(x, y, n);
}
vec4 reproject() {
	if ({NUM_SAMPLES} <= 1) {
		return {ENCODE_FUNC}({DECODE_FUNC}({SOURCE_FUNC}({TARGET_FUNC}())));
	} else {
		vec3 t = {TARGET_FUNC}();
		vec3 tu = dFdx(t);
		vec3 tv = dFdy(t);
		vec3 result = vec3(0.0);
		for (float u = 0.0; u < {NUM_SAMPLES_SQRT}; ++u) {
			for (float v = 0.0; v < {NUM_SAMPLES_SQRT}; ++v) {
				result += {DECODE_FUNC}({SOURCE_FUNC}(normalize(t +
															tu * (u / {NUM_SAMPLES_SQRT} - 0.5) +
															tv * (v / {NUM_SAMPLES_SQRT} - 0.5))));
			}
		}
		return {ENCODE_FUNC}(result / ({NUM_SAMPLES_SQRT} * {NUM_SAMPLES_SQRT}));
	}
}
vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);
#ifdef USE_SAMPLES_TEX
	void unpackSample(int i, out vec3 L, out float mipLevel) {
		float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
		float v = (floor(u) + 0.5) * samplesTexInverseSize.y;
		vec4 raw;
		raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
		raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);
		L.xyz = raw.xyz * 2.0 - 1.0;
		mipLevel = raw.w * 8.0;
	}
	vec4 prefilterSamples() {
		mat3 vecSpace = matrixFromVectorSlow({TARGET_FUNC}());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < {NUM_SAMPLES}; ++i) {
			unpackSample(i, L, mipLevel);
			result += {DECODE_FUNC}({SOURCE_FUNC}(vecSpace * L, mipLevel)) * L.z;
			totalWeight += L.z;
		}
		return {ENCODE_FUNC}(result / totalWeight);
	}
	vec4 prefilterSamplesUnweighted() {
		mat3 vecSpace = matrixFromVectorSlow({TARGET_FUNC}());
		vec3 L;
		float mipLevel;
		vec3 result = vec3(0.0);
		float totalWeight = 0.0;
		for (int i = 0; i < {NUM_SAMPLES}; ++i) {
			unpackSample(i, L, mipLevel);
			result += {DECODE_FUNC}({SOURCE_FUNC}(vecSpace * L, mipLevel));
		}
		return {ENCODE_FUNC}(result / float({NUM_SAMPLES}));
	}
#endif
void main(void) {
	gl_FragColor = {PROCESS_FUNC}();
}
`,jW=`
attribute vec2 vertex_position;
uniform vec4 uvMod;
varying vec2 vUv0;
void main(void) {
	gl_Position = vec4(vertex_position, 0.5, 1.0);
	vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`,$W=`
uniform highp sampler2D uSceneDepthMap;
#ifndef SCREENSIZE
	#define SCREENSIZE
	uniform vec4 uScreenSize;
#endif
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform mat4 matrix_view;
#endif
#ifndef LINEARIZE_DEPTH
	#define LINEARIZE_DEPTH
	
	#ifndef CAMERAPLANES
		#define CAMERAPLANES
		uniform vec4 camera_params;
	#endif
	float linearizeDepth(float z) {
		if (camera_params.w == 0.0)
			return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
		else
			return camera_params.z + z * (camera_params.y - camera_params.z);
	}
#endif
float delinearizeDepth(float linearDepth) {
	if (camera_params.w == 0.0) {
		return (camera_params.y * (camera_params.z - linearDepth)) / (linearDepth * (camera_params.z - camera_params.y));
	} else {
		return (linearDepth - camera_params.z) / (camera_params.y - camera_params.z);
	}
}
float getLinearScreenDepth(vec2 uv) {
	#ifdef SCENE_DEPTHMAP_LINEAR
		#ifdef SCENE_DEPTHMAP_FLOAT
			return texture2D(uSceneDepthMap, uv).r;
		#else
			ivec2 textureSize = textureSize(uSceneDepthMap, 0);
			ivec2 texel = ivec2(uv * vec2(textureSize));
			vec4 data = texelFetch(uSceneDepthMap, texel, 0);
			uint intBits = 
				(uint(data.r * 255.0) << 24u) |
				(uint(data.g * 255.0) << 16u) |
				(uint(data.b * 255.0) << 8u) |
				uint(data.a * 255.0);
			return uintBitsToFloat(intBits);
		#endif
	#else
		return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
	#endif
}
#ifndef VERTEXSHADER
	float getLinearScreenDepth() {
		vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
		return getLinearScreenDepth(uv);
	}
#endif
float getLinearDepth(vec3 pos) {
	return -(matrix_view * vec4(pos, 1.0)).z;
}
`,KW=`
int getShadowCascadeIndex(vec4 shadowCascadeDistances, int shadowCascadeCount) {
	float depth = 1.0 / gl_FragCoord.w;
	vec4 comparisons = step(shadowCascadeDistances, vec4(depth));
	int cascadeIndex = int(dot(comparisons, vec4(1.0)));
	return min(cascadeIndex, shadowCascadeCount - 1);
}
int ditherShadowCascadeIndex(int cascadeIndex, vec4 shadowCascadeDistances, int shadowCascadeCount, float blendFactor) {
 
	if (cascadeIndex < shadowCascadeCount - 1) {
		float currentRangeEnd = shadowCascadeDistances[cascadeIndex];
		float transitionStart = blendFactor * currentRangeEnd;
		float depth = 1.0 / gl_FragCoord.w;
		if (depth > transitionStart) {
			float transitionFactor = smoothstep(transitionStart, currentRangeEnd, depth);
			float dither = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);
			if (dither < transitionFactor) {
				cascadeIndex += 1;
			}
		}
	}
	return cascadeIndex;
}
vec3 fadeShadow(vec3 shadowCoord, vec4 shadowCascadeDistances) {				  
	float depth = 1.0 / gl_FragCoord.w;
	if (depth > shadowCascadeDistances.w) {
		shadowCoord.z = -9999999.0;
	}
	return shadowCoord;
}
`,ZW=`
float linstep(float a, float b, float v) {
	return saturate((v - a) / (b - a));
}
float reduceLightBleeding(float pMax, float amount) {
	 return linstep(amount, 1.0, pMax);
}
float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
	float variance = moments.y - (moments.x * moments.x);
	variance = max(variance, minVariance);
	float d = mean - moments.x;
	float pMax = variance / (variance + (d * d));
	pMax = reduceLightBleeding(pMax, lightBleedingReduction);
	return (mean <= moments.x ? 1.0 : pMax);
}
float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
	Z = 2.0 * Z - 1.0;
	float warpedDepth = exp(exponent * Z);
	moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);
	float VSMBias = vsmBias;
	float depthScale = VSMBias * exponent * warpedDepth;
	float minVariance1 = depthScale * depthScale;
	return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
float VSM16(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	vec3 moments = texture2DLod(tex, texCoords, 0.0).xyz;
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM16(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent) {
	return VSM16(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM16(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	return VSM16(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
float VSM32(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
	#ifdef CAPS_TEXTURE_FLOAT_FILTERABLE
		vec3 moments = texture2DLod(tex, texCoords, 0.0).xyz;
	#else
		float pixelSize = 1.0 / resolution;
		texCoords -= vec2(pixelSize);
		vec3 s00 = texture2DLod(tex, texCoords, 0.0).xyz;
		vec3 s10 = texture2DLod(tex, texCoords + vec2(pixelSize, 0), 0.0).xyz;
		vec3 s01 = texture2DLod(tex, texCoords + vec2(0, pixelSize), 0.0).xyz;
		vec3 s11 = texture2DLod(tex, texCoords + vec2(pixelSize), 0.0).xyz;
		vec2 fr = fract(texCoords * resolution);
		vec3 h0 = mix(s00, s10, fr.x);
		vec3 h1 = mix(s01, s11, fr.x);
		vec3 moments = mix(h0, h1, fr.y);
	#endif
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
float getShadowVSM32(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent) {
	return VSM32(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
float getShadowSpotVSM32(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
	float Z = length(lightDir) * shadowParams.w + shadowParams.z;
	return VSM32(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, Z, shadowParams.y, exponent);
}
`,QW=`
float getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
float getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return textureShadow(shadowMap, shadowCoord);
}
#ifndef WEBGPU
float getShadowOmniPCF1x1(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
	return texture(shadowMap, vec4(lightDir, shadowZ));
}
#endif
`,JW=`
float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y); 
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float sum = 0.0;
	float uw0 = (3.0 - 2.0 * s);
	float uw1 = (1.0 + 2.0 * s);
	float u0 = (2.0 - s) / uw0 - 1.0;
	float u1 = s / uw1 + 1.0;
	float vw0 = (3.0 - 2.0 * t);
	float vw1 = (1.0 + 2.0 * t);
	float v0 = (2.0 - t) / vw0 - 1.0;
	float v1 = t / vw1 + 1.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum *= 1.0f / 16.0;
	return sum;
}
float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
#ifndef WEBGPU
float getShadowOmniPCF3x3(samplerCubeShadow shadowMap, vec4 shadowParams, vec3 dir) {
	
	float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
	float z = 1.0 / float(textureSize(shadowMap, 0));
	vec3 tc = normalize(dir);
	mediump vec4 shadows;
	shadows.x = texture(shadowMap, vec4(tc + vec3( z, z, z), shadowZ));
	shadows.y = texture(shadowMap, vec4(tc + vec3(-z,-z, z), shadowZ));
	shadows.z = texture(shadowMap, vec4(tc + vec3(-z, z,-z), shadowZ));
	shadows.w = texture(shadowMap, vec4(tc + vec3( z,-z,-z), shadowZ));
	return dot(shadows, vec4(0.25));
}
float getShadowOmniPCF3x3(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
	return getShadowOmniPCF3x3(shadowMap, shadowParams, lightDir);
}
#endif
`,e8=`
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
	float z = shadowCoord.z;
	vec2 uv = shadowCoord.xy * shadowParams.x;
	float shadowMapSizeInv = 1.0 / shadowParams.x;
	vec2 base_uv = floor(uv + 0.5);
	float s = (uv.x + 0.5 - base_uv.x);
	float t = (uv.y + 0.5 - base_uv.y);
	base_uv -= vec2(0.5);
	base_uv *= shadowMapSizeInv;
	float uw0 = (4.0 - 3.0 * s);
	float uw1 = 7.0;
	float uw2 = (1.0 + 3.0 * s);
	float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
	float u1 = (3.0 + s) / uw1;
	float u2 = s / uw2 + 2.0;
	float vw0 = (4.0 - 3.0 * t);
	float vw1 = 7.0;
	float vw2 = (1.0 + 3.0 * t);
	float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
	float v1 = (3.0 + t) / vw1;
	float v2 = t / vw2 + 2.0;
	float sum = 0.0;
	u0 = u0 * shadowMapSizeInv + base_uv.x;
	v0 = v0 * shadowMapSizeInv + base_uv.y;
	u1 = u1 * shadowMapSizeInv + base_uv.x;
	v1 = v1 * shadowMapSizeInv + base_uv.y;
	u2 = u2 * shadowMapSizeInv + base_uv.x;
	v2 = v2 * shadowMapSizeInv + base_uv.y;
	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
	sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));
	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
	sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));
	sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
	sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
	sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));
	sum *= 1.0f / 144.0;
	sum = saturate(sum);
	return sum;
}
float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
`,t8=`
#define PCSS_SAMPLE_COUNT 16
uniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];
uniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];
vec2 vogelDisk(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float sine = sin(theta);
	float cosine = cos(theta);
	return vec2(r * cosine, r * sine);
}
vec3 vogelSphere(int sampleIndex, float count, float phi, float r) {
	const float GoldenAngle = 2.4;
	float theta = float(sampleIndex) * GoldenAngle + phi;
	float weight = float(sampleIndex) / count;
	return vec3(cos(theta) * r, weight, sin(theta) * r);
}
float noise(vec2 screenPos) {
	const float PHI = 1.61803398874989484820459;
	return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);
}
float viewSpaceDepth(float depth, mat4 invProjection) {
	float z = depth * 2.0 - 1.0;
	vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);
	vec4 viewSpace = invProjection * clipSpace;
	return viewSpace.z;
}
float PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z, vec4 cameraParams) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec2 offset = sampleCoords[i] * searchSize;
		vec2 sampleUV = shadowCoords + offset;
		float blocker = texture2DLod(shadowMap, sampleUV, 0.0).r;
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker / blockers;
	return -1.0;
}
float PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {
	float receiverDepth = linearizeDepthWithParams(shadowCoords.z, cameraParams);
	vec2 samplePoints[PCSS_SAMPLE_COUNT];
	const float PI = 3.141592653589793;
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float pcssPresample = pcssDiskSamples[i];
		samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);
	}
	float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth, cameraParams);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		float depthDifference = (receiverDepth - averageBlocker) / 3.0;
		vec2 filterRadius = depthDifference * shadowSearchArea;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)
		{
			vec2 sampleUV = samplePoints[i] * filterRadius;
			sampleUV = shadowCoords.xy + sampleUV;
			float depth = texture2DLod(shadowMap, sampleUV, 0.0).r;
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	} 
}
#ifndef WEBGPU
float PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {
	float blockers = 0.0;
	float averageBlocker = 0.0;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;
		sampleDir = normalize(sampleDir);
		float blocker = textureCubeLod(shadowMap, sampleDir, 0.0).r;
		float isBlocking = step(blocker, z);
		blockers += isBlocking;
		averageBlocker += blocker * isBlocking;
	}
	if (blockers > 0.0)
		return averageBlocker / blockers;
	return -1.0;
}
float PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {
	
	vec3 samplePoints[PCSS_SAMPLE_COUNT];
	const float PI = 3.141592653589793;
	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
		float r = pcssSphereSamples[i];
		samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);
	}
	float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;
	vec3 lightDirNorm = normalize(lightDir);
	
	float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);
	if (averageBlocker == -1.0) {
		return 1.0;
	} else {
		float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;
		float shadow = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)
		{
			vec3 offset = samplePoints[i] * filterRadius;
			vec3 sampleDir = lightDirNorm + offset;
			sampleDir = normalize(sampleDir);
			float depth = textureCubeLod(shadowMap, sampleDir, 0.0).r;
			shadow += step(receiverDepth, depth);
		}
		return shadow / float(PCSS_SAMPLE_COUNT);
	}
}
float getShadowOmniPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);
}
#endif
float getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}
`,s8=`
highp float fractSinRand(const in vec2 uv) {
	const float PI = 3.141592653589793;
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);
	return fract(sin(sn) * c);
}
struct VogelDiskData {
	float invNumSamples;
	float initialAngle;
	float currentPointId;
};
void prepareDiskConstants(out VogelDiskData data, int sampleCount, float randomSeed) {
	const float pi2 = 6.28318530718;
	data.invNumSamples = 1.0 / float(sampleCount);
	data.initialAngle = randomSeed * pi2;
	data.currentPointId = 0.0;
}
vec2 generateDiskSample(inout VogelDiskData data) {
	const float GOLDEN_ANGLE = 2.399963;
	float r = sqrt((data.currentPointId + 0.5) * data.invNumSamples);
	float theta = data.currentPointId * GOLDEN_ANGLE + data.initialAngle;
	vec2 offset = vec2(cos(theta), sin(theta)) * pow(r, 1.33);
	data.currentPointId += 1.0;
	return offset;
}
void PCSSFindBlocker(TEXTURE_ACCEPT(shadowMap), out float avgBlockerDepth, out int numBlockers,
	vec2 shadowCoords, float z, int shadowBlockerSamples, float penumbraSize, float invShadowMapSize, float randomSeed) {
	VogelDiskData diskData;
	prepareDiskConstants(diskData, shadowBlockerSamples, randomSeed);
	float searchWidth = penumbraSize * invShadowMapSize;
	float blockerSum = 0.0;
	numBlockers = 0;
	for( int i = 0; i < shadowBlockerSamples; ++i ) {
		vec2 diskUV = generateDiskSample(diskData);
		vec2 sampleUV = shadowCoords + diskUV * searchWidth;
		float shadowMapDepth = texture2DLod(shadowMap, sampleUV, 0.0).r;
		if ( shadowMapDepth < z ) {
			blockerSum += shadowMapDepth;
			numBlockers++;
		}
	}
	avgBlockerDepth = blockerSum / float(numBlockers);
}
float PCSSFilter(TEXTURE_ACCEPT(shadowMap), vec2 uv, float receiverDepth, int shadowSamples, float filterRadius, float randomSeed) {
	VogelDiskData diskData;
	prepareDiskConstants(diskData, shadowSamples, randomSeed);
	float sum = 0.0;
	for (int i = 0; i < shadowSamples; i++) {
		vec2 offsetUV = generateDiskSample(diskData) * filterRadius;
		float depth = texture2DLod(shadowMap, uv + offsetUV, 0.0).r;
		sum += step(receiverDepth, depth);
	}
	return sum / float(shadowSamples);
}
float getPenumbra(float dblocker, float dreceiver, float penumbraSize, float penumbraFalloff) {
	float dist = dreceiver - dblocker;
	float penumbra = 1.0 - pow(1.0 - dist, penumbraFalloff);
	return penumbra * penumbraSize;
}
float PCSSDirectional(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec4 softShadowParams) {
	float receiverDepth = shadowCoords.z;
	float randomSeed = fractSinRand(gl_FragCoord.xy);
	int shadowSamples = int(softShadowParams.x);
	int shadowBlockerSamples = int(softShadowParams.y);
	float penumbraSize = softShadowParams.z;
	float penumbraFalloff = softShadowParams.w;
	int shadowMapSize = textureSize(shadowMap, 0).x;
	float invShadowMapSize = 1.0 / float(shadowMapSize);
	invShadowMapSize *= float(shadowMapSize) / 2048.0;
	float penumbra;
	if (shadowBlockerSamples > 0) {
		float avgBlockerDepth = 0.0;
		int numBlockers = 0;
		PCSSFindBlocker(TEXTURE_PASS(shadowMap), avgBlockerDepth, numBlockers, shadowCoords.xy, receiverDepth, shadowBlockerSamples, penumbraSize, invShadowMapSize, randomSeed);
		if (numBlockers < 1)
			return 1.0f;
		penumbra = getPenumbra(avgBlockerDepth, shadowCoords.z, penumbraSize, penumbraFalloff);
	} else {
		penumbra = penumbraSize;
	}
	float filterRadius = penumbra * invShadowMapSize;
	return PCSSFilter(TEXTURE_PASS(shadowMap), shadowCoords.xy, receiverDepth, shadowSamples, filterRadius, randomSeed);
}
float getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec4 softShadowParams, vec3 lightDir) {
	return PCSSDirectional(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, softShadowParams);
}
`,i8=`
attribute float vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
mat4 getBoneMatrix(const in float indexFloat) {
	int width = textureSize(texture_poseMap, 0).x;
	int index = int(indexFloat + 0.5) * 3;
	int iy = index / width;
	int ix = index % width;
	vec4 v1 = texelFetch(texture_poseMap, ivec2(ix + 0, iy), 0);
	vec4 v2 = texelFetch(texture_poseMap, ivec2(ix + 1, iy), 0);
	vec4 v3 = texelFetch(texture_poseMap, ivec2(ix + 2, iy), 0);
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1
	);
}
`,r8=`
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;
uniform highp sampler2D texture_poseMap;
void getBoneMatrix(const in int width, const in int index, out vec4 v1, out vec4 v2, out vec4 v3) {
	int v = index / width;
	int u = index % width;
	v1 = texelFetch(texture_poseMap, ivec2(u + 0, v), 0);
	v2 = texelFetch(texture_poseMap, ivec2(u + 1, v), 0);
	v3 = texelFetch(texture_poseMap, ivec2(u + 2, v), 0);
}
mat4 getSkinMatrix(const in vec4 indicesFloat, const in vec4 weights) {
	int width = textureSize(texture_poseMap, 0).x;
	ivec4 indices = ivec4(indicesFloat + 0.5) * 3;
	vec4 a1, a2, a3;
	getBoneMatrix(width, indices.x, a1, a2, a3);
	vec4 b1, b2, b3;
	getBoneMatrix(width, indices.y, b1, b2, b3);
	vec4 c1, c2, c3;
	getBoneMatrix(width, indices.z, c1, c2, c3);
	vec4 d1, d2, d3;
	getBoneMatrix(width, indices.w, d1, d2, d3);
	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;
	float one = dot(weights, vec4(1.0));
	return mat4(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`,a8=`
	#define LIT_SKYBOX_INTENSITY
	#include "envProcPS"
	#include "gammaPS"
	#include "tonemappingPS"
	#ifdef PREPASS_PASS
		varying float vLinearDepth;
		#include "floatAsUintPS"
	#endif
	varying vec3 vViewDir;
	uniform float skyboxHighlightMultiplier;
	#ifdef SKY_CUBEMAP
		uniform samplerCube texture_cubeMap;
		#ifdef SKYMESH
			varying vec3 vWorldPos;
			uniform mat3 cubeMapRotationMatrix;
			uniform vec3 projectedSkydomeCenter;
		#endif
	#else
		#include "sphericalPS"
		#include "envAtlasPS"
		uniform sampler2D texture_envAtlas;
		uniform float mipLevel;
	#endif
	void main(void) {
		#ifdef PREPASS_PASS
			gl_FragColor = float2vec4(vLinearDepth);
		#else
			#ifdef SKY_CUBEMAP
				#ifdef SKYMESH
					vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);
					vec3 dir = envDir * cubeMapRotationMatrix;
				#else
					vec3 dir = vViewDir;
				#endif
				dir.x *= -1.0;
				vec3 linear = {SKYBOX_DECODE_FNC}(textureCube(texture_cubeMap, dir));
			#else
				vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
				vec2 uv = toSphericalUv(normalize(dir));
				vec3 linear = {SKYBOX_DECODE_FNC}(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));
			#endif
			if (any(greaterThanEqual(linear, vec3(64.0)))) {
				linear *= skyboxHighlightMultiplier;
			}
			gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
		#endif
	}
`,n8=`
attribute vec4 aPosition;
uniform mat4 matrix_view;
uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;
varying vec3 vViewDir;
#ifdef PREPASS_PASS
	varying float vLinearDepth;
#endif
#ifdef SKYMESH
	uniform mat4 matrix_model;
	varying vec3 vWorldPos;
#endif
void main(void) {
	mat4 view = matrix_view;
	#ifdef SKYMESH
		vec4 worldPos = matrix_model * aPosition;
		vWorldPos = worldPos.xyz;
		gl_Position = matrix_projectionSkybox * (view * worldPos);
		#ifdef PREPASS_PASS
			vLinearDepth = -(matrix_view * vec4(vWorldPos, 1.0)).z;
		#endif
	#else
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * (view * aPosition);
		vViewDir = aPosition.xyz * cubeMapRotationMatrix;
		#ifdef PREPASS_PASS
			vLinearDepth = -gl_Position.w;
		#endif
	#endif
	gl_Position.z = gl_Position.w - 1.0e-7;
}
`,o8=`
#ifdef STD_SPECULAR_CONSTANT
uniform vec3 material_specular;
#endif
void getSpecularity() {
	vec3 specularColor = vec3(1,1,1);
	#ifdef STD_SPECULAR_CONSTANT
	specularColor *= material_specular;
	#endif
	#ifdef STD_SPECULAR_TEXTURE
	specularColor *= {STD_SPECULAR_TEXTURE_DECODE}(texture2DBias({STD_SPECULAR_TEXTURE_NAME}, {STD_SPECULAR_TEXTURE_UV}, textureBias)).{STD_SPECULAR_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SPECULAR_VERTEX
	specularColor *= saturate(vVertexColor.{STD_SPECULAR_VERTEX_CHANNEL});
	#endif
	dSpecularity = specularColor;
}
`,l8=`
vec2 toSpherical(vec3 dir) {
	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}
vec2 toSphericalUv(vec3 dir) {
	const float PI = 3.141592653589793;
	vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
	return vec2(uv.x, 1.0 - uv.y);
}
`,c8=`
#ifdef STD_SPECULARITYFACTOR_CONSTANT
uniform float material_specularityFactor;
#endif
void getSpecularityFactor() {
	float specularityFactor = 1.0;
	#ifdef STD_SPECULARITYFACTOR_CONSTANT
	specularityFactor *= material_specularityFactor;
	#endif
	#ifdef STD_SPECULARITYFACTOR_TEXTURE
	specularityFactor *= texture2DBias({STD_SPECULARITYFACTOR_TEXTURE_NAME}, {STD_SPECULARITYFACTOR_TEXTURE_UV}, textureBias).{STD_SPECULARITYFACTOR_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SPECULARITYFACTOR_VERTEX
	specularityFactor *= saturate(vVertexColor.{STD_SPECULARITYFACTOR_VERTEX_CHANNEL});
	#endif
	dSpecularityFactor = specularityFactor;
}
`,h8=`
float getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {
	float cosAngle = dot(lightDirNorm, lightSpotDir);
	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`,u8=`
	nineSlicedUv = vec2(vUv0.x, 1.0 - vUv0.y);
`,d8=`
	vec2 tileMask = step(vMask, vec2(0.99999));
	vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
	vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
	vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
	nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
	
`,f8=`
	float dAlpha = 1.0;
	#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE
		#ifdef STD_OPACITY_TEXTURE_ALLOCATE
			uniform sampler2D texture_opacityMap;
		#endif
	#endif
	#ifdef FORWARD_PASS
		vec3 dAlbedo;
		vec3 dNormalW;
		vec3 dSpecularity = vec3(0.0);
		float dGlossiness = 0.0;
		#ifdef LIT_REFRACTION
			float dTransmission;
			float dThickness;
		#endif
		#ifdef LIT_SCENE_COLOR
			uniform sampler2D uSceneColorMap;
		#endif
		#ifdef LIT_SCREEN_SIZE
			uniform vec4 uScreenSize;
		#endif
		#ifdef LIT_TRANSFORMS
			uniform mat4 matrix_viewProjection;
			uniform mat4 matrix_model;
		#endif
		#ifdef STD_HEIGHT_MAP
			vec2 dUvOffset;
			#ifdef STD_HEIGHT_TEXTURE_ALLOCATE
				uniform sampler2D texture_heightMap;
			#endif
		#endif
		#ifdef STD_DIFFUSE_TEXTURE_ALLOCATE
			uniform sampler2D texture_diffuseMap;
		#endif
		#ifdef STD_DIFFUSEDETAIL_TEXTURE_ALLOCATE
			uniform sampler2D texture_diffuseDetailMap;
		#endif
		#ifdef STD_NORMAL_TEXTURE_ALLOCATE
			uniform sampler2D texture_normalMap;
		#endif
		#ifdef STD_NORMALDETAIL_TEXTURE_ALLOCATE
			uniform sampler2D texture_normalDetailMap;
		#endif
		#ifdef STD_THICKNESS_TEXTURE_ALLOCATE
			uniform sampler2D texture_thicknessMap;
		#endif
		#ifdef STD_REFRACTION_TEXTURE_ALLOCATE
			uniform sampler2D texture_refractionMap;
		#endif
		#ifdef LIT_IRIDESCENCE
			float dIridescence;
			float dIridescenceThickness;
			#ifdef STD_IRIDESCENCE_THICKNESS_TEXTURE_ALLOCATE
				uniform sampler2D texture_iridescenceThicknessMap;
			#endif
			#ifdef STD_IRIDESCENCE_TEXTURE_ALLOCATE
				uniform sampler2D texture_iridescenceMap;
			#endif
		#endif
		#ifdef LIT_CLEARCOAT
			float ccSpecularity;
			float ccGlossiness;
			vec3 ccNormalW;
		#endif
		#ifdef LIT_GGX_SPECULAR
			float dAnisotropy;
			vec2 dAnisotropyRotation;
		#endif
		#ifdef LIT_SPECULAR_OR_REFLECTION
			#ifdef LIT_SHEEN
				vec3 sSpecularity;
				float sGlossiness;
				#ifdef STD_SHEEN_TEXTURE_ALLOCATE
					uniform sampler2D texture_sheenMap;
				#endif
				#ifdef STD_SHEENGLOSS_TEXTURE_ALLOCATE
					uniform sampler2D texture_sheenGlossMap;
				#endif
			#endif
			#ifdef LIT_METALNESS
				float dMetalness;
				float dIor;
				#ifdef STD_METALNESS_TEXTURE_ALLOCATE
					uniform sampler2D texture_metalnessMap;
				#endif
			#endif
			#ifdef LIT_SPECULARITY_FACTOR
				float dSpecularityFactor;
				#ifdef STD_SPECULARITYFACTOR_TEXTURE_ALLOCATE
					uniform sampler2D texture_specularityFactorMap;
				#endif
			#endif
			#ifdef STD_SPECULAR_COLOR
				#ifdef STD_SPECULAR_TEXTURE_ALLOCATE
					uniform sampler2D texture_specularMap;
				#endif
			#endif
			#ifdef STD_GLOSS_TEXTURE_ALLOCATE
				uniform sampler2D texture_glossMap;
			#endif
		#endif
		#ifdef STD_AO
			float dAo;
			#ifdef STD_AO_TEXTURE_ALLOCATE
				uniform sampler2D texture_aoMap;
			#endif
			#ifdef STD_AODETAIL_TEXTURE_ALLOCATE
				uniform sampler2D texture_aoDetailMap;
			#endif
		#endif
		vec3 dEmission;
		#ifdef STD_EMISSIVE_TEXTURE_ALLOCATE
			uniform sampler2D texture_emissiveMap;
		#endif
		#ifdef LIT_CLEARCOAT
			#ifdef STD_CLEARCOAT_TEXTURE_ALLOCATE
				uniform sampler2D texture_clearCoatMap;
			#endif
			#ifdef STD_CLEARCOATGLOSS_TEXTURE_ALLOCATE
				uniform sampler2D texture_clearCoatGlossMap;
			#endif
			#ifdef STD_CLEARCOATNORMAL_TEXTURE_ALLOCATE
				uniform sampler2D texture_clearCoatNormalMap;
			#endif
		#endif
		
		#ifdef LIT_GGX_SPECULAR
			#ifdef STD_ANISOTROPY_TEXTURE_ALLOCATE
				uniform sampler2D texture_anisotropyMap;
			#endif
		#endif
		#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)
			vec3 dLightmap;
			#ifdef STD_LIGHT_TEXTURE_ALLOCATE
				uniform sampler2D texture_lightMap;
			#endif
		#endif
	#endif
	#include "litShaderCorePS"
`,m8=`
	#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE
		#include "opacityPS"
		#if defined(LIT_ALPHA_TEST)
			#include "alphaTestPS"
		#endif
		#if STD_OPACITY_DITHER != NONE
			#include "opacityDitherPS"
		#endif
	#endif
	#ifdef FORWARD_PASS
		#ifdef STD_HEIGHT_MAP
			#include "parallaxPS"
		#endif
		#include  "diffusePS"
		#ifdef LIT_NEEDS_NORMAL
			#include "normalMapPS"
		#endif
		#ifdef LIT_REFRACTION
			#include "transmissionPS"
			#include "thicknessPS"
		#endif
		#ifdef LIT_IRIDESCENCE
			#include "iridescencePS"
			#include "iridescenceThicknessPS"
		#endif
		#ifdef LIT_SPECULAR_OR_REFLECTION
			#ifdef LIT_SHEEN
				#include "sheenPS"
				#include "sheenGlossPS"
			#endif
			#ifdef LIT_METALNESS
				#include "metalnessPS"
				#include "iorPS"
			#endif
			#ifdef LIT_SPECULARITY_FACTOR
				#include "specularityFactorPS"
			#endif
			#ifdef STD_SPECULAR_COLOR
				#include "specularPS"
			#else
				void getSpecularity() { 
					dSpecularity = vec3(1);
				}
			#endif
			#include "glossPS"
		#endif
		#ifdef STD_AO
			#include "aoPS"
		#endif
		#include "emissivePS"
		#ifdef LIT_CLEARCOAT
			#include "clearCoatPS"
			#include "clearCoatGlossPS"
			#include "clearCoatNormalPS"
		#endif
		#if defined(LIT_SPECULAR) && defined(LIT_LIGHTING) && defined(LIT_GGX_SPECULAR)
			#include "anisotropyPS"
		#endif
		#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)
			#include "lightmapPS"
		#endif
	#endif
	void evaluateFrontend() {
		#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE
			getOpacity();
			#if defined(LIT_ALPHA_TEST)
				alphaTest(dAlpha);
			#endif
			#if STD_OPACITY_DITHER != NONE
				opacityDither(dAlpha, 0.0);
			#endif
			litArgs_opacity = dAlpha;
		#endif
		#ifdef FORWARD_PASS
			#ifdef STD_HEIGHT_MAP
				getParallax();
			#endif
			getAlbedo();
			litArgs_albedo = dAlbedo;
			#ifdef LIT_NEEDS_NORMAL
				getNormal();
				litArgs_worldNormal = dNormalW;
			#endif
			#ifdef LIT_REFRACTION
				getRefraction();
				litArgs_transmission = dTransmission;
				getThickness();
				litArgs_thickness = dThickness;
				#ifdef LIT_DISPERSION
					litArgs_dispersion = material_dispersion;
				#endif
			#endif
			#ifdef LIT_IRIDESCENCE
				getIridescence();
				getIridescenceThickness();
				litArgs_iridescence_intensity = dIridescence;
				litArgs_iridescence_thickness = dIridescenceThickness;
			#endif
			#ifdef LIT_SPECULAR_OR_REFLECTION
				#ifdef LIT_SHEEN
					getSheen();
					litArgs_sheen_specularity = sSpecularity;
					getSheenGlossiness();
					litArgs_sheen_gloss = sGlossiness;
				#endif
				#ifdef LIT_METALNESS
					getMetalness();
					litArgs_metalness = dMetalness;
					getIor();
					litArgs_ior = dIor;
				#endif
				#ifdef LIT_SPECULARITY_FACTOR
					getSpecularityFactor();
					litArgs_specularityFactor = dSpecularityFactor;
				#endif
				getGlossiness();
				getSpecularity();
				litArgs_specularity = dSpecularity;
				litArgs_gloss = dGlossiness;
			#endif
			#ifdef STD_AO
				getAO();
				litArgs_ao = dAo;
			#endif
			getEmission();
			litArgs_emission = dEmission;
			#ifdef LIT_CLEARCOAT
				getClearCoat();
				getClearCoatGlossiness();
				getClearCoatNormal();
				litArgs_clearcoat_specularity = ccSpecularity;
				litArgs_clearcoat_gloss = ccGlossiness;
				litArgs_clearcoat_worldNormal = ccNormalW;
			#endif
			#if defined(LIT_SPECULAR) && defined(LIT_LIGHTING) && defined(LIT_GGX_SPECULAR)
				getAnisotropy();
			#endif
			#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)
				getLightMap();
				litArgs_lightmap = dLightmap;
				#ifdef STD_LIGHTMAP_DIR
					litArgs_lightmapDir = dLightmapDir;
				#endif
			#endif
		#endif
	}
`,p8=`
#ifdef LIT_TANGENTS
	#define TBN_TANGENTS
#else
	#if defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)
		#define TBN_DERIVATIVES
	#endif
#endif
#if defined(TBN_DERIVATIVES)
	uniform float tbnBasis;
#endif
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
	#ifdef TBN_TANGENTS
		dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));
	#elif defined(TBN_DERIVATIVES)
		vec2 uv = {lightingUv};
		vec3 dp1 = dFdx( vPositionW );
		vec3 dp2 = dFdy( vPositionW );
		vec2 duv1 = dFdx( uv );
		vec2 duv2 = dFdy( uv );
		vec3 dp2perp = cross( dp2, normal );
		vec3 dp1perp = cross( normal, dp1 );
		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
		float denom = max( dot(T,T), dot(B,B) );
		float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
		dTBN = mat3(T * invmax, -B * invmax, normal );
	#else
		vec3 B = cross(normal, vObjectSpaceUpW);
		vec3 T = cross(normal, B);
		if (dot(B,B)==0.0)
		{
			float major=max(max(normal.x, normal.y), normal.z);
			if (normal.x == major)
			{
				B = cross(normal, vec3(0,1,0));
				T = cross(normal, B);
			}
			else if (normal.y == major)
			{
				B = cross(normal, vec3(0,0,1));
				T = cross(normal, B);
			}
			else if (normal.z == major)
			{
				B = cross(normal, vec3(1,0,0));
				T = cross(normal, B);
			}
		}
		dTBN = mat3(normalize(T), normalize(B), normalize(normal));
	#endif
}
`,_8=`
#ifdef STD_THICKNESS_CONSTANT
uniform float material_thickness;
#endif
void getThickness() {
	dThickness = 1.0;
	#ifdef STD_THICKNESS_CONSTANT
	dThickness *= material_thickness;
	#endif
	#ifdef STD_THICKNESS_TEXTURE
	dThickness *= texture2DBias({STD_THICKNESS_TEXTURE_NAME}, {STD_THICKNESS_TEXTURE_UV}, textureBias).{STD_THICKNESS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_THICKNESS_VERTEX
	dThickness *= saturate(vVertexColor.{STD_THICKNESS_VERTEX_CHANNEL});
	#endif
}
`,g8=`
#if (TONEMAP == NONE)
	#include "tonemappingNonePS"
#elif TONEMAP == FILMIC
	#include "tonemappingFilmicPS"
#elif TONEMAP == LINEAR
	#include "tonemappingLinearPS"
#elif TONEMAP == HEJL
	#include "tonemappingHejlPS"
#elif TONEMAP == ACES
	#include "tonemappingAcesPS"
#elif TONEMAP == ACES2
	#include "tonemappingAces2PS"
#elif TONEMAP == NEUTRAL
	#include "tonemappingNeutralPS"
#endif
`,v8=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	float tA = 2.51;
	float tB = 0.03;
	float tC = 2.43;
	float tD = 0.59;
	float tE = 0.14;
	vec3 x = color * exposure;
	return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`,S8=`
uniform float exposure;
const mat3 ACESInputMat = mat3(
	0.59719, 0.35458, 0.04823,
	0.07600, 0.90834, 0.01566,
	0.02840, 0.13383, 0.83777
);
const mat3 ACESOutputMat = mat3(
	 1.60475, -0.53108, -0.07367,
	-0.10208,  1.10813, -0.00605,
	-0.00327, -0.07276,  1.07602
);
vec3 RRTAndODTFit(vec3 v) {
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return a / b;
}
vec3 toneMap(vec3 color) {
	color *= exposure / 0.6;
	color = color * ACESInputMat;
	color = RRTAndODTFit(color);
	color = color * ACESOutputMat;
	color = clamp(color, 0.0, 1.0);
	return color;
}
`,y8=`
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;
uniform float exposure;
vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}
vec3 toneMap(vec3 color) {
	color = uncharted2Tonemap(color * exposure);
	vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
	color = color * whiteScale;
	return color;
}
`,x8=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
	const float Scl = 1.25;
	vec3 h = max( vec3(0.0), color - vec3(0.004) );
	return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`,T8=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	return color * exposure;
}
`,E8=`
uniform float exposure;
vec3 toneMap(vec3 color) {
	color *= exposure;
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, newPeak * vec3(1, 1, 1), g);
}
`,b8=`
vec3 toneMap(vec3 color) {
	return color;
}
`,A8=`
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif
#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif
vec4 evalWorldPosition(vec3 vertexPosition, mat4 modelMatrix) {
	vec3 localPos = getLocalPosition(vertexPosition);
	#ifdef NINESLICED
		localPos.xz *= outerScale;
		vec2 positiveUnitOffset = clamp(vertexPosition.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertexPosition.xz, vec2(0.0), vec2(1.0));
		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;
		localPos.xz *= -0.5;
		localPos = localPos.xzy;
	#endif
	vec4 posW = modelMatrix * vec4(localPos, 1.0);
	#ifdef SCREENSPACE
		posW.zw = vec2(0.0, 1.0);
	#endif
	return posW;
}
vec4 getPosition() {
	dModelMatrix = getModelMatrix();
	vec4 posW = evalWorldPosition(vertex_position.xyz, dModelMatrix);
	dPositionW = posW.xyz;
	vec4 screenPos;
	#ifdef UV1LAYOUT
		screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#ifdef WEBGPU
			screenPos.y *= -1.0;
		#endif
	#else
		#ifdef SCREENSPACE
			screenPos = posW;
			screenPos.y *= projectionFlipY;
		#else
			screenPos = matrix_viewProjection * posW;
		#endif
		#ifdef PIXELSNAP
			screenPos.xy = (screenPos.xy * 0.5) + 0.5;
			screenPos.xy *= uScreenSize.xy;
			screenPos.xy = floor(screenPos.xy);
			screenPos.xy *= uScreenSize.zw;
			screenPos.xy = (screenPos.xy * 2.0) - 1.0;
		#endif
	#endif
	return screenPos;
}
vec3 getWorldPosition() {
	return dPositionW;
}
`,w8=`
attribute vec4 vertex_position;
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
#ifdef MORPHING
	uniform vec2 morph_tex_params;
	attribute uint morph_vertex_id;
	ivec2 getTextureMorphCoords() {
		ivec2 textureSize = ivec2(morph_tex_params);
		int morphGridV = int(morph_vertex_id) / textureSize.x;
		int morphGridU = int(morph_vertex_id) - (morphGridV * textureSize.x);
		#ifdef WEBGPU
			morphGridV = textureSize.y - morphGridV - 1;
		#endif
		return ivec2(morphGridU, morphGridV);
	}
	#ifdef MORPHING_POSITION
		#ifdef MORPHING_INT
			uniform vec3 aabbSize;
			uniform vec3 aabbMin;
			uniform usampler2D morphPositionTex;
		#else
			uniform highp sampler2D morphPositionTex;
		#endif
	#endif
#endif
#ifdef defined(BATCH)
	#include "skinBatchVS"
	mat4 getModelMatrix() {
		return getBoneMatrix(vertex_boneIndices);
	}
#elif defined(SKIN)
	#include "skinVS"
	mat4 getModelMatrix() {
		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
	}
#elif defined(INSTANCING)
	#include "transformInstancingVS"
#else
	mat4 getModelMatrix() {
		return matrix_model;
	}
#endif
vec3 getLocalPosition(vec3 vertexPosition) {
	vec3 localPos = vertexPosition;
	#ifdef MORPHING_POSITION
		ivec2 morphUV = getTextureMorphCoords();
		#ifdef MORPHING_INT
			vec3 morphPos = vec3(texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz) / 65535.0 * aabbSize + aabbMin;
		#else
			vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;
		#endif
		localPos += morphPos;
	#endif
	return localPos;
}
`,C8=`
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
mat4 getModelMatrix() {
	return matrix_model * mat4(instance_line1, instance_line2, instance_line3, instance_line4);
}
`,D8=`
#ifdef STD_REFRACTION_CONSTANT
uniform float material_refraction;
#endif
void getRefraction() {
	float refraction = 1.0;
	#ifdef STD_REFRACTION_CONSTANT
	refraction = material_refraction;
	#endif
	#ifdef STD_REFRACTION_TEXTURE
	refraction *= texture2DBias({STD_REFRACTION_TEXTURE_NAME}, {STD_REFRACTION_TEXTURE_UV}, textureBias).{STD_REFRACTION_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_REFRACTION_VERTEX
	refraction *= saturate(vVertexColor.{STD_REFRACTION_VERTEX_CHANNEL});
	#endif
	dTransmission = refraction;
}
`,P8=`
uniform float twoSidedLightingNegScaleFactor;
void handleTwoSidedLighting() {
	dTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;
}
`,R8=`
#ifdef NINESLICED
	vec2 getUv0() {
		vec2 uv = vertex_position.xz;
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;
		uv = uv * -0.5 + 0.5;
		uv = uv * atlasRect.zw + atlasRect.xy;
		vMask = vertex_texCoord0.xy;
		return uv;
	}
#else
	vec2 getUv0() {
		return vertex_texCoord0;
	}
#endif
`,M8=`
vec2 getUv1() {
	return vertex_texCoord1;
}
`,L8=`
vUV{TRANSFORM_UV_{i}}_{TRANSFORM_ID_{i}} = vec2(
	dot(vec3(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}0),
	dot(vec3(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}1)
);
`,I8=`
	uniform vec3 {TRANSFORM_NAME_{i}}0;
	uniform vec3 {TRANSFORM_NAME_{i}}1;
`,O8=`
void getViewDir() {
	dViewDirW = normalize(view_position - vPositionW);
}
`;const N8={alphaTestPS:$H,ambientPS:KH,anisotropyPS:ZH,aoPS:QH,aoDiffuseOccPS:JH,aoSpecOccPS:e5,bakeDirLmEndPS:t5,bakeLmEndPS:s5,basePS:i5,baseNineSlicedPS:r5,baseNineSlicedTiledPS:a5,bayerPS:n5,blurVSMPS:o5,clearCoatPS:l5,clearCoatGlossPS:c5,clearCoatNormalPS:h5,clusteredLightCookiesPS:d5,clusteredLightShadowsPS:f5,clusteredLightUtilsPS:u5,clusteredLightPS:m5,combinePS:p5,cookieBlit2DPS:_5,cookieBlitCubePS:g5,cookieBlitVS:v5,cookiePS:S5,cubeMapProjectPS:y5,cubeMapRotatePS:x5,debugOutputPS:T5,debugProcessFrontendPS:E5,detailModesPS:A5,diffusePS:w5,decodePS:b5,emissivePS:C5,encodePS:D5,endPS:P5,envAtlasPS:R5,envProcPS:M5,falloffInvSquaredPS:L5,falloffLinearPS:I5,floatAsUintPS:O5,fogPS:N5,fresnelSchlickPS:F5,frontendCodePS:"",frontendDeclPS:"",fullscreenQuadVS:B5,gammaPS:U5,gles3PS:c2,gles3VS:h2,glossPS:z5,quadVS:k5,immediateLinePS:V5,immediateLineVS:G5,iridescenceDiffractionPS:H5,iridescencePS:W5,iridescenceThicknessPS:X5,iorPS:q5,lightDeclarationPS:Y5,lightDiffuseLambertPS:j5,lightDirPointPS:$5,lightEvaluationPS:K5,lightFunctionLightPS:Z5,lightFunctionShadowPS:Q5,lightingPS:J5,lightmapAddPS:eW,lightmapPS:tW,lightSpecularAnisoGGXPS:sW,lightSpecularGGXPS:iW,lightSpecularBlinnPS:rW,lightSheenPS:aW,linearizeDepthPS:nW,litForwardBackendPS:oW,litForwardDeclarationPS:lW,litForwardMainPS:cW,litForwardPostCodePS:hW,litForwardPreCodePS:uW,litMainPS:dW,litMainVS:fW,litOtherMainPS:mW,litShaderArgsPS:pW,litShaderCorePS:_W,litShadowMainPS:gW,litUserDeclarationPS:"",litUserDeclarationVS:"",litUserCodePS:"",litUserCodeVS:"",litUserMainStartPS:"",litUserMainStartVS:"",litUserMainEndPS:"",litUserMainEndVS:"",ltcPS:vW,metalnessPS:SW,metalnessModulatePS:xW,morphPS:TW,morphVS:EW,msdfPS:yW,msdfVS:bW,normalVS:AW,normalCoreVS:wW,normalMapPS:CW,opacityPS:DW,opacityDitherPS:PW,outputPS:RW,outputAlphaPS:MW,outputTex2DPS:LW,sheenPS:IW,sheenGlossPS:OW,parallaxPS:NW,pickPS:FW,reflDirPS:BW,reflDirAnisoPS:UW,reflectionCCPS:zW,reflectionCubePS:kW,reflectionEnvHQPS:VW,reflectionEnvPS:GW,reflectionSpherePS:HW,reflectionSheenPS:WW,refractionCubePS:XW,refractionDynamicPS:qW,reprojectPS:YW,reprojectVS:jW,screenDepthPS:$W,shadowCascadesPS:KW,shadowEVSMPS:ZW,shadowPCF1PS:QW,shadowPCF3PS:JW,shadowPCF5PS:e8,shadowPCSSPS:t8,shadowSoftPS:s8,skinBatchVS:i8,skinVS:r8,skyboxPS:a8,skyboxVS:n8,specularPS:o8,sphericalPS:l8,specularityFactorPS:c8,spotPS:h8,startNineSlicedPS:u8,startNineSlicedTiledPS:d8,stdDeclarationPS:f8,stdFrontEndPS:m8,TBNPS:p8,thicknessPS:_8,tonemappingPS:g8,tonemappingAcesPS:v8,tonemappingAces2PS:S8,tonemappingFilmicPS:y8,tonemappingHejlPS:x8,tonemappingLinearPS:T8,tonemappingNeutralPS:E8,tonemappingNonePS:b8,transformVS:A8,transformCoreVS:w8,transformInstancingVS:C8,transmissionPS:D8,twoSidedLightingPS:P8,uv0VS:R8,uv1VS:M8,uvTransformVS:L8,uvTransformUniformsPS:I8,viewDirPS:O8,webgpuPS:u2,webgpuVS:d2};var F8=`
uniform alpha_ref: f32;
fn alphaTest(a: f32) {
	if (a < uniform.alpha_ref) {
		discard;
	}
}
`,B8=`
#if LIT_AMBIENT_SOURCE == AMBIENTSH
	uniform ambientSH: array<vec3f, 9>;
#endif
#if LIT_AMBIENT_SOURCE == ENVALATLAS
	#include "envAtlasPS"
	#ifndef ENV_ATLAS
		#define ENV_ATLAS
		var texture_envAtlas: texture_2d<f32>;
		var texture_envAtlasSampler: sampler;
	#endif
#endif
fn addAmbient(worldNormal: vec3f) {
	#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH
		let n: vec3f = cubeMapRotate(worldNormal);
		let color: vec3f =
			uniform.ambientSH[0] +
			uniform.ambientSH[1] * n.x +
			uniform.ambientSH[2] * n.y +
			uniform.ambientSH[3] * n.z +
			uniform.ambientSH[4] * n.x * n.z +
			uniform.ambientSH[5] * n.z * n.y +
			uniform.ambientSH[6] * n.y * n.x +
			uniform.ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
			uniform.ambientSH[8] * (n.x * n.x - n.y * n.y);
		dDiffuseLight += processEnvironment(max(color, vec3f(0.0)));
	#endif
	#if LIT_AMBIENT_SOURCE == ENVALATLAS
		let dir: vec3f = normalize(cubeMapRotate(worldNormal) * vec3f(-1.0, 1.0, 1.0));
		let uv: vec2f = mapUv(toSphericalUv(dir), vec4f(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);
		let raw: vec4f = textureSample(texture_envAtlas, texture_envAtlasSampler, uv);
		let linear: vec3f = {ambientDecode}(raw);
		dDiffuseLight += processEnvironment(linear);
	#endif
	#if LIT_AMBIENT_SOURCE == CONSTANT
		dDiffuseLight += uniform.light_globalAmbient;
	#endif
}
`,U8=`
#ifdef LIT_GGX_SPECULAR
	uniform material_anisotropyIntensity: f32;
	uniform material_anisotropyRotation: vec2f;
#endif
fn getAnisotropy() {
	dAnisotropy = 0.0;
	dAnisotropyRotation = vec2f(1.0, 0.0);
#ifdef LIT_GGX_SPECULAR
	dAnisotropy = uniform.material_anisotropyIntensity;
	dAnisotropyRotation = uniform.material_anisotropyRotation;
#endif
#ifdef STD_ANISOTROPY_TEXTURE
	let anisotropyTex: vec3f = textureSampleBias({STD_ANISOTROPY_TEXTURE_NAME}, {STD_ANISOTROPY_TEXTURE_NAME}Sampler, {STD_ANISOTROPY_TEXTURE_UV}, uniform.textureBias).rgb;
	dAnisotropy *= anisotropyTex.b;
	let anisotropyRotationFromTex: vec2f = anisotropyTex.rg * 2.0 - vec2f(1.0);
	let rotationMatrix: mat2x2f = mat2x2f(dAnisotropyRotation.x, dAnisotropyRotation.y, -dAnisotropyRotation.y, dAnisotropyRotation.x);
	dAnisotropyRotation = rotationMatrix * anisotropyRotationFromTex;
#endif
	dAnisotropy = clamp(dAnisotropy, 0.0, 1.0);
}
`,z8=`
#if defined(STD_AO_TEXTURE) || defined(STD_AO_VERTEX)
	uniform material_aoIntensity: f32;
#endif
#ifdef STD_AODETAIL_TEXTURE
	#include "detailModesPS"
#endif
fn getAO() {
	dAo = 1.0;
	#ifdef STD_AO_TEXTURE
		var aoBase: f32 = textureSampleBias({STD_AO_TEXTURE_NAME}, {STD_AO_TEXTURE_NAME}Sampler, {STD_AO_TEXTURE_UV}, uniform.textureBias).{STD_AO_TEXTURE_CHANNEL};
		#ifdef STD_AODETAIL_TEXTURE
			var aoDetail: f32 = textureSampleBias({STD_AODETAIL_TEXTURE_NAME}, {STD_AODETAIL_TEXTURE_NAME}Sampler, {STD_AODETAIL_TEXTURE_UV}, uniform.textureBias).{STD_AODETAIL_TEXTURE_CHANNEL};
			aoBase = detailMode_{STD_AODETAIL_DETAILMODE}(vec3f(aoBase), vec3f(aoDetail)).r;
		#endif
		dAo = dAo * aoBase;
	#endif
	#ifdef STD_AO_VERTEX
		dAo = dAo * saturate(vVertexColor.{STD_AO_VERTEX_CHANNEL});
	#endif
	#if defined(STD_AO_TEXTURE) || defined(STD_AO_VERTEX)
		dAo = mix(1.0, dAo, uniform.material_aoIntensity);
	#endif
}
`,k8=`
fn occludeDiffuse(ao: f32) {
	dDiffuseLight = dDiffuseLight * ao;
}
`,V8=`
#if LIT_OCCLUDE_SPECULAR != NONE
	#ifdef LIT_OCCLUDE_SPECULAR_FLOAT
		uniform material_occludeSpecularIntensity: f32;
	#endif
#endif
fn occludeSpecular(gloss: f32, ao: f32, worldNormal: vec3f, viewDir: vec3f) {
	#if LIT_OCCLUDE_SPECULAR == AO
		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT
			var specOcc: f32 = mix(1.0, ao, uniform.material_occludeSpecularIntensity);
		#else
			var specOcc: f32 = ao;
		#endif
	#endif
	#if LIT_OCCLUDE_SPECULAR == GLOSSDEPENDENT
		var specPow: f32 = exp2(gloss * 11.0);
		var specOcc: f32 = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01 * specPow) - 1.0 + ao);
		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT
			specOcc = mix(1.0, specOcc, uniform.material_occludeSpecularIntensity);
		#endif
	#endif
	#if LIT_OCCLUDE_SPECULAR != NONE
		dSpecularLight = dSpecularLight * specOcc;
		dReflection = dReflection * specOcc;
		#ifdef LIT_SHEEN
			sSpecularLight = sSpecularLight * specOcc;
			sReflection = sReflection * specOcc;
		#endif
	#endif
}
`,G8=`
	let dirLm = textureSample(texture_dirLightMap, texture_dirLightMapSampler, vUv1);
	if (uniform.bakeDir > 0.5) {
		if (dAtten > 0.00001) {
			let unpacked_dir = dirLm.xyz * 2.0 - vec3f(1.0);
			dAtten = clamp(dAtten, 0.0, 1.0);
			let combined_dir = dLightDirNormW.xyz * dAtten + unpacked_dir * dirLm.w;
			let finalRgb = normalize(combined_dir) * 0.5 + vec3f(0.5);
			let finalA = max(dirLm.w + dAtten, 1.0 / 255.0);
			output.color = vec4f(finalRgb, finalA);
		} else {
			output.color = dirLm;
		}
	} else {
		let alpha_min = select(0.0, 1.0 / 255.0, dAtten > 0.00001);
		let finalA = max(dirLm.w, alpha_min);
		output.color = vec4f(dirLm.rgb, finalA);
	}
`,H8=`
#ifdef LIT_LIGHTMAP_BAKING_ADD_AMBIENT
	dDiffuseLight = ((dDiffuseLight - 0.5) * max(uniform.ambientBakeOcclusionContrast + 1.0, 0.0)) + 0.5;
	dDiffuseLight = dDiffuseLight + vec3f(uniform.ambientBakeOcclusionBrightness);
	dDiffuseLight = saturate3(dDiffuseLight);
	dDiffuseLight = dDiffuseLight * dAmbientLight;
#endif
#ifdef LIGHTMAP_RGBM
	var temp_color_rgbm = vec4f(dDiffuseLight, 1.0);
	temp_color_rgbm = vec4f(pow(temp_color_rgbm.rgb, vec3f(0.5)), temp_color_rgbm.a);
	temp_color_rgbm = vec4f(temp_color_rgbm.rgb / 8.0, temp_color_rgbm.a);
	let max_g_b = max(temp_color_rgbm.g, max(temp_color_rgbm.b, 1.0 / 255.0));
	let max_rgb = max(temp_color_rgbm.r, max_g_b);
	temp_color_rgbm.a = clamp(max_rgb, 0.0, 1.0);
	temp_color_rgbm.a = ceil(temp_color_rgbm.a * 255.0) / 255.0;
	temp_color_rgbm = vec4f(temp_color_rgbm.rgb / temp_color_rgbm.a, temp_color_rgbm.a);
	output.color = temp_color_rgbm;
#else
	output.color = vec4f(dDiffuseLight, 1.0);
#endif
`,W8=`
uniform view_position: vec3f;
uniform light_globalAmbient: vec3f;
fn square(x: f32) -> f32 {
	return x*x;
}
fn saturate(x: f32) -> f32 {
	return clamp(x, 0.0, 1.0);
}
fn saturate3(x: vec3f) -> vec3f {
	return clamp(x, vec3f(0.0), vec3f(1.0));
}
`,X8=`
#define NINESLICED
varying vMask: vec2f;
varying vTiledUv: vec2f;
uniform innerOffset: vec4f;
uniform outerScale: vec2f;
uniform atlasRect: vec4f;
var<private> nineSlicedUv: vec2f;
`,q8=`
#define NINESLICED
#define NINESLICETILED
varying vMask: vec2f;
varying vTiledUv: vec2f;
uniform innerOffset: vec4f;
uniform outerScale: vec2f;
uniform atlasRect: vec4f;
var<private> nineSlicedUv: vec2f;
`,Y8=`
fn bayer2(p: vec2f) -> f32 {
	return (2.0 * p.y + p.x + 1.0) % 4.0;
}
fn bayer4(p: vec2f) -> f32 {
	let p1: vec2f = p % vec2f(2.0);
	let p2: vec2f = floor(0.5 * (p % vec2f(4.0)));
	return 4.0 * bayer2(p1) + bayer2(p2);
}
fn bayer8(p: vec2f) -> f32 {
	let p1: vec2f = p % vec2f(2.0);
	let p2: vec2f = floor(0.5 * (p % vec2f(4.0)));
	let p4: vec2f = floor(0.25 * (p % vec2f(8.0)));
	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);
}
`,j8=`
varying vUv0: vec2f;
var source: texture_2d<f32>;
var sourceSampler: sampler;
#ifdef GAUSS
	uniform weight: array<f32, {SAMPLES}>;
#endif
uniform pixelOffset: vec2f;
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	var moments: vec3f = vec3f(0.0);
	let uv: vec2f = input.vUv0 - uniform.pixelOffset * (f32({SAMPLES}) * 0.5);
	for (var i: i32 = 0; i < {SAMPLES}; i = i + 1) {
		let c: vec4f = textureSample(source, sourceSampler, uv + uniform.pixelOffset * f32(i));
		#ifdef GAUSS
			moments = moments + c.xyz * uniform.weight[i].element;
		#else
			moments = moments + c.xyz;
		#endif
	}
	#ifndef GAUSS
		moments = moments * (1.0 / f32({SAMPLES}));
	#endif
	output.color = vec4f(moments, 1.0);
	return output;
}
`,$8=`
uniform material_clearCoat: f32;
fn getClearCoat() {
	ccSpecularity = uniform.material_clearCoat;
	#ifdef STD_CLEARCOAT_TEXTURE
	ccSpecularity = ccSpecularity * textureSampleBias({STD_CLEARCOAT_TEXTURE_NAME}, {STD_CLEARCOAT_TEXTURE_NAME}Sampler, {STD_CLEARCOAT_TEXTURE_UV}, uniform.textureBias).{STD_CLEARCOAT_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_CLEARCOAT_VERTEX
	ccSpecularity = ccSpecularity * saturate(vVertexColor.{STD_CLEARCOAT_VERTEX_CHANNEL});
	#endif
}
`,K8=`
	uniform material_clearCoatGloss: f32;
fn getClearCoatGlossiness() {
	ccGlossiness = uniform.material_clearCoatGloss;
	#ifdef STD_CLEARCOATGLOSS_TEXTURE
	ccGlossiness = ccGlossiness * textureSampleBias({STD_CLEARCOATGLOSS_TEXTURE_NAME}, {STD_CLEARCOATGLOSS_TEXTURE_NAME}Sampler, {STD_CLEARCOATGLOSS_TEXTURE_UV}, uniform.textureBias).{STD_CLEARCOATGLOSS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_CLEARCOATGLOSS_VERTEX
	ccGlossiness = ccGlossiness * saturate(vVertexColor.{STD_CLEARCOATGLOSS_VERTEX_CHANNEL});
	#endif
	#ifdef STD_CLEARCOATGLOSS_INVERT
	ccGlossiness = 1.0 - ccGlossiness;
	#endif
	ccGlossiness += 0.0000001;
}
`,Z8=`
#ifdef STD_CLEARCOATNORMAL_TEXTURE
	uniform material_clearCoatBumpiness: f32;
#endif
fn getClearCoatNormal() {
#ifdef STD_CLEARCOATNORMAL_TEXTURE
	var normalMap: vec3f = {STD_CLEARCOATNORMAL_TEXTURE_DECODE}(textureSampleBias({STD_CLEARCOATNORMAL_TEXTURE_NAME}, {STD_CLEARCOATNORMAL_TEXTURE_NAME}Sampler, {STD_CLEARCOATNORMAL_TEXTURE_UV}, uniform.textureBias));
	normalMap = mix(vec3f(0.0, 0.0, 1.0), normalMap, uniform.material_clearCoatBumpiness);
	ccNormalW = normalize(dTBN * normalMap);
#else
	ccNormalW = dVertexNormalW;
#endif
}
`,Q8=`
struct FaceCoords {
	uv: vec2f,
	faceIndex: f32,
	tileOffset: vec2f,
}
fn getCubemapFaceCoordinates(dir: vec3f) -> FaceCoords {
	var faceIndex: f32;
	var tileOffset: vec2f;
	var uv: vec2f;
	let vAbs: vec3f = abs(dir);
	var ma: f32;
	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {
		let is_neg_z = dir.z < 0.0;
		faceIndex = select(4.0, 5.0, is_neg_z);
		ma = 0.5 / vAbs.z;
		uv = vec2f(select(dir.x, -dir.x, is_neg_z), -dir.y);
		tileOffset = vec2f(2.0, select(0.0, 1.0, is_neg_z));
	} else if (vAbs.y >= vAbs.x) {
		let is_neg_y = dir.y < 0.0;
		faceIndex = select(2.0, 3.0, is_neg_y);
		ma = 0.5 / vAbs.y;
		uv = vec2f(dir.x, select(dir.z, -dir.z, is_neg_y));
		tileOffset = vec2f(1.0, select(0.0, 1.0, is_neg_y));
	} else {
		let is_neg_x = dir.x < 0.0;
		faceIndex = select(0.0, 1.0, is_neg_x);
		ma = 0.5 / vAbs.x;
		uv = vec2f(select(-dir.z, dir.z, is_neg_x), -dir.y);
		tileOffset = vec2f(0.0, select(0.0, 1.0, is_neg_x));
	}
	uv = uv * ma + 0.5;
	return FaceCoords(uv, faceIndex, tileOffset);
}
fn getCubemapAtlasCoordinates(omniAtlasViewport: vec3f, shadowEdgePixels: f32, shadowTextureResolution: f32, dir: vec3f) -> vec2f {
	let faceData: FaceCoords = getCubemapFaceCoordinates(dir);
	var uv: vec2f = faceData.uv;
	let tileOffset: vec2f = faceData.tileOffset;
	let atlasFaceSize: f32 = omniAtlasViewport.z;
	let tileSize: f32 = shadowTextureResolution * atlasFaceSize;
	var offset: f32 = shadowEdgePixels / tileSize;
	uv = uv * (1.0 - offset * 2.0) + offset;
	uv = uv * atlasFaceSize;
	uv = uv + tileOffset * atlasFaceSize;
	uv = uv + omniAtlasViewport.xy;
	return uv;
}
`,J8=`
fn _getCookieClustered(tex: texture_2d<f32>, texSampler: sampler, uv: vec2f, intensity: f32, cookieChannel: vec4f) -> vec3f {
	let pixel: vec4f = mix(vec4f(1.0), textureSampleLevel(tex, texSampler, uv, 0.0), intensity);
	let isRgb: bool = dot(cookieChannel.rgb, vec3f(1.0)) == 3.0;
	return select(vec3f(dot(pixel, cookieChannel)), pixel.rgb, isRgb);
}
fn getCookie2DClustered(tex: texture_2d<f32>, texSampler: sampler, transform: mat4x4f, worldPosition: vec3f, intensity: f32, cookieChannel: vec4f) -> vec3f {
	let projPos: vec4f = transform * vec4f(worldPosition, 1.0);
	return _getCookieClustered(tex, texSampler, projPos.xy / projPos.w, intensity, cookieChannel);
}
fn getCookieCubeClustered(tex: texture_2d<f32>, texSampler: sampler, dir: vec3f, intensity: f32, cookieChannel: vec4f, shadowTextureResolution: f32, shadowEdgePixels: f32, omniAtlasViewport: vec3f) -> vec3f {
	let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
	return _getCookieClustered(tex, texSampler, uv, intensity, cookieChannel);
}
`,eX=`
fn _getShadowCoordPerspZbuffer(shadowMatrix: mat4x4f, shadowParams: vec4f, wPos: vec3f) -> vec3f {
	var projPos = shadowMatrix * vec4f(wPos, 1.0);
	return projPos.xyz / projPos.w;
}
fn getShadowCoordPerspZbufferNormalOffset(shadowMatrix: mat4x4f, shadowParams: vec4f, normal: vec3f) -> vec3f {
	let wPos: vec3f = vPositionW + normal * shadowParams.y;
	return _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}
fn normalOffsetPointShadow(shadowParams: vec4f, lightPos: vec3f, lightDir: vec3f, lightDirNorm: vec3f, normal: vec3f) -> vec3f {
	let distScale: f32 = length(lightDir);
	let wPos: vec3f = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
	let dir: vec3f = wPos - lightPos;
	return dir;
}
#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	fn getShadowOmniClusteredPCF1(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowParams: vec4f, omniAtlasViewport: vec3f, shadowEdgePixels: f32, lightDir: vec3f) -> f32 {
		let shadowTextureResolution: f32 = shadowParams.x;
		let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		let shadowZ: f32 = length(lightDir) * shadowParams.w + shadowParams.z;
		return textureSampleCompareLevel(shadowMap, shadowMapSampler, uv, shadowZ);
	}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	fn getShadowOmniClusteredPCF3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowParams: vec4f, omniAtlasViewport: vec3f, shadowEdgePixels: f32, lightDir: vec3f) -> f32 {
		let shadowTextureResolution: f32 = shadowParams.x;
		let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		let shadowZ: f32 = length(lightDir) * shadowParams.w + shadowParams.z;
		let shadowCoord: vec3f = vec3f(uv, shadowZ);
		return getShadowPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams);
	}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	fn getShadowOmniClusteredPCF5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowParams: vec4f, omniAtlasViewport: vec3f, shadowEdgePixels: f32, lightDir: vec3f) -> f32 {
		let shadowTextureResolution: f32 = shadowParams.x;
		let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);
		let shadowZ: f32 = length(lightDir) * shadowParams.w + shadowParams.z;
		let shadowCoord: vec3f = vec3f(uv, shadowZ);
		return getShadowPCF5x5(shadowMap, shadowMapSampler, shadowCoord, shadowParams);
	}
#endif
#if defined(CLUSTER_SHADOW_TYPE_PCF1)
	fn getShadowSpotClusteredPCF1(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
		return textureSampleCompareLevel(shadowMap, shadowMapSampler, shadowCoord.xy, shadowCoord.z);
	}
#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF3)
	fn getShadowSpotClusteredPCF3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
		return getShadowSpotPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams);
	}
#endif
	#if defined(CLUSTER_SHADOW_TYPE_PCF5)
	fn getShadowSpotClusteredPCF5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
		return getShadowPCF5x5(shadowMap, shadowMapSampler, shadowCoord, shadowParams);
	}
#endif
`,tX=`
#include "lightBufferDefinesPS"
#include "clusteredLightUtilsPS"
#ifdef CLUSTER_COOKIES
	#include "clusteredLightCookiesPS"
#endif
#ifdef CLUSTER_SHADOWS
	#include "clusteredLightShadowsPS"
#endif
var clusterWorldTexture: texture_2d<u32>;
var lightsTexture: texture_2d<uff>;
#ifdef CLUSTER_SHADOWS
	var shadowAtlasTexture: texture_depth_2d;
	var shadowAtlasTextureSampler: sampler_comparison;
#endif
#ifdef CLUSTER_COOKIES
	var cookieAtlasTexture: texture_2d<f32>;
	var cookieAtlasTextureSampler: sampler;
#endif
uniform clusterMaxCells: i32;
uniform numClusteredLights: i32;
uniform clusterTextureWidth: i32;
uniform clusterCellsCountByBoundsSize: vec3f;
uniform clusterBoundsMin: vec3f;
uniform clusterBoundsDelta: vec3f;
uniform clusterCellsDot: vec3i;
uniform clusterCellsMax: vec3i;
uniform shadowAtlasParams: vec2f;
struct ClusterLightData {
	flags: u32,
	halfWidth: vec3f,
	isSpot: bool,
	halfHeight: vec3f,
	lightIndex: i32,
	position: vec3f,
	shape: u32,
	direction: vec3f,
	falloffModeLinear: bool,
	color: vec3f,
	shadowIntensity: f32,
	omniAtlasViewport: vec3f,
	range: f32,
	cookieChannelMask: vec4f,
	biasesData: f32,
	colorBFlagsData: u32,
	shadowBias: f32,
	shadowNormalBias: f32,
	anglesData: f32,
	innerConeAngleCos: f32,
	outerConeAngleCos: f32,
	cookieIntensity: f32,
	isDynamic: bool,
	isLightmapped: bool
}
var<private> lightProjectionMatrix: mat4x4f;
fn sampleLightTextureF(lightIndex: i32, index: i32) -> vec4f {
	return textureLoad(lightsTexture, vec2<i32>(index, lightIndex), 0);
}
fn decodeClusterLightCore(clusterLightData: ptr<function, ClusterLightData>, lightIndex: i32) {
	clusterLightData.lightIndex = lightIndex;
	let halfData: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_COLOR_ANGLES_BIAS});
	clusterLightData.anglesData = halfData.z;
	clusterLightData.biasesData = halfData.w;
	clusterLightData.colorBFlagsData = bitcast<u32>(halfData.y);
	let colorRG: vec2f = unpack2x16float(bitcast<u32>(halfData.x));
	let colorB_flags: vec2f = unpack2x16float(clusterLightData.colorBFlagsData);
	clusterLightData.color = vec3f(colorRG, colorB_flags.x) * {LIGHT_COLOR_DIVIDER};
	let lightPosRange: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_POSITION_RANGE});
	clusterLightData.position = lightPosRange.xyz;
	clusterLightData.range = lightPosRange.w;
	let lightDir_Flags: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_DIRECTION_FLAGS});
	clusterLightData.direction = lightDir_Flags.xyz;
	let flags_uint: u32 = bitcast<u32>(lightDir_Flags.w);
	clusterLightData.flags = flags_uint;
	clusterLightData.isSpot = (flags_uint & (1u << 30u)) != 0u;
	clusterLightData.shape = (flags_uint >> 28u) & 0x3u;
	clusterLightData.falloffModeLinear = (flags_uint & (1u << 27u)) == 0u;
	clusterLightData.shadowIntensity = f32((flags_uint >> 0u) & 0xFFu) / 255.0;
	clusterLightData.cookieIntensity = f32((flags_uint >> 8u) & 0xFFu) / 255.0;
	clusterLightData.isDynamic = (flags_uint & (1u << 22u)) != 0u;
	clusterLightData.isLightmapped = (flags_uint & (1u << 21u)) != 0u;
}
fn decodeClusterLightSpot(clusterLightData: ptr<function, ClusterLightData>) {
	let angleFlags: u32 = (clusterLightData.colorBFlagsData >> 16u) & 0xFFFFu;
	let angleValues: vec2f = unpack2x16float(bitcast<u32>(clusterLightData.anglesData));
	let innerVal: f32 = angleValues.x;
	let outerVal: f32 = angleValues.y;
	let innerIsVersine: bool = (angleFlags & 1u) != 0u;
	let outerIsVersine: bool = ((angleFlags >> 1u) & 1u) != 0u;
	clusterLightData.innerConeAngleCos = select(innerVal, 1.0 - innerVal, innerIsVersine);
	clusterLightData.outerConeAngleCos = select(outerVal, 1.0 - outerVal, outerIsVersine);
}
fn decodeClusterLightOmniAtlasViewport(clusterLightData: ptr<function, ClusterLightData>) {
	clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_PROJ_MAT_0}).xyz;
}
fn decodeClusterLightAreaData(clusterLightData: ptr<function, ClusterLightData>) {
	clusterLightData.halfWidth = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_AREA_DATA_WIDTH}).xyz;
	clusterLightData.halfHeight = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_AREA_DATA_HEIGHT}).xyz;
}
fn decodeClusterLightProjectionMatrixData(clusterLightData: ptr<function, ClusterLightData>) {
	let m0: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_PROJ_MAT_0});
	let m1: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_PROJ_MAT_1});
	let m2: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_PROJ_MAT_2});
	let m3: vec4f = sampleLightTextureF(clusterLightData.lightIndex, {CLUSTER_TEXTURE_PROJ_MAT_3});
	lightProjectionMatrix = mat4x4f(m0, m1, m2, m3);
}
fn decodeClusterLightShadowData(clusterLightData: ptr<function, ClusterLightData>) {
	let biases: vec2f = unpack2x16float(bitcast<u32>(clusterLightData.biasesData));
	clusterLightData.shadowBias = biases.x;
	clusterLightData.shadowNormalBias = biases.y;
}
fn decodeClusterLightCookieData(clusterLightData: ptr<function, ClusterLightData>) {
	let cookieFlags: u32 = (clusterLightData.flags >> 23u) & 0x0Fu;
	let mask_uvec: vec4<u32> = vec4<u32>(cookieFlags) & vec4<u32>(1u, 2u, 4u, 8u);
	clusterLightData.cookieChannelMask = step(vec4f(1.0), vec4f(mask_uvec));
}
fn evaluateLight(
	light: ptr<function, ClusterLightData>,
	worldNormal: vec3f,
	viewDir: vec3f,
	reflectionDir: vec3f,
#if defined(LIT_CLEARCOAT)
	clearcoatReflectionDir: vec3f,
#endif
	gloss: f32,
	specularity: vec3f,
	geometricNormal: vec3f,
	tbn: mat3x3f,
#if defined(LIT_IRIDESCENCE)
	iridescenceFresnel: vec3f,
#endif
	clearcoat_worldNormal: vec3f,
	clearcoat_gloss: f32,
	sheen_gloss: f32,
	iridescence_intensity: f32
) {
	var cookieAttenuation: vec3f = vec3f(1.0);
	var diffuseAttenuation: f32 = 1.0;
	var falloffAttenuation: f32 = 1.0;
	let lightDirW: vec3f = evalOmniLight(light.position);
	let lightDirNormW: vec3f = normalize(lightDirW);
	#ifdef CLUSTER_AREALIGHTS
	if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {
		decodeClusterLightAreaData(light);
		if (light.shape == {LIGHTSHAPE_RECT}) {
			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
		} else if (light.shape == {LIGHTSHAPE_DISK}) {
			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
		} else {
			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
		}
		falloffAttenuation = getFalloffWindow(light.range, lightDirW);
	} else
	#endif
	{
		if (light.falloffModeLinear) {
			falloffAttenuation = getFalloffLinear(light.range, lightDirW);
		} else {
			falloffAttenuation = getFalloffInvSquared(light.range, lightDirW);
		}
	}
	if (falloffAttenuation > 0.00001) {
		#ifdef CLUSTER_AREALIGHTS
		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {
			if (light.shape == {LIGHTSHAPE_RECT}) {
				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;
			} else if (light.shape == {LIGHTSHAPE_DISK}) {
				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;
			} else {
				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;
			}
		} else
		#endif
		{
			falloffAttenuation = falloffAttenuation * getLightDiffuse(worldNormal, viewDir, lightDirNormW);
		}
		if (light.isSpot) {
			decodeClusterLightSpot(light);
			falloffAttenuation = falloffAttenuation * getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, lightDirNormW);
		}
		#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)
		if (falloffAttenuation > 0.00001) {
			if (light.shadowIntensity > 0.0 || light.cookieIntensity > 0.0) {
				if (light.isSpot) {
					decodeClusterLightProjectionMatrixData(light);
				} else {
					decodeClusterLightOmniAtlasViewport(light);
				}
				let shadowTextureResolution: f32 = uniform.shadowAtlasParams.x;
				let shadowEdgePixels: f32 = uniform.shadowAtlasParams.y;
				#ifdef CLUSTER_COOKIES
				if (light.cookieIntensity > 0.0) {
					decodeClusterLightCookieData(light);
					if (light.isSpot) {
						cookieAttenuation = getCookie2DClustered(cookieAtlasTexture, cookieAtlasTextureSampler, lightProjectionMatrix, vPositionW, light.cookieIntensity, light.cookieChannelMask);
					} else {
						cookieAttenuation = getCookieCubeClustered(cookieAtlasTexture, cookieAtlasTextureSampler, lightDirW, light.cookieIntensity, light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
					}
				}
				#endif
				#ifdef CLUSTER_SHADOWS
				if (light.shadowIntensity > 0.0) {
					decodeClusterLightShadowData(light);
					let shadowParams: vec4f = vec4f(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);
					if (light.isSpot) {
						let shadowCoord: vec3f = getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							let shadow: f32 = getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowAtlasTextureSampler, shadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							let shadow: f32 = getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowAtlasTextureSampler, shadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							let shadow: f32 = getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowAtlasTextureSampler, shadowCoord, shadowParams);
						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
							let shadow: f32 = getShadowSpotClusteredPCSS(shadowAtlasTexture, shadowAtlasTextureSampler, shadowCoord, shadowParams);
						#endif
						falloffAttenuation = falloffAttenuation * mix(1.0, shadow, light.shadowIntensity);
					} else {
						let dir: vec3f = normalOffsetPointShadow(shadowParams, light.position, lightDirW, lightDirNormW, geometricNormal);
						#if defined(CLUSTER_SHADOW_TYPE_PCF1)
							let shadow: f32 = getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowAtlasTextureSampler, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
							let shadow: f32 = getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowAtlasTextureSampler, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
							let shadow: f32 = getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowAtlasTextureSampler, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
						#endif
						falloffAttenuation = falloffAttenuation * mix(1.0, shadow, light.shadowIntensity);
					}
				}
				#endif
			}
		}
		#endif
		#ifdef CLUSTER_AREALIGHTS
		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {
			{
				var areaDiffuse: vec3f = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;
				#if defined(LIT_SPECULAR)
					areaDiffuse = mix(areaDiffuse, vec3f(0.0), dLTCSpecFres);
				#endif
				dDiffuseLight = dDiffuseLight + areaDiffuse;
			}
			#ifdef LIT_SPECULAR
				var areaLightSpecular: f32;
				if (light.shape == {LIGHTSHAPE_RECT}) {
					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
				} else if (light.shape == {LIGHTSHAPE_DISK}) {
					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
				} else {
					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
				}
				dSpecularLight = dSpecularLight + dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;
				#ifdef LIT_CLEARCOAT
					var areaLightSpecularCC: f32;
					if (light.shape == {LIGHTSHAPE_RECT}) {
						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
					} else if (light.shape == {LIGHTSHAPE_DISK}) {
						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
					} else {
						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
					}
					ccSpecularLight = ccSpecularLight + ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;
				#endif
			#endif
		} else
		#endif
		{
			{
				var punctualDiffuse: vec3f = falloffAttenuation * light.color * cookieAttenuation;
				#if defined(CLUSTER_AREALIGHTS)
				#if defined(LIT_SPECULAR)
					punctualDiffuse = mix(punctualDiffuse, vec3f(0.0), specularity);
				#endif
				#endif
				dDiffuseLight = dDiffuseLight + punctualDiffuse;
			}
			#ifdef LIT_SPECULAR
				let halfDir: vec3f = normalize(-lightDirNormW + viewDir);
				#ifdef LIT_SPECULAR_FRESNEL
					dSpecularLight = dSpecularLight +
						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation *
						getFresnel(
							dot(viewDir, halfDir),
							gloss,
							specularity
						#if defined(LIT_IRIDESCENCE)
							, iridescenceFresnel,
							iridescence_intensity
						#endif
							);
				#else
					dSpecularLight = dSpecularLight + getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
				#endif
				#ifdef LIT_CLEARCOAT
					#ifdef LIT_SPECULAR_FRESNEL
						ccSpecularLight = ccSpecularLight + getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
					#else
						ccSpecularLight = ccSpecularLight + getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation;
					#endif
				#endif
				#ifdef LIT_SHEEN
					sSpecularLight = sSpecularLight + getLightSpecularSheen(halfDir, worldNormal, viewDir, lightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
				#endif
			#endif
		}
	}
	dAtten = falloffAttenuation;
	dLightDirNormW = lightDirNormW;
}
fn evaluateClusterLight(
	lightIndex: i32,
	worldNormal: vec3f,
	viewDir: vec3f,
	reflectionDir: vec3f,
#if defined(LIT_CLEARCOAT)
	clearcoatReflectionDir: vec3f,
#endif
	gloss: f32,
	specularity: vec3f,
	geometricNormal: vec3f,
	tbn: mat3x3f,
#if defined(LIT_IRIDESCENCE)
	iridescenceFresnel: vec3f,
#endif
	clearcoat_worldNormal: vec3f,
	clearcoat_gloss: f32,
	sheen_gloss: f32,
	iridescence_intensity: f32
) {
	var clusterLightData: ClusterLightData;
	decodeClusterLightCore(&clusterLightData, lightIndex);
	#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
		let acceptLightMask: bool = clusterLightData.isDynamic;
	#else
		let acceptLightMask: bool = clusterLightData.isLightmapped;
	#endif
	if (acceptLightMask) {
		evaluateLight(
			&clusterLightData,
			worldNormal,
			viewDir,
			reflectionDir,
#if defined(LIT_CLEARCOAT)
			clearcoatReflectionDir,
#endif
			gloss,
			specularity,
			geometricNormal,
			tbn,
#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel,
#endif
			clearcoat_worldNormal,
			clearcoat_gloss,
			sheen_gloss,
			iridescence_intensity
		);
	}
}
fn addClusteredLights(
	worldNormal: vec3f,
	viewDir: vec3f,
	reflectionDir: vec3f,
#if defined(LIT_CLEARCOAT)
	clearcoatReflectionDir: vec3f,
#endif
	gloss: f32,
	specularity: vec3f,
	geometricNormal: vec3f,
	tbn: mat3x3f,
#if defined(LIT_IRIDESCENCE)
	iridescenceFresnel: vec3f,
#endif
	clearcoat_worldNormal: vec3f,
	clearcoat_gloss: f32,
	sheen_gloss: f32,
	iridescence_intensity: f32
) {
	if (uniform.numClusteredLights <= 1) {
		return;
	}
	let cellCoords: vec3i = vec3i(floor((vPositionW - uniform.clusterBoundsMin) * uniform.clusterCellsCountByBoundsSize));
	if (!(any(cellCoords < vec3i(0)) || any(cellCoords >= uniform.clusterCellsMax))) {
		let cellIndex: i32 = cellCoords.x * uniform.clusterCellsDot.x + cellCoords.y * uniform.clusterCellsDot.y + cellCoords.z * uniform.clusterCellsDot.z;
		let clusterV: i32 = cellIndex / uniform.clusterTextureWidth;
		let clusterU: i32 = cellIndex - clusterV * uniform.clusterTextureWidth;
		for (var lightCellIndex: i32 = 0; lightCellIndex < uniform.clusterMaxCells; lightCellIndex = lightCellIndex + 1) {
			let lightIndex: u32 = textureLoad(clusterWorldTexture, vec2<i32>(clusterU + lightCellIndex, clusterV), 0).r;
			if (lightIndex == 0u) {
				break;
			}
			evaluateClusterLight(
				i32(lightIndex),
				worldNormal,
				viewDir,
				reflectionDir,
#if defined(LIT_CLEARCOAT)
				clearcoatReflectionDir,
#endif
				gloss,
				specularity,
				geometricNormal,
				tbn,
#if defined(LIT_IRIDESCENCE)
				iridescenceFresnel,
#endif
				clearcoat_worldNormal,
				clearcoat_gloss,
				sheen_gloss,
				iridescence_intensity
			);
		}
	}
}`,sX=`
fn combineColor(albedo: vec3f, sheenSpecularity: vec3f, clearcoatSpecularity: f32) -> vec3f {
	var ret: vec3f = vec3f(0.0);
	#ifdef LIT_OLD_AMBIENT
		ret = ret + ((dDiffuseLight - uniform.light_globalAmbient) * albedo + uniform.material_ambient * uniform.light_globalAmbient);
	#else
		ret = ret + (albedo * dDiffuseLight);
	#endif
	#ifdef LIT_SPECULAR
		ret = ret + dSpecularLight;
	#endif
	#ifdef LIT_REFLECTIONS
		ret = ret + (dReflection.rgb * dReflection.a);
	#endif
	#ifdef LIT_SHEEN
		let sheenScaling: f32 = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
		ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
	#endif
	#ifdef LIT_CLEARCOAT
		let clearCoatScaling: f32 = 1.0 - ccFresnel * clearcoatSpecularity;
		ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection) * clearcoatSpecularity;
	#endif
	return ret;
}
`,iX=`
	varying uv0: vec2f;
	var blitTexture: texture_2d<f32>;
	var blitTextureSampler : sampler;
	@fragment
	fn fragmentMain(input : FragmentInput) -> FragmentOutput {
		var output: FragmentOutput;
		output.color = textureSample(blitTexture, blitTextureSampler, input.uv0);
		return output;
	}
`,rX=`
	varying uv0: vec2f;
	uniform invViewProj: mat4x4<f32>;
	var blitTexture: texture_cube<f32>;
	var blitTextureSampler : sampler;
	@fragment
	fn fragmentMain(input : FragmentInput) -> FragmentOutput {
		var output: FragmentOutput;
		var projPos = vec4f(input.uv0 * 2.0 - 1.0, 0.5, 1.0);
		var worldPos = uniform.invViewProj * projPos;
		output.color = textureSample(blitTexture, blitTextureSampler, worldPos.xyz);
		return output;
	}
`,aX=`
	attribute vertex_position: vec2f;
	varying uv0: vec2f;
	@vertex
	fn vertexMain(input: VertexInput) -> VertexOutput {
		var output: VertexOutput;
		output.position = vec4f(input.vertex_position, 0.5, 1.0);
		output.uv0 = input.vertex_position * 0.5 + vec2f(0.5, 0.5);
		output.uv0.y = 1.0 - output.uv0.y;
		return output;
	}
`,nX=`
#if LIT_CUBEMAP_PROJECTION == BOX
	uniform envBoxMin: vec3f;
	uniform envBoxMax: vec3f;
#endif
fn cubeMapProject(nrdir: vec3f) -> vec3f {
	#if LIT_CUBEMAP_PROJECTION == NONE
		return cubeMapRotate(nrdir);
	#endif
	#if LIT_CUBEMAP_PROJECTION == BOX
		let nrdir_rotated: vec3f = cubeMapRotate(nrdir);
		let rbmax: vec3f = (uniform.envBoxMax - vPositionW) / nrdir_rotated;
		let rbmin: vec3f = (uniform.envBoxMin - vPositionW) / nrdir_rotated;
		let rbminmax: vec3f = select(rbmin, rbmax, nrdir_rotated > vec3f(0.0));
		let fa: f32 = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
		let posonbox: vec3f = vPositionW + nrdir_rotated * fa;
		let envBoxPos: vec3f = (uniform.envBoxMin + uniform.envBoxMax) * 0.5;
		return normalize(posonbox - envBoxPos);
	#endif
}
`,oX=`
#ifdef CUBEMAP_ROTATION
uniform cubeMapRotationMatrix: mat3x3f;
#endif
fn cubeMapRotate(refDir: vec3f) -> vec3f {
#ifdef CUBEMAP_ROTATION
	return refDir * uniform.cubeMapRotationMatrix;
#else
	return refDir;
#endif
}
`,lX=`
#ifdef DEBUG_ALBEDO_PASS
output.color = vec4(gammaCorrectOutput(dAlbedo), 1.0);
#endif
#ifdef DEBUG_UV0_PASS
output.color = vec4f(litArgs_albedo , 1.0);
#endif
#ifdef DEBUG_WORLD_NORMAL_PASS
output.color = vec4f(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif
#ifdef DEBUG_OPACITY_PASS
output.color = vec4f(vec3f(litArgs_opacity) , 1.0);
#endif
#ifdef DEBUG_SPECULARITY_PASS
output.color = vec4f(litArgs_specularity, 1.0);
#endif
#ifdef DEBUG_GLOSS_PASS
output.color = vec4f(vec3f(litArgs_gloss) , 1.0);
#endif
#ifdef DEBUG_METALNESS_PASS
output.color = vec4f(vec3f(litArgs_metalness) , 1.0);
#endif
#ifdef DEBUG_AO_PASS
output.color = vec4f(vec3f(litArgs_ao) , 1.0);
#endif
#ifdef DEBUG_EMISSION_PASS
output.color = vec4f(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`,cX=`
#ifdef DEBUG_LIGHTING_PASS
	litArgs_albedo = vec3f(0.5);
#endif
#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
	litArgs_albedo = vec3f(vUv0, 0.0);
#else
	litArgs_albedo = vec3f(0.0);
#endif
#endif
`,hX=`
#ifndef _DECODE_INCLUDED_
#define _DECODE_INCLUDED_
fn decodeLinear(raw: vec4f) -> vec3f {
	return raw.rgb;
}
fn decodeGammaFloat(raw: f32) -> f32 {
	return pow(raw, 2.2);
}
fn decodeGamma3(raw: vec3f) -> vec3f {
	return pow(raw, vec3f(2.2));
}
fn decodeGamma(raw: vec4f) -> vec3f {
	return pow(raw.xyz, vec3f(2.2));
}
fn decodeRGBM(raw: vec4f) -> vec3f {
	let color = (8.0 * raw.a) * raw.rgb;
	return color * color;
}
fn decodeRGBP(raw: vec4f) -> vec3f {
	let color = raw.rgb * (-raw.a * 7.0 + 8.0);
	return color * color;
}
fn decodeRGBE(raw: vec4f) -> vec3f {
	return select(vec3f(0.0), raw.xyz * pow(2.0, raw.w * 255.0 - 128.0), raw.a != 0.0);
}
fn passThrough(raw: vec4f) -> vec4f {
	return raw;
}
fn unpackNormalXYZ(nmap: vec4f) -> vec3f {
	return nmap.xyz * 2.0 - 1.0;
}
fn unpackNormalXY(nmap: vec4f) -> vec3f {
	var xy = nmap.wy * 2.0 - 1.0;
	return vec3f(xy, sqrt(1.0 - clamp(dot(xy, xy), 0.0, 1.0)));
}
#endif
`,uX=`
#ifndef _DETAILMODES_INCLUDED_
#define _DETAILMODES_INCLUDED_
fn detailMode_mul(c1: vec3f, c2: vec3f) -> vec3f {
	return c1 * c2;
}
fn detailMode_add(c1: vec3f, c2: vec3f) -> vec3f {
	return c1 + c2;
}
fn detailMode_screen(c1: vec3f, c2: vec3f) -> vec3f {
	return 1.0 - (1.0 - c1)*(1.0 - c2);
}
fn detailMode_overlay(c1: vec3f, c2: vec3f) -> vec3f {
	return mix(1.0 - 2.0 * (1.0 - c1)*(1.0 - c2), 2.0 * c1 * c2, step(c1, vec3f(0.5)));
}
fn detailMode_min(c1: vec3f, c2: vec3f) -> vec3f {
	return min(c1, c2);
}
fn detailMode_max(c1: vec3f, c2: vec3f) -> vec3f {
	return max(c1, c2);
}
#endif
`,dX=`
uniform material_diffuse: vec3f;
#ifdef STD_DIFFUSEDETAIL_TEXTURE
	#include "detailModesPS"
#endif
fn getAlbedo() {
	dAlbedo = uniform.material_diffuse.rgb;
	#ifdef STD_DIFFUSE_TEXTURE
		var albedoTexture: vec3f = {STD_DIFFUSE_TEXTURE_DECODE}(textureSampleBias({STD_DIFFUSE_TEXTURE_NAME}, {STD_DIFFUSE_TEXTURE_NAME}Sampler, {STD_DIFFUSE_TEXTURE_UV}, uniform.textureBias)).{STD_DIFFUSE_TEXTURE_CHANNEL};
		#ifdef STD_DIFFUSEDETAIL_TEXTURE
			var albedoDetail: vec3f = {STD_DIFFUSEDETAIL_TEXTURE_DECODE}(textureSampleBias({STD_DIFFUSEDETAIL_TEXTURE_NAME}, {STD_DIFFUSEDETAIL_TEXTURE_NAME}Sampler, {STD_DIFFUSEDETAIL_TEXTURE_UV}, uniform.textureBias)).{STD_DIFFUSEDETAIL_TEXTURE_CHANNEL};
			albedoTexture = detailMode_{STD_DIFFUSEDETAIL_DETAILMODE}(albedoTexture, albedoDetail);
		#endif
		dAlbedo = dAlbedo * albedoTexture;
	#endif
	#ifdef STD_DIFFUSE_VERTEX
		dAlbedo = dAlbedo * saturate3(vVertexColor.{STD_DIFFUSE_VERTEX_CHANNEL});
	#endif
}
`,fX=`
uniform material_emissive: vec3f;
uniform material_emissiveIntensity: f32;
fn getEmission() {
	dEmission = uniform.material_emissive * uniform.material_emissiveIntensity;
	#ifdef STD_EMISSIVE_TEXTURE
	dEmission *= {STD_EMISSIVE_TEXTURE_DECODE}(textureSampleBias({STD_EMISSIVE_TEXTURE_NAME}, {STD_EMISSIVE_TEXTURE_NAME}Sampler, {STD_EMISSIVE_TEXTURE_UV}, uniform.textureBias)).{STD_EMISSIVE_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_EMISSIVE_VERTEX
	dEmission = dEmission * saturate3(vVertexColor.{STD_EMISSIVE_VERTEX_CHANNEL});
	#endif
}
`,mX=`
fn encodeLinear(source: vec3f) -> vec4f {
	return vec4f(source, 1.0);
}
fn encodeGamma(source: vec3f) -> vec4f {
	return vec4f(pow(source + vec3f(0.0000001), vec3f(1.0 / 2.2)), 1.0);
}
fn encodeRGBM(source: vec3f) -> vec4f {
	var color: vec3f = pow(source, vec3f(0.5));
	color *= 1.0 / 8.0;
	var a: f32 = saturate(max(max(color.r, color.g), max(color.b, 1.0 / 255.0)));
	a = ceil(a * 255.0) / 255.0;
	color /= a;
	return vec4f(color, a);
}
fn encodeRGBP(source: vec3f) -> vec4f {
	var gamma: vec3f = pow(source, vec3f(0.5));
	var maxVal: f32 = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));
	var v: f32 = 1.0 - ((maxVal - 1.0) / 7.0);
	v = ceil(v * 255.0) / 255.0;
	return vec4f(gamma / (-v * 7.0 + 8.0), v);
}
fn encodeRGBE(source: vec3f) -> vec4f {
	var maxVal: f32 = max(source.x, max(source.y, source.z));
	if (maxVal < 1e-32) {
		return vec4f(0.0, 0.0, 0.0, 0.0);
	} else {
		var e: f32 = ceil(log2(maxVal));
		return vec4f(source / pow(2.0, e), (e + 128.0) / 255.0);
	}
}
`,pX=`
	var finalRgb: vec3f = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);
	finalRgb = finalRgb + litArgs_emission;
	finalRgb = addFog(finalRgb);
	finalRgb = toneMap(finalRgb);
	finalRgb = gammaCorrectOutput(finalRgb);
	output.color = vec4f(finalRgb, output.color.a);
`,_X=`
#ifndef _ENVATLAS_INCLUDED_
#define _ENVATLAS_INCLUDED_
const atlasSize : f32 = 512.0;
const seamSize : f32 = 1.0 / atlasSize;
fn mapUv(uv : vec2f, rect : vec4f) -> vec2f {
	return vec2f(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
				 mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}
fn mapRoughnessUv(uv : vec2f, level : f32) -> vec2f {
	let t : f32 = 1.0 / exp2(level);
	return mapUv(uv, vec4f(0.0, 1.0 - t, t, t * 0.5));
}
fn mapShinyUv(uv : vec2f, level : f32) -> vec2f {
	let t : f32 = 1.0 / exp2(level);
	return mapUv(uv, vec4f(1.0 - t, 1.0 - t, t, t * 0.5));
}
#endif
`,gX=`
#ifdef LIT_SKYBOX_INTENSITY
	uniform skyboxIntensity : f32;
#endif
fn processEnvironment(color : vec3f) -> vec3f {
	#ifdef LIT_SKYBOX_INTENSITY
		return color * uniform.skyboxIntensity;
	#else
		return color;
	#endif
}
`,vX=`
fn getFalloffWindow(lightRadius: f32, lightDir: vec3f) -> f32 {
	let sqrDist: f32 = dot(lightDir, lightDir);
	let invRadius: f32 = 1.0 / lightRadius;
	return square(saturate(1.0 - square(sqrDist * square(invRadius))));
}
fn getFalloffInvSquared(lightRadius: f32, lightDir: vec3f) -> f32 {
	let sqrDist: f32 = dot(lightDir, lightDir);
	var falloff: f32 = 1.0 / (sqrDist + 1.0);
	let invRadius: f32 = 1.0 / lightRadius;
	falloff = falloff * 16.0;
	falloff = falloff * square(saturate(1.0 - square(sqrDist * square(invRadius))));
	return falloff;
}
`,SX=`
fn getFalloffLinear(lightRadius: f32, lightDir: vec3f) -> f32 {
	let d: f32 = length(lightDir);
	return max(((lightRadius - d) / lightRadius), 0.0);
}
`,yX=`
#ifndef FLOAT_AS_UINT
#define FLOAT_AS_UINT
fn float2uint(value: f32) -> vec4f {
	let intBits = bitcast<u32>(value);
	return vec4f(
		f32((intBits >> 24u) & 0xffu),
		f32((intBits >> 16u) & 0xffu),
		f32((intBits >> 8u) & 0xffu),
		f32(intBits & 0xffu)
	) / 255.0;
}
fn uint2float(value: vec4f) -> f32 {
	let rgba_u32 = vec4<u32>(value * 255.0);
	let intBits: u32 =
		(rgba_u32.r << 24u) |
		(rgba_u32.g << 16u) |
		(rgba_u32.b << 8u)  |
		 rgba_u32.a;
	return bitcast<f32>(intBits);
}
fn float2vec4(value: f32) -> vec4f {
	#if defined(CAPS_TEXTURE_FLOAT_RENDERABLE)
		return vec4f(value, 1.0, 1.0, 1.0);
	#else
		return float2uint(value);
	#endif
}
#endif
`,xX=`
var<private> dBlendModeFogFactor : f32 = 1.0;
#if (FOG != NONE)
	uniform fog_color : vec3f;
	
	#if (FOG == LINEAR)
		uniform fog_start : f32;
		uniform fog_end : f32;
	#else
		uniform fog_density : f32;
	#endif
#endif
fn getFogFactor() -> f32 {
	let depth = pcPosition.z / pcPosition.w;
	var fogFactor : f32 = 0.0;
	#if (FOG == LINEAR)
		fogFactor = (uniform.fog_end - depth) / (uniform.fog_end - uniform.fog_start);
	#elif (FOG == EXP)
		fogFactor = exp(-depth * uniform.fog_density);
	#elif (FOG == EXP2)
		fogFactor = exp(-depth * depth * uniform.fog_density * uniform.fog_density);
	#endif
	return clamp(fogFactor, 0.0, 1.0);
}
fn addFog(color : vec3f) -> vec3f {
	#if (FOG != NONE)
		return mix(uniform.fog_color * dBlendModeFogFactor, color, getFogFactor());
	#else
		return color;
	#endif
}
`,TX=`
fn getFresnel(
		cosTheta: f32,
		gloss: f32,
		specularity: vec3f
	#if defined(LIT_IRIDESCENCE)
		, iridescenceFresnel: vec3f,
		iridescenceIntensity: f32
	#endif
) -> vec3f {
	let fresnel: f32 = pow(1.0 - saturate(cosTheta), 5.0);
	let glossSq: f32 = gloss * gloss;
	let specIntensity: f32 = max(specularity.r, max(specularity.g, specularity.b));
	let ret: vec3f = specularity + (max(vec3f(glossSq * specIntensity), specularity) - specularity) * fresnel;
	#if defined(LIT_IRIDESCENCE)
		return mix(ret, iridescenceFresnel, iridescenceIntensity);
	#else
		return ret;
	#endif
}
fn getFresnelCC(cosTheta: f32) -> f32 {
	let fresnel: f32 = pow(1.0 - saturate(cosTheta), 5.0);
	return 0.04 + (1.0 - 0.04) * fresnel;
}`,EX=`
attribute vertex_position: vec2f;
varying vUv0: vec2f;
@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
	var output: VertexOutput;
	output.position = vec4f(input.vertex_position, 0.5, 1.0);
	output.vUv0 = input.vertex_position.xy * 0.5 + vec2f(0.5);
	return output;
}
`,bX=`
#include "decodePS"
#if (GAMMA == SRGB)
	fn gammaCorrectInput(color: f32) -> f32 {
		return decodeGammaFloat(color);
	}
	fn gammaCorrectInputVec3(color: vec3f) -> vec3f {
		return decodeGamma3(color);
	}
	fn gammaCorrectInputVec4(color: vec4f) -> vec4f {
		return vec4f(decodeGamma3(color.xyz), color.w);
	}
	fn gammaCorrectOutput(color: vec3f) -> vec3f {
		return pow(color + 0.0000001, vec3f(1.0 / 2.2));
	}
#else
	fn gammaCorrectInput(color: f32) -> f32 {
		return color;
	}
	fn gammaCorrectInputVec3(color: vec3f) -> vec3f {
		return color;
	}
	fn gammaCorrectInputVec4(color: vec4f) -> vec4f {
		return color;
	}
	fn gammaCorrectOutput(color: vec3f) -> vec3f {
		return color;
	}
#endif
`,AX=`
#ifdef STD_GLOSS_CONSTANT
	uniform material_gloss: f32;
#endif
fn getGlossiness() {
	dGlossiness = 1.0;
	#ifdef STD_GLOSS_CONSTANT
	dGlossiness = dGlossiness * uniform.material_gloss;
	#endif
	#ifdef STD_GLOSS_TEXTURE
	dGlossiness = dGlossiness * textureSampleBias({STD_GLOSS_TEXTURE_NAME}, {STD_GLOSS_TEXTURE_NAME}Sampler, {STD_GLOSS_TEXTURE_UV}, uniform.textureBias).{STD_GLOSS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_GLOSS_VERTEX
	dGlossiness = dGlossiness * saturate(vVertexColor.{STD_GLOSS_VERTEX_CHANNEL});
	#endif
	#ifdef STD_GLOSS_INVERT
	dGlossiness = 1.0 - dGlossiness;
	#endif
	dGlossiness = dGlossiness + 0.0000001;
}
`,wX=`
	attribute aPosition: vec2f;
	varying uv0: vec2f;
	@vertex fn vertexMain(input: VertexInput) -> VertexOutput {
		var output: VertexOutput;
		output.position = vec4f(input.aPosition, 0.0, 1.0);
		output.uv0 = getImageEffectUV((input.aPosition + 1.0) * 0.5);
		return output;
	}
`,CX=`
struct DrawIndexedIndirectArgs {
	indexCount: u32,
	instanceCount: u32,
	firstIndex: u32,
	baseVertex: i32,
	firstInstance: u32
};
struct DrawIndirectArgs {
	vertexCount: u32,
	instanceCount: u32,
	firstVertex: u32,
	firstInstance: u32,
	_pad: u32
};
`,DX=`
	#include "gammaPS"
	varying color: vec4f;
	@fragment
	fn fragmentMain(input : FragmentInput) -> FragmentOutput {
		var output: FragmentOutput;
		output.color = vec4f(gammaCorrectOutput(decodeGamma3(input.color.rgb)), input.color.a);
		return output;
	}
`,PX=`
	attribute vertex_position: vec4f;
	attribute vertex_color: vec4f;
	uniform matrix_model: mat4x4f;
	uniform matrix_viewProjection: mat4x4f;
	varying color: vec4f;
	@vertex
	fn vertexMain(input : VertexInput) -> VertexOutput {
		var output : VertexOutput;
		output.color = input.vertex_color;
		output.position = uniform.matrix_viewProjection * uniform.matrix_model * input.vertex_position;
		return output;
	}
`,RX=`
uniform material_iridescenceRefractionIndex: f32;
fn iridescence_iorToFresnelScalar(transmittedIor: f32, incidentIor: f32) -> f32 {
	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}
fn iridescence_iorToFresnelVec3(transmittedIor: vec3f, incidentIor: f32) -> vec3f {
	return pow((transmittedIor - vec3f(incidentIor)) / (transmittedIor + vec3f(incidentIor)), vec3f(2.0));
}
fn iridescence_fresnelToIor(f0: vec3f) -> vec3f {
	let sqrtF0: vec3f = sqrt(f0);
	return (vec3f(1.0) + sqrtF0) / (vec3f(1.0) - sqrtF0);
}
const XYZ_TO_REC709: mat3x3f = mat3x3f(
	vec3f(3.2404542, -1.5371385, -0.4985314),
	vec3f(-0.9692660,  1.8760108,  0.0415560),
	vec3f(0.0556434, -0.2040259,  1.0572252)
);
fn iridescence_sensitivity(opd: f32, shift: vec3f) -> vec3f {
	let PI: f32 = 3.141592653589793;
	let phase: f32 = 2.0 * PI * opd * 1.0e-9;
	const val: vec3f = vec3f(5.4856e-13, 4.4201e-13, 5.2481e-13);
	const pos: vec3f = vec3f(1.6810e+06, 1.7953e+06, 2.2084e+06);
	const var_: vec3f = vec3f(4.3278e+09, 9.3046e+09, 6.6121e+09);
	var xyz: vec3f = val * sqrt(2.0 * PI * var_) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var_);
	xyz.x = xyz.x + 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
	xyz = xyz / vec3f(1.0685e-07);
	return XYZ_TO_REC709 * xyz;
}
fn iridescence_fresnelScalar(cosTheta: f32, f0: f32) -> f32 {
	let x: f32 = clamp(1.0 - cosTheta, 0.0, 1.0);
	let x2: f32 = x * x;
	let x5: f32 = x * x2 * x2;
	return f0 + (1.0 - f0) * x5;
}
fn iridescence_fresnelVec3(cosTheta: f32, f0: vec3f) -> vec3f {
	let x: f32 = clamp(1.0 - cosTheta, 0.0, 1.0);
	let x2: f32 = x * x;
	let x5: f32 = x * x2 * x2;
	return f0 + (vec3f(1.0) - f0) * x5;
}
fn calcIridescence(outsideIor: f32, cosTheta: f32, base_f0: vec3f, iridescenceThickness: f32) -> vec3f {
	let PI: f32 = 3.141592653589793;
	let iridescenceIor: f32 = mix(outsideIor, uniform.material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
	let sinTheta2Sq: f32 = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
	let cosTheta2Sq: f32 = 1.0 - sinTheta2Sq;
	if (cosTheta2Sq < 0.0) {
		return vec3f(1.0);
	}
	let cosTheta2: f32 = sqrt(cosTheta2Sq);
	let r0: f32 = iridescence_iorToFresnelScalar(iridescenceIor, outsideIor);
	let r12: f32 = iridescence_fresnelScalar(cosTheta, r0);
	let r21: f32 = r12;
	let t121: f32 = 1.0 - r12;
	let phi12: f32 = select(0.0, PI, iridescenceIor < outsideIor);
	let phi21: f32 = PI - phi12;
	let baseIor: vec3f = iridescence_fresnelToIor(base_f0 + vec3f(0.0001));
	let r1: vec3f = iridescence_iorToFresnelVec3(baseIor, iridescenceIor);
	let r23: vec3f = iridescence_fresnelVec3(cosTheta2, r1);
	let phi23: vec3f = select(vec3f(0.0), vec3f(PI), baseIor < vec3f(iridescenceIor));
	let opd: f32 = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
	let phi: vec3f = vec3f(phi21) + phi23;
	let r123Sq: vec3f = clamp(vec3f(r12) * r23, vec3f(1e-5), vec3f(0.9999));
	let r123: vec3f = sqrt(r123Sq);
	let rs: vec3f = pow(vec3f(t121), vec3f(2.0)) * r23 / (vec3f(1.0) - r123Sq);
	let c0: vec3f = vec3f(r12) + rs;
	var i_irid: vec3f = c0;
	var cm: vec3f = rs - vec3f(t121);
	cm = cm * r123;
	let sm1: vec3f = 2.0 * iridescence_sensitivity(1.0 * opd, 1.0 * phi);
	i_irid = i_irid + cm * sm1;
	cm = cm * r123;
	let sm2: vec3f = 2.0 * iridescence_sensitivity(2.0 * opd, 2.0 * phi);
	i_irid = i_irid + cm * sm2;
	return max(i_irid, vec3f(0.0));
}
fn getIridescenceDiffraction(cosTheta: f32, specularity: vec3f, iridescenceThickness: f32) -> vec3f {
	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`,MX=`
#ifdef STD_IRIDESCENCE_CONSTANT
	uniform material_iridescence: f32;
#endif
fn getIridescence() {
	var iridescence = 1.0;
	#ifdef STD_IRIDESCENCE_CONSTANT
	iridescence = iridescence * uniform.material_iridescence;
	#endif
	#ifdef STD_IRIDESCENCE_TEXTURE
	iridescence = iridescence * textureSampleBias({STD_IRIDESCENCE_TEXTURE_NAME}, {STD_IRIDESCENCE_TEXTURE_NAME}Sampler, {STD_IRIDESCENCE_TEXTURE_UV}, uniform.textureBias).{STD_IRIDESCENCE_TEXTURE_CHANNEL};
	#endif
	dIridescence = iridescence; 
}
`,LX=`
uniform material_iridescenceThicknessMax: f32;
#ifdef STD_IRIDESCENCETHICKNESS_TEXTURE
	uniform material_iridescenceThicknessMin: f32;
#endif
fn getIridescenceThickness() {
	#ifdef STD_IRIDESCENCETHICKNESS_TEXTURE
		var blend: f32 = textureSampleBias({STD_IRIDESCENCETHICKNESS_TEXTURE_NAME}, {STD_IRIDESCENCETHICKNESS_TEXTURE_NAME}Sampler, {STD_IRIDESCENCETHICKNESS_TEXTURE_UV}, uniform.textureBias).{STD_IRIDESCENCETHICKNESS_TEXTURE_CHANNEL};
		var iridescenceThickness: f32 = mix(uniform.material_iridescenceThicknessMin, uniform.material_iridescenceThicknessMax, blend);
	#else
		var iridescenceThickness: f32 = uniform.material_iridescenceThicknessMax;
	#endif
	dIridescenceThickness = iridescenceThickness; 
}
`,IX=`
#ifdef STD_IOR_CONSTANT
	uniform material_refractionIndex: f32;
#endif
fn getIor() {
#ifdef STD_IOR_CONSTANT
	dIor = uniform.material_refractionIndex;
#else
	dIor = 1.0 / 1.5;
#endif
}
`,OX=`
#if defined(LIGHT{i})
	uniform light{i}_color: vec3f;
	#if LIGHT{i}TYPE == DIRECTIONAL
		uniform light{i}_direction: vec3f;
	#else
		#define LIT_CODE_LIGHTS_POINT
		uniform light{i}_position: vec3f;
		uniform light{i}_radius: f32;
		#if LIGHT{i}TYPE == SPOT
			#define LIT_CODE_LIGHTS_SPOT
			uniform light{i}_direction: vec3f;
			uniform light{i}_innerConeAngle: f32;
			uniform light{i}_outerConeAngle: f32;
		#endif
	#endif
	#if LIGHT{i}SHAPE != PUNCTUAL
		#define LIT_CODE_FALLOFF_SQUARED
		#if LIGHT{i}TYPE == DIRECTIONAL
			uniform light{i}_position: vec3f;
		#endif
		uniform light{i}_halfWidth: vec3f;
		uniform light{i}_halfHeight: vec3f;
	#else
		#if LIGHT{i}FALLOFF == LINEAR
			#define LIT_CODE_FALLOFF_LINEAR
		#endif
		#if LIGHT{i}FALLOFF == INVERSESQUARED
			#define LIT_CODE_FALLOFF_SQUARED
		#endif
	#endif
	#if defined(LIGHT{i}CASTSHADOW)
		#if LIGHT{i}TYPE != OMNI
			uniform light{i}_shadowMatrix: mat4x4f;
		#endif
		uniform light{i}_shadowIntensity: f32;
		uniform light{i}_shadowParams: vec4f;
		#if LIGHT{i}SHADOWTYPE == PCSS_32F
			uniform light{i}_shadowSearchArea: f32;
			uniform light{i}_cameraParams: vec4f;
			#if LIGHT{i}TYPE == DIRECTIONAL
				uniform light{i}_softShadowParams: vec4f;
			#endif
		#endif
		#if LIGHT{i}TYPE == DIRECTIONAL
			uniform light{i}_shadowMatrixPalette: array<mat4x4f, 4>;
			uniform light{i}_shadowCascadeDistances: vec4f;
			uniform light{i}_shadowCascadeCount: i32;
			uniform light{i}_shadowCascadeBlend: f32;
		#endif
		#if LIGHT{i}TYPE == OMNI
			NOT SUPPORTED
			
		#else
			#if defined(LIGHT{i}SHADOW_PCF)
				var light{i}_shadowMap: texture_depth_2d;
				var light{i}_shadowMapSampler: sampler_comparison;
			#else
				var light{i}_shadowMap: texture_2d<f32>;
				var light{i}_shadowMapSampler: sampler;
			#endif
		#endif
	#endif
	#if defined(LIGHT{i}COOKIE)
		#define LIT_CODE_COOKIE
		#if LIGHT{i}TYPE == OMNI
			NOT SUPPORTED
		#endif
		#if LIGHT{i}TYPE == SPOT
			NOT SUPPORTED
		#endif
	#endif
#endif
`,NX=`
fn getLightDiffuse(worldNormal: vec3f, viewDir: vec3f, lightDirNorm: vec3f) -> f32 {
	return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`,FX=`
fn evalOmniLight(lightPosW: vec3f) -> vec3f {
	return vPositionW - lightPosW;
}
`,BX=`
#if defined(LIGHT{i})
	evaluateLight{i}(
		#if defined(LIT_IRIDESCENCE)
			iridescenceFresnel
		#endif
	);
#endif
`,UX=`
#if defined(LIGHT{i})
fn evaluateLight{i}(
	#if defined(LIT_IRIDESCENCE)
		iridescenceFresnel: vec3f
	#endif
) {
	var lightColor: vec3f = uniform.light{i}_color;
	#if LIGHT{i}TYPE == DIRECTIONAL && !defined(LIT_SHADOW_CATCHER)
		if (all(lightColor == vec3f(0.0, 0.0, 0.0))) {
			return;
		}
	#endif
	#if LIGHT{i}TYPE == DIRECTIONAL
		dLightDirNormW = uniform.light{i}_direction;
		dAtten = 1.0;
	#else
		var lightDirW: vec3f = evalOmniLight(uniform.light{i}_position);
		dLightDirNormW = normalize(lightDirW);
		#if defined(LIGHT{i}COOKIE)
			#if LIGHT{i}TYPE == SPOT
				#ifdef LIGHT{i}COOKIE_FALLOFF
					#ifdef LIGHT{i}COOKIE_TRANSFORM
						var cookieAttenuation: vec3f = getCookie2DXform(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity, uniform.light{i}_cookieMatrix, uniform.light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};
					#else
						var cookieAttenuation: vec3f = getCookie2D(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};
					#endif
				#else
					#ifdef LIGHT{i}COOKIE_TRANSFORM
						var cookieAttenuation: vec3f = getCookie2DClipXform(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity, uniform.light{i}_cookieMatrix, uniform.light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};
					#else
						var cookieAttenuation: vec3f = getCookie2DClip(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};
					#endif
				#endif
			#endif
			#if LIGHT{i}TYPE == OMNI
				var cookieAttenuation: vec3f = getCookieCube(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};
			#endif
			lightColor = lightColor * cookieAttenuation;
		#endif
		#if LIGHT{i}SHAPE == PUNCTUAL
			#if LIGHT{i}FALLOFF == LINEAR
				dAtten = getFalloffLinear(uniform.light{i}_radius, lightDirW);
			#else
				dAtten = getFalloffInvSquared(uniform.light{i}_radius, lightDirW);
			#endif
		#else
			dAtten = getFalloffWindow(uniform.light{i}_radius, lightDirW);
		#endif
		#if LIGHT{i}TYPE == SPOT
			#if !defined(LIGHT{i}COOKIE) || defined(LIGHT{i}COOKIE_FALLOFF)
				dAtten = dAtten * getSpotEffect(uniform.light{i}_direction, uniform.light{i}_innerConeAngle, uniform.light{i}_outerConeAngle, dLightDirNormW);
			#endif
		#endif
	#endif
	if (dAtten < 0.00001) {
		return;
	}
	#if LIGHT{i}SHAPE != PUNCTUAL
		#if LIGHT{i}SHAPE == RECT
			calcRectLightValues(uniform.light{i}_position, uniform.light{i}_halfWidth, uniform.light{i}_halfHeight);
		#elif LIGHT{i}SHAPE == DISK
			calcDiskLightValues(uniform.light{i}_position, uniform.light{i}_halfWidth, uniform.light{i}_halfHeight);
		#elif LIGHT{i}SHAPE == SPHERE
			calcSphereLightValues(uniform.light{i}_position, uniform.light{i}_halfWidth, uniform.light{i}_halfHeight);
		#endif
	#endif
	#if LIGHT{i}SHAPE != PUNCTUAL
		#if LIGHT{i}TYPE == DIRECTIONAL
			var attenDiffuse: f32 = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirNormW);
		#else
			#if LIGHT{i}SHAPE == RECT
				var attenDiffuse: f32 = getRectLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;
			#elif LIGHT{i}SHAPE == DISK
				var attenDiffuse: f32 = getDiskLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;
			#elif LIGHT{i}SHAPE == SPHERE
				var attenDiffuse: f32 = getSphereLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;
			#endif
		#endif
	#else
		dAtten = dAtten * getLightDiffuse(litArgs_worldNormal, vec3(0.0), dLightDirNormW);
	#endif
	#ifdef LIGHT{i}CASTSHADOW
		#if LIGHT{i}TYPE == DIRECTIONAL
			var shadow: f32 = getShadow{i}(vec3(0.0));
		#else
			var shadow: f32 = getShadow{i}(lightDirW);
		#endif
		shadow = mix(1.0, shadow, uniform.light{i}_shadowIntensity);
		dAtten = dAtten * shadow;
		#if defined(LIT_SHADOW_CATCHER) && LIGHT{i}TYPE == DIRECTIONAL
			dShadowCatcher = dShadowCatcher * shadow;
		#endif			
	#endif
	#if LIGHT{i}SHAPE != PUNCTUAL
		#ifdef LIT_SPECULAR
			dDiffuseLight = dDiffuseLight + (((attenDiffuse * dAtten) * lightColor) * (1.0 - dLTCSpecFres));
		#else
			dDiffuseLight = dDiffuseLight + ((attenDiffuse * dAtten) * lightColor);
		#endif						
	#else
		#if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)
			dDiffuseLight = dDiffuseLight + ((dAtten * lightColor) * (1.0 - litArgs_specularity));
		#else
			dDiffuseLight = dDiffuseLight + (dAtten * lightColor);
		#endif
	#endif
	#ifdef LIGHT{i}AFFECT_SPECULARITY
		#if LIGHT{i}SHAPE != PUNCTUAL
			#ifdef LIT_CLEARCOAT
				#if LIGHT{i}SHAPE == RECT
					ccSpecularLight = ccSpecularLight + (ccLTCSpecFres * getRectLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor);
				#elif LIGHT{i}SHAPE == DISK
					ccSpecularLight = ccSpecularLight + (ccLTCSpecFres * getDiskLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor);
				#elif LIGHT{i}SHAPE == SPHERE
					ccSpecularLight = ccSpecularLight + (ccLTCSpecFres * getSphereLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor);
				#endif
			#endif
			#ifdef LIT_SPECULAR
				#if LIGHT{i}SHAPE == RECT
					dSpecularLight = dSpecularLight + (dLTCSpecFres * getRectLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor);
				#elif LIGHT{i}SHAPE == DISK
					dSpecularLight = dSpecularLight + (dLTCSpecFres * getDiskLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor);
				#elif LIGHT{i}SHAPE == SPHERE
					dSpecularLight = dSpecularLight + (dLTCSpecFres * getSphereLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor);
				#endif
			#endif
		#else
			#if LIGHT{i}TYPE == DIRECTIONAL && LIT_FRESNEL_MODEL != NONE
				#define LIGHT{i}FRESNEL
			#endif
			#ifdef LIT_SPECULAR
				var halfDirW: vec3f = normalize(-dLightDirNormW + dViewDirW);
			#endif
			#ifdef LIT_CLEARCOAT
				var lightspecularCC: vec3f = getLightSpecular(halfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * lightColor;
				#ifdef LIGHT{i}FRESNEL
					lightspecularCC = lightspecularCC * getFresnelCC(dot(dViewDirW, halfDirW));
				#endif
				ccSpecularLight = ccSpecularLight + lightspecularCC;
			#endif
			#ifdef LIT_SHEEN
				sSpecularLight = sSpecularLight + (getLightSpecularSheen(halfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * lightColor);
			#endif
			#ifdef LIT_SPECULAR
				var lightSpecular: vec3f = getLightSpecular(halfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * lightColor;
				#ifdef LIGHT{i}FRESNEL
					#if defined(LIT_IRIDESCENCE)
						lightSpecular = lightSpecular * getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity, iridescenceFresnel, litArgs_iridescence_intensity);
					#else
						lightSpecular = lightSpecular * getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity);
					#endif
				#else
					lightSpecular = lightSpecular * litArgs_specularity;
				#endif
				
				dSpecularLight = dSpecularLight + lightSpecular;
			#endif
		#endif
	#endif
}
#endif
`,zX=`
#ifdef LIGHT{i}CASTSHADOW
	#ifdef LIGHT{i}_SHADOW_SAMPLE_POINT
		fn getShadowSampleCoordOmni{i}(shadowParams: vec4f, worldPosition: vec3f, lightPos: vec3f, lightDir: ptr<function, vec3f>, lightDirNorm: vec3f, normal: vec3f) -> vec3f {
			#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET
				let distScale: f32 = length(*lightDir);
				var surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				*lightDir = surfacePosition - lightPos;
			#endif
			return *lightDir;
		}
	#endif
	#ifndef LIGHT{i}_SHADOW_SAMPLE_POINT
		fn getShadowSampleCoord{i}(shadowTransform: mat4x4f, shadowParams: vec4f, worldPosition: vec3f, lightPos: vec3f, lightDir: ptr<function, vec3f>, lightDirNorm: vec3f, normal: vec3f) -> vec3f {
			var surfacePosition = worldPosition;
			#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER
				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET
					surfacePosition = surfacePosition + normal * shadowParams.y;
				#endif
			#else
				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET
					#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO
						var distScale: f32 = 1.0;
					#else
						var distScale: f32 = abs(dot(vPositionW - lightPos, lightDirNorm));
					#endif
					surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				#endif
			#endif
			var positionInShadowSpace: vec4f = shadowTransform * vec4f(surfacePosition, 1.0);
			#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO
				positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
			#else
				#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER
					positionInShadowSpace.xyz = positionInShadowSpace.xyz / positionInShadowSpace.w;
				#else
					positionInShadowSpace.xy = positionInShadowSpace.xy / positionInShadowSpace.w;
					positionInShadowSpace.z = length(*lightDir) * shadowParams.w;
				#endif
			#endif
			return positionInShadowSpace.xyz;
		}
	#endif
	fn getShadow{i}(lightDirW_in: vec3f) -> f32 {
		var lightDirArg = lightDirW_in;
		#if LIGHT{i}TYPE == OMNI
			var shadowCoord: vec3f = getShadowSampleCoordOmni{i}(uniform.light{i}_shadowParams, vPositionW, uniform.light{i}_position, &lightDirArg, dLightDirNormW, dVertexNormalW);
		#else
			#ifdef LIGHT{i}_SHADOW_CASCADES
				var cascadeIndex: i32 = getShadowCascadeIndex(uniform.light{i}_shadowCascadeDistances, uniform.light{i}_shadowCascadeCount);
				#ifdef LIGHT{i}_SHADOW_CASCADE_BLEND
					cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, uniform.light{i}_shadowCascadeDistances, uniform.light{i}_shadowCascadeCount, uniform.light{i}_shadowCascadeBlend);
				#endif
				var shadowMatrix: mat4x4f = uniform.light{i}_shadowMatrixPalette[cascadeIndex];
			#else
				var shadowMatrix: mat4x4f = uniform.light{i}_shadowMatrix;
			#endif
			#if LIGHT{i}TYPE == DIRECTIONAL
				var shadowCoord: vec3f = getShadowSampleCoord{i}(shadowMatrix, uniform.light{i}_shadowParams, vPositionW, vec3f(0.0), &lightDirArg, dLightDirNormW, dVertexNormalW);
			#else
				var shadowCoord: vec3f = getShadowSampleCoord{i}(shadowMatrix, uniform.light{i}_shadowParams, vPositionW, uniform.light{i}_position, &lightDirArg, dLightDirNormW, dVertexNormalW);
			#endif
		#endif
		#if LIGHT{i}TYPE == DIRECTIONAL
			shadowCoord = fadeShadow(shadowCoord, uniform.light{i}_shadowCascadeDistances);
		#endif
		#if LIGHT{i}TYPE == DIRECTIONAL
			#if LIGHT{i}SHADOWTYPE == VSM_16F
				return getShadowVSM16(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 5.54);
			#endif
			#if LIGHT{i}SHADOWTYPE == VSM_32F
				return getShadowVSM32(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 15.0);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCSS_32F
				#if LIGHT{i}SHAPE != PUNCTUAL
					let shadowSearchArea = vec2f(length(uniform.light{i}_halfWidth), length(uniform.light{i}_halfHeight)) * uniform.light{i}_shadowSearchArea;
					return getShadowPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, shadowSearchArea, lightDirW_in);
				#else
					return getShadowPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, uniform.light{i}_softShadowParams, lightDirW_in);
				#endif
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F
				return getShadowPCF1x1(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F
				return getShadowPCF3x3(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F
				return getShadowPCF5x5(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);
			#endif
		#endif
		#if LIGHT{i}TYPE == SPOT
			#if LIGHT{i}SHADOWTYPE == VSM_16F
				return getShadowSpotVSM16(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 5.54, lightDirW_in);
			#endif
			#if LIGHT{i}SHADOWTYPE == VSM_32F
				return getShadowSpotVSM32(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 15.0, lightDirW_in);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCSS_32F
				#if LIGHT{i}SHAPE != PUNCTUAL
					var shadowSearchArea: vec2f = vec2f(length(uniform.light{i}_halfWidth), length(uniform.light{i}_halfHeight)) * uniform.light{i}_shadowSearchArea;
				#else
					var shadowSearchArea: vec2f = vec2f(uniform.light{i}_shadowSearchArea);
				#endif
				return getShadowSpotPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, shadowSearchArea, lightDirW_in);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F
				return getShadowSpotPCF1x1(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F
				return getShadowSpotPCF3x3(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F
				return getShadowSpotPCF5x5(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);
			#endif
		#endif
		#if LIGHT{i}TYPE == OMNI
			#if LIGHT{i}SHADOWTYPE == PCSS_32F
				 var shadowSearchArea: vec2f;
				 #if LIGHT{i}SHAPE != PUNCTUAL
					var shadowSearchArea: vec2f = vec2f(length(uniform.light{i}_halfWidth), length(uniform.light{i}_halfHeight)) * uniform.light{i}_shadowSearchArea;
				#else
					var shadowSearchArea: vec2f = vec2f(uniform.light{i}_shadowSearchArea);
				#endif
				return getShadowOmniPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, shadowSearchArea, lightDirW_in);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F
				return getShadowOmniPCF1x1(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, lightDirW_in);
			#endif
			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F
				return getShadowOmniPCF3x3(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, lightDirW_in);
			#endif
		#endif
	}
#endif
`,kX=`
#ifdef LIT_CLUSTERED_LIGHTS
	#define LIT_CODE_FALLOFF_LINEAR
	#define LIT_CODE_FALLOFF_SQUARED
	#define LIT_CODE_LIGHTS_POINT
	#define LIT_CODE_LIGHTS_SPOT
#endif
#ifdef AREA_LIGHTS
	var areaLightsLutTex1: texture_2d<f32>;
	var areaLightsLutTex1Sampler: sampler;
	var areaLightsLutTex2: texture_2d<f32>;
	var areaLightsLutTex2Sampler: sampler;
#endif
#ifdef LIT_LIGHTING
	#include "lightDiffuseLambertPS"
	#if defined(AREA_LIGHTS) || defined(LIT_CLUSTERED_AREA_LIGHTS)
		#include "ltcPS"
	#endif
#endif
#ifdef SHADOW_DIRECTIONAL
	#include "shadowCascadesPS"
#endif
#if defined(SHADOW_KIND_PCF1)
	#include "shadowPCF1PS"
#endif
#if defined(SHADOW_KIND_PCF3)
	#include "shadowPCF3PS"
#endif
#if defined(SHADOW_KIND_PCF5)
	#include "shadowPCF5PS"
#endif
#if defined(SHADOW_KIND_PCSS)
	#include "linearizeDepthPS"
	#include "shadowSoftPS"
#endif
#if defined(SHADOW_KIND_VSM)
	#include "shadowEVSMPS"
#endif
#ifdef LIT_CODE_FALLOFF_LINEAR
	#include "falloffLinearPS"
#endif
#ifdef LIT_CODE_FALLOFF_SQUARED
	#include "falloffInvSquaredPS"
#endif
#ifdef LIT_CODE_LIGHTS_POINT
	#include "lightDirPointPS"
#endif
#ifdef LIT_CODE_LIGHTS_SPOT
	#include "spotPS"
#endif
#ifdef LIT_CODE_COOKIE
	#include "cookiePS"
#endif
#ifdef LIT_CLUSTERED_LIGHTS
	#include "clusteredLightPS"
#endif
#ifdef LIGHT_COUNT > 0
	#include "lightFunctionShadowPS, LIGHT_COUNT"
	#include "lightFunctionLightPS, LIGHT_COUNT"
#endif
`,VX=`
fn addLightMap(
	lightmap: vec3f,
	dir: vec3f,
	worldNormal: vec3f,
	viewDir: vec3f,
	reflectionDir: vec3f,
	gloss: f32,
	specularity: vec3f,
	vertexNormal: vec3f,
	tbn: mat3x3f
#if defined(LIT_IRIDESCENCE)
	, iridescenceFresnel: vec3f,
	iridescenceIntensity: f32
#endif
) {
	#if defined(LIT_SPECULAR) && defined(LIT_DIR_LIGHTMAP)
		if (dot(dir, dir) < 0.0001) {
				dDiffuseLight = dDiffuseLight + lightmap;
		} else {
			let vlight: f32 = saturate(dot(dir, -vertexNormal));
			let flight: f32 = saturate(dot(dir, -worldNormal));
			let nlight: f32 = (flight / max(vlight, 0.01)) * 0.5;
			dDiffuseLight = dDiffuseLight + lightmap * nlight * 2.0;
			let halfDir: vec3f = normalize(-dir + viewDir);
			var specularLight: vec3f = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);
			#ifdef LIT_SPECULAR_FRESNEL
				specularLight = specularLight *
					getFresnel(dot(viewDir, halfDir),
					gloss,
					specularity
				#if defined(LIT_IRIDESCENCE)
					, iridescenceFresnel,
					iridescenceIntensity
				#endif
					);
			#endif
			dSpecularLight = dSpecularLight + specularLight;
		}
	#else
		dDiffuseLight = dDiffuseLight + lightmap;
	#endif
}
`,GX=`
#ifdef STD_LIGHTMAP_DIR
	var<private> dLightmapDir: vec3f;
	var texture_dirLightMap: texture_2d<f32>;
	var texture_dirLightMapSampler: sampler;
#endif
fn getLightMap() {
	dLightmap = vec3f(1.0);
	#ifdef STD_LIGHT_TEXTURE
		dLightmap = dLightmap * {STD_LIGHT_TEXTURE_DECODE}(textureSampleBias({STD_LIGHT_TEXTURE_NAME}, {STD_LIGHT_TEXTURE_NAME}Sampler, {STD_LIGHT_TEXTURE_UV}, uniform.textureBias)).{STD_LIGHT_TEXTURE_CHANNEL};
		#ifdef STD_LIGHTMAP_DIR
			var dir: vec3f = textureSampleBias(texture_dirLightMap, texture_dirLightMapSampler, {STD_LIGHT_TEXTURE_UV}, uniform.textureBias).xyz * 2.0 - 1.0;
			var dirDot = dot(dir, dir);
			dLightmapDir = select(vec3(0.0), dir / sqrt(dirDot), dirDot > 0.001);
		#endif
	#endif
	#ifdef STD_LIGHT_VERTEX
		dLightmap = dLightmap * saturate(vVertexColor.{STD_LIGHT_VERTEX_CHANNEL});
	#endif
}
`,HX=`
fn calcLightSpecular(gloss: f32, worldNormal: vec3f, viewDir: vec3f, h: vec3f, lightDirNorm: vec3f, tbn: mat3x3f) -> f32 {
	let PI: f32 = 3.141592653589793;
	let roughness: f32 = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	let alphaRoughness: f32 = roughness * roughness;
	let anisotropy: f32 = dAnisotropy;
	let direction: vec2f = dAnisotropyRotation;
	let at: f32 = mix(alphaRoughness, 1.0, anisotropy * anisotropy);
	let ab: f32 = clamp(alphaRoughness, 0.001, 1.0);
	let anisotropicT: vec3f = normalize(tbn * vec3f(direction, 0.0));
	let anisotropicB: vec3f = normalize(cross(tbn[2], anisotropicT));
	let NoH: f32 = dot(worldNormal, h);
	let ToH: f32 = dot(anisotropicT, h);
	let BoH: f32 = dot(anisotropicB, h);
	let a2: f32 = at * ab;
	let v: vec3f = vec3f(ab * ToH, at * BoH, a2 * NoH);
	let v2: f32 = dot(v, v);
	let w2: f32 = a2 / v2;
	let D: f32 = a2 * w2 * w2 * (1.0 / PI);
	let ToV: f32 = dot(anisotropicT, viewDir);
	let BoV: f32 = dot(anisotropicB, viewDir);
	let ToL: f32 = dot(anisotropicT, -lightDirNorm);
	let BoL: f32 = dot(anisotropicB, -lightDirNorm);
	let NoV: f32 = dot(worldNormal, viewDir);
	let NoL: f32 = dot(worldNormal, -lightDirNorm);
	let lambdaV: f32 = NoL * length(vec3f(at * ToV, ab * BoV, NoV));
	let lambdaL: f32 = NoV * length(vec3f(at * ToL, ab * BoL, NoL));
	let G: f32 = 0.5 / (lambdaV + lambdaL);
	return D * G;
}
fn getLightSpecular(h: vec3f, reflDir: vec3f, worldNormal: vec3f, viewDir: vec3f, lightDirNorm: vec3f, gloss: f32, tbn: mat3x3f) -> f32 {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`,WX=`
fn calcLightSpecular(gloss: f32, worldNormal: vec3f, viewDir: vec3f, h: vec3f, lightDirNorm: vec3f) -> f32 {
	const PI: f32 = 3.141592653589793;
	let roughness: f32 = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	let alpha: f32 = roughness * roughness;
	let NoH: f32 = max(dot(worldNormal, h), 0.0);
	let NoV: f32 = max(dot(worldNormal, viewDir), 0.0);
	let NoL: f32 = max(dot(worldNormal, -lightDirNorm), 0.0);
	let NoH2: f32 = NoH * NoH;
	let denom: f32 = NoH2 * (alpha - 1.0) + 1.0;
	let D: f32 = alpha / (PI * denom * denom);
	let alpha2: f32 = alpha * alpha;
	let lambdaV: f32 = NoL * sqrt(NoV * NoV * (1.0 - alpha2) + alpha2);
	let lambdaL: f32 = NoV * sqrt(NoL * NoL * (1.0 - alpha2) + alpha2);
	let G: f32 = 0.5 / max(lambdaV + lambdaL, 0.00001);
	return D * G;
}
fn getLightSpecular(h: vec3f, reflDir: vec3f, worldNormal: vec3f, viewDir: vec3f, lightDirNorm: vec3f, gloss: f32, tbn: mat3x3f) -> f32 {
	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm);
}
`,XX=`
fn calcLightSpecular(gloss: f32, worldNormal: vec3f, h: vec3f) -> f32 {
	let nh: f32 = max( dot( h, worldNormal ), 0.0 );
	var specPow: f32 = exp2(gloss * 11.0);
	specPow = max(specPow, 0.0001);
	return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}
fn getLightSpecular(h: vec3f, reflDir: vec3f, worldNormal: vec3f, viewDir: vec3f, lightDirNorm: vec3f, gloss: f32, tbn: mat3x3f) -> f32 {
	return calcLightSpecular(gloss, worldNormal, h);
}
`,qX=`
fn sheenD(normal: vec3f, h: vec3f, roughness: f32) -> f32 {
	let PI: f32 = 3.141592653589793;
	let invR: f32 = 1.0 / (roughness * roughness);
	var cos2h: f32 = max(dot(normal, h), 0.0);
	cos2h = cos2h * cos2h;
	let sin2h: f32 = max(1.0 - cos2h, 0.0078125);
	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}
fn sheenV(normal: vec3f, viewDir: vec3f, light: vec3f) -> f32 {
	let NoV: f32 = max(dot(normal, viewDir), 0.000001);
	let NoL: f32 = max(dot(normal, light), 0.000001);
	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}
fn getLightSpecularSheen(h: vec3f, worldNormal: vec3f, viewDir: vec3f, lightDirNorm: vec3f, sheenGloss: f32) -> f32 {
	let D: f32 = sheenD(worldNormal, h, sheenGloss);
	let V: f32 = sheenV(worldNormal, viewDir, -lightDirNorm);
	return D * V;
}`,YX=`
#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH
fn linearizeDepthWithParams(z: f32, cameraParams: vec4f) -> f32 {
	if (cameraParams.w == 0.0) {
		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
	} else {
		return cameraParams.z + z * (cameraParams.y - cameraParams.z);
	}
}
#ifndef CAMERAPLANES
	#define CAMERAPLANES
	uniform camera_params: vec4f;
#endif
fn linearizeDepth(z: f32) -> f32 {
	return linearizeDepthWithParams(z, uniform.camera_params);
}
#endif
`,jX=`
fn evaluateBackend() -> FragmentOutput {
	var output: FragmentOutput;
	#ifdef LIT_SSAO
		litArgs_ao = litArgs_ao * textureSampleLevel(ssaoTexture, ssaoTextureSampler, pcPosition.xy * uniform.ssaoTextureSizeInv, 0.0).r;
	#endif
	#ifdef LIT_NEEDS_NORMAL
		#ifdef LIT_SPECULAR
			getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);
		#endif
		#ifdef LIT_CLEARCOAT
			ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));
		#endif
	#endif
	#ifdef LIT_SPECULAR_OR_REFLECTION
		#ifdef LIT_METALNESS
			var f0: f32 = 1.0 / litArgs_ior;
			f0 = (f0 - 1.0) / (f0 + 1.0);
			f0 = f0 * f0;
			#ifdef LIT_SPECULARITY_FACTOR
				litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0, litArgs_specularityFactor);
			#else
				litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0, 1.0);
			#endif
			litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);
		#endif
		#ifdef LIT_IRIDESCENCE
			var iridescenceFresnel: vec3f = getIridescenceDiffraction(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);
		#endif
	#endif
	#ifdef LIT_ADD_AMBIENT
		addAmbient(litArgs_worldNormal);
		#ifdef LIT_SPECULAR
			dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);
		#endif
		#ifdef LIT_SEPARATE_AMBIENT
			var dAmbientLight: vec3f = dDiffuseLight;
			dDiffuseLight = vec3(0.0);
		#endif
	#endif
	#ifndef LIT_OLD_AMBIENT
		dDiffuseLight = dDiffuseLight * uniform.material_ambient;
	#endif
	#ifdef LIT_AO
		#ifndef LIT_OCCLUDE_DIRECT
			occludeDiffuse(litArgs_ao);
		#endif
	#endif
	#ifdef LIT_LIGHTMAP
		addLightMap(
			litArgs_lightmap, 
			litArgs_lightmapDir, 
			litArgs_worldNormal, 
			dViewDirW, 
			dReflDirW, 
			litArgs_gloss, 
			litArgs_specularity, 
			dVertexNormalW,
			dTBN
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			litArgs_iridescence_intensity
		#endif
		);
	#endif
	#ifdef LIT_LIGHTING || LIT_REFLECTIONS
		#ifdef LIT_REFLECTIONS
			#ifdef LIT_CLEARCOAT
				addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);
			
				#ifdef LIT_SPECULAR_FRESNEL
					ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));
					ccReflection = ccReflection * ccFresnel;
				#else
					ccFresnel = 0.0;
				#endif
			#endif
			#ifdef LIT_SPECULARITY_FACTOR
				ccReflection = ccReflection * litArgs_specularityFactor;
			#endif
			#ifdef LIT_SHEEN
				addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);
			#endif
			addReflection(dReflDirW, litArgs_gloss);
			#ifdef LIT_FRESNEL_MODEL
				dReflection = vec4f(
					dReflection.rgb * getFresnel(
						dot(dViewDirW, litArgs_worldNormal),
						litArgs_gloss,
						litArgs_specularity
					#if defined(LIT_IRIDESCENCE)
						, iridescenceFresnel,
						litArgs_iridescence_intensity
					#endif
						),
					dReflection.a
				);
			#else
				dReflection = vec4f(dReflection.rgb * litArgs_specularity, dReflection.a);
			#endif
		#endif
		#ifdef AREA_LIGHTS
			dSpecularLight = dSpecularLight * litArgs_specularity;
			#ifdef LIT_SPECULAR
				calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);
			#endif
		#endif
		
		#ifdef LIGHT_COUNT > 0
			#include "lightEvaluationPS, LIGHT_COUNT"
		#endif
		#ifdef LIT_CLUSTERED_LIGHTS
			addClusteredLights(litArgs_worldNormal, dViewDirW, dReflDirW,
				#if defined(LIT_CLEARCOAT)
						ccReflDirW,
				#endif
						litArgs_gloss, litArgs_specularity, dVertexNormalW, dTBN, 
				#if defined(LIT_IRIDESCENCE)
						iridescenceFresnel,
				#endif
						litArgs_clearcoat_worldNormal, litArgs_clearcoat_gloss, litArgs_sheen_gloss, litArgs_iridescence_intensity
			);
		#endif
		#ifdef AREA_LIGHTS
			#ifdef LIT_CLEARCOAT
				litArgs_clearcoat_specularity = 1.0;
			#endif
			#ifdef LIT_SPECULAR
				litArgs_specularity = vec3(1.0);
			#endif
		#endif
		#ifdef LIT_REFRACTION
			addRefraction(
				litArgs_worldNormal, 
				dViewDirW, 
				litArgs_thickness, 
				litArgs_gloss, 
				litArgs_specularity, 
				litArgs_albedo, 
				litArgs_transmission,
				litArgs_ior,
				litArgs_dispersion
				#if defined(LIT_IRIDESCENCE)
					, iridescenceFresnel, 
					litArgs_iridescence_intensity
				#endif
			);
		#endif
	#endif
	#ifdef LIT_AO
		#ifdef LIT_OCCLUDE_DIRECT
			occludeDiffuse(litArgs_ao);
		#endif
		#if LIT_OCCLUDE_SPECULAR != NONE
			occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);
		#endif
	#endif
	#if !defined(LIT_OPACITY_FADES_SPECULAR)
		#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED
			var specLum: f32 = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3f( 0.2126, 0.7152, 0.0722 ));
			#ifdef LIT_CLEARCOAT
				specLum = specLum + dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection * litArgs_clearcoat_specularity, vec3f( 0.2126, 0.7152, 0.0722 ));
			#endif
			litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);
		#endif
		litArgs_opacity = litArgs_opacity * uniform.material_alphaFade;
	#endif
	#ifdef LIT_LIGHTMAP_BAKING
		#ifdef LIT_LIGHTMAP_BAKING_COLOR
			#include "bakeLmEndPS"
		#endif
		#ifdef LIT_LIGHTMAP_BAKING_DIR
			#include "bakeDirLmEndPS"
		#endif
	#else
		#include "endPS"
		#include "outputAlphaPS"
	#endif
	#ifdef LIT_MSDF
		output.color = applyMsdf(output.color);
	#endif
	#include "outputPS"
	#include "debugOutputPS"
	#ifdef LIT_SHADOW_CATCHER
		output.color = vec4f(vec3f(dShadowCatcher), output.color.a);
	#endif
	return output;
}
`,$X=`
var<private> sReflection: vec3f;
var<private> dVertexNormalW: vec3f;
var<private> dTangentW: vec3f;
var<private> dBinormalW: vec3f;
var<private> dViewDirW: vec3f;
var<private> dReflDirW: vec3f;
var<private> ccReflDirW: vec3f;
var<private> dLightDirNormW: vec3f;
var<private> dAtten: f32;
var<private> dTBN: mat3x3f;
var<private> dReflection: vec4f;
var<private> dDiffuseLight: vec3f;
var<private> dSpecularLight: vec3f;
var<private> ccFresnel: f32;
var<private> ccReflection: vec3f;
var<private> ccSpecularLight: vec3f;
var<private> ccSpecularityNoFres: f32;
var<private> sSpecularLight: vec3f;
#ifdef LIT_DISPERSION
	uniform material_dispersion: f32;
#endif
#ifndef LIT_OPACITY_FADES_SPECULAR
	uniform material_alphaFade: f32;
#endif
#ifdef LIT_SSAO
	var ssaoTexture : texture_2d<f32>;
	var ssaoTextureSampler : sampler;
	uniform ssaoTextureSizeInv: vec2f;
#endif
#ifdef LIT_SHADOW_CATCHER
	var<private> dShadowCatcher: f32 = 1.0;
#endif
#if LIGHT_COUNT > 0
	#include "lightDeclarationPS, LIGHT_COUNT"
#endif
#ifdef LIT_SPECULAR
	#if LIT_FRESNEL_MODEL == NONE && !defined(LIT_REFLECTIONS) && !defined(LIT_DIFFUSE_MAP) 
		#define LIT_OLD_AMBIENT
	#endif
#endif
#ifdef STD_LIGHTMAP_DIR
	uniform bakeDir: f32;
#endif
#ifdef LIT_LIGHTMAP_BAKING_ADD_AMBIENT
	uniform ambientBakeOcclusionContrast: f32;
	uniform ambientBakeOcclusionBrightness: f32;
#endif
`,KX=`
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	#include "litUserMainStartPS"
	dReflection = vec4f(0.0);
	#ifdef LIT_CLEARCOAT
		ccSpecularLight = vec3f(0.0);
		ccReflection = vec3f(0.0);
	#endif
	#if LIT_NONE_SLICE_MODE == SLICED
		#include "startNineSlicedPS"
	#elif LIT_NONE_SLICE_MODE == TILED
		#include "startNineSlicedTiledPS"
	#endif
	#ifdef LIT_NEEDS_NORMAL
		dVertexNormalW = normalize(vNormalW);
		#ifdef LIT_TANGENTS
			#if defined(LIT_HEIGHTS) || defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS) || defined(LIT_GGX_SPECULAR)
				dTangentW = vTangentW;
				dBinormalW = vBinormalW;
			#endif
		#endif
		getViewDir();
		#ifdef LIT_TBN
			getTBN(dTangentW, dBinormalW, dVertexNormalW);
			#ifdef LIT_TWO_SIDED_LIGHTING
				handleTwoSidedLighting();
			#endif
		#endif
	#endif
	evaluateFrontend();
	#include "debugProcessFrontendPS"
	var output: FragmentOutput = evaluateBackend();
	#include "litUserMainEndPS"
	return output;
}
`,ZX=`
#ifdef LIT_NEEDS_NORMAL
	#include "cubeMapRotatePS"
	#include "cubeMapProjectPS"
	#include "envProcPS"
#endif
#ifdef LIT_SPECULAR_OR_REFLECTION
	#ifdef LIT_METALNESS
		#include "metalnessModulatePS"
	#endif
	#if LIT_FRESNEL_MODEL == SCHLICK
		#include "fresnelSchlickPS"
	#endif
	#ifdef LIT_IRIDESCENCE
		#include "iridescenceDiffractionPS"
	#endif
#endif
#ifdef LIT_AO
	#include "aoDiffuseOccPS"
	#include "aoSpecOccPS"
#endif
#if LIT_REFLECTION_SOURCE == ENVATLASHQ
	#include "envAtlasPS"
	#include "reflectionEnvHQPS"
#elif LIT_REFLECTION_SOURCE == ENVATLAS
	#include "envAtlasPS"
	#include "reflectionEnvPS"
#elif LIT_REFLECTION_SOURCE == CUBEMAP
	#include "reflectionCubePS"
#elif LIT_REFLECTION_SOURCE == SPHEREMAP
	#include "reflectionSpherePS"
#endif
#ifdef LIT_REFLECTIONS
	#ifdef LIT_CLEARCOAT
		#include "reflectionCCPS"
	#endif
	#ifdef LIT_SHEEN
		#include "reflectionSheenPS"
	#endif
#endif
#ifdef LIT_REFRACTION
	#if defined(LIT_DYNAMIC_REFRACTION)
		#include "refractionDynamicPS"
	#elif defined(LIT_REFLECTIONS)
		#include "refractionCubePS"
	#endif
#endif
#ifdef LIT_SHEEN
	#include "lightSheenPS"
#endif
uniform material_ambient: vec3f;
#ifdef LIT_SPECULAR
	#ifdef LIT_LIGHTING
		#ifdef LIT_GGX_SPECULAR
			#ifdef LIT_ANISOTROPY
				#include "lightSpecularAnisoGGXPS"
			#else
				#include "lightSpecularGGXPS"
			#endif
		#else
			#include "lightSpecularBlinnPS"
		#endif
	#endif
#endif
#include "combinePS"
#ifdef LIT_LIGHTMAP
	#include "lightmapAddPS"
#endif
#ifdef LIT_ADD_AMBIENT
	#include "ambientPS"
#endif
#ifdef LIT_MSDF
	#include "msdfPS"
#endif
#ifdef LIT_NEEDS_NORMAL
	#include "viewDirPS"
	#ifdef LIT_SPECULAR
		#ifdef LIT_ANISOTROPY
			#include "reflDirAnisoPS"
		#else
			#include "reflDirPS"
		#endif
	#endif
#endif
#include "lightingPS"
`,QX=`
#include "basePS"
#include "sphericalPS"
#include "decodePS"
#include "gammaPS"
#include "tonemappingPS"
#include "fogPS"
#if LIT_NONE_SLICE_MODE == SLICED
	#include "baseNineSlicedPS"
#elif LIT_NONE_SLICE_MODE == TILED
	#include "baseNineSlicedTiledPS"
#endif
#ifdef LIT_TBN
	#include "TBNPS"
	#ifdef LIT_TWO_SIDED_LIGHTING
		#include "twoSidedLightingPS"
	#endif
#endif
`,JX=`
#include "varyingsPS"
#include "litUserDeclarationPS"
#include "frontendDeclPS"
#if defined(PICK_PASS) || defined(PREPASS_PASS)
	#include "frontendCodePS"
	#include "litUserCodePS"
	#include "litOtherMainPS"
#elif defined(SHADOW_PASS)
	#include "frontendCodePS"
	#include "litUserCodePS"
	#include "litShadowMainPS"
#else
	#include "litForwardDeclarationPS"
	#include "litForwardPreCodePS"
	#include "frontendCodePS"
	#include "litForwardPostCodePS"
	#include "litForwardBackendPS"
	#include "litUserCodePS"
	#include "litForwardMainPS"
#endif
`,e6=`
#include "varyingsVS"
#include  "litUserDeclarationVS"
#ifdef VERTEX_COLOR
	attribute vertex_color: vec4f;
#endif
#ifdef NINESLICED
	varying vMask: vec2f;
	varying vTiledUv: vec2f;
	var<private> dMaskGlobal: vec2f;
	var<private> dTiledUvGlobal: vec2f;
	uniform innerOffset: vec4f;
	uniform outerScale: vec2f;
	uniform atlasRect: vec4f;
#endif
var<private> dPositionW: vec3f;
var<private> dModelMatrix: mat4x4f;
#include "transformCoreVS"
#ifdef UV0
	attribute vertex_texCoord0: vec2f;
	#include "uv0VS"
#endif
#ifdef UV1
	attribute vertex_texCoord1: vec2f;
	#include "uv1VS"
#endif
#ifdef LINEAR_DEPTH
	#ifndef VIEWMATRIX
	#define VIEWMATRIX
		uniform matrix_view: mat4x4f;
	#endif
#endif
#include "transformVS"
#ifdef NORMALS
	#include "normalCoreVS"
	#include "normalVS"
#endif
#ifdef TANGENTS
	attribute vertex_tangent: vec4f;
#endif
#include "uvTransformUniformsPS, UV_TRANSFORMS_COUNT"
#ifdef MSDF
	#include "msdfVS"
#endif
#include  "litUserCodeVS"
#ifdef VERTEX_COLOR
	fn decodeGamma3(raw: vec3f) -> vec3f {
		return pow(raw, vec3f(2.2));
	}
	fn gammaCorrectInputVec4(color: vec4f) -> vec4f {
		return vec4f(decodeGamma3(color.xyz), color.w);
	}
#endif
@vertex
fn vertexMain(input : VertexInput) -> VertexOutput {
	#include "litUserMainStartVS"
	var output : VertexOutput;
	output.position = getPosition();
	output.vPositionW = getWorldPosition();
	#ifdef NORMALS
		output.vNormalW = getNormal();
	#endif
	#ifdef TANGENTS
		output.vTangentW = normalize(dNormalMatrix * vertex_tangent.xyz);
		output.vBinormalW = cross(output.vNormalW, output.vTangentW) * vertex_tangent.w;
	#elif defined(GGX_SPECULAR)
		output.vObjectSpaceUpW = normalize(dNormalMatrix * vec3f(0.0, 1.0, 0.0));
	#endif
	#ifdef UV0
		var uv0: vec2f = getUv0();
		#ifdef UV0_UNMODIFIED
			output.vUv0 = uv0;
		#endif
	#endif
	#ifdef UV1
		var uv1: vec2f = getUv1();
		#ifdef UV1_UNMODIFIED
			output.vUv1 = uv1;
		#endif
	#endif
	#include "uvTransformVS, UV_TRANSFORMS_COUNT"
	#ifdef VERTEX_COLOR
		#ifdef STD_VERTEX_COLOR_GAMMA
			output.vVertexColor = gammaCorrectInputVec4(vertex_color);
		#else
			output.vVertexColor = vertex_color;
		#endif
	#endif
	#ifdef LINEAR_DEPTH
		output.vLinearDepth = -(uniform.matrix_view * vec4f(output.vPositionW, 1.0)).z;
	#endif
	#ifdef MSDF
		unpackMsdfParams();
		output.outline_color = dOutlineColor;
		output.outline_thickness = dOutlineThickness;
		output.shadow_color = dShadowColor;
		output.shadow_offset = dShadowOffset;
	#endif
	#ifdef NINESLICED
		output.vMask = dMaskGlobal;
		output.vTiledUv = dTiledUvGlobal;
	#endif
	#include "litUserMainEndVS"
	return output;
}
`,t6=`
#ifdef PICK_PASS
	#include "pickPS"
#endif
#ifdef PREPASS_PASS
	#include "floatAsUintPS"
#endif
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	#include "litUserMainStartPS"
	var output: FragmentOutput;
	
	evaluateFrontend();
	#ifdef PICK_PASS
		output.color = getPickOutput();
		#ifdef DEPTH_PICK_PASS
			output.color1 = getPickDepth();
		#endif
	#endif
	#ifdef PREPASS_PASS
		output.color = float2vec4(vLinearDepth);
	#endif
	#include "litUserMainEndPS"
	return output;
}
`,s6=`
var<private> litArgs_albedo: vec3f;
var<private> litArgs_opacity: f32;
var<private> litArgs_emission: vec3f;
var<private> litArgs_worldNormal: vec3f;
var<private> litArgs_ao: f32;
var<private> litArgs_lightmap: vec3f;
var<private> litArgs_lightmapDir: vec3f;
var<private> litArgs_metalness: f32;
var<private> litArgs_specularity: vec3f;
var<private> litArgs_specularityFactor: f32;
var<private> litArgs_gloss: f32;
var<private> litArgs_sheen_gloss: f32;
var<private> litArgs_sheen_specularity: vec3f;
var<private> litArgs_transmission: f32;
var<private> litArgs_thickness: f32;
var<private> litArgs_ior: f32;
var<private> litArgs_dispersion: f32;
var<private> litArgs_iridescence_intensity: f32;
var<private> litArgs_iridescence_thickness: f32;
var<private> litArgs_clearcoat_worldNormal: vec3f;
var<private> litArgs_clearcoat_specularity: f32;
var<private> litArgs_clearcoat_gloss: f32;
`,i6=`
	#if LIT_NONE_SLICE_MODE == TILED
		var<private> textureBias: f32 = -1000.0;
	#else
		uniform textureBias: f32;
	#endif
	#include "litShaderArgsPS"
`,r6=`
#if LIGHT_TYPE != DIRECTIONAL
	uniform view_position: vec3f;
	uniform light_radius: f32;
#endif
#if SHADOW_TYPE == PCSS_32F
	#include "linearizeDepthPS"
#endif
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	#include "litUserMainStartPS"
	var output: FragmentOutput;
	evaluateFrontend();
	#ifdef PERSPECTIVE_DEPTH
		var depth: f32 = input.position.z;
		#if SHADOW_TYPE == PCSS_32F
			#if LIGHT_TYPE != DIRECTIONAL
				depth = linearizeDepthWithParams(depth, camera_params);
			#endif
		#endif
	#else
		var depth: f32 = min(distance(uniform.view_position, input.vPositionW) / uniform.light_radius, 0.99999);
		#define MODIFIED_DEPTH
	#endif
	#if SHADOW_TYPE == VSM_16F || SHADOW_TYPE == VSM_32F
		#if SHADOW_TYPE == VSM_32F
			var exponent: f32 = 15.0;
		#else
			var exponent: f32 = 5.54;
		#endif
		var depth_vsm = 2.0 * depth - 1.0;
		depth_vsm = exp(exponent * depth_vsm);
		output.color = vec4f(depth_vsm, depth_vsm * depth_vsm, 1.0, 1.0);
	#else
		#if SHADOW_TYPE == PCSS_32F
			output.color = vec4f(depth, 0.0, 0.0, 1.0);
		#else
			#ifdef MODIFIED_DEPTH
				output.fragDepth = depth;
			#endif
			output.color = vec4f(1.0);
		#endif
	#endif
	#include "litUserMainEndPS"
	
	return output;
}
`,a6=`
fn LTC_Uv(N: vec3f, V: vec3f, roughness: f32) -> vec2f {
	const LUT_SIZE: f32 = 64.0;
	const LUT_SCALE: f32 = (LUT_SIZE - 1.0) / LUT_SIZE;
	const LUT_BIAS: f32 = 0.5 / LUT_SIZE;
	let dotNV: f32 = saturate(dot( N, V ));
	let uv: vec2f = vec2f( roughness, sqrt( 1.0 - dotNV ) );
	return uv * LUT_SCALE + LUT_BIAS;
}
fn LTC_ClippedSphereFormFactor( f: vec3f ) -> f32 {
	let l: f32 = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
fn LTC_EdgeVectorFormFactor( v1: vec3f, v2: vec3f ) -> vec3f {
	let x: f32 = dot( v1, v2 );
	let y: f32 = abs( x );
	let a: f32 = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	let b: f32 = 3.4175940 + ( 4.1616724 + y ) * y;
	let v: f32 = a / b;
	let inv_sqrt_term = inverseSqrt( max( 1.0 - x * x, 1e-7f ) );
	let theta_sintheta: f32 = select( (0.5 * inv_sqrt_term - v), v, x > 0.0 );
	return cross( v1, v2 ) * theta_sintheta;
}
struct Coords {
	coord0: vec3f,
	coord1: vec3f,
	coord2: vec3f,
	coord3: vec3f,
}
fn LTC_EvaluateRect( N: vec3f, V: vec3f, P: vec3f, mInv: mat3x3f, rectCoords: Coords) -> f32 {
	let v1: vec3f = rectCoords.coord1 - rectCoords.coord0;
	let v2: vec3f = rectCoords.coord3 - rectCoords.coord0;
	let lightNormal: vec3f = cross( v1, v2 );
	let factor: f32 = sign(-dot( lightNormal, P - rectCoords.coord0 ));
	let T1: vec3f = normalize( V - N * dot( V, N ) );
	let T2: vec3f = factor * cross( N, T1 );
	let mat: mat3x3f = mInv * transpose( mat3x3f( T1, T2, N ) );
	var coords: array<vec3f, 4>;
	coords[0] = mat * ( rectCoords.coord0 - P );
	coords[1] = mat * ( rectCoords.coord1 - P );
	coords[2] = mat * ( rectCoords.coord2 - P );
	coords[3] = mat * ( rectCoords.coord3 - P );
	coords[0] = normalize( coords[0] );
	coords[1] = normalize( coords[1] );
	coords[2] = normalize( coords[2] );
	coords[3] = normalize( coords[3] );
	var vectorFormFactor: vec3f = vec3f( 0.0 );
	vectorFormFactor = vectorFormFactor + LTC_EdgeVectorFormFactor( coords[0], coords[1] );
	vectorFormFactor = vectorFormFactor + LTC_EdgeVectorFormFactor( coords[1], coords[2] );
	vectorFormFactor = vectorFormFactor + LTC_EdgeVectorFormFactor( coords[2], coords[3] );
	vectorFormFactor = vectorFormFactor + LTC_EdgeVectorFormFactor( coords[3], coords[0] );
	let result: f32 = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return result;
}
var<private> dLTCCoords: Coords;
fn getLTCLightCoords(lightPos: vec3f, halfWidth: vec3f, halfHeight: vec3f) -> Coords {
	var coords: Coords;
	coords.coord0 = lightPos + halfWidth - halfHeight;
	coords.coord1 = lightPos - halfWidth - halfHeight;
	coords.coord2 = lightPos - halfWidth + halfHeight;
	coords.coord3 = lightPos + halfWidth + halfHeight;
	return coords;
}
var<private> dSphereRadius: f32;
fn getSphereLightCoords(lightPos: vec3f, halfWidth: vec3f, halfHeight: vec3f) -> Coords {
	dSphereRadius = max(length(halfWidth), length(halfHeight));
	let f: vec3f = reflect(normalize(lightPos - uniform.view_position), vNormalW);
	let w: vec3f = normalize(cross(f, halfHeight));
	let h: vec3f = normalize(cross(f, w));
	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}
var<private> dLTCUV: vec2f;
#ifdef LIT_CLEARCOAT
	var<private> ccLTCUV: vec2f;
#endif
fn getLTCLightUV(gloss: f32, worldNormal: vec3f, viewDir: vec3f) -> vec2f {
	let roughness: f32 = max((1.0 - gloss) * (1.0 - gloss), 0.001);
	return LTC_Uv( worldNormal, viewDir, roughness );
}
var<private> dLTCSpecFres: vec3f;
#ifdef LIT_CLEARCOAT
	var<private> ccLTCSpecFres: vec3f;
#endif
fn getLTCLightSpecFres(uv: vec2f, specularity: vec3f) -> vec3f {
	let t2: vec4f = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2Sampler, uv, 0.0);
	return specularity * t2.x + ( vec3f( 1.0 ) - specularity) * t2.y;
}
fn calcLTCLightValues(gloss: f32, worldNormal: vec3f, viewDir: vec3f, specularity: vec3f, clearcoatGloss: f32, clearcoatWorldNormal: vec3f, clearcoatSpecularity: f32) {
	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity);
	#ifdef LIT_CLEARCOAT
		ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
		ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3f(clearcoatSpecularity));
	#endif
}
fn calcRectLightValues(lightPos: vec3f, halfWidth: vec3f, halfHeight: vec3f) {
	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
fn calcDiskLightValues(lightPos: vec3f, halfWidth: vec3f, halfHeight: vec3f) {
	calcRectLightValues(lightPos, halfWidth, halfHeight);
}
fn calcSphereLightValues(lightPos: vec3f, halfWidth: vec3f, halfHeight: vec3f) {
	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}
fn SolveCubic(Coefficient_in: vec4f) -> vec3f {
	let pi: f32 = 3.14159;
	var Coefficient = Coefficient_in;
	Coefficient = vec4f(Coefficient.xyz / Coefficient.w, Coefficient.w);
	let new_yz: vec2f = Coefficient.yz / 3.0;
	Coefficient = vec4f(Coefficient.x, new_yz.x, new_yz.y, Coefficient.w);
	
	let A: f32 = Coefficient.w;
	let B: f32 = Coefficient.z;
	let C: f32 = Coefficient.y;
	let D: f32 = Coefficient.x;
	let Delta: vec3f = vec3f(
		-Coefficient.z * Coefficient.z + Coefficient.y,
		-Coefficient.y * Coefficient.z + Coefficient.x,
		dot(vec2f(Coefficient.z, -Coefficient.y), Coefficient.xy)
	);
	let Discriminant: f32 = dot(vec2f(4.0 * Delta.x, -Delta.y), Delta.zy);
	var xlc: vec2f;
	var xsc: vec2f;
	{
		let A_a: f32 = 1.0;
		let C_a: f32 = Delta.x;
		let D_a: f32 = -2.0 * B * Delta.x + Delta.y;
		let Theta: f32 = atan2(sqrt(Discriminant), -D_a) / 3.0;
		let sqrt_neg_Ca = sqrt(-C_a);
		let x_1a: f32 = 2.0 * sqrt_neg_Ca * cos(Theta);
		let x_3a: f32 = 2.0 * sqrt_neg_Ca * cos(Theta + (2.0 / 3.0) * pi);
		let xl: f32 = select(x_3a, x_1a, (x_1a + x_3a) > 2.0 * B);
		xlc = vec2f(xl - B, A);
	}
	{
		let A_d: f32 = D;
		let C_d: f32 = Delta.z;
		let D_d: f32 = -D * Delta.y + 2.0 * C * Delta.z;
		let Theta: f32 = atan2(D * sqrt(Discriminant), -D_d) / 3.0;
		let sqrt_neg_Cd = sqrt(-C_d);
		let x_1d: f32 = 2.0 * sqrt_neg_Cd * cos(Theta);
		let x_3d: f32 = 2.0 * sqrt_neg_Cd * cos(Theta + (2.0 / 3.0) * pi);
		let xs: f32 = select(x_3d, x_1d, x_1d + x_3d < 2.0 * C);
		xsc = vec2f(-D, xs + C);
	}
	let E: f32 =  xlc.y * xsc.y;
	let F: f32 = -xlc.x * xsc.y - xlc.y * xsc.x;
	let G: f32 =  xlc.x * xsc.x;
	let xmc: vec2f = vec2f(C * F - B * G, -B * F + C * E);
	var Root: vec3f = vec3f(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);
	if (Root.x < Root.y && Root.x < Root.z) {
		Root = Root.yxz;
	} else if (Root.z < Root.x && Root.z < Root.y) {
		Root = Root.xzy;
	}
	return Root;
}
fn LTC_EvaluateDisk(N: vec3f, V: vec3f, P: vec3f, Minv: mat3x3f, points: Coords) -> f32 {
	let T1: vec3f = normalize(V - N * dot(V, N));
	let T2: vec3f = cross(N, T1);
	let R: mat3x3f = transpose( mat3x3f( T1, T2, N ) );
	var L_: array<vec3f, 3>;
	L_[0] = R * ( points.coord0 - P );
	L_[1] = R * ( points.coord1 - P );
	L_[2] = R * ( points.coord2 - P );
	let C: vec3f  = 0.5 * (L_[0] + L_[2]);
	var V1: vec3f = 0.5 * (L_[1] - L_[2]);
	var V2: vec3f = 0.5 * (L_[1] - L_[0]);
	let C_Minv: vec3f  = Minv * C;
	let V1_Minv: vec3f = Minv * V1;
	let V2_Minv: vec3f = Minv * V2;
	var a: f32;
	var b: f32;
	let d11: f32 = dot(V1_Minv, V1_Minv);
	let d22: f32 = dot(V2_Minv, V2_Minv);
	let d12: f32 = dot(V1_Minv, V2_Minv);
	if (abs(d12) / sqrt(d11 * d22) > 0.0001) {
		let tr: f32 = d11 + d22;
		let det_inner: f32 = -d12 * d12 + d11 * d22;
		let det: f32 = sqrt(det_inner);
		let u: f32 = 0.5 * sqrt(tr - 2.0 * det);
		let v: f32 = 0.5 * sqrt(tr + 2.0 * det);
		let e_max: f32 = (u + v) * (u + v);
		let e_min: f32 = (u - v) * (u - v);
		var V1_: vec3f;
		var V2_: vec3f;
		if (d11 > d22) {
			V1_ = d12 * V1_Minv + (e_max - d11) * V2_Minv;
			V2_ = d12 * V1_Minv + (e_min - d11) * V2_Minv;
		} else {
			V1_ = d12*V2_Minv + (e_max - d22)*V1_Minv;
			V2_ = d12*V2_Minv + (e_min - d22)*V1_Minv;
		}
		a = 1.0 / e_max;
		b = 1.0 / e_min;
		V1 = normalize(V1_);
		V2 = normalize(V2_);
	} else {
		a = 1.0 / dot(V1_Minv, V1_Minv);
		b = 1.0 / dot(V2_Minv, V2_Minv);
		V1 = V1_Minv * sqrt(a);
		V2 = V2_Minv * sqrt(b);
	}
	var V3: vec3f = normalize(cross(V1, V2));
	if (dot(C_Minv, V3) < 0.0) {
		V3 = V3 * -1.0;
	}
	let L: f32  = dot(V3, C_Minv);
	let x0: f32 = dot(V1, C_Minv) / L;
	let y0: f32 = dot(V2, C_Minv) / L;
	let E1: f32 = inverseSqrt(a);
	let E2: f32 = inverseSqrt(b);
	let a_scaled = a * L * L;
	let b_scaled = b * L * L;
	let c0: f32 = a_scaled * b_scaled;
	let c1: f32 = a_scaled * b_scaled * (1.0 + x0 * x0 + y0 * y0) - a_scaled - b_scaled;
	let c2: f32 = 1.0 - a_scaled * (1.0 + x0 * x0) - b_scaled * (1.0 + y0 * y0);
	let c3: f32 = 1.0;
	let roots: vec3f = SolveCubic(vec4f(c0, c1, c2, c3));
	let e1: f32 = roots.x;
	let e2: f32 = roots.y;
	let e3: f32 = roots.z;
	var avgDir: vec3f = vec3f(a_scaled * x0 / (a_scaled - e2), b_scaled * y0 / (b_scaled - e2), 1.0);
	let rotate: mat3x3f = mat3x3f(V1, V2, V3);
	avgDir = rotate * avgDir;
	avgDir = normalize(avgDir);
	let L1: f32 = sqrt(-e2 / e3);
	let L2: f32 = sqrt(-e2 / e1);
	let formFactor: f32 = max(0.0, L1 * L2 * inverseSqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));
	const LUT_SIZE_disk: f32 = 64.0;
	const LUT_SCALE_disk: f32 = ( LUT_SIZE_disk - 1.0 ) / LUT_SIZE_disk;
	const LUT_BIAS_disk: f32 = 0.5 / LUT_SIZE_disk;
	var uv: vec2f = vec2f(avgDir.z * 0.5 + 0.5, formFactor);
	uv = uv * LUT_SCALE_disk + LUT_BIAS_disk;
	let scale: f32 = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2Sampler, uv, 0.0).w;
	return formFactor * scale;
}
fn FixNan(value: f32) -> f32 {
	return select(value, 0.0, value != value);
}
fn getRectLightDiffuse(worldNormal: vec3f, viewDir: vec3f, lightDir: vec3f, lightDirNorm: vec3f) -> f32 {
	let identityMat = mat3x3f(vec3f(1.0, 0.0, 0.0), vec3f(0.0, 1.0, 0.0), vec3f(0.0, 0.0, 1.0));
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, identityMat, dLTCCoords );
}
fn getDiskLightDiffuse(worldNormal: vec3f, viewDir: vec3f, lightDir: vec3f, lightDirNorm: vec3f) -> f32 {
	let identityMat = mat3x3f(vec3f(1.0, 0.0, 0.0), vec3f(0.0, 1.0, 0.0), vec3f(0.0, 0.0, 1.0));
	return FixNan(LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, identityMat, dLTCCoords ));
}
fn getSphereLightDiffuse(worldNormal: vec3f, viewDir: vec3f, lightDir: vec3f, lightDirNorm: vec3f) -> f32 {
	let falloff: f32 = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
	return FixNan(getLightDiffuse(worldNormal, viewDir, lightDirNorm) * falloff);
}
fn getLTCLightInvMat(uv: vec2f) -> mat3x3f {
	let t1: vec4f = textureSampleLevel(areaLightsLutTex1, areaLightsLutTex1Sampler, uv, 0.0);
	return mat3x3f(
		vec3f( t1.x, 0.0, t1.y ),
		vec3f( 0.0, 1.0, 0.0 ),
		vec3f( t1.z, 0.0, t1.w )
	);
}
fn calcRectLightSpecular(worldNormal: vec3f, viewDir: vec3f, uv: vec2f) -> f32 {
	let mInv: mat3x3f = getLTCLightInvMat(uv);
	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
fn getRectLightSpecular(worldNormal: vec3f, viewDir: vec3f) -> f32 {
	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}
fn calcDiskLightSpecular(worldNormal: vec3f, viewDir: vec3f, uv: vec2f) -> f32 {
	let mInv: mat3x3f = getLTCLightInvMat(uv);
	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}
fn getDiskLightSpecular(worldNormal: vec3f, viewDir: vec3f) -> f32 {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
fn getSphereLightSpecular(worldNormal: vec3f, viewDir: vec3f) -> f32 {
	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`,n6=`
#ifdef STD_METALNESS_CONSTANT
uniform material_metalness: f32;
#endif
fn getMetalness() {
	var metalness: f32 = 1.0;
	#ifdef STD_METALNESS_CONSTANT
		metalness = metalness * uniform.material_metalness;
	#endif
	#ifdef STD_METALNESS_TEXTURE
		metalness = metalness * textureSampleBias({STD_METALNESS_TEXTURE_NAME}, {STD_METALNESS_TEXTURE_NAME}Sampler, {STD_METALNESS_TEXTURE_UV}, uniform.textureBias).{STD_METALNESS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_METALNESS_VERTEX
	metalness = metalness * saturate(vVertexColor.{STD_METALNESS_VERTEX_CHANNEL});
	#endif
	dMetalness = metalness;
}
`,o6=`
var texture_msdfMap: texture_2d<f32>;
var texture_msdfMapSampler: sampler;
fn median(r: f32, g: f32, b: f32) -> f32 {
	return max(min(r, g), min(max(r, g), b));
}
fn map(min: f32, max: f32, v: f32) -> f32 {
	return (v - min) / (max - min);
}
uniform font_sdfIntensity: f32;
uniform font_pxrange: f32;
uniform font_textureWidth: f32;
#ifndef LIT_MSDF_TEXT_ATTRIBUTE
	uniform outline_color: vec4f;
	uniform outline_thickness: f32;
	uniform shadow_color: vec4f;
	uniform shadow_offset: vec2f;
#else
	varying outline_color: vec4f;
	varying outline_thickness: f32;
	varying shadow_color: vec4f;
	varying shadow_offset: vec2f;
#endif
fn applyMsdf(color_in: vec4f) -> vec4f {
	#ifndef LIT_MSDF_TEXT_ATTRIBUTE
		var outline_colorValue = uniform.outline_color;
		var outline_thicknessValue = uniform.outline_thickness;
		var shadow_colorValue = uniform.shadow_color;
		var shadow_offsetValue = uniform.shadow_offset;
	#else
		var outline_colorValue = outline_color;
		var outline_thicknessValue = outline_thickness;
		var shadow_colorValue = shadow_color;
		var shadow_offsetValue = shadow_offset;
	#endif
	var color = vec4f(gammaCorrectInputVec3(color_in.rgb), color_in.a);
	let tsample: vec3f = textureSample(texture_msdfMap, texture_msdfMapSampler, vUv0).rgb;
	let uvShdw: vec2f = vUv0 - shadow_offsetValue;
	let ssample: vec3f = textureSample(texture_msdfMap, texture_msdfMapSampler, uvShdw).rgb;
	let sigDist: f32 = median(tsample.r, tsample.g, tsample.b);
	var sigDistShdw: f32 = median(ssample.r, ssample.g, ssample.b);
	let smoothingMax: f32 = 0.2;
	let w: vec2f = abs(dpdx(vUv0)) + abs(dpdy(vUv0));
	let smoothing: f32 = clamp(w.x * uniform.font_textureWidth / uniform.font_pxrange, 0.0, smoothingMax);
	let mapMin: f32 = 0.05;
	let mapMax: f32 = clamp(1.0 - uniform.font_sdfIntensity, mapMin, 1.0);
	let sigDistInner: f32 = map(mapMin, mapMax, sigDist);
	let sigDistOutline: f32 = map(mapMin, mapMax, sigDist + outline_thicknessValue);
	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thicknessValue);
	let center: f32 = 0.5;
	let inside: f32 = smoothstep(center - smoothing, center + smoothing, sigDistInner);
	let outline: f32 = smoothstep(center - smoothing, center + smoothing, sigDistOutline);
	let shadow: f32 = smoothstep(center - smoothing, center + smoothing, sigDistShdw);
	let tcolor_outline: vec4f = outline * vec4f(outline_colorValue.a * outline_colorValue.rgb, outline_colorValue.a);
	var tcolor: vec4f = select(vec4f(0.0), tcolor_outline, outline > inside);
	tcolor = mix(tcolor, color, inside);
	let scolor_shadow: vec4f = shadow * vec4f(shadow_colorValue.a * shadow_colorValue.rgb, shadow_colorValue.a);
	let scolor: vec4f = select(tcolor, scolor_shadow, shadow > outline);
	tcolor = mix(scolor, tcolor, outline);
	tcolor = vec4f(gammaCorrectOutput(tcolor.rgb), tcolor.a);
	return tcolor;
}
`,l6=`
fn getSpecularModulate(specularity: vec3f, albedo: vec3f, metalness: f32, f0: f32, specularityFactor: f32) -> vec3f {
	let dielectricF0: vec3f = f0 * specularity * specularityFactor;
	return mix(dielectricF0, albedo, metalness);
}
fn getAlbedoModulate(albedo: vec3f, metalness: f32) -> vec3f {
	return albedo * (1.0 - metalness);
}
`,c6=`
	varying uv0: vec2f;
	var morphTexture: texture_2d_array<f32>;
	uniform morphFactor: array<f32, {MORPH_TEXTURE_MAX_COUNT}>;
	uniform morphIndex: array<u32, {MORPH_TEXTURE_MAX_COUNT}>;
	uniform count: u32;
	@fragment
	fn fragmentMain(input : FragmentInput) -> FragmentOutput {
		var color = vec3f(0, 0, 0);
		let textureDims = textureDimensions(morphTexture);
		let pixelCoords = vec2i(input.uv0 * vec2f(textureDims));
		
		for (var i: u32 = 0; i < uniform.count; i = i + 1) {
			var textureIndex: u32 = uniform.morphIndex[i].element;
			var delta = textureLoad(morphTexture, pixelCoords, textureIndex, 0).xyz;
			color += uniform.morphFactor[i].element * delta;
		}
		var output: FragmentOutput;
		output.color = vec4f(color, 1.0);
		return output;
	}
`,h6=`
	attribute vertex_position: vec2f;
	varying uv0: vec2f;
	@vertex
	fn vertexMain(input: VertexInput) -> VertexOutput {
		var output: VertexOutput;
		output.position = vec4f(input.vertex_position, 0.5, 1.0);
		output.uv0 = input.vertex_position * 0.5 + vec2f(0.5, 0.5);
		return output;
	}
`,u6=`
attribute vertex_outlineParameters: vec3f;
attribute vertex_shadowParameters: vec3f;
varying outline_color: vec4f;
varying outline_thickness: f32;
varying shadow_color: vec4f;
varying shadow_offset: vec2f;
var<private> dOutlineColor: vec4f;
var<private> dOutlineThickness: f32;
var<private> dShadowColor: vec4f;
var<private> dShadowOffset: vec2f;
fn unpackMsdfParams() {
	let little: vec3f = vertex_outlineParameters % vec3f(256.0);
	let big: vec3f = (vertex_outlineParameters - little) / 256.0;
	dOutlineColor = vec4f(little.x, big.x, little.y, big.y) / 255.0;
	dOutlineThickness = little.z / 255.0 * 0.2;
	let little_shadow = vertex_shadowParameters % vec3f(256.0);
	let big_shadow = (vertex_shadowParameters - little_shadow) / 256.0;
	dShadowColor = vec4f(little_shadow.x, big_shadow.x, little_shadow.y, big_shadow.y) / 255.0;
	dShadowOffset = (vec2f(little_shadow.z, big_shadow.z) / 127.0 - 1.0) * 0.005;
}
`,d6=`
var<private> dNormalMatrix: mat3x3f;
fn getNormal() -> vec3f {
	dNormalMatrix = getNormalMatrix(dModelMatrix);
	let localNormal: vec3f = getLocalNormal(vertex_normal);
	return normalize(dNormalMatrix * localNormal);
}`,f6=`
attribute vertex_normal: vec3f;
uniform matrix_normal: mat3x3f;
#ifdef MORPHING_NORMAL
	#ifdef MORPHING_INT
		var morphNormalTex: texture_2d<u32>;
		var morphNormalTexSampler: sampler;
	#else
		var morphNormalTex: texture_2d<f32>;
		var morphNormalTexSampler: sampler;
	#endif
#endif
fn getLocalNormal(vertexNormal: vec3f) -> vec3f {
	var localNormal: vec3f = vertexNormal;
	#ifdef MORPHING_NORMAL
		let morphUV: vec2i = getTextureMorphCoords();
		#ifdef MORPHING_INT
			let morphNormalInt: vec4u = textureLoad(morphNormalTex, morphUV, 0);
			let morphNormalF: vec3f = vec3f(morphNormalInt.xyz) / 65535.0 * 2.0 - 1.0;
			localNormal = localNormal + morphNormalF;
		#else
			let morphNormal: vec3f = textureLoad(morphNormalTex, morphUV, 0).xyz;
			localNormal = localNormal + morphNormal;
		#endif
	#endif
	return localNormal;
}
#if defined(SKIN) || defined(BATCH)
	fn getNormalMatrix(modelMatrix: mat4x4f) -> mat3x3f {
		return mat3x3f(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);
	}
#elif defined(INSTANCING)
	fn getNormalMatrix(modelMatrix: mat4x4f) -> mat3x3f {
		return mat3x3f(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);
	}
#else
	fn getNormalMatrix(modelMatrix: mat4x4f) -> mat3x3f {
		return uniform.matrix_normal;
	}
#endif
`,m6=`
#ifdef STD_NORMAL_TEXTURE
	uniform material_bumpiness: f32;
#endif
#ifdef STD_NORMALDETAIL_TEXTURE
	uniform material_normalDetailMapBumpiness: f32;
	fn blendNormals(inN1: vec3f, inN2: vec3f) -> vec3f {
		let n1: vec3f = inN1 + vec3f(0.0, 0.0, 1.0);
		let n2: vec3f = inN2 * vec3f(-1.0, -1.0, 1.0);
		return n1 * dot(n1, n2) / n1.z - n2;
	}
#endif
fn getNormal() {
#ifdef STD_NORMAL_TEXTURE
	var normalMap: vec3f = {STD_NORMAL_TEXTURE_DECODE}(textureSampleBias({STD_NORMAL_TEXTURE_NAME}, {STD_NORMAL_TEXTURE_NAME}Sampler, {STD_NORMAL_TEXTURE_UV}, uniform.textureBias));
	normalMap = mix(vec3f(0.0, 0.0, 1.0), normalMap, uniform.material_bumpiness);
	#ifdef STD_NORMALDETAIL_TEXTURE
		var normalDetailMap: vec3f = {STD_NORMALDETAIL_TEXTURE_DECODE}(textureSampleBias({STD_NORMALDETAIL_TEXTURE_NAME}, {STD_NORMALDETAIL_TEXTURE_NAME}Sampler, {STD_NORMALDETAIL_TEXTURE_UV}, uniform.textureBias));
		normalDetailMap = mix(vec3f(0.0, 0.0, 1.0), normalDetailMap, uniform.material_normalDetailMapBumpiness);
		normalMap = blendNormals(normalMap, normalDetailMap);
	#endif
	dNormalW = normalize(dTBN * normalMap);
#else
	dNormalW = dVertexNormalW;
#endif
}
`,p6=`
uniform material_opacity: f32;
fn getOpacity() {
	dAlpha = uniform.material_opacity;
	#ifdef STD_OPACITY_TEXTURE
	dAlpha = dAlpha * textureSampleBias({STD_OPACITY_TEXTURE_NAME}, {STD_OPACITY_TEXTURE_NAME}Sampler, {STD_OPACITY_TEXTURE_UV}, uniform.textureBias).{STD_OPACITY_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_OPACITY_VERTEX
	dAlpha = dAlpha * clamp(vVertexColor.{STD_OPACITY_VERTEX_CHANNEL}, 0.0, 1.0);
	#endif
}
`,_6=`
#if STD_OPACITY_DITHER == BAYER8
	#include "bayerPS"
#endif
uniform blueNoiseJitter: vec4f;
#if STD_OPACITY_DITHER == BLUENOISE
	var blueNoiseTex32 : texture_2d<f32>;
	var blueNoiseTex32Sampler : sampler;
#endif
fn opacityDither(alpha: f32, id: f32) {
	#if STD_OPACITY_DITHER == BAYER8
		var noise: f32 = bayer8(floor((pcPosition.xy + uniform.blueNoiseJitter.xy + id) % vec2f(8.0))) / 64.0;
	#else
		#if STD_OPACITY_DITHER == BLUENOISE
			var uv = fract(pcPosition.xy / 32.0 + uniform.blueNoiseJitter.xy + id);
			var noise: f32 = textureSampleLevel(blueNoiseTex32, blueNoiseTex32Sampler, uv, 0.0).y;
		#endif
		#if STD_OPACITY_DITHER == IGNNOISE
			var magic = vec3f(0.06711056, 0.00583715, 52.9829189);
			var noise: f32 = fract(magic.z * fract(dot(pcPosition.xy + uniform.blueNoiseJitter.xy + id, magic.xy)));
		#endif
	#endif
	noise = pow(noise, 2.2);
	if (alpha < noise) {
		discard;
	}
}
`,g6=`
`,v6=`
#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == ADDITIVEALPHA || defined(LIT_ALPHA_TO_COVERAGE)
	output.color = vec4f(output.color.rgb, litArgs_opacity);
#elif LIT_BLEND_TYPE == PREMULTIPLIED
	output.color = vec4f(output.color.rgb * litArgs_opacity, litArgs_opacity);
#else
	output.color = vec4f(output.color.rgb, 1.0);
#endif
`,S6=`
varying vUv0: vec2f;
var source: texture_2d<f32>;
var sourceSampler: sampler;
@fragment fn fragmentMain(input : FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	output.color = textureSample(source, sourceSampler, input.vUv0);
	return output;
}
`,y6=`
uniform material_sheen: vec3f;
fn getSheen() {
	var sheenColor = uniform.material_sheen;
	#ifdef STD_SHEEN_TEXTURE
	sheenColor = sheenColor * {STD_SHEEN_TEXTURE_DECODE}(textureSampleBias({STD_SHEEN_TEXTURE_NAME}, {STD_SHEEN_TEXTURE_NAME}Sampler, {STD_SHEEN_TEXTURE_UV}, uniform.textureBias)).{STD_SHEEN_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SHEEN_VERTEX
	sheenColor = sheenColor * saturate3(vVertexColor.{STD_SHEEN_VERTEX_CHANNEL});
	#endif
	sSpecularity = sheenColor;
}
`,x6=`
uniform material_sheenGloss: f32;
fn getSheenGlossiness() {
	var sheenGlossiness = uniform.material_sheenGloss;
	#ifdef STD_SHEENGLOSS_TEXTURE
	sheenGlossiness = sheenGlossiness * textureSampleBias({STD_SHEENGLOSS_TEXTURE_NAME}, {STD_SHEENGLOSS_TEXTURE_NAME}Sampler, {STD_SHEENGLOSS_TEXTURE_UV}, uniform.textureBias).{STD_SHEENGLOSS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SHEENGLOSS_VERTEX
	sheenGlossiness = sheenGlossiness * saturate(vVertexColor.{STD_SHEENGLOSS_VERTEX_CHANNEL});
	#endif
	#ifdef STD_SHEENGLOSS_INVERT
	sheenGlossiness = 1.0 - sheenGlossiness;
	#endif
	sGlossiness = sheenGlossiness + 0.0000001;
}
`,T6=`
uniform material_heightMapFactor: f32;
fn getParallax() {
	var parallaxScale = uniform.material_heightMapFactor;
	var height: f32 = textureSampleBias({STD_HEIGHT_TEXTURE_NAME}, {STD_HEIGHT_TEXTURE_NAME}Sampler, {STD_HEIGHT_TEXTURE_UV}, uniform.textureBias).{STD_HEIGHT_TEXTURE_CHANNEL};
	height = height * parallaxScale - parallaxScale * 0.5;
	var viewDirT: vec3f = dViewDirW * dTBN;
	viewDirT.z = viewDirT.z + 0.42;
	dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`,E6=`
uniform meshInstanceId: u32;
fn getPickOutput() -> vec4f {
	let inv: vec4f = vec4f(1.0 / 255.0);
	let shifts: vec4u = vec4u(16u, 8u, 0u, 24u);
	let col: vec4u = (vec4u(uniform.meshInstanceId) >> shifts) & vec4u(0xffu);
	return vec4f(col) * inv;
}
#ifdef DEPTH_PICK_PASS
	#include "floatAsUintPS"
	fn getPickDepth() -> vec4f {
		return float2uint(pcPosition.z);
	}
#endif
`,b6=`
fn getReflDir(worldNormal: vec3f, viewDir: vec3f, gloss: f32, tbn: mat3x3f) {
	dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`,A6=`
fn getReflDir(worldNormal: vec3f, viewDir: vec3f, gloss: f32, tbn: mat3x3f) {
	let roughness: f32 = sqrt(1.0 - min(gloss, 1.0));
	let direction: vec2f = dAnisotropyRotation;
	let anisotropicT: vec3f = normalize(tbn * vec3f(direction, 0.0));
	let anisotropicB: vec3f = normalize(cross(tbn[2], anisotropicT));
	let anisotropy: f32 = dAnisotropy;
	let anisotropicDirection: vec3f = anisotropicB;
	let anisotropicTangent: vec3f = cross(anisotropicDirection, viewDir);
	let anisotropicNormal: vec3f = cross(anisotropicTangent, anisotropicDirection);
	let bendFactor: f32 = 1.0 - anisotropy * (1.0 - roughness);
	let bendFactor4: f32 = bendFactor * bendFactor * bendFactor * bendFactor;
	let bentNormal: vec3f = normalize(mix(normalize(anisotropicNormal), normalize(worldNormal), bendFactor4));
	dReflDirW = reflect(-viewDir, bentNormal);
}`,w6=`
#ifdef LIT_CLEARCOAT
fn addReflectionCC(reflDir: vec3f, gloss: f32) {
	ccReflection = ccReflection + calcReflection(reflDir, gloss);
}
#endif
`,C6=`
var texture_cubeMap: texture_cube<f32>;
var texture_cubeMapSampler: sampler;
uniform material_reflectivity: f32;
fn calcReflection(reflDir: vec3f, gloss: f32) -> vec3f {
	var lookupVec: vec3f = cubeMapProject(reflDir);
	lookupVec.x = lookupVec.x * -1.0;
	return {reflectionDecode}(textureSample(texture_cubeMap, texture_cubeMapSampler, lookupVec));
}
fn addReflection(reflDir: vec3f, gloss: f32) {
	dReflection = dReflection + vec4f(calcReflection(reflDir, gloss), uniform.material_reflectivity);
}
`,D6=`
#ifndef ENV_ATLAS
	#define ENV_ATLAS
	var texture_envAtlas: texture_2d<f32>;
	var texture_envAtlasSampler: sampler;
#endif
var texture_cubeMap: texture_cube<f32>;
var texture_cubeMapSampler: sampler;
uniform material_reflectivity: f32;
fn calcReflection(reflDir: vec3f, gloss: f32) -> vec3f {
	let dir: vec3f = cubeMapProject(reflDir) * vec3f(-1.0, 1.0, 1.0);
	let uv: vec2f = toSphericalUv(dir);
	let level: f32 = saturate(1.0 - gloss) * 5.0;
	let ilevel: f32 = floor(level);
	let flevel: f32 = level - ilevel;
	let sharp: vec3f = {reflectionCubemapDecode}(textureSample(texture_cubeMap, texture_cubeMapSampler, dir));
	let roughA: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, mapRoughnessUv(uv, ilevel)));
	let roughB: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}
fn addReflection(reflDir: vec3f, gloss: f32) {
	dReflection = dReflection + vec4f(calcReflection(reflDir, gloss), uniform.material_reflectivity);
}
`,P6=`
#ifndef ENV_ATLAS
#define ENV_ATLAS
	var texture_envAtlas: texture_2d<f32>;
	var texture_envAtlasSampler: sampler;
#endif
uniform material_reflectivity: f32;
fn shinyMipLevel(uv: vec2f) -> f32 {
	let dx: vec2f = dpdx(uv);
	let dy: vec2f = dpdy(uv);
	let uv2: vec2f = vec2f(fract(uv.x + 0.5), uv.y);
	let dx2: vec2f = dpdx(uv2);
	let dy2: vec2f = dpdy(uv2);
	let maxd: f32 = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));
	return clamp(0.5 * log2(maxd) - 1.0 + uniform.textureBias, 0.0, 5.0);
}
fn calcReflection(reflDir: vec3f, gloss: f32) -> vec3f {
	let dir: vec3f = cubeMapProject(reflDir) * vec3f(-1.0, 1.0, 1.0);
	let uv: vec2f = toSphericalUv(dir);
	let level: f32 = saturate(1.0 - gloss) * 5.0;
	let ilevel: f32 = floor(level);
	let level2: f32 = shinyMipLevel(uv * atlasSize);
	let ilevel2: f32 = floor(level2);
	var uv0: vec2f;
	var uv1: vec2f;
	var weight: f32;
	if (ilevel == 0.0) {
		uv0 = mapShinyUv(uv, ilevel2);
		uv1 = mapShinyUv(uv, ilevel2 + 1.0);
		weight = level2 - ilevel2;
	} else {
		uv0 = mapRoughnessUv(uv, ilevel);
		uv1 = uv0;
		weight = 0.0;
	}
	let linearA: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, uv0));
	let linearB: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, uv1));
	let linear0: vec3f = mix(linearA, linearB, weight);
	let linear1: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, mapRoughnessUv(uv, ilevel + 1.0)));
	return processEnvironment(mix(linear0, linear1, level - ilevel));
}
fn addReflection(reflDir: vec3f, gloss: f32) {
	dReflection = dReflection + vec4f(calcReflection(reflDir, gloss), uniform.material_reflectivity);
}
`,R6=`
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform matrix_view: mat4x4f;
#endif
var texture_sphereMap: texture_2d<f32>;
var texture_sphereMapSampler: sampler;
uniform material_reflectivity: f32;
fn calcReflection(reflDir: vec3f, gloss: f32) -> vec3f {
	let viewRotationMatrix = mat3x3f(uniform.matrix_view[0].xyz, uniform.matrix_view[1].xyz, uniform.matrix_view[2].xyz);
	let reflDirV: vec3f = viewRotationMatrix * reflDir;
	let m: f32 = 2.0 * sqrt(dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z + 1.0) * (reflDirV.z + 1.0));
	let sphereMapUv: vec2f = reflDirV.xy / m + 0.5;
	return {reflectionDecode}(textureSample(texture_sphereMap, texture_sphereMapSampler, sphereMapUv));
}
fn addReflection(reflDir: vec3f, gloss: f32) {
	dReflection = dReflection + vec4f(calcReflection(reflDir, gloss), uniform.material_reflectivity);
}
`,M6=`
fn addReflectionSheen(worldNormal: vec3f, viewDir: vec3f, gloss: f32) {
	let NoV: f32 = dot(worldNormal, viewDir);
	let alphaG: f32 = gloss * gloss;
	let a: f32 = select(
		-8.48 * alphaG + 14.3 * gloss - 9.95,
		-339.2 * alphaG + 161.4 * gloss - 25.9,
		gloss < 0.25
	);
	let b: f32 = select(
		1.97 * alphaG - 3.27 * gloss + 0.72,
		44.0 * alphaG - 23.7 * gloss + 3.26,
		gloss < 0.25
	);
	let dg_add: f32 = select(
		0.1 * ( gloss - 0.25 ),
		0.0,
		gloss < 0.25
	);
	let dg: f32 = exp( a * NoV + b ) + dg_add;
	sReflection = sReflection + (calcReflection(worldNormal, 0.0) * saturate(dg));
}`,L6=`
fn refract2(viewVec: vec3f, normal: vec3f, IOR: f32) -> vec3f {
	let vn: f32 = dot(viewVec, normal);
	let k: f32 = 1.0 - IOR * IOR * (1.0 - vn * vn);
	let refrVec: vec3f = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
	return refrVec;
}
fn addRefraction(
	worldNormal: vec3f,
	viewDir: vec3f,
	thickness: f32,
	gloss: f32,
	specularity: vec3f,
	albedo: vec3f,
	transmission: f32,
	refractionIndex: f32,
	dispersion: f32
#if defined(LIT_IRIDESCENCE)
	, iridescenceFresnel: vec3f,
	iridescenceIntensity: f32
#endif
) {
	let tmpRefl: vec4f = dReflection;
	let reflectionDir: vec3f = refract2(-viewDir, worldNormal, refractionIndex);
	dReflection = vec4f(0.0);
	addReflection(reflectionDir, gloss);
	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
	dReflection = tmpRefl;
}
`,I6=`
uniform material_invAttenuationDistance: f32;
uniform material_attenuation: vec3f;
fn evalRefractionColor(refractionVector: vec3f, gloss: f32, refractionIndex: f32) -> vec3f {
	let pointOfRefraction: vec4f = vec4f(vPositionW + refractionVector, 1.0);
	let projectionPoint: vec4f = uniform.matrix_viewProjection * pointOfRefraction;
	let uv: vec2f = getGrabScreenPos(projectionPoint);
	let iorToRoughness: f32 = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
	let refractionLod: f32 = log2(uniform.uScreenSize.x) * iorToRoughness;
	var refraction: vec3f = textureSampleLevel(uSceneColorMap, uSceneColorMapSampler, uv, refractionLod).rgb;
	#ifdef SCENE_COLORMAP_GAMMA
		refraction = decodeGamma3(refraction);
	#endif
	return refraction;
}
fn addRefraction(
	worldNormal: vec3f,
	viewDir: vec3f,
	thickness: f32,
	gloss: f32,
	specularity: vec3f,
	albedo: vec3f,
	transmission: f32,
	refractionIndex: f32,
	dispersion: f32,
#if defined(LIT_IRIDESCENCE)
	iridescenceFresnel: vec3f,
	iridescenceIntensity: f32
#endif
) {
	var modelScale: vec3f;
	modelScale.x = length(uniform.matrix_model[0].xyz);
	modelScale.y = length(uniform.matrix_model[1].xyz);
	modelScale.z = length(uniform.matrix_model[2].xyz);
	let scale: vec3f = thickness * modelScale;
	var refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;
	var refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);
	#ifdef LIT_DISPERSION
		let halfSpread: f32 = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;
		let refractionIndexR: f32 = refractionIndex - halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;
		refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;
		let refractionIndexB: f32 = refractionIndex + halfSpread;
		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;
		refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;
	#endif
	var transmittance: vec3f;
	if (uniform.material_invAttenuationDistance != 0.0)
	{
		let attenuation: vec3f = -log(uniform.material_attenuation) * uniform.material_invAttenuationDistance;
		transmittance = exp(-attenuation * length(refractionVector));
	}
	else
	{
		transmittance = vec3f(1.0);
	}
	let fresnel: vec3f = vec3f(1.0) -
		getFresnel(
			dot(viewDir, worldNormal),
			gloss,
			specularity
		#if defined(LIT_IRIDESCENCE)
			, iridescenceFresnel,
			iridescenceIntensity
		#endif
		);
	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`,O6=`
varying vUv0: vec2f;
#ifdef CUBEMAP_SOURCE
	var sourceCube: texture_cube<f32>;
	var sourceCubeSampler : sampler;
#else
	var sourceTex: texture_2d<f32>;
	var sourceTexSampler : sampler;
#endif
#ifdef USE_SAMPLES_TEX
	var samplesTex: texture_2d<f32>;
	var samplesTexSampler : sampler;
	uniform samplesTexInverseSize: vec2f;
#endif
uniform params: vec3f;
fn targetFace() -> f32 { return uniform.params.x; }
fn targetTotalPixels() -> f32 { return uniform.params.y; }
fn sourceTotalPixels() -> f32 { return uniform.params.z; }
const PI: f32 = 3.141592653589793;
fn saturate(x: f32) -> f32 {
	return clamp(x, 0.0, 1.0);
}
#include "decodePS"
#include "encodePS"
fn modifySeams(dir: vec3f, scale: f32) -> vec3f {
	let adir = abs(dir);
	let M = max(max(adir.x, adir.y), adir.z);
	return dir / M * vec3f(
		select(scale, 1.0, adir.x == M),
		select(scale, 1.0, adir.y == M),
		select(scale, 1.0, adir.z == M)
	);
}
fn toSpherical(dir: vec3f) -> vec2f {
	let nonZeroXZ = any(dir.xz != vec2f(0.0, 0.0));
	return vec2f(select(0.0, atan2(dir.x, dir.z), nonZeroXZ), asin(dir.y));
}
fn fromSpherical(uv: vec2f) -> vec3f {
	return vec3f(cos(uv.y) * sin(uv.x),
				sin(uv.y),
				cos(uv.y) * cos(uv.x));
}
fn getDirectionEquirect(uv: vec2f) -> vec3f {
	return fromSpherical((vec2f(uv.x, 1.0 - uv.y) * 2.0 - 1.0) * vec2f(PI, PI * 0.5));
}
fn signNotZero(k: f32) -> f32 {
	return select(-1.0, 1.0, k >= 0.0);
}
fn signNotZeroVec2(v: vec2f) -> vec2f {
	return vec2f(signNotZero(v.x), signNotZero(v.y));
}
fn octDecode(o: vec2f) -> vec3f {
	var v = vec3f(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
	if (v.y < 0.0) {
		var temp: vec2f = (1.0 - abs(v.zx)) * signNotZeroVec2(v.xz);
		v = vec3f(temp.x, v.y, temp.y);
	}
	return normalize(v);
}
fn getDirectionOctahedral(uv: vec2f) -> vec3f {
	return octDecode(vec2f(uv.x, 1.0 - uv.y) * 2.0 - 1.0);
}
fn octEncode(v: vec3f) -> vec2f {
	let l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	var result = v.xz * (1.0 / l1norm);
	if (v.y < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZeroVec2(result.xy);
	}
	return result;
}
#ifdef CUBEMAP_SOURCE
	fn sampleCubemapDir(dir: vec3f) -> vec4f {
		return textureSample(sourceCube, sourceCubeSampler, modifySeams(dir, 1.0));
	}
	fn sampleCubemapSph(sph: vec2f) -> vec4f {
		return sampleCubemapDir(fromSpherical(sph));
	}
	fn sampleCubemapDirLod(dir: vec3f, mipLevel: f32) -> vec4f {
		return textureSampleLevel(sourceCube, sourceCubeSampler, modifySeams(dir, 1.0), mipLevel);
	}
	fn sampleCubemapSphLod(sph: vec2f, mipLevel: f32) -> vec4f {
		return sampleCubemapDirLod(fromSpherical(sph), mipLevel);
	}
#else
	fn sampleEquirectSph(sph: vec2f) -> vec4f {
		let uv = sph / vec2f(PI * 2.0, PI) + 0.5;
		return textureSample(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y));
	}
	fn sampleEquirectDir(dir: vec3f) -> vec4f {
		return sampleEquirectSph(toSpherical(dir));
	}
	fn sampleEquirectSphLod(sph: vec2f, mipLevel: f32) -> vec4f {
		let uv = sph / vec2f(PI * 2.0, PI) + 0.5;
		return textureSampleLevel(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y), mipLevel);
	}
	fn sampleEquirectDirLod(dir: vec3f, mipLevel: f32) -> vec4f {
		return sampleEquirectSphLod(toSpherical(dir), mipLevel);
	}
	fn sampleOctahedralDir(dir: vec3f) -> vec4f {
		let uv = octEncode(dir) * 0.5 + 0.5;
		return textureSample(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y));
	}
	fn sampleOctahedralSph(sph: vec2f) -> vec4f {
		return sampleOctahedralDir(fromSpherical(sph));
	}
	fn sampleOctahedralDirLod(dir: vec3f, mipLevel: f32) -> vec4f {
		let uv = octEncode(dir) * 0.5 + 0.5;
		return textureSampleLevel(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y), mipLevel);
	}
	fn sampleOctahedralSphLod(sph: vec2f, mipLevel: f32) -> vec4f {
		return sampleOctahedralDirLod(fromSpherical(sph), mipLevel);
	}
#endif
fn getDirectionCubemap(uv: vec2f) -> vec3f {
	let st = uv * 2.0 - 1.0;
	let face = targetFace();
	var vec: vec3f;
	if (face == 0.0) {
		vec = vec3f(1, -st.y, -st.x);
	} else if (face == 1.0) {
		vec = vec3f(-1, -st.y, st.x);
	} else if (face == 2.0) {
		vec = vec3f(st.x, 1, st.y);
	} else if (face == 3.0) {
		vec = vec3f(st.x, -1, -st.y);
	} else if (face == 4.0) {
		vec = vec3f(st.x, -st.y, 1);
	} else {
		vec = vec3f(-st.x, -st.y, -1);
	}
	return normalize(modifySeams(vec, 1.0));
}
fn matrixFromVector(n: vec3f) -> mat3x3f {
	let a = 1.0 / (1.0 + n.z);
	let b = -n.x * n.y * a;
	let b1 = vec3f(1.0 - n.x * n.x * a, b, -n.x);
	let b2 = vec3f(b, 1.0 - n.y * n.y * a, -n.y);
	return mat3x3f(b1, b2, n);
}
fn matrixFromVectorSlow(n: vec3f) -> mat3x3f {
	let up = select(vec3f(0.0, 0.0, select(-1.0, 1.0, n.y > 0.0)), vec3f(0.0, 1.0, 0.0), abs(n.y) > 0.0000001);
	let x = normalize(cross(up, n));
	let y = cross(n, x);
	return mat3x3f(x, y, n);
}
fn reproject(uv: vec2f) -> vec4f {
	if ({NUM_SAMPLES} <= 1) {
		return {ENCODE_FUNC}({DECODE_FUNC}({SOURCE_FUNC}Dir({TARGET_FUNC}(uv))));
	} else {
		let t = {TARGET_FUNC}(uv);
		let tu = dpdx(t);
		let tv = dpdy(t);
		var result = vec3f(0.0);
		for (var u = 0.0; u < {NUM_SAMPLES_SQRT}; u += 1.0) {
			for (var v = 0.0; v < {NUM_SAMPLES_SQRT}; v += 1.0) {
				result += {DECODE_FUNC}({SOURCE_FUNC}Dir(normalize(t +
															tu * (u / {NUM_SAMPLES_SQRT} - 0.5) +
															tv * (v / {NUM_SAMPLES_SQRT} - 0.5))));
			}
		}
		return {ENCODE_FUNC}(result / ({NUM_SAMPLES_SQRT} * {NUM_SAMPLES_SQRT}));
	}
}
const unpackFloat: vec4f = vec4f(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);
#ifdef USE_SAMPLES_TEX
	fn unpackSample(i: i32, L: ptr<function, vec3f>, mipLevel: ptr<function, f32>) {
		var u = (f32(i * 4) + 0.5) * uniform.samplesTexInverseSize.x;
		var v = (floor(u) + 0.5) * uniform.samplesTexInverseSize.y;
		var raw: vec4f;
		raw.x = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;
		raw.y = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;
		raw.z = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;
		raw.w = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat);
		*L = raw.xyz * 2.0 - 1.0;
		*mipLevel = raw.w * 8.0;
	}
	fn prefilterSamples(uv: vec2f) -> vec4f {
		let vecSpace = matrixFromVectorSlow({TARGET_FUNC}(uv));
		var L: vec3f;
		var mipLevel: f32;
		var result = vec3f(0.0);
		var totalWeight = 0.0;
		for (var i = 0; i < {NUM_SAMPLES}; i += 1) {
			unpackSample(i, &L, &mipLevel);
			result += {DECODE_FUNC}({SOURCE_FUNC}DirLod(vecSpace * L, mipLevel)) * L.z;
			totalWeight += L.z;
		}
		return {ENCODE_FUNC}(result / totalWeight);
	}
	fn prefilterSamplesUnweighted(uv: vec2f) -> vec4f {
		let vecSpace = matrixFromVectorSlow({TARGET_FUNC}(uv));
		var L: vec3f;
		var mipLevel: f32;
		var result = vec3f(0.0);
		for (var i = 0; i < {NUM_SAMPLES}; i += 1) {
			unpackSample(i, &L, &mipLevel);
			result += {DECODE_FUNC}({SOURCE_FUNC}DirLod(vecSpace * L, mipLevel));
		}
		return {ENCODE_FUNC}(result / f32({NUM_SAMPLES}));
	}
#endif
@fragment
fn fragmentMain(input : FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	output.color = {PROCESS_FUNC}(input.vUv0);
	return output;
}
`,N6=`
attribute vertex_position: vec2f;
uniform uvMod: vec4f;
varying vUv0: vec2f;
@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
	var output: VertexOutput;
	output.position = vec4f(input.vertex_position, 0.5, 1.0);
	output.vUv0 = getImageEffectUV((input.vertex_position * 0.5 + vec2f(0.5, 0.5)) * uniform.uvMod.xy + uniform.uvMod.zw);
	return output;
}
`,F6=`
var uSceneDepthMap: texture_2d<uff>;
#ifndef SCREENSIZE
	#define SCREENSIZE
	uniform uScreenSize: vec4f;
#endif
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform matrix_view: mat4x4f;
#endif
#ifndef LINEARIZE_DEPTH
	#define LINEARIZE_DEPTH
	#ifndef CAMERAPLANES
		#define CAMERAPLANES
		uniform camera_params: vec4f;
	#endif
	fn linearizeDepth(z: f32) -> f32 {
		if (uniform.camera_params.w == 0.0) {
			return (uniform.camera_params.z * uniform.camera_params.y) / (uniform.camera_params.y + z * (uniform.camera_params.z - uniform.camera_params.y));
		} else {
			return uniform.camera_params.z + z * (uniform.camera_params.y - uniform.camera_params.z);
		}
	}
#endif
fn delinearizeDepth(linearDepth: f32) -> f32 {
	if (uniform.camera_params.w == 0.0) {
		return (uniform.camera_params.y * (uniform.camera_params.z - linearDepth)) / (linearDepth * (uniform.camera_params.z - uniform.camera_params.y));
	} else {
		return (linearDepth - uniform.camera_params.z) / (uniform.camera_params.y - uniform.camera_params.z);
	}
}
fn getLinearScreenDepth(uv: vec2f) -> f32 {
	let textureSize = textureDimensions(uSceneDepthMap, 0);
	let texel: vec2i = vec2i(uv * vec2f(textureSize));
	#ifdef SCENE_DEPTHMAP_LINEAR
		return textureLoad(uSceneDepthMap, texel, 0).r;
	#else
		return linearizeDepth(textureLoad(uSceneDepthMap, texel, 0).r);
	#endif
}
#ifndef VERTEXSHADER
	fn getLinearScreenDepthFrag() -> f32 {
		let uv: vec2f = pcPosition.xy * uniform.uScreenSize.zw;
		return getLinearScreenDepth(uv);
	}
#endif
fn getLinearDepth(pos: vec3f) -> f32 {
	return -(uniform.matrix_view * vec4f(pos, 1.0)).z;
}
`,B6=`
fn getShadowCascadeIndex(shadowCascadeDistances: vec4f, shadowCascadeCount: i32) -> i32 {
	let depth: f32 = 1.0 / pcPosition.w;
	let comparisons: vec4f = step(shadowCascadeDistances, vec4f(depth));
	let cascadeIndex: i32 = i32(dot(comparisons, vec4f(1.0)));
	return min(cascadeIndex, shadowCascadeCount - 1);
}
fn ditherShadowCascadeIndex(cascadeIndex_in: i32, shadowCascadeDistances: vec4f, shadowCascadeCount: i32, blendFactor: f32) -> i32 {
	var cascadeIndex: i32 = cascadeIndex_in;
	if (cascadeIndex < shadowCascadeCount - 1) {
		let currentRangeEnd: f32 = shadowCascadeDistances[cascadeIndex];
		let transitionStart: f32 = blendFactor * currentRangeEnd;
		let depth: f32 = 1.0 / pcPosition.w;
		if (depth > transitionStart) {
			let transitionFactor: f32 = smoothstep(transitionStart, currentRangeEnd, depth);
			let dither: f32 = fract(sin(dot(pcPosition.xy, vec2f(12.9898, 78.233))) * 43758.5453);
			if (dither < transitionFactor) {
				cascadeIndex = cascadeIndex + 1;
			}
		}
	}
	return cascadeIndex;
}
fn fadeShadow(shadowCoord_in: vec3f, shadowCascadeDistances: vec4f) -> vec3f {
	var shadowCoord: vec3f = shadowCoord_in;
	let depth: f32 = 1.0 / pcPosition.w;
	if (depth > shadowCascadeDistances.w) {
		shadowCoord.z = -9999999.0;
	}
	return shadowCoord;
}
`,U6=`
fn linstep(a: f32, b: f32, v: f32) -> f32 {
	return clamp((v - a) / (b - a), 0.0, 1.0);
}
fn reduceLightBleeding(pMax: f32, amount: f32) -> f32 {
	 return linstep(amount, 1.0, pMax);
}
fn chebyshevUpperBound(moments: vec2f, mean: f32, minVariance: f32, lightBleedingReduction: f32) -> f32 {
	var variance: f32 = moments.y - (moments.x * moments.x);
	variance = max(variance, minVariance);
	let d: f32 = mean - moments.x;
	var pMax: f32 = variance / (variance + (d * d));
	pMax = reduceLightBleeding(pMax, lightBleedingReduction);
	return select(pMax, 1.0, mean <= moments.x);
}
fn calculateEVSM(moments_in: vec3f, Z_in: f32, vsmBias: f32, exponent: f32) -> f32 {
	let Z: f32 = 2.0 * Z_in - 1.0;
	let warpedDepth: f32 = exp(exponent * Z);
	let moments: vec2f = moments_in.xy + vec2f(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments_in.z);
	let VSMBias: f32 = vsmBias;
	let depthScale: f32 = VSMBias * exponent * warpedDepth;
	let minVariance1: f32 = depthScale * depthScale;
	return chebyshevUpperBound(moments, warpedDepth, minVariance1, 0.1);
}
fn VSM16(tex: texture_2d<f32>, texSampler: sampler, texCoords: vec2f, resolution: f32, Z: f32, vsmBias: f32, exponent: f32) -> f32 {
	let moments: vec3f = textureSampleLevel(tex, texSampler, texCoords, 0.0).xyz;
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
fn getShadowVSM16(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, shadowCoord: vec3f, shadowParams: vec4f, exponent: f32) -> f32 {
	return VSM16(shadowMap, shadowMapSampler, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
fn getShadowSpotVSM16(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, shadowCoord: vec3f, shadowParams: vec4f, exponent: f32, lightDir: vec3f) -> f32 {
	let Z: f32 = length(lightDir) * shadowParams.w + shadowParams.z;
	return VSM16(shadowMap, shadowMapSampler, shadowCoord.xy, shadowParams.x, Z, shadowParams.y, exponent);
}
fn VSM32(tex: texture_2d<f32>, texSampler: sampler, texCoords_in: vec2f, resolution: f32, Z: f32, vsmBias: f32, exponent: f32) -> f32 {
	#ifdef CAPS_TEXTURE_FLOAT_FILTERABLE
		var moments: vec3f = textureSampleLevel(tex, texSampler, texCoords_in, 0.0).xyz;
	#else
		var pixelSize : f32 = 1.0 / resolution;
		let texCoords: vec2f = texCoords_in - vec2f(pixelSize);
		let s00: vec3f = textureSampleLevel(tex, texSampler, texCoords, 0.0).xyz;
		let s10: vec3f = textureSampleLevel(tex, texSampler, texCoords + vec2f(pixelSize, 0.0), 0.0).xyz;
		let s01: vec3f = textureSampleLevel(tex, texSampler, texCoords + vec2f(0.0, pixelSize), 0.0).xyz;
		let s11: vec3f = textureSampleLevel(tex, texSampler, texCoords + vec2f(pixelSize), 0.0).xyz;
		let fr: vec2f = fract(texCoords * resolution);
		let h0: vec3f = mix(s00, s10, fr.x);
		let h1: vec3f = mix(s01, s11, fr.x);
		var moments: vec3f = mix(h0, h1, fr.y);
	#endif
	return calculateEVSM(moments, Z, vsmBias, exponent);
}
fn getShadowVSM32(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, shadowCoord: vec3f, shadowParams: vec4f, exponent: f32) -> f32 {
	return VSM32(shadowMap, shadowMapSampler, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}
fn getShadowSpotVSM32(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, shadowCoord: vec3f, shadowParams: vec4f, exponent: f32, lightDir: vec3f) -> f32 {
	let Z: f32 = length(lightDir) * shadowParams.w + shadowParams.z;
	return VSM32(shadowMap, shadowMapSampler, shadowCoord.xy, shadowParams.x, Z, shadowParams.y, exponent);
}
`,z6=`
fn getShadowPCF1x1(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
	return textureSampleCompareLevel(shadowMap, shadowMapSampler, shadowCoord.xy, shadowCoord.z);
}
fn getShadowSpotPCF1x1(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
	return textureSampleCompareLevel(shadowMap, shadowMapSampler, shadowCoord.xy, shadowCoord.z);
}
`,k6=`
fn _getShadowPCF3x3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec3f) -> f32 {
	let z: f32 = shadowCoord.z;
	let uv: vec2f = shadowCoord.xy * shadowParams.x;
	let shadowMapSizeInv: f32 = 1.0 / shadowParams.x;
	let base_uv_temp: vec2f = floor(uv + 0.5);
	let s: f32 = (uv.x + 0.5 - base_uv_temp.x);
	let t: f32 = (uv.y + 0.5 - base_uv_temp.y);
	let base_uv: vec2f = (base_uv_temp - vec2f(0.5)) * shadowMapSizeInv;
	var sum: f32 = 0.0;
	let uw0: f32 = (3.0 - 2.0 * s);
	let uw1: f32 = (1.0 + 2.0 * s);
	let u0_offset: f32 = (2.0 - s) / uw0 - 1.0;
	let u1_offset: f32 = s / uw1 + 1.0;
	let vw0: f32 = (3.0 - 2.0 * t);
	let vw1: f32 = (1.0 + 2.0 * t);
	let v0_offset: f32 = (2.0 - t) / vw0 - 1.0;
	let v1_offset: f32 = t / vw1 + 1.0;
	let u0: f32 = u0_offset * shadowMapSizeInv + base_uv.x;
	let v0: f32 = v0_offset * shadowMapSizeInv + base_uv.y;
	let u1: f32 = u1_offset * shadowMapSizeInv + base_uv.x;
	let v1: f32 = v1_offset * shadowMapSizeInv + base_uv.y;
	sum = sum + uw0 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v0), z);
	sum = sum + uw1 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v0), z);
	sum = sum + uw0 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v1), z);
	sum = sum + uw1 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v1), z);
	sum = sum * (1.0 / 16.0);
	return sum;
}
fn getShadowPCF3x3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
	return _getShadowPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams.xyz);
}
fn getShadowSpotPCF3x3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
	return _getShadowPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams.xyz);
}
`,V6=`
fn _getShadowPCF5x5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec3f) -> f32 {
	let z: f32 = shadowCoord.z;
	let uv: vec2f = shadowCoord.xy * shadowParams.x;
	let shadowMapSizeInv: f32 = 1.0 / shadowParams.x;
	let base_uv_temp: vec2f = floor(uv + 0.5);
	let s: f32 = (uv.x + 0.5 - base_uv_temp.x);
	let t: f32 = (uv.y + 0.5 - base_uv_temp.y);
	let base_uv: vec2f = (base_uv_temp - vec2f(0.5)) * shadowMapSizeInv;
	let uw0: f32 = (4.0 - 3.0 * s);
	let uw1: f32 = 7.0;
	let uw2: f32 = (1.0 + 3.0 * s);
	let u0_offset: f32 = (3.0 - 2.0 * s) / uw0 - 2.0;
	let u1_offset: f32 = (3.0 + s) / uw1;
	let u2_offset: f32 = s / uw2 + 2.0;
	let vw0: f32 = (4.0 - 3.0 * t);
	let vw1: f32 = 7.0;
	let vw2: f32 = (1.0 + 3.0 * t);
	let v0_offset: f32 = (3.0 - 2.0 * t) / vw0 - 2.0;
	let v1_offset: f32 = (3.0 + t) / vw1;
	let v2_offset: f32 = t / vw2 + 2.0;
	var sum: f32 = 0.0;
	let u0: f32 = u0_offset * shadowMapSizeInv + base_uv.x;
	let v0: f32 = v0_offset * shadowMapSizeInv + base_uv.y;
	let u1: f32 = u1_offset * shadowMapSizeInv + base_uv.x;
	let v1: f32 = v1_offset * shadowMapSizeInv + base_uv.y;
	let u2: f32 = u2_offset * shadowMapSizeInv + base_uv.x;
	let v2: f32 = v2_offset * shadowMapSizeInv + base_uv.y;
	sum = sum + uw0 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v0), z);
	sum = sum + uw1 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v0), z);
	sum = sum + uw2 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u2, v0), z);
	sum = sum + uw0 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v1), z);
	sum = sum + uw1 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v1), z);
	sum = sum + uw2 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u2, v1), z);
	sum = sum + uw0 * vw2 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v2), z);
	sum = sum + uw1 * vw2 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v2), z);
	sum = sum + uw2 * vw2 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u2, v2), z);
	sum = sum * (1.0 / 144.0);
	sum = saturate(sum);
	return sum;
}
fn getShadowPCF5x5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
	return _getShadowPCF5x5(shadowMap, shadowMapSampler, shadowCoord, shadowParams.xyz);
}
fn getShadowSpotPCF5x5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {
	return _getShadowPCF5x5(shadowMap, shadowMapSampler, shadowCoord, shadowParams.xyz);
}
`,G6=`
fn fractSinRand(uv: vec2f) -> f32 {
	let PI: f32 = 3.141592653589793;
	let a: f32 = 12.9898; let b: f32 = 78.233; let c: f32 = 43758.5453;
	let dt: f32 = dot(uv.xy, vec2f(a, b));
	let sn: f32 = dt % PI;
	return fract(sin(sn) * c);
}
struct VogelDiskData {
	invNumSamples: f32,
	initialAngle: f32,
	currentPointId: f32,
}
fn prepareDiskConstants(data: ptr<function, VogelDiskData>, sampleCount: i32, randomSeed: f32) {
	let pi2: f32 = 6.28318530718;
	data.invNumSamples = 1.0 / f32(sampleCount);
	data.initialAngle = randomSeed * pi2;
	data.currentPointId = 0.0;
}
fn generateDiskSample(data: ptr<function, VogelDiskData>) -> vec2f {
	let GOLDEN_ANGLE: f32 = 2.399963;
	let r: f32 = sqrt((data.currentPointId + 0.5) * data.invNumSamples);
	let theta: f32 = data.currentPointId * GOLDEN_ANGLE + data.initialAngle;
	let offset: vec2f = vec2f(cos(theta), sin(theta)) * pow(r, 1.33);
	data.currentPointId = data.currentPointId + 1.0;
	return offset;
}
fn PCSSFindBlocker(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, avgBlockerDepth: ptr<function, f32>, numBlockers: ptr<function, i32>,
	shadowCoords: vec2f, z: f32, shadowBlockerSamples: i32, penumbraSize: f32, invShadowMapSize: f32, randomSeed: f32) {
	var diskData: VogelDiskData;
	prepareDiskConstants(&diskData, shadowBlockerSamples, randomSeed);
	let searchWidth: f32 = penumbraSize * invShadowMapSize;
	var blockerSum: f32 = 0.0;
	var numBlockers_local: i32 = 0;
	for( var i: i32 = 0; i < shadowBlockerSamples; i = i + 1 ) {
		let diskUV: vec2f = generateDiskSample(&diskData);
		let sampleUV: vec2f = shadowCoords + diskUV * searchWidth;
		let shadowMapDepth: f32 = textureSampleLevel(shadowMap, shadowMapSampler, sampleUV, 0.0).r;
		if ( shadowMapDepth < z ) {
			blockerSum = blockerSum + shadowMapDepth;
			numBlockers_local = numBlockers_local + 1;
		}
	}
	*avgBlockerDepth = blockerSum / f32(numBlockers_local);
	*numBlockers = numBlockers_local;
}
fn PCSSFilter(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, uv: vec2f, receiverDepth: f32, shadowSamples: i32, filterRadius: f32, randomSeed: f32) -> f32 {
	var diskData: VogelDiskData;
	prepareDiskConstants(&diskData, shadowSamples, randomSeed);
	var sum: f32 = 0.0;
	for (var i: i32 = 0; i < shadowSamples; i = i + 1) {
		let offsetUV: vec2f = generateDiskSample(&diskData) * filterRadius;
		let depth: f32 = textureSampleLevel(shadowMap, shadowMapSampler, uv + offsetUV, 0.0).r;
		sum = sum + step(receiverDepth, depth);
	}
	return sum / f32(shadowSamples);
}
fn getPenumbra(dblocker: f32, dreceiver: f32, penumbraSize: f32, penumbraFalloff: f32) -> f32 {
	let dist: f32 = dreceiver - dblocker;
	let penumbra: f32 = 1.0 - pow(1.0 - dist, penumbraFalloff);
	return penumbra * penumbraSize;
}
fn PCSSDirectional(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, shadowCoords: vec3f, cameraParams: vec4f, softShadowParams: vec4f) -> f32 {
	let receiverDepth: f32 = shadowCoords.z;
	let randomSeed: f32 = fractSinRand(pcPosition.xy);
	let shadowSamples: i32 = i32(softShadowParams.x);
	let shadowBlockerSamples: i32 = i32(softShadowParams.y);
	let penumbraSize: f32 = softShadowParams.z;
	let penumbraFalloff: f32 = softShadowParams.w;
	let shadowMapSize: i32 = i32(textureDimensions(shadowMap, 0).x);
	var invShadowMapSize: f32 = 1.0 / f32(shadowMapSize);
	invShadowMapSize = invShadowMapSize * (f32(shadowMapSize) / 2048.0);
	var penumbra: f32;
	if (shadowBlockerSamples > 0) {
		var avgBlockerDepth: f32 = 0.0;
		var numBlockers: i32 = 0;
		PCSSFindBlocker(shadowMap, shadowMapSampler, &avgBlockerDepth, &numBlockers, shadowCoords.xy, receiverDepth, shadowBlockerSamples, penumbraSize, invShadowMapSize, randomSeed);
		if (numBlockers < 1) {
			return 1.0;
		}
		penumbra = getPenumbra(avgBlockerDepth, shadowCoords.z, penumbraSize, penumbraFalloff);
	} else {
		penumbra = penumbraSize;
	}
	let filterRadius: f32 = penumbra * invShadowMapSize;
	return PCSSFilter(shadowMap, shadowMapSampler, shadowCoords.xy, receiverDepth, shadowSamples, filterRadius, randomSeed);
}
fn getShadowPCSS(shadowMap: texture_2d<f32>, shadowMapSampler: sampler, shadowCoord: vec3f, shadowParams: vec4f, cameraParams: vec4f, softShadowParams: vec4f, lightDir: vec3f) -> f32 {
	return PCSSDirectional(shadowMap, shadowMapSampler, shadowCoord, cameraParams, softShadowParams);
}
`,H6=`
attribute vertex_boneIndices: f32;
var texture_poseMap: texture_2d<uff>;
fn getBoneMatrix(indexFloat: f32) -> mat4x4f {
	let width = i32(textureDimensions(texture_poseMap).x);
	let index: i32 = i32(indexFloat + 0.5) * 3;
	let iy: i32 = index / width;
	let ix: i32 = index % width;
	let v1: vec4f = textureLoad(texture_poseMap, vec2i(ix + 0, iy), 0);
	let v2: vec4f = textureLoad(texture_poseMap, vec2i(ix + 1, iy), 0);
	let v3: vec4f = textureLoad(texture_poseMap, vec2i(ix + 2, iy), 0);
	return mat4x4f(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, 1.0
	);
}
`,W6=`
attribute vertex_boneWeights: vec4f;
attribute vertex_boneIndices: vec4f;
var texture_poseMap: texture_2d<uff>;
struct BoneMatrix {
	v1: vec4f,
	v2: vec4f,
	v3: vec4f,
}
fn getBoneMatrix(width: i32, index: i32) -> BoneMatrix {
	let v = index / width;
	let u = index % width;
	var result: BoneMatrix;
	result.v1 = textureLoad(texture_poseMap, vec2i(u + 0, v), 0);
	result.v2 = textureLoad(texture_poseMap, vec2i(u + 1, v), 0);
	result.v3 = textureLoad(texture_poseMap, vec2i(u + 2, v), 0);
	return result;
}
fn getSkinMatrix(indicesFloat: vec4f, weights: vec4f) -> mat4x4f {
	let width = i32(textureDimensions(texture_poseMap).x);
	var indices = vec4i(indicesFloat + 0.5) * 3;
	let boneA = getBoneMatrix(width, indices.x);
	let boneB = getBoneMatrix(width, indices.y);
	let boneC = getBoneMatrix(width, indices.z);
	let boneD = getBoneMatrix(width, indices.w);
	let v1 = boneA.v1 * weights.x + boneB.v1 * weights.y + boneC.v1 * weights.z + boneD.v1 * weights.w;
	let v2 = boneA.v2 * weights.x + boneB.v2 * weights.y + boneC.v2 * weights.z + boneD.v2 * weights.w;
	let v3 = boneA.v3 * weights.x + boneB.v3 * weights.y + boneC.v3 * weights.z + boneD.v3 * weights.w;
	let one = dot(weights, vec4f(1.0, 1.0, 1.0, 1.0));
	return mat4x4f(
		v1.x, v2.x, v3.x, 0,
		v1.y, v2.y, v3.y, 0,
		v1.z, v2.z, v3.z, 0,
		v1.w, v2.w, v3.w, one
	);
}
`,X6=`
	#define LIT_SKYBOX_INTENSITY
	#include "envProcPS"
	#include "gammaPS"
	#include "tonemappingPS"
	#ifdef PREPASS_PASS
		varying vLinearDepth: f32;
		#include "floatAsUintPS"
	#endif
	varying vViewDir : vec3f;
	uniform skyboxHighlightMultiplier : f32;
	#ifdef SKY_CUBEMAP
		var texture_cubeMap : texture_cube<f32>;
		var texture_cubeMap_sampler : sampler;
		#ifdef SKYMESH
			varying vWorldPos : vec3f;
			uniform cubeMapRotationMatrix : mat3x3f;
			uniform projectedSkydomeCenter : vec3f;
		#endif
	#else
		#include "sphericalPS"
		#include "envAtlasPS"
		var texture_envAtlas : texture_2d<f32>;
		var texture_envAtlas_sampler : sampler;
		uniform mipLevel : f32;
	#endif
	@fragment
	fn fragmentMain(input : FragmentInput) -> FragmentOutput {
		var output: FragmentOutput;
		#ifdef PREPASS_PASS
			output.color = float2vec4(vLinearDepth);
		#else
			var linear : vec3f;
			var dir : vec3f;
			#ifdef SKY_CUBEMAP
				#ifdef SKYMESH
					var envDir : vec3f = normalize(input.vWorldPos - uniform.projectedSkydomeCenter);
					dir = envDir * uniform.cubeMapRotationMatrix;
				#else
					dir = input.vViewDir;
				#endif
				dir.x *= -1.0;
				linear = {SKYBOX_DECODE_FNC}(textureSample(texture_cubeMap, texture_cubeMap_sampler, dir));
			#else
				dir = input.vViewDir * vec3f(-1.0, 1.0, 1.0);
				let uv : vec2f = toSphericalUv(normalize(dir));
				linear = {SKYBOX_DECODE_FNC}(textureSample(texture_envAtlas, texture_envAtlas_sampler, mapRoughnessUv(uv, uniform.mipLevel)));
			#endif
			if (any(linear >= vec3f(64.0))) {
				linear *= uniform.skyboxHighlightMultiplier;
			}
			
			output.color = vec4f(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
		#endif
		return output;
	}
`,q6=`
	attribute aPosition : vec4f;
	uniform matrix_view : mat4x4f;
	uniform matrix_projectionSkybox : mat4x4f;
	uniform cubeMapRotationMatrix : mat3x3f;
	varying vViewDir : vec3f;
	#ifdef PREPASS_PASS
		varying vLinearDepth: f32;
	#endif
	#ifdef SKYMESH
		uniform matrix_model : mat4x4f;
		varying vWorldPos : vec3f;
	#endif
	@vertex
	fn vertexMain(input : VertexInput) -> VertexOutput {
		var output : VertexOutput;
		var view : mat4x4f = uniform.matrix_view;
		#ifdef SKYMESH
			var worldPos : vec4f = uniform.matrix_model * input.aPosition;
			output.vWorldPos = worldPos.xyz;
			output.position = uniform.matrix_projectionSkybox * (view * worldPos);
			#ifdef PREPASS_PASS
				output.vLinearDepth = -(uniform.matrix_view * vec4f(worldPos.xyz, 1.0)).z;
			#endif
		#else
			view[3][0] = 0.0;
			view[3][1] = 0.0;
			view[3][2] = 0.0;
			output.position = uniform.matrix_projectionSkybox * (view * input.aPosition);
			output.vViewDir = input.aPosition.xyz * uniform.cubeMapRotationMatrix;
			#ifdef PREPASS_PASS
				output.vLinearDepth = -pcPosition.w;
			#endif
		#endif
		output.position.z = output.position.w - 1.0e-7;
		return output;
	}
`,Y6=`
#ifdef STD_SPECULAR_CONSTANT
	uniform material_specular: vec3f;
#endif
fn getSpecularity() {
	var specularColor = vec3f(1.0, 1.0, 1.0);
	#ifdef STD_SPECULAR_CONSTANT
	specularColor = specularColor * uniform.material_specular;
	#endif
	#ifdef STD_SPECULAR_TEXTURE
	specularColor = specularColor * {STD_SPECULAR_TEXTURE_DECODE}(textureSampleBias({STD_SPECULAR_TEXTURE_NAME}, {STD_SPECULAR_TEXTURE_NAME}Sampler, {STD_SPECULAR_TEXTURE_UV}, uniform.textureBias)).{STD_SPECULAR_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SPECULAR_VERTEX
	specularColor = specularColor * saturate3(vVertexColor.{STD_SPECULAR_VERTEX_CHANNEL});
	#endif
	dSpecularity = specularColor;
}
`,j6=`
fn toSpherical(dir: vec3f) -> vec2f {
	let angle_xz = select(0.0, atan2(dir.x, dir.z), any(dir.xz != vec2f(0.0)));
	return vec2f(angle_xz, asin(dir.y));
}
fn toSphericalUv(dir : vec3f) -> vec2f {
	const PI : f32 = 3.141592653589793;
	let uv : vec2f = toSpherical(dir) / vec2f(PI * 2.0, PI) + vec2f(0.5, 0.5);
	return vec2f(uv.x, 1.0 - uv.y);
}
`,$6=`
#ifdef STD_SPECULARITYFACTOR_CONSTANT
	uniform material_specularityFactor: f32;
#endif
fn getSpecularityFactor() {
	var specularityFactor = 1.0;
	#ifdef STD_SPECULARITYFACTOR_CONSTANT
	specularityFactor = specularityFactor * uniform.material_specularityFactor;
	#endif
	#ifdef STD_SPECULARITYFACTOR_TEXTURE
	specularityFactor = specularityFactor * textureSampleBias({STD_SPECULARITYFACTOR_TEXTURE_NAME}, {STD_SPECULARITYFACTOR_TEXTURE_NAME}Sampler, {STD_SPECULARITYFACTOR_TEXTURE_UV}, uniform.textureBias).{STD_SPECULARITYFACTOR_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_SPECULARITYFACTOR_VERTEX
	specularityFactor = specularityFactor * saturate(vVertexColor.{STD_SPECULARITYFACTOR_VERTEX_CHANNEL});
	#endif
	dSpecularityFactor = specularityFactor;
}
`,K6=`
fn getSpotEffect(lightSpotDir: vec3f, lightInnerConeAngle: f32, lightOuterConeAngle: f32, lightDirNorm: vec3f) -> f32 {
	let cosAngle: f32 = dot(lightDirNorm, lightSpotDir);
	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}`,Z6=`
	nineSlicedUv = vec2f(vUv0.x, 1.0 - vUv0.y);
`,Q6=`
	let tileMask: vec2f = step(vMask, vec2f(0.99999));
	let tileSize: vec2f = 0.5 * (innerOffset.xy + innerOffset.zw);
	let tileScale: vec2f = vec2f(1.0) / (vec2f(1.0) - tileSize);
	var clampedUv: vec2f = mix(innerOffset.xy * 0.5, vec2f(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
	var nineSlicedUv: vec2f = vUv0 * tileMask + clampedUv * (vec2f(1.0) - tileMask);
	nineSlicedUv.y = 1.0 - nineSlicedUv.y;
`,J6=`
	var<private> dAlpha: f32 = 1.0;
	#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE
		#ifdef STD_OPACITY_TEXTURE_ALLOCATE
			var texture_opacityMap : texture_2d<f32>;
			var texture_opacityMapSampler : sampler;
		#endif
	#endif
	#ifdef FORWARD_PASS
		var<private> dAlbedo: vec3f;
		var<private> dNormalW: vec3f;
		var<private> dSpecularity: vec3f = vec3f(0.0, 0.0, 0.0);
		var<private> dGlossiness: f32 = 0.0;
		#ifdef LIT_REFRACTION
			var<private> dTransmission: f32;
			var<private> dThickness: f32;
		#endif
		#ifdef LIT_SCENE_COLOR
			var uSceneColorMap : texture_2d<f32>;
			var uSceneColorMapSampler : sampler;
		#endif
		#ifdef LIT_SCREEN_SIZE
			uniform uScreenSize: vec4f;
		#endif
		#ifdef LIT_TRANSFORMS
			var<private> matrix_viewProjection: mat4x4f;
			var<private> matrix_model: mat4x4f;
		#endif
		#ifdef STD_HEIGHT_MAP
			var<private> dUvOffset: vec2f;
			#ifdef STD_HEIGHT_TEXTURE_ALLOCATE
				var texture_heightMap : texture_2d<f32>;
				var texture_heightMapSampler : sampler;
			#endif
		#endif
		#ifdef STD_DIFFUSE_TEXTURE_ALLOCATE
			var texture_diffuseMap : texture_2d<f32>;
			var texture_diffuseMapSampler : sampler;
		#endif
		#ifdef STD_DIFFUSEDETAIL_TEXTURE_ALLOCATE
			var texture_diffuseDetailMap : texture_2d<f32>;
			var texture_diffuseDetailMapSampler : sampler;
		#endif
		#ifdef STD_NORMAL_TEXTURE_ALLOCATE
			var texture_normalMap : texture_2d<f32>;
			var texture_normalMapSampler : sampler;
		#endif
		#ifdef STD_NORMALDETAIL_TEXTURE_ALLOCATE
			var texture_normalDetailMap : texture_2d<f32>;
			var texture_normalDetailMapSampler : sampler;
		#endif
		#ifdef STD_THICKNESS_TEXTURE_ALLOCATE
			var texture_thicknessMap : texture_2d<f32>;
			var texture_thicknessMapSampler : sampler;
		#endif
		#ifdef STD_REFRACTION_TEXTURE_ALLOCATE
			var texture_refractionMap : texture_2d<f32>;
			var texture_refractionMapSampler : sampler;
		#endif
		#ifdef LIT_IRIDESCENCE
			var<private> dIridescence: f32;
			var<private> dIridescenceThickness: f32;
			#ifdef STD_IRIDESCENCE_THICKNESS_TEXTURE_ALLOCATE
				var texture_iridescenceThicknessMap : texture_2d<f32>;
				var texture_iridescenceThicknessMapSampler : sampler;
			#endif
			#ifdef STD_IRIDESCENCE_TEXTURE_ALLOCATE
				var texture_iridescenceMap : texture_2d<f32>;
				var texture_iridescenceMapSampler : sampler;
			#endif
		#endif
		#ifdef LIT_CLEARCOAT
			var<private> ccSpecularity: f32;
			var<private> ccGlossiness: f32;
			var<private> ccNormalW: vec3f;
		#endif
		#ifdef LIT_GGX_SPECULAR
			var<private> dAnisotropy: f32;
			var<private> dAnisotropyRotation: vec2f;
		#endif
		#ifdef LIT_SPECULAR_OR_REFLECTION
			#ifdef LIT_SHEEN
				var<private> sSpecularity: vec3f;
				var<private> sGlossiness: f32;
				#ifdef STD_SHEEN_TEXTURE_ALLOCATE
					var texture_sheenMap : texture_2d<f32>;
					var texture_sheenMapSampler : sampler;
				#endif
				#ifdef STD_SHEENGLOSS_TEXTURE_ALLOCATE
					var texture_sheenGlossMap : texture_2d<f32>;
					var texture_sheenGlossMapSampler : sampler;
				#endif
			#endif
			#ifdef LIT_METALNESS
				var<private> dMetalness: f32;
				var<private> dIor: f32;
				#ifdef STD_METALNESS_TEXTURE_ALLOCATE
					var texture_metalnessMap : texture_2d<f32>;
					var texture_metalnessMapSampler : sampler;
				#endif
			#endif
			#ifdef LIT_SPECULARITY_FACTOR
				var<private> dSpecularityFactor: f32;
				#ifdef STD_SPECULARITYFACTOR_TEXTURE_ALLOCATE
					var texture_specularityFactorMap : texture_2d<f32>;
					var texture_specularityFactorMapSampler : sampler;
				#endif
			#endif
			#ifdef STD_SPECULAR_COLOR
				#ifdef STD_SPECULAR_TEXTURE_ALLOCATE
					var texture_specularMap : texture_2d<f32>;
					var texture_specularMapSampler : sampler;
				#endif
			#endif
			#ifdef STD_GLOSS_TEXTURE_ALLOCATE
				var texture_glossMap : texture_2d<f32>;
				var texture_glossMapSampler : sampler;
			#endif
		#endif
		#ifdef STD_AO
			var <private> dAo: f32;
			#ifdef STD_AO_TEXTURE_ALLOCATE
				var texture_aoMap : texture_2d<f32>;
				var texture_aoMapSampler : sampler;
			#endif
			#ifdef STD_AODETAIL_TEXTURE_ALLOCATE
				var texture_aoDetailMap : texture_2d<f32>;
				var texture_aoDetailMapSampler : sampler;
			#endif
		#endif
		var <private> dEmission: vec3f;
		#ifdef STD_EMISSIVE_TEXTURE_ALLOCATE
			var texture_emissiveMap : texture_2d<f32>;
			var texture_emissiveMapSampler : sampler;
		#endif
		#ifdef LIT_CLEARCOAT
			#ifdef STD_CLEARCOAT_TEXTURE_ALLOCATE
				var texture_clearCoatMap : texture_2d<f32>;
				var texture_clearCoatMapSampler : sampler;
			#endif
			#ifdef STD_CLEARCOATGLOSS_TEXTURE_ALLOCATE
				var texture_clearCoatGlossMap : texture_2d<f32>;
				var texture_clearCoatGlossMapSampler : sampler;
			#endif
			#ifdef STD_CLEARCOATNORMAL_TEXTURE_ALLOCATE
				var texture_clearCoatNormalMap : texture_2d<f32>;
				var texture_clearCoatNormalMapSampler : sampler;
			#endif
		#endif
		#ifdef LIT_GGX_SPECULAR
			#ifdef STD_ANISOTROPY_TEXTURE_ALLOCATE
				var texture_anisotropyMap : texture_2d<f32>;
				var texture_anisotropyMapSampler : sampler;
			#endif
		#endif
		#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)
			var<private> dLightmap: vec3f;
			#ifdef STD_LIGHT_TEXTURE_ALLOCATE
				var texture_lightMap : texture_2d<f32>;
				var texture_lightMapSampler : sampler;
			#endif
		#endif
	#endif
	#include "litShaderCorePS"
`,eq=`
	#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE
		#include "opacityPS"
		#if defined(LIT_ALPHA_TEST)
			#include "alphaTestPS"
		#endif
		#if STD_OPACITY_DITHER != NONE
			#include "opacityDitherPS"
		#endif
	#endif
	#ifdef FORWARD_PASS
		#ifdef STD_HEIGHT_MAP
			#include "parallaxPS"
		#endif
		#include  "diffusePS"
		#ifdef LIT_NEEDS_NORMAL
			#include "normalMapPS"
		#endif
		#ifdef LIT_REFRACTION
			#include "transmissionPS"
			#include "thicknessPS"
		#endif
		#ifdef LIT_IRIDESCENCE
			#include "iridescencePS"
			#include "iridescenceThicknessPS"
		#endif
		#ifdef LIT_SPECULAR_OR_REFLECTION
			#ifdef LIT_SHEEN
				#include "sheenPS"
				#include "sheenGlossPS"
			#endif
			#ifdef LIT_METALNESS
				#include "metalnessPS"
				#include "iorPS"
			#endif
			#ifdef LIT_SPECULARITY_FACTOR
				#include "specularityFactorPS"
			#endif
			#ifdef STD_SPECULAR_COLOR
				#include "specularPS"
			#else
				fn getSpecularity() { 
					dSpecularity = vec3f(1.0, 1.0, 1.0);
				}
			#endif
			#include "glossPS"
		#endif
		#ifdef STD_AO
			#include "aoPS"
		#endif
		#include "emissivePS"
		#ifdef LIT_CLEARCOAT
			#include "clearCoatPS"
			#include "clearCoatGlossPS"
			#include "clearCoatNormalPS"
		#endif
		#if defined(LIT_SPECULAR) && defined(LIT_LIGHTING) && defined(LIT_GGX_SPECULAR)
			#include "anisotropyPS"
		#endif
		#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)
			#include "lightmapPS"
		#endif
	#endif
	fn evaluateFrontend() {
		#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE
			getOpacity();
			#if defined(LIT_ALPHA_TEST)
				alphaTest(dAlpha);
			#endif
			#if STD_OPACITY_DITHER != NONE
				opacityDither(dAlpha, 0.0);
			#endif
			litArgs_opacity = dAlpha;
		#endif
		#ifdef FORWARD_PASS
			#ifdef STD_HEIGHT_MAP
				getParallax();
			#endif
			getAlbedo();
			litArgs_albedo = dAlbedo;
			#ifdef LIT_NEEDS_NORMAL
				getNormal();
				litArgs_worldNormal = dNormalW;
			#endif
			#ifdef LIT_REFRACTION
				getRefraction();
				litArgs_transmission = dTransmission;
				getThickness();
				litArgs_thickness = dThickness;
				#ifdef LIT_DISPERSION
					litArgs_dispersion = uniform.material_dispersion;
				#endif
			#endif
			#ifdef LIT_IRIDESCENCE
				getIridescence();
				getIridescenceThickness();
				litArgs_iridescence_intensity = dIridescence;
				litArgs_iridescence_thickness = dIridescenceThickness;
			#endif
			#ifdef LIT_SPECULAR_OR_REFLECTION
				#ifdef LIT_SHEEN
					getSheen();
					litArgs_sheen_specularity = sSpecularity;
					getSheenGlossiness();
					litArgs_sheen_gloss = sGlossiness;
				#endif
				#ifdef LIT_METALNESS
					getMetalness();
					litArgs_metalness = dMetalness;
					getIor();
					litArgs_ior = dIor;
				#endif
				#ifdef LIT_SPECULARITY_FACTOR
					getSpecularityFactor();
					litArgs_specularityFactor = dSpecularityFactor;
				#endif
				getGlossiness();
				getSpecularity();
				litArgs_specularity = dSpecularity;
				litArgs_gloss = dGlossiness;
			#endif
			#ifdef STD_AO
				getAO();
				litArgs_ao = dAo;
			#endif
			getEmission();
			litArgs_emission = dEmission;
			#ifdef LIT_CLEARCOAT
				getClearCoat();
				getClearCoatGlossiness();
				getClearCoatNormal();
				litArgs_clearcoat_specularity = ccSpecularity;
				litArgs_clearcoat_gloss = ccGlossiness;
				litArgs_clearcoat_worldNormal = ccNormalW;
			#endif
			#if defined(LIT_SPECULAR) && defined(LIT_LIGHTING) && defined(LIT_GGX_SPECULAR)
				getAnisotropy();
			#endif
			#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)
				getLightMap();
				litArgs_lightmap = dLightmap;
				#ifdef STD_LIGHTMAP_DIR
					litArgs_lightmapDir = dLightmapDir;
				#endif
			#endif
		#endif
	}
`,tq=`
#ifdef LIT_TANGENTS
	#define TBN_TANGENTS
#else
	#if defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)
		#define TBN_DERIVATIVES
	#endif
#endif
#if defined(TBN_DERIVATIVES)
	uniform tbnBasis: f32;
#endif
fn getTBN(tangent: vec3f, binormal: vec3f, normal: vec3f) {
	#ifdef TBN_TANGENTS
		dTBN = mat3x3f(normalize(tangent), normalize(binormal), normalize(normal));
	#elif defined(TBN_DERIVATIVES)
		let uv: vec2f = {lightingUv};
		let dp1: vec3f = dpdx( vPositionW );
		let dp2: vec3f = dpdy( vPositionW );
		let duv1: vec2f = dpdx( uv );
		let duv2: vec2f = dpdy( uv );
		let dp2perp: vec3f = cross( dp2, normal );
		let dp1perp: vec3f = cross( normal, dp1 );
		let T: vec3f = dp2perp * duv1.x + dp1perp * duv2.x;
		let B: vec3f = dp2perp * duv1.y + dp1perp * duv2.y;
		let denom: f32 = max( dot(T, T), dot(B, B) );
		let invmax: f32 = select(uniform.tbnBasis / sqrt( denom ), 0.0, denom == 0.0);
		dTBN = mat3x3f(T * invmax, -B * invmax, normal );
	#else
		var B: vec3f = cross(normal, vObjectSpaceUpW);
		var T: vec3f = cross(normal, B);
		if (dot(B,B) == 0.0)
		{
			let major: f32 = max(max(normal.x, normal.y), normal.z);
			if (normal.x == major)
			{
				B = cross(normal, vec3f(0.0, 1.0, 0.0));
				T = cross(normal, B);
			}
			else if (normal.y == major)
			{
				B = cross(normal, vec3f(0.0, 0.0, 1.0));
				T = cross(normal, B);
			}
			else
			{
				B = cross(normal, vec3f(1.0, 0.0, 0.0));
				T = cross(normal, B);
			}
		}
		dTBN = mat3x3f(normalize(T), normalize(B), normalize(normal));
	#endif
}`,sq=`
#ifdef STD_THICKNESS_CONSTANT
uniform material_thickness: f32;
#endif
fn getThickness() {
	dThickness = 1.0;
	#ifdef STD_THICKNESS_CONSTANT
	dThickness = dThickness * uniform.material_thickness;
	#endif
	#ifdef STD_THICKNESS_TEXTURE
	dThickness = dThickness * textureSampleBias({STD_THICKNESS_TEXTURE_NAME}, {STD_THICKNESS_TEXTURE_NAME}Sampler, {STD_THICKNESS_TEXTURE_UV}, uniform.textureBias).{STD_THICKNESS_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_THICKNESS_VERTEX
	dThickness = dThickness * saturate(vVertexColor.{STD_THICKNESS_VERTEX_CHANNEL});
	#endif
}
`,iq=`
#if (TONEMAP == NONE)
	#include "tonemappingNonePS"
#elif TONEMAP == FILMIC
	#include "tonemappingFilmicPS"
#elif TONEMAP == LINEAR
	#include "tonemappingLinearPS"
#elif TONEMAP == HEJL
	#include "tonemappingHejlPS"
#elif TONEMAP == ACES
	#include "tonemappingAcesPS"
#elif TONEMAP == ACES2
	#include "tonemappingAces2PS"
#elif TONEMAP == NEUTRAL
	#include "tonemappingNeutralPS"
#endif
`,rq=`
uniform exposure: f32;
fn toneMap(color: vec3f) -> vec3f {
	let tA: f32 = 2.51;
	let tB: f32 = 0.03;
	let tC: f32 = 2.43;
	let tD: f32 = 0.59;
	let tE: f32 = 0.14;
	let x: vec3f = color * uniform.exposure;
	return (x * (tA * x + tB)) / (x * (tC * x + tD) + tE);
}
`,aq=`
uniform exposure: f32;
const ACESInputMat: mat3x3f = mat3x3f(
	vec3f(0.59719, 0.35458, 0.04823),
	vec3f(0.07600, 0.90834, 0.01566),
	vec3f(0.02840, 0.13383, 0.83777)
);
const ACESOutputMat: mat3x3f = mat3x3f(
	vec3f( 1.60475, -0.53108, -0.07367),
	vec3f(-0.10208,  1.10813, -0.00605),
	vec3f(-0.00327, -0.07276,  1.07602)
);
fn RRTAndODTFit(v: vec3f) -> vec3f {
	let a: vec3f = v * (v + vec3f(0.0245786)) - vec3f(0.000090537);
	let b: vec3f = v * (vec3f(0.983729) * v + vec3f(0.4329510)) + vec3f(0.238081);
	return a / b;
}
fn toneMap(color: vec3f) -> vec3f {
	var c: vec3f = color * (uniform.exposure / 0.6);
	c = c * ACESInputMat;
	c = RRTAndODTFit(c);
	c = c * ACESOutputMat;
	return clamp(c, vec3f(0.0), vec3f(1.0));
}
`,nq=`
const A: f32 = 0.15;
const B: f32 = 0.50;
const C: f32 = 0.10;
const D: f32 = 0.20;
const E: f32 = 0.02;
const F: f32 = 0.30;
const W: f32 = 11.2;
uniform exposure: f32;
fn uncharted2Tonemap(x: vec3f) -> vec3f {
	return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - vec3f(E / F);
}
fn toneMap(color: vec3f) -> vec3f {
	var c: vec3f = uncharted2Tonemap(color * uniform.exposure);
	let whiteScale: vec3f = vec3f(1.0) / uncharted2Tonemap(vec3f(W, W, W));
	c *= whiteScale;
	return c;
}
`,oq=`
uniform exposure: f32;
fn toneMap(color: vec3f) -> vec3f {
	let A: f32 = 0.22;
	let B: f32 = 0.3;
	let C: f32 = 0.1;
	let D: f32 = 0.2;
	let E: f32 = 0.01;
	let F: f32 = 0.3;
	let Scl: f32 = 1.25;
	let adjusted_color = color * uniform.exposure;
	let h = max(vec3f(0.0), adjusted_color - vec3f(0.004));
	return (h * ((Scl * A) * h + Scl * vec3f(C * B)) + Scl * vec3f(D * E)) /
		   (h * (A * h + vec3f(B)) + vec3f(D * F)) -
		   Scl * vec3f(E / F);
}
`,lq=`
uniform exposure: f32;
fn toneMap(color: vec3f) -> vec3f {
	return color * uniform.exposure;
}
`,cq=`
uniform exposure: f32;
fn toneMap(col: vec3f) -> vec3f {
	var color = col * uniform.exposure;
	let startCompression = 0.8 - 0.04;
	let desaturation = 0.15;
	let x = min(color.r, min(color.g, color.b));
	let offset = select(0.04, x - 6.25 * x * x, x < 0.08);
	color -= vec3f(offset);
	let peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) {
		return color;
	}
	let d = 1.0 - startCompression;
	let newPeak = 1.0 - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);
	return mix(color, vec3f(newPeak), vec3f(g));
}
`,hq=`
fn toneMap(color: vec3f) -> vec3f {
	return color;
}
`,uq=`
#ifdef PIXELSNAP
	uniform uScreenSize: vec4f;
#endif
#ifdef SCREENSPACE
	uniform projectionFlipY: f32;
#endif
fn evalWorldPosition(vertexPosition: vec3f, modelMatrix: mat4x4f) -> vec4f {
	var localPos: vec3f = getLocalPosition(vertexPosition);
	#ifdef NINESLICED
		var localPosXZ: vec2f = localPos.xz;
		localPosXZ = localPosXZ * uniform.outerScale;
		let positiveUnitOffset: vec2f = clamp(vertexPosition.xz, vec2f(0.0), vec2f(1.0));
		let negativeUnitOffset: vec2f = clamp(-vertexPosition.xz, vec2f(0.0), vec2f(1.0));
		localPosXZ = localPosXZ + (-positiveUnitOffset * uniform.innerOffset.xy + negativeUnitOffset * uniform.innerOffset.zw) * vertex_texCoord0.xy;
		dTiledUvGlobal = (localPosXZ - uniform.outerScale + uniform.innerOffset.xy) * -0.5 + 1.0;
		localPosXZ = localPosXZ * -0.5;
		localPos = vec3f(localPosXZ.x, localPosXZ.y, localPos.y);
	#endif
	var posW: vec4f = modelMatrix * vec4f(localPos, 1.0);
	#ifdef SCREENSPACE
		posW = vec4f(posW.xy, 0.0, 1.0);
	#endif
	return posW;
}
fn getPosition() -> vec4f {
	dModelMatrix = getModelMatrix();
	let posW: vec4f = evalWorldPosition(vertex_position.xyz, dModelMatrix);
	dPositionW = posW.xyz;
	var screenPos: vec4f;
	#ifdef UV1LAYOUT
		screenPos = vec4f(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1.0);
		screenPos.y *= -1.0;
	#else
		#ifdef SCREENSPACE
			screenPos = posW;
			screenPos.y *= uniform.projectionFlipY;
		#else
			screenPos = uniform.matrix_viewProjection * posW;
		#endif
		#ifdef PIXELSNAP
			screenPos.xy = (screenPos.xy * 0.5) + 0.5;
			screenPos.xy *= uniforms.uScreenSize.xy;
			screenPos.xy = floor(screenPos.xy);
			screenPos.xy *= uniforms.uScreenSize.zw;
			screenPos.xy = (screenPos.xy * 2.0) - 1.0;
		#endif
	#endif
	return screenPos;
}
fn getWorldPosition() -> vec3f {
	return dPositionW;
}
`,dq=`
	attribute vertex_position: vec4f;
	uniform matrix_viewProjection: mat4x4f;
	uniform matrix_model: mat4x4f;
	
	#ifdef MORPHING
		uniform morph_tex_params: vec2f;
		attribute morph_vertex_id: u32;
		fn getTextureMorphCoords() -> vec2i {
			var textureSize: vec2i = vec2i(uniform.morph_tex_params);
			var morphGridV: i32 = i32(morph_vertex_id) / textureSize.x;
			var morphGridU: i32 = i32(morph_vertex_id) - (morphGridV * textureSize.x);
			morphGridV = textureSize.y - morphGridV - 1;
			return vec2i(morphGridU, morphGridV);
		}
		#ifdef MORPHING_POSITION
			#ifdef MORPHING_INT
				uniform aabbSize: vec3f;
				uniform aabbMin: vec3f;
				var morphPositionTex: texture_2d<u32>;
			#else
				var morphPositionTex: texture_2d<f32>;
			#endif
		#endif
	#endif
	#ifdef defined(BATCH)
		#include "skinBatchVS"
		fn getModelMatrix() -> mat4x4f {
			return getBoneMatrix(vertex_boneIndices);
		}
	#elif defined(SKIN)
		#include "skinVS"
		fn getModelMatrix() -> mat4x4f {
			return uniform.matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
		}
	#elif defined(INSTANCING)
		#include "transformInstancingVS"
	#else
		fn getModelMatrix() -> mat4x4f {
			return uniform.matrix_model;
		}
	#endif
	fn getLocalPosition(vertexPosition: vec3f) -> vec3f {
		var localPos: vec3f = vertexPosition;
		#ifdef MORPHING_POSITION
			var morphUV: vec2i = getTextureMorphCoords();
			#ifdef MORPHING_INT
				var morphPos: vec3f = vec3f(textureLoad(morphPositionTex, morphUV, 0).xyz) / 65535.0 * uniform.aabbSize + uniform.aabbMin;
			#else
				var morphPos: vec3f = textureLoad(morphPositionTex, morphUV, 0).xyz;
			#endif
			localPos += morphPos;
		#endif
		return localPos;
	}
`,fq=`
attribute instance_line1: vec4f;
attribute instance_line2: vec4f;
attribute instance_line3: vec4f;
attribute instance_line4: vec4f;
fn getModelMatrix() -> mat4x4f {
	return uniform.matrix_model * mat4x4f(instance_line1, instance_line2, instance_line3, instance_line4);
}
`,mq=`
#ifdef STD_REFRACTION_CONSTANT
	uniform material_refraction: f32;
#endif
fn getRefraction() {
	var refraction: f32 = 1.0;
	#ifdef STD_REFRACTION_CONSTANT
	refraction = uniform.material_refraction;
	#endif
	#ifdef STD_REFRACTION_TEXTURE
	refraction = refraction * textureSampleBias({STD_REFRACTION_TEXTURE_NAME}, {STD_REFRACTION_TEXTURE_NAME}Sampler, {STD_REFRACTION_TEXTURE_UV}, uniform.textureBias).{STD_REFRACTION_TEXTURE_CHANNEL};
	#endif
	#ifdef STD_REFRACTION_VERTEX
	refraction = refraction * saturate(vVertexColor.{STD_REFRACTION_VERTEX_CHANNEL});
	#endif
	dTransmission = refraction;
}
`,pq=`
uniform twoSidedLightingNegScaleFactor: f32;
fn handleTwoSidedLighting() {
	dTBN[2] = dTBN[2] * select(-uniform.twoSidedLightingNegScaleFactor, uniform.twoSidedLightingNegScaleFactor, pcFrontFacing);
}
`,_q=`
#ifdef NINESLICED
	fn getUv0() -> vec2f {
		var uv = vertex_position.xz;
		let positiveUnitOffset = clamp(vertex_position.xz, vec2f(0.0, 0.0), vec2f(1.0, 1.0));
		let negativeUnitOffset = clamp(-vertex_position.xz, vec2f(0.0, 0.0), vec2f(1.0, 1.0));
		uv = uv + ((-positiveUnitOffset * uniform.innerOffset.xy) + (negativeUnitOffset * uniform.innerOffset.zw)) * vertex_texCoord0.xy;
		uv = uv * -0.5 + vec2f(0.5, 0.5);
		uv = uv * uniform.atlasRect.zw + uniform.atlasRect.xy;
		dMaskGlobal = vertex_texCoord0.xy;
		return uv;
	}
#else
	fn getUv0() -> vec2f {
		return vertex_texCoord0;
	}
#endif
`,gq=`
fn getUv1() -> vec2f {
	return vertex_texCoord1;
}
`,vq=`
output.vUV{TRANSFORM_UV_{i}}_{TRANSFORM_ID_{i}} = vec2f(
	dot(vec3f(uv{TRANSFORM_UV_{i}}, 1), uniform.{TRANSFORM_NAME_{i}}0),
	dot(vec3f(uv{TRANSFORM_UV_{i}}, 1), uniform.{TRANSFORM_NAME_{i}}1)
);
`,Sq=`
	uniform {TRANSFORM_NAME_{i}}0: vec3f;
	uniform {TRANSFORM_NAME_{i}}1: vec3f;
`,yq=`
fn getViewDir() {
	dViewDirW = normalize(uniform.view_position - vPositionW);
}
`;const xq={alphaTestPS:F8,ambientPS:B8,anisotropyPS:U8,aoPS:z8,aoDiffuseOccPS:k8,aoSpecOccPS:V8,bakeDirLmEndPS:G8,bakeLmEndPS:H8,basePS:W8,baseNineSlicedPS:X8,baseNineSlicedTiledPS:q8,bayerPS:Y8,blurVSMPS:j8,clearCoatPS:$8,clearCoatGlossPS:K8,clearCoatNormalPS:Z8,clusteredLightCookiesPS:J8,clusteredLightShadowsPS:eX,clusteredLightUtilsPS:Q8,clusteredLightPS:tX,combinePS:sX,cookieBlit2DPS:iX,cookieBlitCubePS:rX,cookieBlitVS:aX,cubeMapProjectPS:nX,cubeMapRotatePS:oX,debugOutputPS:lX,debugProcessFrontendPS:cX,detailModesPS:uX,diffusePS:dX,decodePS:hX,emissivePS:fX,encodePS:mX,endPS:pX,envAtlasPS:_X,envProcPS:gX,falloffInvSquaredPS:vX,falloffLinearPS:SX,floatAsUintPS:yX,fogPS:xX,fresnelSchlickPS:TX,frontendCodePS:"",frontendDeclPS:"",fullscreenQuadVS:EX,gammaPS:bX,glossPS:AX,quadVS:wX,indirectCoreCS:CX,immediateLinePS:DX,immediateLineVS:PX,iridescenceDiffractionPS:RX,iridescencePS:MX,iridescenceThicknessPS:LX,iorPS:IX,lightDeclarationPS:OX,lightDiffuseLambertPS:NX,lightDirPointPS:FX,lightEvaluationPS:BX,lightFunctionLightPS:UX,lightFunctionShadowPS:zX,lightingPS:kX,lightmapAddPS:VX,lightmapPS:GX,lightSpecularAnisoGGXPS:HX,lightSpecularGGXPS:WX,lightSpecularBlinnPS:XX,lightSheenPS:qX,linearizeDepthPS:YX,litForwardBackendPS:jX,litForwardDeclarationPS:$X,litForwardMainPS:KX,litForwardPostCodePS:ZX,litForwardPreCodePS:QX,litMainPS:JX,litMainVS:e6,litOtherMainPS:t6,litShaderArgsPS:s6,litShaderCorePS:i6,litShadowMainPS:r6,litUserDeclarationPS:"",litUserDeclarationVS:"",litUserCodePS:"",litUserCodeVS:"",litUserMainStartPS:"",litUserMainStartVS:"",litUserMainEndPS:"",litUserMainEndVS:"",ltcPS:a6,metalnessPS:n6,metalnessModulatePS:l6,morphPS:c6,morphVS:h6,msdfPS:o6,msdfVS:u6,normalVS:d6,normalCoreVS:f6,normalMapPS:m6,opacityPS:p6,opacityDitherPS:_6,outputPS:g6,outputAlphaPS:v6,outputTex2DPS:S6,sheenPS:y6,sheenGlossPS:x6,parallaxPS:T6,pickPS:E6,reflDirPS:b6,reflDirAnisoPS:A6,reflectionCCPS:w6,reflectionCubePS:C6,reflectionEnvHQPS:D6,reflectionEnvPS:P6,reflectionSpherePS:R6,reflectionSheenPS:M6,refractionCubePS:L6,refractionDynamicPS:I6,reprojectPS:O6,reprojectVS:N6,screenDepthPS:F6,shadowCascadesPS:B6,shadowEVSMPS:U6,shadowPCF1PS:z6,shadowPCF3PS:k6,shadowPCF5PS:V6,shadowSoftPS:G6,skinBatchVS:H6,skinVS:W6,skyboxPS:X6,skyboxVS:q6,specularPS:Y6,sphericalPS:j6,specularityFactorPS:$6,spotPS:K6,startNineSlicedPS:Z6,startNineSlicedTiledPS:Q6,stdDeclarationPS:J6,stdFrontEndPS:eq,TBNPS:tq,thicknessPS:sq,tonemappingPS:iq,tonemappingAcesPS:rq,tonemappingAces2PS:aq,tonemappingFilmicPS:nq,tonemappingHejlPS:oq,tonemappingLinearPS:lq,tonemappingNeutralPS:cq,tonemappingNonePS:hq,transformVS:uq,transformCoreVS:dq,transformInstancingVS:fq,transmissionPS:mq,twoSidedLightingPS:pq,uv0VS:_q,uv1VS:gq,uvTransformVS:vq,uvTransformUniformsPS:Sq,viewDirPS:yq,webgpuPS:f2,webgpuVS:m2};class Yn extends Pe{init(e){const{assetPrefix:t,batchManager:s,componentSystems:i,elementInput:r,gamepads:a,graphicsDevice:o,keyboard:h,lightmapper:u,mouse:f,resourceHandlers:m,scriptsOrder:_,scriptPrefix:g,soundManager:S,touch:x,xr:T}=e;this.graphicsDevice=o,Ue.get(o,ot).add(N8),Ue.get(o,Je).add(xq),this._initDefaultMaterial(),this._initProgramLibrary(),this.stats=new jH(o),this._soundManager=S,this.scene=new an(o),this._registerSceneImmediate(this.scene),this.assets=new Kf(this.loader),t&&(this.assets.prefix=t),this.bundles=new UH(this.assets),this.scriptsOrder=_||[],this.defaultLayerWorld=new il({name:"World",id:sn}),this.defaultLayerDepth=new il({name:"Depth",id:xi,enabled:!1,opaqueSortMode:w_}),this.defaultLayerSkybox=new il({name:"Skybox",id:FE,opaqueSortMode:w_}),this.defaultLayerUi=new il({name:"UI",id:Cv,transparentSortMode:Jk}),this.defaultLayerImmediate=new il({name:"Immediate",id:BE,opaqueSortMode:w_});const E=new nP("default");E.pushOpaque(this.defaultLayerWorld),E.pushOpaque(this.defaultLayerDepth),E.pushOpaque(this.defaultLayerSkybox),E.pushTransparent(this.defaultLayerWorld),E.pushOpaque(this.defaultLayerImmediate),E.pushTransparent(this.defaultLayerImmediate),E.pushTransparent(this.defaultLayerUi),this.scene.layers=E,nl.createPlaceholder(o),this.renderer=new x4(o,this.scene),u&&(this.lightmapper=new u(o,this.root,this.scene,this.renderer,this.assets),this.once("prerender",this._firstBake,this)),s&&(this._batcher=new s(o,this.root,this.scene),this.once("prerender",this._firstBatch,this)),this.keyboard=h||null,this.mouse=f||null,this.touch=x||null,this.gamepads=a||null,r&&(this.elementInput=r,this.elementInput.app=this),this.xr=T?new T(this):null,this.elementInput&&this.elementInput.attachSelectEvents(),this._scriptPrefix=g||"",this.enableBundles&&this.loader.addHandler("bundle",new VH(this)),m.forEach(b=>{const C=new b(this);this.loader.addHandler(C.handlerType,C)}),i.forEach(b=>{this.systems.add(new b(this))}),this._visibilityChangeHandler=this.onVisibilityChange.bind(this),typeof document<"u"&&(document.hidden!==void 0?(this._hiddenAttr="hidden",document.addEventListener("visibilitychange",this._visibilityChangeHandler,!1)):document.mozHidden!==void 0?(this._hiddenAttr="mozHidden",document.addEventListener("mozvisibilitychange",this._visibilityChangeHandler,!1)):document.msHidden!==void 0?(this._hiddenAttr="msHidden",document.addEventListener("msvisibilitychange",this._visibilityChangeHandler,!1)):document.webkitHidden!==void 0&&(this._hiddenAttr="webkitHidden",document.addEventListener("webkitvisibilitychange",this._visibilityChangeHandler,!1))),this.tick=Tq(this)}static getApplication(e){return e?Yn._applications[e]:fl()}_initDefaultMaterial(){const e=new vr;e.name="Default Material",EV(this.graphicsDevice,e)}_initProgramLibrary(){const e=new QG(this.graphicsDevice,new vr);fV(this.graphicsDevice,e)}get soundManager(){return this._soundManager}get batcher(){return this._batcher}get fillMode(){return this._fillMode}get resolutionMode(){return this._resolutionMode}configure(e,t){Pt.get(e,(s,i)=>{if(s){t(s);return}const r=i.application_properties,a=i.scenes,o=i.assets;this._parseApplicationProperties(r,h=>{this._parseScenes(a),this._parseAssets(o),t(h||null)})})}preload(e){this.fire("preload:start");const t=this.assets.list({preload:!0});if(t.length===0){this.fire("preload:end"),e();return}let s=0;const i=()=>{s++,this.fire("preload:progress",s/t.length),s===t.length&&(this.fire("preload:end"),e())};t.forEach(r=>{r.loaded?i():(r.once("load",i),r.once("error",i),this.assets.load(r))})}_preloadScripts(e,t){t()}_parseApplicationProperties(e,t){if(typeof e.maxAssetRetries=="number"&&e.maxAssetRetries>0&&this.loader.enableRetry(e.maxAssetRetries),e.useDevicePixelRatio||(e.useDevicePixelRatio=e.use_device_pixel_ratio),e.resolutionMode||(e.resolutionMode=e.resolution_mode),e.fillMode||(e.fillMode=e.fill_mode),this._width=e.width,this._height=e.height,e.useDevicePixelRatio&&(this.graphicsDevice.maxPixelRatio=window.devicePixelRatio),this.setCanvasResolution(e.resolutionMode,this._width,this._height),this.setCanvasFillMode(e.fillMode,this._width,this._height),e.layers&&e.layerOrder){const s=new nP("application"),i={};for(const r in e.layers){const a=e.layers[r];a.id=parseInt(r,10),a.enabled=a.id!==xi,i[r]=new il(a)}for(let r=0,a=e.layerOrder.length;r<a;r++){const o=e.layerOrder[r],h=i[o.layer];h&&(o.transparent?s.pushTransparent(h):s.pushOpaque(h),s.subLayerEnabled[r]=o.enabled)}this.scene.layers=s}if(e.batchGroups){const s=this.batcher;if(s)for(let i=0,r=e.batchGroups.length;i<r;i++){const a=e.batchGroups[i];s.addGroup(a.name,a.dynamic,a.maxAabbSize,a.id,a.layers)}}e.i18nAssets&&(this.i18n.assets=e.i18nAssets),this._loadLibraries(e.libraries,t)}_loadLibraries(e,t){const s=e.length;let i=s;const r=/^https?:\/\//;if(s){const a=(o,h)=>{i--,o?t(o):i===0&&(this.onLibrariesLoaded(),t(null))};for(let o=0;o<s;++o){let h=e[o];!r.test(h.toLowerCase())&&this._scriptPrefix&&(h=Re.join(this._scriptPrefix,h)),this.loader.load(h,"script",a)}}else this.onLibrariesLoaded(),t(null)}_parseScenes(e){if(e)for(let t=0;t<e.length;t++)this.scenes.add(e[t].name,e[t].url)}_parseAssets(e){const t=[],s={},i={};for(let r=0;r<this.scriptsOrder.length;r++){const a=this.scriptsOrder[r];e[a]&&(s[a]=!0,t.push(e[a]))}if(this.enableBundles)for(const r in e)e[r].type==="bundle"&&(i[r]=!0,t.push(e[r]));for(const r in e)s[r]||i[r]||t.push(e[r]);for(let r=0;r<t.length;r++){const a=t[r],o=new Ee(a.name,a.type,a.file,a.data);if(o.id=parseInt(a.id,10),o.preload=a.preload?a.preload:!1,o.loaded=a.type==="script"&&a.data&&a.data.loadingType>0,o.tags.add(a.tags),a.i18n)for(const h in a.i18n)o.addLocalizedAssetId(h,a.i18n[h]);this.assets.add(o)}}start(){this.frame=0,this.fire("start",{timestamp:vs(),target:this}),this._librariesLoaded||this.onLibrariesLoaded(),this.systems.fire("initialize",this.root),this.fire("initialize"),this.systems.fire("postInitialize",this.root),this.systems.fire("postPostInitialize",this.root),this.fire("postinitialize"),this.requestAnimationFrame()}requestAnimationFrame(){this.xr?.session?this.frameRequestId=this.xr.session.requestAnimationFrame(this.tick):this.frameRequestId=Ve.browser||Ve.worker?requestAnimationFrame(this.tick):null}inputUpdate(e){this.controller&&this.controller.update(e),this.mouse&&this.mouse.update(),this.keyboard&&this.keyboard.update(),this.gamepads&&this.gamepads.update()}update(e){this.frame++,this.graphicsDevice.update(),this.stats.frame.scriptUpdateStart=vs(),this.systems.fire(this._inTools?"toolsUpdate":"update",e),this.stats.frame.scriptUpdate=vs()-this.stats.frame.scriptUpdateStart,this.stats.frame.animUpdateStart=vs(),this.systems.fire("animationUpdate",e),this.stats.frame.animUpdate=vs()-this.stats.frame.animUpdateStart,this.stats.frame.scriptPostUpdateStart=vs(),this.systems.fire("postUpdate",e),this.stats.frame.scriptPostUpdate=vs()-this.stats.frame.scriptPostUpdateStart,this.fire("update",e),this.inputUpdate(e)}render(){this.updateCanvasSize(),this.graphicsDevice.frameStart(),this.fire("prerender"),this.root.syncHierarchy(),this._batcher&&this._batcher.updateAll(),this.renderComposition(this.scene.layers),this.fire("postrender"),this.stats.frame.renderTime=vs()-this.stats.frame.renderStart,this.graphicsDevice.frameEnd()}renderComposition(e){this.renderer.update(e),this.renderer.buildFrameGraph(this.frameGraph,e),this.frameGraph.render(this.graphicsDevice)}_fillFrameStatsBasic(e,t,s){const i=this.stats.frame;i.dt=t,i.ms=s,e>i._timeToCountFrames?(i.fps=i._fpsAccum,i._fpsAccum=0,i._timeToCountFrames=e+1e3):i._fpsAccum++,this.stats.drawCalls.total=this.graphicsDevice._drawCallsPerFrame,this.graphicsDevice._drawCallsPerFrame=0,i.gsplats=this.renderer._gsplatCount}_fillFrameStats(){let e=this.stats.frame;e.cameras=this.renderer._camerasRendered,e.materials=this.renderer._materialSwitches,e.shaders=this.graphicsDevice._shaderSwitchesPerFrame,e.shadowMapUpdates=this.renderer._shadowMapUpdates,e.shadowMapTime=this.renderer._shadowMapTime,e.depthMapTime=this.renderer._depthMapTime,e.forwardTime=this.renderer._forwardTime;const t=this.graphicsDevice._primsPerFrame;e.triangles=t[ka]/3+Math.max(t[zr]-2,0)+Math.max(t[cl]-2,0),e.cullTime=this.renderer._cullTime,e.sortTime=this.renderer._sortTime,e.skinTime=this.renderer._skinTime,e.morphTime=this.renderer._morphTime,e.lightClusters=this.renderer._lightClusters,e.lightClustersTime=this.renderer._lightClustersTime,e.otherPrimitives=0;for(let s=0;s<t.length;s++)s<ka&&(e.otherPrimitives+=t[s]),t[s]=0;this.renderer._camerasRendered=0,this.renderer._materialSwitches=0,this.renderer._shadowMapUpdates=0,this.graphicsDevice._shaderSwitchesPerFrame=0,this.renderer._cullTime=0,this.renderer._layerCompositionUpdateTime=0,this.renderer._lightClustersTime=0,this.renderer._sortTime=0,this.renderer._skinTime=0,this.renderer._morphTime=0,this.renderer._shadowMapTime=0,this.renderer._depthMapTime=0,this.renderer._forwardTime=0,e=this.stats.drawCalls,e.forward=this.renderer._forwardDrawCalls,e.culled=this.renderer._numDrawCallsCulled,e.depth=0,e.shadow=this.renderer._shadowDrawCalls,e.skinned=this.renderer._skinDrawCalls,e.immediate=0,e.instanced=0,e.removedByInstancing=0,e.misc=e.total-(e.forward+e.shadow),this.renderer._depthDrawCalls=0,this.renderer._shadowDrawCalls=0,this.renderer._forwardDrawCalls=0,this.renderer._numDrawCallsCulled=0,this.renderer._skinDrawCalls=0,this.renderer._immediateRendered=0,this.renderer._instancedDrawCalls=0,this.stats.misc.renderTargetCreationTime=this.graphicsDevice.renderTargetCreationTime,e=this.stats.particles,e.updatesPerFrame=e._updatesPerFrame,e.frameTime=e._frameTime,e._updatesPerFrame=0,e._frameTime=0}setCanvasFillMode(e,t,s){this._fillMode=e,this.resizeCanvas(t,s)}setCanvasResolution(e,t,s){this._resolutionMode=e,e===yh&&t===void 0&&(t=this.graphicsDevice.canvas.clientWidth,s=this.graphicsDevice.canvas.clientHeight),this.graphicsDevice.resizeCanvas(t,s)}isHidden(){return document[this._hiddenAttr]}onVisibilityChange(){this.isHidden()?this._soundManager&&this._soundManager.suspend():this._soundManager&&this._soundManager.resume()}resizeCanvas(e,t){if(!this._allowResize||this.xr&&this.xr.session)return;const s=window.innerWidth,i=window.innerHeight;if(this._fillMode===gg){const r=this.graphicsDevice.canvas.width/this.graphicsDevice.canvas.height,a=s/i;r>a?(e=s,t=e/r):(t=i,e=t*r)}else this._fillMode===iT&&(e=s,t=i);return this.graphicsDevice.canvas.style.width=`${e}px`,this.graphicsDevice.canvas.style.height=`${t}px`,this.updateCanvasSize(),{width:e,height:t}}updateCanvasSize(){if(!(!this._allowResize||this.xr?.active)&&this._resolutionMode===yh){const e=this.graphicsDevice.canvas;this.graphicsDevice.resizeCanvas(e.clientWidth,e.clientHeight)}}onLibrariesLoaded(){this._librariesLoaded=!0,this.systems.rigidbody&&this.systems.rigidbody.onLibraryLoaded()}applySceneSettings(e){let t;if(this.systems.rigidbody&&typeof Ammo<"u"){const[s,i,r]=e.physics.gravity;this.systems.rigidbody.gravity.set(s,i,r)}this.scene.applySettings(e),e.render.hasOwnProperty("skybox")&&(e.render.skybox?(t=this.assets.get(e.render.skybox),t?this.setSkybox(t):this.assets.once(`add:${e.render.skybox}`,this.setSkybox,this)):this.setSkybox(null))}setAreaLightLuts(e,t){e&&t&&nl.set(this.graphicsDevice,e,t)}setSkybox(e){if(e!==this._skyboxAsset){const t=()=>{this.setSkybox(null)},s=()=>{this.scene.setSkybox(this._skyboxAsset?this._skyboxAsset.resources:null)};this._skyboxAsset&&(this.assets.off(`load:${this._skyboxAsset.id}`,s,this),this.assets.off(`remove:${this._skyboxAsset.id}`,t,this),this._skyboxAsset.off("change",s,this)),this._skyboxAsset=e,this._skyboxAsset&&(this.assets.on(`load:${this._skyboxAsset.id}`,s,this),this.assets.once(`remove:${this._skyboxAsset.id}`,t,this),this._skyboxAsset.on("change",s,this),this.scene.skyboxMip===0&&!this._skyboxAsset.loadFaces&&(this._skyboxAsset.loadFaces=!0),this.assets.load(this._skyboxAsset)),s()}}_firstBake(){this.lightmapper?.bake(null,this.scene.lightmapMode)}_firstBatch(){this.batcher?.generate()}_processTimestamp(e){return e}drawLine(e,t,s,i,r){this.scene.drawLine(e,t,s,i,r)}drawLines(e,t,s=!0,i=this.scene.defaultDrawLayer){this.scene.drawLines(e,t,s,i)}drawLineArrays(e,t,s=!0,i=this.scene.defaultDrawLayer){this.scene.drawLineArrays(e,t,s,i)}drawWireSphere(e,t,s=ue.WHITE,i=20,r=!0,a=this.scene.defaultDrawLayer){this.scene.immediate.drawWireSphere(e,t,s,i,r,a)}drawWireAlignedBox(e,t,s=ue.WHITE,i=!0,r=this.scene.defaultDrawLayer,a){this.scene.immediate.drawWireAlignedBox(e,t,s,i,r,a)}drawMeshInstance(e,t=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(null,null,null,e,t)}drawMesh(e,t,s,i=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(t,s,e,null,i)}drawQuad(e,t,s=this.scene.defaultDrawLayer){this.scene.immediate.drawMesh(t,e,this.scene.immediate.getQuadMesh(),null,s)}drawTexture(e,t,s,i,r,a,o=this.scene.defaultDrawLayer,h=!0){if(h===!1&&!this.graphicsDevice.isWebGPU)return;const u=new fe;u.setTRS(new D(e,t,0),pe.IDENTITY,new D(s,-i,0)),a||(a=new Za,a.cull=Ft,a.setParameter("colorMap",r),a.shaderDesc=h?this.scene.immediate.getTextureShaderDesc(r.encoding):this.scene.immediate.getUnfilterableTextureShaderDesc(),a.update()),this.drawQuad(u,a,o)}drawDepthTexture(e,t,s,i,r=this.scene.defaultDrawLayer){const a=new Za;a.cull=Ft,a.shaderDesc=this.scene.immediate.getDepthTextureShaderDesc(),a.update(),this.drawTexture(e,t,s,i,null,a,r)}destroy(){if(this._inFrameUpdate){this._destroyRequested=!0;return}const e=this.graphicsDevice.canvas.id;this.fire("destroy",this),this.off("librariesloaded"),this._gsplatSortedEvt?.off(),this._gsplatSortedEvt=null,typeof document<"u"&&(document.removeEventListener("visibilitychange",this._visibilityChangeHandler,!1),document.removeEventListener("mozvisibilitychange",this._visibilityChangeHandler,!1),document.removeEventListener("msvisibilitychange",this._visibilityChangeHandler,!1),document.removeEventListener("webkitvisibilitychange",this._visibilityChangeHandler,!1)),this._visibilityChangeHandler=null,this.root.destroy(),this.root=null,this.mouse&&(this.mouse.off(),this.mouse.detach(),this.mouse=null),this.keyboard&&(this.keyboard.off(),this.keyboard.detach(),this.keyboard=null),this.touch&&(this.touch.off(),this.touch.detach(),this.touch=null),this.elementInput&&(this.elementInput.detach(),this.elementInput=null),this.gamepads&&(this.gamepads.destroy(),this.gamepads=null),this.controller&&(this.controller=null),this.systems.destroy(),this.scene.layers&&this.scene.layers.destroy(),this.bundles.destroy(),this.bundles=null,this.i18n.destroy(),this.i18n=null,this.loader.getHandler("script")?.clearCache(),this.loader.destroy(),this.loader=null,this.systems=null,this.context=null,this.scripts.destroy(),this.scripts=null,this.scenes.destroy(),this.scenes=null,this.lightmapper?.destroy(),this.lightmapper=null,this._batcher&&(this._batcher.destroy(),this._batcher=null),this._entityIndex={},this.defaultLayerDepth.onDisable=null,this.defaultLayerDepth.onEnable=null,this.defaultLayerDepth=null,this.defaultLayerWorld=null,this.xr?.end(),this.xr?.destroy(),this.renderer.destroy(),this.renderer=null;const s=this.assets.list();for(let i=0;i<s.length;i++)s[i].unload(),s[i].off();this.assets.off(),this.scene.destroy(),this.scene=null,this.graphicsDevice.destroy(),this.graphicsDevice=null,this.tick=null,this.off(),this._soundManager?.destroy(),this._soundManager=null,Yn._applications[e]=null,fl()===this&&aT(null),Yn.cancelTick(this)}static cancelTick(e){e.frameRequestId&&(cancelAnimationFrame(e.frameRequestId),e.frameRequestId=void 0)}getEntityFromIndex(e){return this._entityIndex[e]}_registerSceneImmediate(e){this.on("postrender",e.immediate.onPostRender,e.immediate),this._gsplatSortedEvt=e.on("gsplat:sorted",t=>{this.stats.frame.gsplatSort+=t})}constructor(e){super(),this._batcher=null,this._destroyRequested=!1,this._inFrameUpdate=!1,this._librariesLoaded=!1,this._fillMode=gg,this._resolutionMode=rT,this._allowResize=!0,this._skyboxAsset=null,this._entityIndex={},this._inTools=!1,this._scriptPrefix="",this._time=0,this.enableBundles=typeof TextDecoder<"u",this.timeScale=1,this.maxDeltaTime=.1,this.frame=0,this.frameGraph=new RH,this.scriptsOrder=[],this.autoRender=!0,this.renderNextFrame=!1,this.lightmapper=null,this.loader=new xh(this),this.scenes=new YH(this),this.scripts=new HH(this),this.systems=new zH,this.i18n=new ao(this),this.keyboard=null,this.mouse=null,this.touch=null,this.gamepads=null,this.elementInput=null,this.xr=null,Yn._applications[e.id]=this,aT(this),this.root=new Nt,this.root._enabledInHierarchy=!0}}Yn._applications={};const Tq=function(c){const e=c;return function(t,s){if(!e.graphicsDevice)return;e.frameRequestId&&(e.xr?.session?.cancelAnimationFrame(e.frameRequestId),cancelAnimationFrame(e.frameRequestId),e.frameRequestId=null),e._inFrameUpdate=!0,aT(e);const i=e._processTimestamp(t)||vs(),r=i-(e._time||i);let a=r/1e3;if(a=J.clamp(a,0,e.maxDeltaTime),a*=e.timeScale,e._time=i,e.requestAnimationFrame(),e.graphicsDevice.contextLost)return;e._fillFrameStatsBasic(i,a,r),e.fire("frameupdate",r);let o=!1;s?(o=!e.xr?.update(s),e.graphicsDevice.defaultFramebuffer=s.session.renderState.baseLayer.framebuffer):e.graphicsDevice.defaultFramebuffer=null,o||(e.update(a),e.fire("framerender"),(e.autoRender||e.renderNextFrame)&&(e.render(),e.renderNextFrame=!1),e.fire("frameend"),e.stats.frameEnd()),e._inFrameUpdate=!1,e._destroyRequested&&e.destroy()}};class Eq{constructor(){this.componentSystems=[],this.resourceHandlers=[]}}const _d=new KT;class EL{store(){this.mask=this.light.mask,this.shadowUpdateMode=this.light.shadowUpdateMode,this.enabled=this.light.enabled,this.intensity=this.light.intensity,this.rotation=this.light._node.getLocalRotation().clone(),this.numCascades=this.light.numCascades,this.castShadows=this.light._castShadows}restore(){const e=this.light;e.mask=this.mask,e.shadowUpdateMode=this.shadowUpdateMode,e.enabled=this.enabled,e.intensity=this.intensity,e._node.setLocalRotation(this.rotation),e.numCascades=this.numCascades,e._castShadows=this.castShadows}startBake(){this.light.enabled=!0,this.light._destroyShadowMap(),this.light.beginFrame()}endBake(e){const t=this.light;t.enabled=!1,t.shadowMap&&(t.shadowMap.cached&&e.add(t,t.shadowMap),t.shadowMap=null)}constructor(e,t,s){this.scene=e,this.light=t,this.store(),t.numCascades=1,this.scene.clusteredLightingEnabled&&!s.shadowsEnabled&&(t.castShadows=!1),t.type!==Ne&&(t._node.getWorldTransform(),t.getBoundingSphere(_d),this.lightBounds=new Ge,this.lightBounds.center.copy(_d.center),this.lightBounds.halfExtents.set(_d.radius,_d.radius,_d.radius))}}const Jp=new ne;class bq extends EL{get numVirtualLights(){return this.light.type===Ne?this.light.bakeNumSamples:1}prepareVirtualLight(e,t){const s=this.light;if(s._node.setLocalRotation(this.rotation),e>0){const a=s.bakeArea;$f.circlePointDeterministic(Jp,e,t),Jp.mulScalar(a*.5),s._node.rotateLocal(Jp.x,0,Jp.y)}s._node.getWorldTransform();const i=2.2,r=Math.pow(this.intensity,i);s.intensity=Math.pow(r/t,1/i)}constructor(e,t){super(e.scene,t,e.lightingParams)}}const UP=new D;class zP extends EL{get numVirtualLights(){return this.light.bakeNumSamples}prepareVirtualLight(e,t){$f.spherePointDeterministic(UP,e,t,0,this.scene.ambientBakeSpherePart),this.light._node.lookAt(UP.mulScalar(-1)),this.light._node.rotateLocal(90,0,0);const s=2.2,i=2*Math.PI*this.scene.ambientBakeSpherePart,r=Math.pow(i,s);this.light.intensity=Math.pow(r/t,1/s)}constructor(e){const t=e.scene,s=new Nt("AmbientLight");s.addComponent("light",{type:"directional",affectDynamic:!0,affectLightmapped:!1,bake:!0,bakeNumSamples:t.ambientBakeNumSamples,castShadows:!0,normalOffsetBias:.05,shadowBias:.2,shadowDistance:1,shadowResolution:2048,shadowType:ur,color:ue.WHITE,intensity:1,bakeDir:!1}),super(t,s.light.light,e.lightingParams)}}class e_{store(){this.castShadows=this.component.castShadows}restore(){this.component.castShadows=this.castShadows}constructor(e,t=null){this.node=e,this.component=e.render||e.model,t=t||this.component.meshInstances,this.store(),this.meshInstances=t,this.bounds=null,this.renderTargets=[]}}var Aq=`
float normpdf3(in vec3 v, in float sigma) {
	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}
vec3 decodeRGBM(vec4 rgbm) {
	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
	return color * color;
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 encodeRGBM(vec3 color) {
	vec4 encoded;
	encoded.rgb = pow(color.rgb, vec3(0.5));
	encoded.rgb *= 1.0 / 8.0;
	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
	encoded.a = ceil(encoded.a * 255.0) / 255.0;
	encoded.rgb /= encoded.a;
	return encoded;
}
vec3 decode(vec4 pixel) {
	#if HDR
		return pixel.rgb;
	#else
		return decodeRGBM(pixel);
	#endif
}
bool isUsed(vec4 pixel) {
	#if HDR
		return any(greaterThan(pixel.rgb, vec3(0.0)));
	#else
		return pixel.a > 0.0;
	#endif
}
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[{MSIZE}];
void main(void) {
	
	vec4 pixel = texture2DLod(source, vUv0, 0.0);
	if (!isUsed(pixel)) {
		gl_FragColor = pixel;
		return ;
	}
	float sigma = sigmas.x;
	float bSigma = sigmas.y;
	vec3 pixelHdr = decode(pixel);
	vec3 accumulatedHdr = vec3(0.0);
	float accumulatedFactor = 0.000001;
	const int kSize = ({MSIZE} - 1) / 2;
	for (int i = -kSize; i <= kSize; ++i) {
		for (int j = -kSize; j <= kSize; ++j) {
			
			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
			vec4 pix = texture2DLod(source, coord, 0.0);
			if (isUsed(pix)) {
				vec3 hdr = decode(pix);
				float factor = kernel[kSize + j] * kernel[kSize + i];
				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;
				accumulatedHdr += factor * hdr;
				accumulatedFactor += factor;
			}
		}
	}
	vec3 finalHDR = accumulatedHdr / accumulatedFactor;
	#if HDR
		gl_FragColor = vec4(finalHDR, 1.0);
	#else
		gl_FragColor = encodeRGBM(finalHDR);
	#endif
}
`,wq=`
varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
bool isUsed(vec4 pixel) {
	#if HDR
		return any(greaterThan(pixel.rgb, vec3(0.0)));
	#else
		return pixel.a > 0.0;
	#endif
}
void main(void) {
	vec4 c = texture2DLod(source, vUv0, 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 - pixelOffset, 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(0, pixelOffset.y), 0.0);
	c = isUsed(c) ? c : texture2DLod(source, vUv0 + pixelOffset, 0.0);
	gl_FragColor = c;
}
`,Cq=`
fn normpdf3(v: vec3f, sigma: f32) -> f32 {
	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}
fn decodeRGBM(rgbm: vec4f) -> vec3f {
	let color = (8.0 * rgbm.a) * rgbm.rgb;
	return color * color;
}
fn saturate(x: f32) -> f32 {
	return clamp(x, 0.0, 1.0);
}
fn encodeRGBM(color: vec3f) -> vec4f {
	var encoded: vec4f;
	let rgb_processed = pow(color.rgb, vec3f(0.5)) * (1.0 / 8.0);
	encoded = vec4f(rgb_processed, 0.0);
	let max_g_b = max( encoded.g, max( encoded.b, 1.0 / 255.0 ) );
	let max_rgb = max( encoded.r, max_g_b );
	encoded.a = clamp(max_rgb, 0.0, 1.0);
	encoded.a = ceil(encoded.a * 255.0) / 255.0;
	encoded = vec4f(encoded.rgb / encoded.a, encoded.a);
	return encoded;
}
fn decode(pixel: vec4f) -> vec3f {
	#if HDR
		return pixel.rgb;
	#else
		return decodeRGBM(pixel);
	#endif
}
fn isUsed(pixel: vec4f) -> bool {
	#if HDR
		return any(pixel.rgb > vec3f(0.0));
	#else
		return pixel.a > 0.0;
	#endif
}
varying vUv0: vec2f;
var source: texture_2d<f32>;
var sourceSampler: sampler;
uniform kernel: array<f32, {MSIZE}>;
uniform pixelOffset: vec2f;
uniform sigmas: vec2f;
uniform bZnorm: f32;
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	let pixel = textureSampleLevel(source, sourceSampler, input.vUv0, 0.0);
	if (!isUsed(pixel)) {
		output.color = pixel;
		return output;
	}
	let sigma = uniform.sigmas.x;
	let bSigma = uniform.sigmas.y;
	let pixelHdr = decode(pixel);
	var accumulatedHdr = vec3f(0.0);
	var accumulatedFactor = 0.000001;
	const kSize = ({MSIZE} - 1) / 2;
	for (var i: i32 = -kSize; i <= kSize; i = i + 1) {
		for (var j: i32 = -kSize; j <= kSize; j = j + 1) {
			let coord = input.vUv0 + vec2f(f32(i), f32(j)) * uniform.pixelOffset;
			let pix = textureSampleLevel(source, sourceSampler, coord, 0.0);
			if (isUsed(pix)) {
				let hdr = decode(pix);
				var factor = uniform.kernel[u32(kSize + j)].element * uniform.kernel[u32(kSize + i)].element;
				factor = factor * normpdf3(hdr - pixelHdr, bSigma) * uniform.bZnorm;
				accumulatedHdr = accumulatedHdr + factor * hdr;
				accumulatedFactor = accumulatedFactor + factor;
			}
		}
	}
	let finalHDR = accumulatedHdr / accumulatedFactor;
	#if HDR
		output.color = vec4f(finalHDR, 1.0);
	#else
		output.color = encodeRGBM(finalHDR);
	#endif
	return output;
}
`,Dq=`
varying vUv0: vec2f;
var source: texture_2d<f32>;
var sourceSampler: sampler;
uniform pixelOffset: vec2f;
fn isUsed(pixel: vec4f) -> bool {
	#ifdef HDR
		return any(pixel.rgb > vec3f(0.0));
	#else
		return pixel.a > 0.0;
	#endif
}
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var c: vec4f = textureSampleLevel(source, sourceSampler, input.vUv0, 0.0);
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 - uniform.pixelOffset, 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + vec2f(0.0, -uniform.pixelOffset.y), 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + vec2f(uniform.pixelOffset.x, -uniform.pixelOffset.y), 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + vec2f(-uniform.pixelOffset.x, 0.0), 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + vec2f(uniform.pixelOffset.x, 0.0), 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + vec2f(-uniform.pixelOffset.x, uniform.pixelOffset.y), 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + vec2f(0.0, uniform.pixelOffset.y), 0.0), c, isUsed(c));
	c = select(textureSampleLevel(source, sourceSampler, input.vUv0 + uniform.pixelOffset, 0.0), c, isUsed(c));
	var output: FragmentOutput;
	output.color = c;
	return output;
}
`;const kP=15,Pq={glslBilateralDeNoisePS:Aq,glslDilatePS:wq},Rq={wgslBilateralDeNoisePS:Cq,wgslDilatePS:Dq};class Mq{setSourceTexture(e){this.constantTexSource.setValue(e)}prepare(e,t){this.pixelOffset[0]=1/e,this.pixelOffset[1]=1/t,this.constantPixelOffset.setValue(this.pixelOffset)}prepareDenoise(e,t,s){const i=s?0:1;if(!this.shaderDenoise[i]){const r=new Map;r.set("{MSIZE}",15),s&&r.set("HDR",""),this.shaderDenoise[i]=ns.createShader(this.device,{uniqueName:`lmBilateralDeNoise-${s?"hdr":"rgbm"}`,attributes:{vertex_position:He},vertexGLSL:Ue.get(this.device,ot).get("fullscreenQuadVS"),vertexWGSL:Ue.get(this.device,Je).get("fullscreenQuadVS"),fragmentGLSL:Ue.get(this.device,ot).get("glslBilateralDeNoisePS"),fragmentWGSL:Ue.get(this.device,Je).get("wgslBilateralDeNoisePS"),fragmentDefines:r}),this.sigmas=new Float32Array(2),this.constantSigmas=this.device.scope.resolve("sigmas"),this.constantKernel=this.device.scope.resolve("kernel[0]"),this.bZnorm=this.device.scope.resolve("bZnorm")}this.sigmas[0]=e,this.sigmas[1]=t,this.constantSigmas.setValue(this.sigmas),this.evaluateDenoiseUniforms(e,t)}getDenoise(e){const t=e?0:1;return this.shaderDenoise[t]}getDilate(e,t){const s=t?0:1;if(!this.shaderDilate[s]){const i=t?`#define HDR
`:"";this.shaderDilate[s]=ns.createShader(e,{uniqueName:`lmDilate-${t?"hdr":"rgbm"}`,attributes:{vertex_position:He},vertexGLSL:Ue.get(this.device,ot).get("fullscreenQuadVS"),vertexWGSL:Ue.get(this.device,Je).get("fullscreenQuadVS"),fragmentGLSL:i+Ue.get(this.device,ot).get("glslDilatePS"),fragmentWGSL:i+Ue.get(this.device,Je).get("wgslDilatePS")})}return this.shaderDilate[s]}evaluateDenoiseUniforms(e,t){function s(o,h){return .39894*Math.exp(-.5*o*o/(h*h))/h}this.kernel=this.kernel||new Float32Array(kP);const i=this.kernel,r=Math.floor((kP-1)/2);for(let o=0;o<=r;++o){const h=s(o,e);i[r+o]=h,i[r-o]=h}this.constantKernel.setValue(this.kernel);const a=1/s(0,t);this.bZnorm.setValue(a)}constructor(e){this.shaderDilate=[],this.shaderDenoise=[],this.device=e,Ue.get(this.device,ot).add(Pq),Ue.get(this.device,Je).add(Rq),this.constantTexSource=e.scope.resolve("source"),this.constantPixelOffset=e.scope.resolve("pixelOffset"),this.pixelOffset=new Float32Array(2),this.sigmas=null,this.constantSigmas=null,this.kernel=null}}class Lq extends ii{destroy(){this.viewBindGroups.forEach(e=>{e.defaultUniformBuffer.destroy(),e.destroy()}),this.viewBindGroups.length=0}execute(){const e=this.device,{renderer:t,camera:s,receivers:i,renderTarget:r,worldClusters:a,lightArray:o}=this;e.supportsUniformBuffers&&!t.viewUniformFormat&&t.initViewBindGroupFormat(t.scene.clusteredLightingEnabled),t.renderForwardLayer(s,r,null,void 0,Zh,this.viewBindGroups,{meshInstances:i,splitLights:o,lightClusters:a})}constructor(e,t,s,i,r,a){super(e),this.viewBindGroups=[],this.renderer=t,this.camera=s,this.worldClusters=i,this.receivers=r,this.lightArray=a}}const Iq=2048,Oq=0,Nq=1,t_=new D;class Fq{destroy(){Ra.decRef(this.blackTex),this.blackTex=null,Ra.destroy(),this.device=null,this.root=null,this.scene=null,this.renderer=null,this.assets=null,this.camera?.destroy(),this.camera=null}initBake(e){if(this.bakeHDR=this.scene.lightmapPixelFormat!==Ze,!this._initCalled){this._initCalled=!0,this.lightmapFilters=new Mq(e),this.constantBakeDir=e.scope.resolve("bakeDir"),this.materials=[],this.blackTex=new De(this.device,{width:4,height:4,format:Ze,type:Sl,name:"lightmapBlack"}),Ra.incRef(this.blackTex);const t=new KE;t.clearColor.set(0,0,0,0),t.clearColorBuffer=!0,t.clearDepthBuffer=!1,t.clearStencilBuffer=!1,t.frustumCulling=!1,t.projection=Dv,t.aspectRatio=1,t.node=new Dt,this.camera=t,this.camera.shaderParams.gammaCorrection=Xf,this.camera.shaderParams.toneMapping=GE}if(this.scene.clusteredLightingEnabled){const t=new tL(e.supportsAreaLights,e.maxTextureSize,()=>{});this.lightingParams=t;const s=this.scene.lighting;t.shadowsEnabled=s.shadowsEnabled,t.shadowAtlasResolution=s.shadowAtlasResolution,t.cookiesEnabled=s.cookiesEnabled,t.cookieAtlasResolution=s.cookieAtlasResolution,t.areaLightsEnabled=s.areaLightsEnabled,t.cells=new D(3,3,3),t.maxLightsPerCell=4,this.worldClusters=new Qx(e),this.worldClusters.name="ClusterLightmapper",this.shadowLocalClusteredPass=new J2(e,this.renderer.shadowRenderer,this.renderer._shadowRendererLocal)}}finishBake(e){this.materials=[];function t(s){Ra.decRef(s.colorBuffer),s.destroy()}this.renderTargets.forEach(s=>{t(s)}),this.renderTargets.clear(),e.forEach(s=>{s.renderTargets.forEach(i=>{t(i)}),s.renderTargets.length=0}),this.ambientAOMaterial=null,this.worldClusters&&(this.worldClusters.destroy(),this.worldClusters=null)}createMaterialForPass(e,t,s){const i=new vr;return i.name=`lmMaterial-pass:${t}-ambient:${s}`,i.setDefine("UV1LAYOUT",""),i.setDefine("LIT_LIGHTMAP_BAKING",""),t===Oq?(i.setDefine("LIT_LIGHTMAP_BAKING_COLOR",""),s?i.setDefine("LIT_LIGHTMAP_BAKING_ADD_AMBIENT",""):i.ambient=new ue(0,0,0),this.bakeHDR||i.setDefine("LIGHTMAP_RGBM",""),i.lightMap=this.blackTex):(i.setDefine("LIT_LIGHTMAP_BAKING_DIR",""),i.setDefine("STD_LIGHTMAP_DIR","")),i.cull=Ft,i.forceUv1=!0,i.update(),i}createMaterials(e,t,s){for(let i=0;i<s;i++)this.passMaterials[i]||(this.passMaterials[i]=this.createMaterialForPass(t,i,!1));this.ambientAOMaterial||(this.ambientAOMaterial=this.createMaterialForPass(t,0,!0),this.ambientAOMaterial.onUpdateShader=function(i){return i.litOptions.lightMapWithoutAmbient=!0,i.litOptions.separateAmbient=!0,i})}createTexture(e,t){return new De(this.device,{width:e,height:e,format:this.scene.lightmapPixelFormat,mipmaps:!1,type:this.bakeHDR?qr:Sl,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te,name:t})}collectModels(e,t,s){if(!e.enabled)return;let i;if(e.model?.model&&e.model?.enabled&&(s&&s.push(new e_(e)),e.model.lightmapped&&t&&(i=e.model.model.meshInstances)),e.render?.enabled&&(s&&s.push(new e_(e)),e.render.lightmapped&&t&&(i=e.render.meshInstances)),i){let r=!0;for(let a=0;a<i.length;a++)if(!i[a].mesh.vertexBuffer.format.hasUv1){r=!1;break}if(r){const a=[];for(let o=0;o<i.length;o++){const h=i[o].mesh;this._tempSet.has(h)?t.push(new e_(e,[i[o]])):a.push(i[o]),this._tempSet.add(h)}this._tempSet.clear(),a.length>0&&t.push(new e_(e,a))}}for(let r=0;r<e._children.length;r++)this.collectModels(e._children[r],t,s)}prepareShadowCasters(e){const t=[];for(let s=0;s<e.length;s++){const i=e[s].component;if(i.castShadows=i.castShadowsLightmap,i.castShadowsLightmap){const r=e[s].meshInstances;for(let a=0;a<r.length;a++)r[a].visibleThisFrame=!0,t.push(r[a])}}return t}updateTransforms(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;for(let i=0;i<s.length;i++)s[i].node.getWorldTransform()}}calculateLightmapSize(e){let t;const s=this.scene.lightmapSizeMultiplier||16,i=t_;let r,a;e.model?(a=e.model.lightmapSizeMultiplier,e.model.asset?(t=this.assets.get(e.model.asset).data,t.area&&(r=t.area)):e.model._area&&(t=e.model,t._area&&(r=t._area))):e.render&&(a=e.render.lightmapSizeMultiplier,e.render.type!=="asset"&&e.render._area&&(t=e.render,t._area&&(r=t._area)));const o={x:1,y:1,z:1,uv:1};r&&(o.x=r.x,o.y=r.y,o.z=r.z,o.uv=r.uv);const h=a||1;o.x*=h,o.y*=h,o.z*=h;const u=e.render||e.model,f=this.computeNodeBounds(u.meshInstances);i.copy(f.halfExtents);let m=o.x*i.y*i.z+o.y*i.x*i.z+o.z*i.x*i.y;return m/=o.uv,m=Math.sqrt(m),Math.min(J.nextPowerOfTwo(m*s),this.scene.lightmapMaxResolution||Iq)}setLightmapping(e,t,s,i){for(let r=0;r<e.length;r++){const a=e[r],o=a.meshInstances;for(let h=0;h<o.length;h++){const u=o[h];if(u.setLightmapped(t),t){i&&(u._shaderDefs|=i),u.mask=Ba;for(let f=0;f<s;f++){const m=a.renderTargets[f].colorBuffer;m.minFilter=$t,m.magFilter=$t,u.setRealtimeLightmap(lt.lightmapParamNames[f],m)}}}}}bake(e,t=A_){const s=this.device,i=vs();this.scene._updateSkyMesh(),this.stats.renderPasses=0,this.stats.shadowMapTime=0,this.stats.forwardTime=0;const r=s._shaderStats.linked,a=s._renderTargetCreationTime,o=s._shaderStats.compileTime,h=[],u=[];if(e){for(let m=0;m<e.length;m++)this.collectModels(e[m],h,null);this.collectModels(this.root,null,u)}else this.collectModels(this.root,h,u);if(h.length>0){this.renderer.shadowRenderer.frameUpdate();const m=t===A_?2:1;this.setLightmapping(h,!1,m),this.initBake(s),this.bakeInternal(m,h,u);let _=Kx;t===A_&&(_|=B2),this.scene.ambientBake&&(_|=U2),this.setLightmapping(h,!0,m,_),this.finishBake(h)}const f=vs();this.stats.totalRenderTime=f-i,this.stats.shadersLinked=s._shaderStats.linked-r,this.stats.compileTime=s._shaderStats.compileTime-o,this.stats.fboTime=s._renderTargetCreationTime-a,this.stats.lightmapCount=h.length}allocateTextures(e,t){for(let s=0;s<e.length;s++){const i=e[s],r=this.calculateLightmapSize(i.node);for(let a=0;a<t;a++){const o=this.createTexture(r,`lightmapper_lightmap_${s}`);Ra.incRef(o),i.renderTargets[a]=new At({colorBuffer:o,depth:!1})}if(!this.renderTargets.has(r)){const a=this.createTexture(r,`lightmapper_temp_lightmap_${r}`);Ra.incRef(a),this.renderTargets.set(r,new At({colorBuffer:a,depth:!1}))}}}prepareLightsToBake(e,t){if(this.scene.ambientBake){const i=new zP(this);t.push(i)}const s=this.renderer.lights;for(let i=0;i<s.length;i++){const r=s[i],a=new bq(this,r);e.push(a),r.enabled&&(r.mask&Ua)!==0&&(r.mask=Ua|Ba|Qi,r.shadowUpdateMode=r.type===Ne?jE:Kn,t.push(a))}t.sort()}restoreLights(e){for(let t=0;t<e.length;t++)e[t].restore()}setupScene(){this.ambientLight.copy(this.scene.ambientLight),this.scene.ambientBake||this.scene.ambientLight.set(0,0,0),this.renderer.setSceneConstants(),this.device.scope.resolve("ambientBakeOcclusionContrast").setValue(this.scene.ambientBakeOcclusionContrast),this.device.scope.resolve("ambientBakeOcclusionBrightness").setValue(this.scene.ambientBakeOcclusionBrightness)}restoreScene(){this.scene.ambientLight.copy(this.ambientLight)}computeNodeBounds(e){const t=new Ge;if(e.length>0){t.copy(e[0].aabb);for(let s=1;s<e.length;s++)t.add(e[s].aabb)}return t}computeNodesBounds(e){for(let t=0;t<e.length;t++){const s=e[t].meshInstances;e[t].bounds=this.computeNodeBounds(s)}}computeBounds(e){const t=new Ge;for(let s=0;s<e.length;s++){t.copy(e[0].aabb);for(let i=1;i<e.length;i++)t.add(e[i].aabb)}return t}backupMaterials(e){for(let t=0;t<e.length;t++)this.materials[t]=e[t].material}restoreMaterials(e){for(let t=0;t<e.length;t++)e[t].material=this.materials[t]}lightCameraPrepare(e,t){const s=t.light;let i;return s.type===bt&&(i=s.getRenderData(null,0).shadowCamera,i._node.setPosition(s._node.getPosition()),i._node.setRotation(s._node.getRotation()),i._node.rotateLocal(-90,0,0),i.projection=dr,i.nearClip=s.attenuationEnd/1e3,i.farClip=s.attenuationEnd,i.aspectRatio=1,i.fov=s._outerConeAngle*2,this.renderer.updateCameraFrustum(i)),i}lightCameraPrepareAndCull(e,t,s,i){const r=e.light;let a=!0;if(r.type===Ne){t_.copy(i.center),t_.y+=i.halfExtents.y,this.camera.node.setPosition(t_),this.camera.node.setEulerAngles(-90,0,0),this.camera.nearClip=0,this.camera.farClip=i.halfExtents.y*2;const o=Math.max(i.halfExtents.x,i.halfExtents.z);this.camera.orthoHeight=o}else e.lightBounds.intersects(t.bounds)||(a=!1);if(r.type===bt){let o=!1;const h=t.meshInstances;for(let u=0;u<h.length;u++)if(h[u]._isVisible(s)){o=!0;break}o||(a=!1)}return a}setupLightArray(e,t){e[Ne].length=0,e[wt].length=0,e[bt].length=0,e[t.type][0]=t,t.visibleThisFrame=!0}renderShadowMap(e,t,s,i){const r=i.light,a=this.scene.clusteredLightingEnabled,o=r.castShadows&&(!a||this.scene.lighting.shadowsEnabled);if(!t&&o)if(!r.shadowMap&&!a&&(r.shadowMap=this.shadowMapCache.get(this.device,r)),r.type===Ne)this.renderer._shadowRendererDirectional.cull(r,e,this.camera,s),this.renderer._shadowRendererDirectional.getLightRenderPass(r,this.camera)?.render();else if(this.renderer._shadowRendererLocal.cull(r,e,s),a)this.shadowLocalClusteredPass.update([r]),this.shadowLocalClusteredPass.enabled&&this.shadowLocalClusteredPass.render();else{const h=r.numShadowFaces,u=r._type===bt;for(let f=0;f<h;f++)new Z2(this.device,this.renderer.shadowRenderer,r,f,u).render()}return!0}postprocessTextures(e,t,s){const r=this.lightmapFilters.getDilate(e,this.bakeHDR);let a;const o=this.scene.lightmapFilterEnabled;o&&(this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange,this.scene.lightmapFilterSmoothness,this.bakeHDR),a=this.lightmapFilters.getDenoise(this.bakeHDR)),e.setBlendState(ht.NOBLEND),e.setDepthState(Gt.NODEPTH),e.setStencilState(null,null);for(let h=0;h<t.length;h++){const u=t[h];for(let f=0;f<s;f++){const m=u.renderTargets[f],_=m.colorBuffer,g=this.renderTargets.get(_.width),S=g.colorBuffer;this.lightmapFilters.prepare(_.width,_.height);for(let x=0;x<1;x++)this.lightmapFilters.setSourceTexture(_),gr(e,g,o&&f===0&&x===0?a:r),this.lightmapFilters.setSourceTexture(S),gr(e,m,r)}}}bakeInternal(e,t,s){const i=this.scene,r=i.layers,a=this.device,o=i.clusteredLightingEnabled;this.createMaterials(a,i,e),this.setupScene(),r._update(),this.computeNodesBounds(t),this.allocateTextures(t,e),this.renderer.collectLights(r);const h=[],u=[];this.prepareLightsToBake(h,u),this.updateTransforms(s);const f=this.prepareShadowCasters(s);this.renderer.updateCpuSkinMatrices(f),this.renderer.gpuUpdate(f);const m=this.computeBounds(f);let _,g,S,x;for(_=0;_<t.length;_++)for(S=t[_].meshInstances,g=0;g<S.length;g++)x=S[g],x.setLightmapped(!1),x.mask=Ua,x.setRealtimeLightmap(lt.lightmapParamNames[0],this.blackTex),x.setRealtimeLightmap(lt.lightmapParamNames[1],this.blackTex);for(g=0;g<u.length;g++)u[g].light.enabled=!1;const T=[[],[],[]];let E,b,C=!1;for(_=0;_<u.length;_++){const w=u[_],P=w instanceof zP,I=w.light.type===Ne;let M=w.numVirtualLights;e>1&&M>1&&w.light.bakeDir&&(M=1);for(let R=0;R<M;R++){M>1&&w.prepareVirtualLight(R,M),w.startBake();let L=!1;const B=this.lightCameraPrepare(a,w);for(b=0;b<t.length;b++){const G=t[b];if(S=G.meshInstances,!this.lightCameraPrepareAndCull(w,G,B,m))continue;this.setupLightArray(T,w.light);const ee=I?[]:[w.light];for(o&&this.renderer.lightTextureAtlas.update(ee,this.lightingParams),L=this.renderShadowMap(r,L,f,w),o&&this.worldClusters.update(ee,this.lightingParams),this.backupMaterials(S),E=0;E<e&&!(E>0&&R>0||P&&E>0);E++){const j=G.renderTargets[E],ae=G.renderTargets[E].colorBuffer.width,k=this.renderTargets.get(ae),O=k.colorBuffer;E===0?C=i.updateShaders:C&&(i.updateShaders=!0);let z=this.passMaterials[E];for(P&&R+1===M&&E===0&&(z=this.ambientAOMaterial),g=0;g<S.length;g++)S[g].material=z;this.renderer.updateShaders(S),E===Nq&&this.constantBakeDir.setValue(w.light.bakeDir?1:0);const X=new Lq(a,this.renderer,this.camera,o?this.worldClusters:null,S,T);for(X.init(k),X.colorOps.clear=!0,X.colorOps.clearValue.copy(this.camera.clearColor),X.render(),X.destroy(),G.renderTargets[E]=k,this.renderTargets.set(ae,j),g=0;g<S.length;g++)x=S[g],x.setRealtimeLightmap(lt.lightmapParamNames[E],O),x._shaderDefs|=Kx}this.restoreMaterials(S)}w.endBake(this.shadowMapCache)}}for(this.postprocessTextures(a,t,e),b=0;b<s.length;b++)s[b].restore();this.restoreLights(h),this.restoreScene(),o||this.shadowMapCache.clear()}constructor(e,t,s,i,r){this.device=e,this.root=t,this.scene=s,this.renderer=i,this.assets=r,this.shadowMapCache=i.shadowMapCache,this._tempSet=new Set,this._initCalled=!1,this.passMaterials=[],this.ambientAOMaterial=null,this.fog="",this.ambientLight=new ue,this.renderTargets=new Map,this.stats={renderPasses:0,lightmapCount:0,totalRenderTime:0,forwardTime:0,fboTime:0,shadowMapTime:0,compileTime:0,shadersLinked:0}}}class ke extends Pe{static _buildAccessors(e,t){t.forEach(s=>{const i=typeof s=="object"?s.name:s;Object.defineProperty(e,i,{get:function(){return this.data[i]},set:function(r){const a=this.data,o=a[i];a[i]=r,this.fire("set",i,o,r)},configurable:!0})}),e._accessorsBuilt=!0}buildAccessors(e){ke._buildAccessors(this,e)}onSetEnabled(e,t,s){t!==s&&this.entity.enabled&&(s?this.onEnable():this.onDisable())}onEnable(){}onDisable(){}onPostStateChange(){}get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){}get enabled(){return!0}constructor(e,t){super(),this.system=e,this.entity=t,this.system.schema&&!this._accessorsBuilt&&this.buildAccessors(this.system.schema),this.on("set",function(s,i,r){this.fire(`set_${s}`,s,i,r)}),this.on("set_enabled",this.onSetEnabled,this)}}ke.order=0;class Ht extends Pe{addComponent(e,t={}){const s=new this.ComponentType(this,e),i=new this.DataType;return this.store[e.getGuid()]={entity:e,data:i},e[this.id]=s,e.c[this.id]=s,this.initializeComponentData(s,t,[]),this.fire("add",e,s),s}removeComponent(e){const t=this.id,s=this.store[e.getGuid()],i=e.c[t];i.fire("beforeremove"),this.fire("beforeremove",e,i),delete this.store[e.getGuid()],e[t]=void 0,delete e.c[t],this.fire("remove",e,s.data)}cloneComponent(e,t){const s=this.store[e.getGuid()];return this.addComponent(t,s.data)}initializeComponentData(e,t={},s){for(let i=0,r=s.length;i<r;i++){const a=s[i];let o,h;typeof a=="object"?(o=a.name,h=a.type):(o=a,h=void 0);let u=t[o];u!==void 0?(h!==void 0&&(u=Bq(u,h)),e[o]=u):e[o]=e.data[o]}e.enabled&&e.entity.enabled&&e.onEnable()}getPropertiesOfType(e){const t=[];return(this.schema||[]).forEach(i=>{i&&typeof i=="object"&&i.type===e&&t.push(i)}),t}destroy(){this.off()}constructor(e){super(),this.app=e,this.store={},this.schema=[]}}function Bq(c,e){if(!c)return c;switch(e){case"rgb":return c instanceof ue?c.clone():new ue(c[0],c[1],c[2]);case"rgba":return c instanceof ue?c.clone():new ue(c[0],c[1],c[2],c[3]);case"vec2":return c instanceof ne?c.clone():new ne(c[0],c[1]);case"vec3":return c instanceof D?c.clone():new D(c[0],c[1],c[2]);case"vec4":return c instanceof me?c.clone():new me(c[0],c[1],c[2],c[3]);case"boolean":case"number":case"string":return c;case"entity":return c;default:throw new Error(`Could not convert unhandled type: ${e}`)}}const bL=0,nT=1,oT=2;class Uq{update(e,t){if(e<this._left||e>=this._right){const s=t.length;if(!s)this._left=-1/0,this._right=1/0,this._len=0,this._recip=0,this._p0=this._p1=0;else if(e<t[0])this._left=-1/0,this._right=t[0],this._len=0,this._recip=0,this._p0=this._p1=0;else if(e>=t[s-1])this._left=t[s-1],this._right=1/0,this._len=0,this._recip=0,this._p0=this._p1=s-1;else{const i=this._findKey(e,t);this._left=t[i],this._right=t[i+1],this._len=this._right-this._left;const r=1/this._len;this._recip=isFinite(r)?r:0,this._p0=i,this._p1=i+1}}this._t=this._recip===0?0:(e-this._left)*this._recip,this._hermite.valid=!1}_findKey(e,t){let s=0;for(;e>=t[s+1];)s++;return s}eval(e,t,s){const i=s._data,r=s._components,a=this._p0*r;if(t===bL)for(let o=0;o<r;++o)e[o]=i[a+o];else{const o=this._t,h=this._p1*r;switch(t){case nT:for(let u=0;u<r;++u)e[u]=J.lerp(i[a+u],i[h+u],o);break;case oT:{const u=this._hermite;if(!u.valid){const S=o*o,x=o+o,T=1-o,E=T*T;u.valid=!0,u.p0=(1+x)*E,u.m0=o*E,u.p1=S*(3-x),u.m1=S*(o-1)}const f=(this._p0*3+1)*r,m=(this._p0*3+2)*r,_=(this._p1*3+1)*r,g=(this._p1*3+0)*r;for(let S=0;S<r;++S)e[S]=u.p0*i[f+S]+u.m0*i[m+S]*this._len+u.p1*i[_+S]+u.m1*i[g+S]*this._len;break}}}}constructor(){this._left=1/0,this._right=-1/0,this._len=0,this._recip=0,this._p0=0,this._p1=0,this._t=0,this._hermite={valid:!1,p0:0,m0:0,p1:0,m1:0}}}class VP{constructor(e){this._name=`${e.name}Snapshot`,this._time=-1,this._cache=[],this._results=[];for(let i=0;i<e._inputs.length;++i)this._cache[i]=new Uq;const t=e._curves,s=e._outputs;for(let i=0;i<t.length;++i){const r=t[i],a=s[r._output],o=[];for(let h=0;h<a._components;++h)o[h]=0;this._results[i]=o}}}class Fh{set name(e){this._name=e}get name(){return this._name}set track(e){this._track=e,this._snapshot=new VP(e)}get track(){return this._track}get snapshot(){return this._snapshot}set time(e){this._time=e,this.alignCursorToCurrentTime()}get time(){return this._time}set speed(e){const t=Math.sign(e)!==Math.sign(this._speed);this._speed=e,t&&this.alignCursorToCurrentTime()}get speed(){return this._speed}set loop(e){this._loop=e}get loop(){return this._loop}set blendWeight(e){this._blendWeight=e}get blendWeight(){return this._blendWeight}set blendOrder(e){this._blendOrder=e}get blendOrder(){return this._blendOrder}set eventCursor(e){this._eventCursor=e}get eventCursor(){return this._eventCursor}get eventCursorEnd(){return this.isReverse?0:this._track.events.length-1}get nextEvent(){return this._track.events[this._eventCursor]}get isReverse(){return this._speed<0}nextEventAheadOfTime(e){return this.nextEvent?this.isReverse?this.nextEvent.time<=e:this.nextEvent.time>=e:!1}nextEventBehindTime(e){return this.nextEvent?e===this.track.duration?this.isReverse?this.nextEvent.time>=e:this.nextEvent.time<=e:this.isReverse?this.nextEvent.time>e:this.nextEvent.time<e:!1}resetEventCursor(){this._eventCursor=this.isReverse?this._track.events.length-1:0}moveEventCursor(){this._eventCursor+=this.isReverse?-1:1,this._eventCursor>=this.track.events.length?this._eventCursor=0:this._eventCursor<0&&(this._eventCursor=this.track.events.length-1)}clipFrameTime(e){const t=Fh.eventFrame;t.start=0,t.end=e,t.residual=0,this.isReverse?e<0&&(t.start=this.track.duration,t.end=0,t.residual=e+this.track.duration):e>this.track.duration&&(t.start=0,t.end=this.track.duration,t.residual=e-this.track.duration)}alignCursorToCurrentTime(){for(this.resetEventCursor();this.nextEventBehindTime(this._time)&&this._eventCursor!==this.eventCursorEnd;)this.moveEventCursor()}fireNextEvent(){this._eventHandler.fire(this.nextEvent.name,{track:this.track,...this.nextEvent}),this.moveEventCursor()}fireNextEventInFrame(e,t){return this.nextEventAheadOfTime(e)&&this.nextEventBehindTime(t)?(this.fireNextEvent(),!0):!1}activeEventsForFrame(e,t){const s=Fh.eventFrame;this.clipFrameTime(t);const i=this.eventCursor;for(;this.fireNextEventInFrame(e,s.end)&&i!==this.eventCursor;);this.loop&&Math.abs(s.residual)>0&&this.activeEventsForFrame(s.start,s.residual)}progressForTime(e){return e*this._speed/this._track.duration}_update(e){if(this._playing){let t=this._time;const s=this._track.duration,i=this._speed,r=this._loop;this._track.events.length>0&&s>0&&this.activeEventsForFrame(t,t+i*e),t+=i*e,i>=0?t>s&&(r?t=t%s||0:(t=this._track.duration,this.pause())):t<0&&(r?t=s+(t%s||0):(t=0,this.pause())),this._time=t}this._time!==this._snapshot._time&&this._track.eval(this._time,this._snapshot)}play(){this._playing=!0,this._time=0}stop(){this._playing=!1,this._time=0}pause(){this._playing=!1}resume(){this._playing=!0}reset(){this._time=0}constructor(e,t,s,i,r,a){this._name=e.name,this._track=e,this._snapshot=new VP(e),this._playing=i,this._time=t,this._speed=s,this._loop=r,this._blendWeight=1,this._blendOrder=0,this._eventHandler=a,this.alignCursorToCurrentTime()}}Fh.eventFrame={start:0,end:0,residual:0};const AL="NONE",zq="PREV_STATE",kq="NEXT_STATE",Vq="PREV_STATE_NEXT_STATE",Gq="NEXT_STATE_PREV_STATE",Hq="GREATER_THAN",Wq="LESS_THAN",Xq="GREATER_THAN_EQUAL_TO",qq="LESS_THAN_EQUAL_TO",Yq="EQUAL_TO",jq="NOT_EQUAL_TO",GP="INTEGER",HP="FLOAT",WP="BOOLEAN",L_="TRIGGER",$q="1D",Kq="2D_DIRECTIONAL",Zq="2D_CARTESIAN",Qq="DIRECT",Md="START",lT="END",al="ANY",yg=[Md,lT,al],wL="OVERWRITE",Jq="ADDITIVE";class Ds{static dot(e,t){const s=e.length;let i=0;for(let r=0;r<s;++r)i+=e[r]*t[r];return i}static normalize(e){let t=Ds.dot(e,e);if(t>0){t=1/Math.sqrt(t);const s=e.length;for(let i=0;i<s;++i)e[i]*=t}}static set(e,t,s){const i=e.length;if(s==="quaternion"){let r=Ds.dot(t,t);r>0&&(r=1/Math.sqrt(r));for(let a=0;a<i;++a)e[a]=t[a]*r}else for(let r=0;r<i;++r)e[r]=t[r]}static blendVec(e,t,s,i){const r=i?1:1-s,a=e.length;for(let o=0;o<a;++o)e[o]=e[o]*r+t[o]*s}static blendQuat(e,t,s,i){const r=e.length,a=i?1:1-s;Ds.dot(e,t)<0&&(s=-s);for(let o=0;o<r;++o)e[o]=e[o]*a+t[o]*s;i||Ds.normalize(e)}static blend(e,t,s,i,r){i==="quaternion"?Ds.blendQuat(e,t,s,r):Ds.blendVec(e,t,s,r)}static stableSort(e,t){const s=e.length;for(let i=0;i<s-1;++i)for(let r=i+1;r<s;++r)if(t(e[r],e[i])){const a=e[i];e[i]=e[r],e[r]=a}}}class Et{get _normalizeWeights(){return this._component.normalizeWeights}getWeight(e){return this.dirty&&this.updateWeights(),this._normalizeWeights&&this.totalWeight===0||!this.mask[e]?0:this._normalizeWeights?this.weights[e]/this.totalWeight:J.clamp(this.weights[e],0,1)}_layerBlendType(e){return this._component.layers[e].blendType}setMask(e,t){this.mask[e]=t,this._normalizeWeights&&(this._component.layers[e].blendType===wL&&(this.mask=this.mask.fill(0,0,e)),this.dirty=!0)}updateWeights(){this.totalWeight=0;for(let e=0;e<this.weights.length;e++)this.weights[e]=this._component.layers[e].weight,this.totalWeight+=this.mask[e]*this.weights[e];this.dirty=!1}updateValue(e,t){if(this.counter===0&&(Ds.set(this.value,Et.IDENTITY_QUAT_ARR,this.valueType),this._normalizeWeights||Ds.blend(this.value,this.baseValue,1,this.valueType)),!(!this.mask[e]||this.getWeight(e)===0)){if(this._layerBlendType(e)===Jq&&!this._normalizeWeights)if(this.valueType===Et.TYPE_QUAT){const s=Et.q1.set(this.value[0],this.value[1],this.value[2],this.value[3]),i=Et.q2.set(this.baseValue[0],this.baseValue[1],this.baseValue[2],this.baseValue[3]),r=Et.q3.set(t[0],t[1],t[2],t[3]),a=i.invert().mul(r);a.slerp(pe.IDENTITY,a,this.getWeight(e)),s.mul(a),Et.quatArr[0]=s.x,Et.quatArr[1]=s.y,Et.quatArr[2]=s.z,Et.quatArr[3]=s.w,Ds.set(this.value,Et.quatArr,this.valueType)}else Et.vecArr[0]=t[0]-this.baseValue[0],Et.vecArr[1]=t[1]-this.baseValue[1],Et.vecArr[2]=t[2]-this.baseValue[2],Ds.blend(this.value,Et.vecArr,this.getWeight(e),this.valueType,!0);else Ds.blend(this.value,t,this.getWeight(e),this.valueType);this.setter&&this.setter(this.value)}}unbind(){this.setter&&this.setter(this.baseValue)}constructor(e,t){this._component=e,this.mask=new Int8Array(e.layers.length),this.weights=new Float32Array(e.layers.length),this.totalWeight=0,this.counter=0,this.layerCounter=0,this.valueType=t,this.dirty=!0,this.value=t===Et.TYPE_QUAT?[0,0,0,1]:[0,0,0],this.baseValue=null,this.setter=null}}Et.TYPE_QUAT="quaternion";Et.TYPE_VEC3="vector3";Et.q1=new pe;Et.q2=new pe;Et.q3=new pe;Et.quatArr=[0,0,0,1];Et.vecArr=[0,0,0];Et.IDENTITY_QUAT_ARR=[0,0,0,1];class CL{get clips(){return this._clips}addClip(e){const t=this._targets,s=this._binder,i=e.track.curves,r=e.snapshot,a=[],o=[];for(let h=0;h<i.length;++h){const f=i[h].paths;for(let m=0;m<f.length;++m){const _=f[m],g=s.resolve(_);let S=t[g&&g.targetPath||null];if(!S&&g){S={target:g,value:[],curves:0,blendCounter:0};for(let x=0;x<S.target.components;++x)S.value.push(0);if(t[g.targetPath]=S,s.animComponent){if(!s.animComponent.targets[g.targetPath]){let x;g.targetPath.substring(g.targetPath.length-13)==="localRotation"?x=Et.TYPE_QUAT:x=Et.TYPE_VEC3,s.animComponent.targets[g.targetPath]=new Et(s.animComponent,x)}s.animComponent.targets[g.targetPath].layerCounter++,s.animComponent.targets[g.targetPath].setMask(s.layerIndex,1)}}S&&(S.curves++,a.push(r._results[h]),o.push(S))}}this._clips.push(e),this._inputs.push(a),this._outputs.push(o)}removeClip(e){const t=this._targets,s=this._binder,i=this._clips,a=i[e].track.curves;for(let o=0;o<a.length;++o){const u=a[o].paths;for(let f=0;f<u.length;++f){const m=u[f],_=this._binder.resolve(m);_&&(_.curves--,_.curves===0&&(s.unresolve(m),delete t[_.targetPath],s.animComponent&&s.animComponent.targets[_.targetPath].layerCounter--))}}i.splice(e,1),this._inputs.splice(e,1),this._outputs.splice(e,1)}removeClips(){for(;this._clips.length>0;)this.removeClip(0)}updateClipTrack(e,t){this._clips.forEach(s=>{s.name.includes(e)&&(s.track=t)}),this.rebind()}findClip(e){const t=this._clips;for(let s=0;s<t.length;++s){const i=t[s];if(i.name===e)return i}return null}rebind(){this._binder.rebind(),this._targets={};const e=[...this.clips];this.removeClips(),e.forEach(t=>{this.addClip(t)})}assignMask(e){return this._binder.assignMask(e)}update(e,t=!0){const s=this._clips,i=s.map((o,h)=>h);Ds.stableSort(i,(o,h)=>s[o].blendOrder<s[h].blendOrder);for(let o=0;o<i.length;++o){const h=i[o],u=s[h],f=this._inputs[h],m=this._outputs[h],_=u.blendWeight;if(_>0&&u._update(e),!t)break;let g,S,x;if(_>=1)for(let T=0;T<f.length;++T)g=f[T],S=m[T],x=S.value,Ds.set(x,g,S.target.type),S.blendCounter++;else if(_>0)for(let T=0;T<f.length;++T)g=f[T],S=m[T],x=S.value,S.blendCounter===0?Ds.set(x,g,S.target.type):Ds.blend(x,g,_,S.target.type),S.blendCounter++}const r=this._targets,a=this._binder;for(const o in r)if(r.hasOwnProperty(o)){const h=r[o];if(a.animComponent&&h.target.usesLayerBlending){const u=a.animComponent.targets[o];u.counter===u.layerCounter&&(u.counter=0),u.path||(u.path=o,u.baseValue=h.target.get(),u.setter=h.target.set),u.updateValue(a.layerIndex,h.value),u.counter++}else h.target.set(h.value);h.blendCounter=0}this._binder.update(e)}constructor(e){this._binder=e,this._clips=[],this._inputs=[],this._outputs=[],this._targets={}}}class DL{get events(){return this._events}constructor(e){this._events=[...e],this._events.sort((t,s)=>t.time-s.time)}}class Qa{get name(){return this._name}get duration(){return this._duration}get inputs(){return this._inputs}get outputs(){return this._outputs}get curves(){return this._curves}set events(e){this._animEvents=e}get events(){return this._animEvents.events}eval(e,t){t._time=e;const s=this._inputs,i=this._outputs,r=this._curves,a=t._cache,o=t._results;for(let h=0;h<s.length;++h)a[h].update(e,s[h]._data);for(let h=0;h<r.length;++h){const u=r[h],f=i[u._output],m=o[h];a[u._input].eval(m,u._interpolation,f)}}constructor(e,t,s,i,r,a=new DL([])){this._name=e,this._duration=t,this._inputs=s,this._outputs=i,this._curves=r,this._animEvents=a}}Qa.EMPTY=Object.freeze(new Qa("empty",Number.MAX_VALUE,[],[],[]));class dh{static joinPath(e,t){t=t||".";const s=function(i){return i.replace(/\\/g,"\\\\").replace(new RegExp(`\\${t}`,"g"),`\\${t}`)};return e.map(s).join(t)}static splitPath(e,t){t=t||".";const s=[];let i="",r=0;for(;r<e.length;){let a=e[r++];a==="\\"&&r<e.length?(a=e[r++],a==="\\"||a===t?i+=a:i+=`\\${a}`):a===t?(s.push(i),i=""):i+=a}return i.length>0&&s.push(i),s}static encode(e,t,s){return`${Array.isArray(e)?e.join("/"):e}/${t}/${Array.isArray(s)?s.join("/"):s}`}resolve(e){return null}unresolve(e){}update(e){}}class cT{get set(){return this._set}get get(){return this._get}get type(){return this._type}get components(){return this._components}get targetPath(){return this._targetPath}get isTransform(){return this._isTransform}get isWeight(){return this._isWeight}get usesLayerBlending(){return this._isTransform||this._isWeight}constructor(e,t,s,i){e.set?(this._set=e.set,this._get=e.get):this._set=e,this._type=t,this._components=s,this._targetPath=i,this._isTransform=this._targetPath.substring(this._targetPath.length-13)==="localRotation"||this._targetPath.substring(this._targetPath.length-13)==="localPosition"||this._targetPath.substring(this._targetPath.length-10)==="localScale",this._isWeight=this._targetPath.indexOf("weight.")!==-1}}class Hn{_isPathActive(e){if(!this._mask)return!0;const t=[e.entityPath[0],this.graph.name];for(let s=0;s<t.length;++s){let i=t[s];if(this._isPathInMask(i,e.entityPath.length===1))return!0;for(let r=1;r<e.entityPath.length;r++)if(i+=`/${e.entityPath[r]}`,this._isPathInMask(i,r===e.entityPath.length-1))return!0}return!1}findNode(e){if(!this._isPathActive(e))return null;let t;return this.graph&&(t=this.graph.findByPath(e.entityPath),t||(t=this.graph.findByPath(e.entityPath.slice(1)))),t||(t=this.nodes[e.entityPath[e.entityPath.length-1]||""]),t}static createAnimTarget(e,t,s,i,r,a){const o=dh.encode(i.path,a||"entity",r);return new cT(e,t,s,o)}resolve(e){const t=dh.encode(e.entityPath,e.component,e.propertyPath);let s=this.targetCache[t];if(s)return s;const i=this.findNode(e);if(!i)return null;const r=this.handlers[e.propertyPath];return!r||(s=r(i),!s)?null:(this.targetCache[t]=s,this.nodeCounts[i.path]?this.nodeCounts[i.path]++:(this.activeNodes.push(i),this.nodeCounts[i.path]=1),s)}unresolve(e){if(e.component!=="graph")return;const t=this.nodes[e.entityPath[e.entityPath.length-1]||""];if(this.nodeCounts[t.path]--,this.nodeCounts[t.path]===0){const s=this.activeNodes,i=s.indexOf(t.node),r=s.length;i<r-1&&(s[i]=s[r-1]),s.pop()}}update(e){const t=this.activeNodes;for(let s=0;s<t.length;++s)t[s]._dirtifyLocal()}assignMask(e){return e!==this._mask?(this._mask=e,!0):!1}constructor(e){if(this._isPathInMask=(r,a)=>{const o=this._mask[r];if(o){if(o.children||a&&o.value!==!1)return!0}else return!1;return!1},this.graph=e,!e)return;this._mask=null;const t={},s=function(r){t[r.name]=r;for(let a=0;a<r.children.length;++a)s(r.children[a])};s(e),this.nodes=t,this.targetCache={};const i=function(r){let a=r;for(;a&&!(a instanceof Nt);)a=a.parent;let o;return a&&(a.render?o=a.render.meshInstances:a.model&&(o=a.model.meshInstances)),o};this.nodeCounts={},this.activeNodes=[],this.handlers={localPosition:function(r){const a=r.localPosition,o=function(h){a.set(...h)};return Hn.createAnimTarget(o,"vector",3,r,"localPosition")},localRotation:function(r){const a=r.localRotation,o=function(h){a.set(...h)};return Hn.createAnimTarget(o,"quaternion",4,r,"localRotation")},localScale:function(r){const a=r.localScale,o=function(h){a.set(...h)};return Hn.createAnimTarget(o,"vector",3,r,"localScale")},weight:function(r,a){a.indexOf("name.")===0?a=a.replace("name.",""):a=Number(a);const o=i(r),h=[];if(o)for(let u=0;u<o.length;++u)o[u].node.name===r.name&&o[u].morphInstance&&h.push(o[u].morphInstance);if(h.length>0){const u={set:f=>{for(let m=0;m<h.length;++m)h[m].setWeight(a,f[0])},get:()=>[h[0].getWeight(a)]};return Hn.createAnimTarget(u,"number",1,r,`weight.${a}`)}return null},materialTexture:(r,a)=>{const o=i(r);if(o){let h;for(let u=0;u<o.length;++u)if(o[u].node.name===r.name){h=o[u];break}if(h){const u=f=>{const m=this.animComponent.system.app.assets.get(f[0]);m&&m.resource&&m.type==="texture"&&(h.material[a]=m.resource,h.material.update())};return Hn.createAnimTarget(u,"vector",1,r,"materialTexture","material")}}return null}}}}class PL extends ke{set animations(e){this._animations=e,this.onSetAnimations()}get animations(){return this._animations}set assets(e){const t=this._assets;if(t&&t.length){for(let i=0;i<t.length;i++)if(t[i]){const r=this.system.app.assets.get(t[i]);if(r){r.off("change",this.onAssetChanged,this),r.off("remove",this.onAssetRemoved,this);const a=this.animationsIndex[r.id];this.currAnim===a&&this._stopCurrentAnimation(),delete this.animations[a],delete this.animationsIndex[r.id]}}}this._assets=e;const s=e.map(i=>i instanceof Ee?i.id:i);this.loadAnimationAssets(s)}get assets(){return this._assets}set currentTime(e){if(this.skeleton&&(this.skeleton.currentTime=e,this.skeleton.addTime(0),this.skeleton.updateGraph()),this.animEvaluator){const t=this.animEvaluator.clips;for(let s=0;s<t.length;++s)t[s].time=e}}get currentTime(){if(this.skeleton)return this.skeleton._time;if(this.animEvaluator){const e=this.animEvaluator.clips;if(e.length>0)return e[e.length-1].time}return 0}get duration(){return this.currAnim?this.animations[this.currAnim].duration:0}set loop(e){if(this._loop=e,this.skeleton&&(this.skeleton.looping=e),this.animEvaluator)for(let t=0;t<this.animEvaluator.clips.length;++t)this.animEvaluator.clips[t].loop=e}get loop(){return this._loop}play(e,t=0){if(!(!this.enabled||!this.entity.enabled)&&this.animations[e]){if(this.prevAnim=this.currAnim,this.currAnim=e,this.model){!this.skeleton&&!this.animEvaluator&&this._createAnimationController();const s=this.animations[this.prevAnim],i=this.animations[this.currAnim];if(this.blending=t>0&&!!this.prevAnim,this.blending&&(this.blend=0,this.blendSpeed=1/t),this.skeleton&&(this.blending?(this.fromSkel.animation=s,this.fromSkel.addTime(this.skeleton._time),this.toSkel.animation=i):this.skeleton.animation=i),this.animEvaluator){const r=this.animEvaluator;if(this.blending)for(;r.clips.length>1;)r.removeClip(0);else this.animEvaluator.removeClips();const a=new Fh(this.animations[this.currAnim],0,1,!0,this.loop);a.name=this.currAnim,a.blendWeight=this.blending?0:1,a.reset(),this.animEvaluator.addClip(a)}}this.playing=!0}}getAnimation(e){return this.animations[e]}setModel(e){e!==this.model&&(this._resetAnimationController(),this.model=e,this.animations&&this.currAnim&&this.animations[this.currAnim]&&this.play(this.currAnim))}onSetAnimations(){const e=this.entity.model;if(e){const t=e.model;t&&t!==this.model&&this.setModel(t)}if(!this.currAnim&&this.activate&&this.enabled&&this.entity.enabled){const t=Object.keys(this._animations);t.length>0&&this.play(t[0])}}_resetAnimationController(){this.skeleton=null,this.fromSkel=null,this.toSkel=null,this.animEvaluator=null}_createAnimationController(){const e=this.model,t=this.animations;let s=!1,i=!1;for(const a in t)t.hasOwnProperty(a)&&(t[a].constructor===Qa?i=!0:s=!0);const r=e.getGraph();s?(this.fromSkel=new q0(r),this.toSkel=new q0(r),this.skeleton=new q0(r),this.skeleton.looping=this.loop,this.skeleton.setGraph(r)):i&&(this.animEvaluator=new CL(new Hn(this.entity)))}loadAnimationAssets(e){if(!e||!e.length)return;const t=this.system.app.assets,s=r=>{if(r.resources.length>1)for(let a=0;a<r.resources.length;a++)this.animations[r.resources[a].name]=r.resources[a],this.animationsIndex[r.id]=r.resources[a].name;else this.animations[r.name]=r.resource,this.animationsIndex[r.id]=r.name;this.animations=this.animations},i=r=>{r.off("change",this.onAssetChanged,this),r.on("change",this.onAssetChanged,this),r.off("remove",this.onAssetRemoved,this),r.on("remove",this.onAssetRemoved,this),r.resource?s(r):(r.once("load",s,this),this.enabled&&this.entity.enabled&&t.load(r))};for(let r=0,a=e.length;r<a;r++){const o=t.get(e[r]);o?i(o):t.on(`add:${e[r]}`,i)}}onAssetChanged(e,t,s,i){if(t==="resource"||t==="resources")if(t==="resources"&&s&&s.length===0&&(s=null),s){let r=!1;if(s.length>1){if(i&&i.length>1)for(let a=0;a<i.length;a++)delete this.animations[i[a].name];else delete this.animations[e.name];r=!1;for(let a=0;a<s.length;a++)this.animations[s[a].name]=s[a],!r&&this.currAnim===s[a].name&&this.playing&&this.enabled&&this.entity.enabled&&(r=!0,this.play(s[a].name));r||(this._stopCurrentAnimation(),this.onSetAnimations())}else{if(i&&i.length>1)for(let a=0;a<i.length;a++)delete this.animations[i[a].name];this.animations[e.name]=s[0]||s,r=!1,this.currAnim===e.name&&this.playing&&this.enabled&&this.entity.enabled&&(r=!0,this.play(e.name)),r||(this._stopCurrentAnimation(),this.onSetAnimations())}this.animationsIndex[e.id]=e.name}else{if(i.length>1)for(let r=0;r<i.length;r++)delete this.animations[i[r].name],this.currAnim===i[r].name&&this._stopCurrentAnimation();else delete this.animations[e.name],this.currAnim===e.name&&this._stopCurrentAnimation();delete this.animationsIndex[e.id]}}onAssetRemoved(e){if(e.off("remove",this.onAssetRemoved,this),this.animations){if(e.resources.length>1)for(let t=0;t<e.resources.length;t++)delete this.animations[e.resources[t].name],this.currAnim===e.resources[t].name&&this._stopCurrentAnimation();else delete this.animations[e.name],this.currAnim===e.name&&this._stopCurrentAnimation();delete this.animationsIndex[e.id]}}_stopCurrentAnimation(){if(this.currAnim=null,this.playing=!1,this.skeleton&&(this.skeleton.currentTime=0,this.skeleton.animation=null),this.animEvaluator){for(let e=0;e<this.animEvaluator.clips.length;++e)this.animEvaluator.clips[e].stop();this.animEvaluator.update(0),this.animEvaluator.removeClips()}}onEnable(){super.onEnable();const e=this.assets,t=this.system.app.assets;if(e)for(let s=0,i=e.length;s<i;s++){let r=e[s];r instanceof Ee||(r=t.get(r)),r&&!r.resource&&t.load(r)}if(this.activate&&!this.currAnim){const s=Object.keys(this.animations);s.length>0&&this.play(s[0])}}onBeforeRemove(){for(let e=0;e<this.assets.length;e++){let t=this.assets[e];typeof t=="number"&&(t=this.system.app.assets.get(t)),t&&(t.off("change",this.onAssetChanged,this),t.off("remove",this.onAssetRemoved,this))}this.skeleton=null,this.fromSkel=null,this.toSkel=null,this.animEvaluator=null}update(e){if(this.blending&&(this.blend+=e*this.blendSpeed,this.blend>=1&&(this.blend=1)),this.playing){const s=this.skeleton;if(s!==null&&this.model!==null){if(this.blending)s.blend(this.fromSkel,this.toSkel,this.blend);else{const i=e*this.speed;s.addTime(i),this.speed>0&&s._time===s.animation.duration&&!this.loop?this.playing=!1:this.speed<0&&s._time===0&&!this.loop&&(this.playing=!1)}this.blending&&this.blend===1&&(s.animation=this.toSkel.animation),s.updateGraph()}}const t=this.animEvaluator;if(t){for(let s=0;s<t.clips.length;++s){const i=t.clips[s];i.speed=this.speed,this.playing?i.resume():i.pause()}this.blending&&t.clips.length>1&&(t.clips[1].blendWeight=this.blend),t.update(e)}this.blending&&this.blend===1&&(this.blending=!1)}constructor(...e){super(...e),this._animations={},this._assets=[],this._loop=!0,this.animEvaluator=null,this.model=null,this.skeleton=null,this.fromSkel=null,this.toSkel=null,this.animationsIndex={},this.prevAnim=null,this.currAnim=null,this.blend=0,this.blending=!1,this.blendSpeed=0,this.activate=!0,this.speed=1}}class eY{constructor(){this.enabled=!0}}const hT=["enabled"];class tY extends Ht{initializeComponentData(e,t,s){s=["activate","enabled","loop","speed","assets"];for(const i of s)t.hasOwnProperty(i)&&(e[i]=t[i]);super.initializeComponentData(e,t,hT)}cloneComponent(e,t){this.addComponent(t,{}),t.animation.assets=e.animation.assets.slice(),t.animation.speed=e.animation.speed,t.animation.loop=e.animation.loop,t.animation.activate=e.animation.activate,t.animation.enabled=e.animation.enabled;const s={},i=e.animation.animations;for(const o in i)i.hasOwnProperty(o)&&(s[o]=i[o]);t.animation.animations=s;const r={},a=e.animation.animationsIndex;for(const o in a)a.hasOwnProperty(o)&&(r[o]=a[o]);return t.animation.animationsIndex=r,t.animation}onBeforeRemove(e,t){t.onBeforeRemove()}onUpdate(e){const t=this.store;for(const s in t)if(t.hasOwnProperty(s)){const i=t[s];i.data.enabled&&i.entity.enabled&&i.entity.animation.update(e)}}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}constructor(e){super(e),this.id="animation",this.ComponentType=PL,this.DataType=eY,this.schema=hT,this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("update",this.onUpdate,this)}}ke._buildAccessors(PL.prototype,hT);class pf{get parent(){return this._parent}get name(){return this._name}get path(){return this._parent?`${this._parent.path}.${this._name}`:this._name}get point(){return this._point}get pointLength(){return this._pointLength}set weight(e){this._weight=e}get weight(){return this._parent?this._parent.weight*this._weight:this._weight}get normalizedWeight(){const e=this._state.totalWeight;return e===0?0:this.weight/e}get speed(){return this._weightedSpeed*this._speed}get absoluteSpeed(){return Math.abs(this._speed)}set weightedSpeed(e){this._weightedSpeed=e}get weightedSpeed(){return this._weightedSpeed}set animTrack(e){this._animTrack=e}get animTrack(){return this._animTrack}constructor(e,t,s,i,r=1){this._state=e,this._parent=t,this._name=s,Array.isArray(i)?(this._point=new ne(i[0],i[1]),this._pointLength=this._point.length()):(this._point=i,this._pointLength=i),this._speed=r,this._weightedSpeed=1,this._weight=1,this._animTrack=null}}class Qh extends pf{get weight(){return this.calculateWeights(),this._parent?this._parent.weight*this._weight:this._weight}get syncAnimations(){return this._syncAnimations}getChild(e){for(let t=0;t<this._children.length;t++)if(this._children[t].name===e)return this._children[t];return null}updateParameterValues(){let e=!0;for(let t=0;t<this._parameterValues.length;t++){const s=this._findParameter(this._parameters[t]).value;this._parameterValues[t]!==s&&(this._parameterValues[t]=s,e=!1)}return e}getNodeWeightedDuration(e){return this._children[e].animTrack.duration/this._children[e].speedMultiplier*this._children[e].weight}getNodeCount(){let e=0;for(let t=0;t<this._children.length;t++)this._children[t].constructor===Qh?e+=this._children[t].getNodeCount():e++;return e}constructor(e,t,s,i,r,a,o,h,u){super(e,t,s,i),this._parameters=r,this._parameterValues=new Array(r.length),this._children=[],this._findParameter=u,this._syncAnimations=o!==!1,this._pointCache={};for(let f=0;f<a.length;f++){const m=a[f];m.children?this._children.push(h(m.type,e,this,m.name,1,m.parameter?[m.parameter]:m.parameters,m.children,m.syncAnimations,h,u)):this._children.push(new pf(e,this,m.name,m.point,m.speed))}}}class sY extends Qh{calculateWeights(){if(this.updateParameterValues())return;let e=0;this._children[0].weight=0;for(let t=0;t<this._children.length;t++){const s=this._children[t];if(t!==this._children.length-1){const i=this._children[t+1];if(s.point===i.point)s.weight=.5,i.weight=.5;else if(J.between(this._parameterValues[0],s.point,i.point,!0)){const r=Math.abs(s.point-i.point),a=Math.abs(s.point-this._parameterValues[0]),o=(r-a)/r;s.weight=o,i.weight=1-o}else i.weight=0}this._syncAnimations&&(e+=s.animTrack.duration/s.absoluteSpeed*s.weight)}if(this._syncAnimations)for(let t=0;t<this._children.length;t++){const s=this._children[t];s.weightedSpeed=s.animTrack.duration/s.absoluteSpeed/e}}constructor(e,t,s,i,r,a,o,h,u){a.sort((f,m)=>f.point-m.point),super(e,t,s,i,r,a,o,h,u)}}class Ia extends Qh{pointDistanceCache(e,t){const s=`${e}${t}`;return this._pointCache[s]||(this._pointCache[s]=this._children[t].point.clone().sub(this._children[e].point)),this._pointCache[s]}calculateWeights(){if(this.updateParameterValues())return;let e,t;Ia._p.set(...this._parameterValues),e=0,t=0;for(let s=0;s<this._children.length;s++){const i=this._children[s],r=i.point;Ia._pip.set(Ia._p.x,Ia._p.y).sub(r);let a=Number.MAX_VALUE;for(let o=0;o<this._children.length;o++){if(s===o)continue;const h=this.pointDistanceCache(s,o),u=J.clamp(1-Ia._pip.dot(h)/h.lengthSq(),0,1);u<a&&(a=u)}i.weight=a,e+=a,this._syncAnimations&&(t+=i.animTrack.duration/i.absoluteSpeed*i.weight)}for(let s=0;s<this._children.length;s++){const i=this._children[s];i.weight=i._weight/e,this._syncAnimations&&(i.weightedSpeed=i.animTrack.duration/i.absoluteSpeed/t)}}}Ia._p=new ne;Ia._pip=new ne;class Oa extends Qh{pointCache(e,t){const s=`${e}${t}`;return this._pointCache[s]||(this._pointCache[s]=new ne((this._children[t].pointLength-this._children[e].pointLength)/((this._children[t].pointLength+this._children[e].pointLength)/2),ne.angleRad(this._children[e].point,this._children[t].point)*2)),this._pointCache[s]}calculateWeights(){if(this.updateParameterValues())return;let e,t;Oa._p.set(...this._parameterValues);const s=Oa._p.length();e=0,t=0;for(let i=0;i<this._children.length;i++){const r=this._children[i],a=r.point,o=r.pointLength;let h=Number.MAX_VALUE;for(let u=0;u<this._children.length;u++){if(i===u)continue;const f=this.pointCache(i,u),m=this._children[u].pointLength;Oa._pip.set((s-o)/((m+o)/2),ne.angleRad(a,Oa._p)*2);const _=J.clamp(1-Math.abs(Oa._pip.dot(f)/f.lengthSq()),0,1);_<h&&(h=_)}r.weight=h,e+=h,this._syncAnimations&&(t+=r.animTrack.duration/r.absoluteSpeed*r.weight)}for(let i=0;i<this._children.length;i++){const r=this._children[i];if(r.weight=r._weight/e,this._syncAnimations){const a=r.animTrack.duration/t*e;r.weightedSpeed=r.absoluteSpeed*a}}}}Oa._p=new ne;Oa._pip=new ne;class iY extends Qh{calculateWeights(){if(this.updateParameterValues())return;let e=0,t=0;for(let s=0;s<this._children.length;s++)if(e+=Math.max(this._parameterValues[s],0),this._syncAnimations){const i=this._children[s];t+=i.animTrack.duration/i.absoluteSpeed*i.weight}for(let s=0;s<this._children.length;s++){const i=this._children[s],r=Math.max(this._parameterValues[s],0);e?(i.weight=r/e,this._syncAnimations&&(i.weightedSpeed=i.animTrack.duration/i.absoluteSpeed/t)):(i.weight=0,this._syncAnimations&&(i.weightedSpeed=0))}}}class XP{_createTree(e,t,s,i,r,a,o,h,u,f){switch(e){case $q:return new sY(t,s,i,r,a,o,h,u,f);case Zq:return new Ia(t,s,i,r,a,o,h,u,f);case Kq:return new Oa(t,s,i,r,a,o,h,u,f);case Qq:return new iY(t,s,i,r,a,o,h,u,f)}}_getNodeFromPath(e){let t=this._blendTree;for(let s=1;s<e.length;s++)t=t.getChild(e[s]);return t}addAnimation(e,t){const s=e.join("."),i=this._animationList.findIndex(r=>r.path===s);if(i>=0)this._animationList[i].animTrack=t;else{const r=this._getNodeFromPath(e);r.animTrack=t,this._animationList.push(r)}this._updateHasAnimations()}_updateHasAnimations(){this._hasAnimations=this._animationList.length>0&&this._animationList.every(e=>e.animTrack&&e.animTrack!==Qa.EMPTY)}get name(){return this._name}set animations(e){this._animationList=e,this._updateHasAnimations()}get animations(){return this._animationList}get hasAnimations(){return this._hasAnimations}set speed(e){this._speed=e}get speed(){return this._speed}set loop(e){this._loop=e}get loop(){return this._loop}get nodeCount(){return!this._blendTree||this._blendTree.constructor===pf?1:this._blendTree.getNodeCount()}get playable(){return yg.indexOf(this.name)!==-1||this.animations.length===this.nodeCount}get looping(){if(this.animations.length>0){const e=`${this.name}.${this.animations[0].animTrack.name}`,t=this._controller.animEvaluator.findClip(e);if(t)return t.loop}return!1}get totalWeight(){let e=0;for(let t=0;t<this.animations.length;t++)e+=this.animations[t].weight;return e}get timelineDuration(){let e=0;for(let t=0;t<this.animations.length;t++){const s=this.animations[t];s.animTrack.duration>e&&(e=s.animTrack.duration)}return e}constructor(e,t,s=1,i=!0,r){this._animations={},this._animationList=[],this._controller=e,this._name=t,this._speed=s,this._loop=i,this._hasAnimations=!1,r?this._blendTree=this._createTree(r.type,this,null,t,1,r.parameter?[r.parameter]:r.parameters,r.children,r.syncAnimations,this._createTree,this._controller.findParameter):this._blendTree=new pf(this,null,t,1,s)}}class xg{get from(){return this._from}set to(e){this._to=e}get to(){return this._to}get time(){return this._time}get priority(){return this._priority}get conditions(){return this._conditions}get exitTime(){return this._exitTime}get transitionOffset(){return this._transitionOffset}get interruptionSource(){return this._interruptionSource}get hasExitTime(){return!!this.exitTime}constructor({from:e,to:t,time:s=0,priority:i=0,conditions:r=[],exitTime:a=null,transitionOffset:o=null,interruptionSource:h=AL}){this._from=e,this._to=t,this._time=s,this._priority=i,this._conditions=r,this._exitTime=a,this._transitionOffset=o,this._interruptionSource=h}}class rY{get animEvaluator(){return this._animEvaluator}set activeState(e){this._activeStateName=e}get activeState(){return this._findState(this._activeStateName)}get activeStateName(){return this._activeStateName}get activeStateAnimations(){return this.activeState.animations}set previousState(e){this._previousStateName=e}get previousState(){return this._findState(this._previousStateName)}get previousStateName(){return this._previousStateName}get playable(){let e=!0;for(let t=0;t<this._stateNames.length;t++)this._states[this._stateNames[t]].playable||(e=!1);return e}set playing(e){this._playing=e}get playing(){return this._playing}get activeStateProgress(){return this._getActiveStateProgressForTime(this._timeInState)}get activeStateDuration(){if(this._activeStateDurationDirty){let e=0;for(let t=0;t<this.activeStateAnimations.length;t++){const s=this._animEvaluator.findClip(this.activeStateAnimations[t].name);s&&(e=Math.max(e,s.track.duration))}this._activeStateDuration=e,this._activeStateDurationDirty=!1}return this._activeStateDuration}set activeStateCurrentTime(e){this._timeInStateBefore=e,this._timeInState=e;for(let t=0;t<this.activeStateAnimations.length;t++){const s=this.animEvaluator.findClip(this.activeStateAnimations[t].name);s&&(s.time=e)}}get activeStateCurrentTime(){return this._timeInState}get transitioning(){return this._isTransitioning}get transitionProgress(){return this._currTransitionTime/this._totalTransitionTime}get states(){return this._stateNames}assignMask(e){return this._animEvaluator.assignMask(e)}_findState(e){return this._states[e]}_getActiveStateProgressForTime(e){if(this.activeStateName===Md||this.activeStateName===lT||this.activeStateName===al)return 1;const t=this._animEvaluator.findClip(this.activeStateAnimations[0].name);return t?t.progressForTime(e):null}_findTransitionsFromState(e){let t=this._findTransitionsFromStateCache[e];return t||(t=this._transitions.filter(s=>s.from===e),df(t),this._findTransitionsFromStateCache[e]=t),t}_findTransitionsBetweenStates(e,t){let s=this._findTransitionsBetweenStatesCache[`${e}->${t}`];return s||(s=this._transitions.filter(i=>i.from===e&&i.to===t),df(s),this._findTransitionsBetweenStatesCache[`${e}->${t}`]=s),s}_transitionHasConditionsMet(e){const t=e.conditions;for(let s=0;s<t.length;s++){const i=t[s],r=this._findParameter(i.parameterName);switch(i.predicate){case Hq:if(!(r.value>i.value))return!1;break;case Wq:if(!(r.value<i.value))return!1;break;case Xq:if(!(r.value>=i.value))return!1;break;case qq:if(!(r.value<=i.value))return!1;break;case Yq:if(r.value!==i.value)return!1;break;case jq:if(r.value===i.value)return!1;break}}return!0}_findTransition(e,t){let s=[];if(e&&t)s=s.concat(this._findTransitionsBetweenStates(e,t));else if(!this._isTransitioning)s=s.concat(this._findTransitionsFromState(this._activeStateName)),s=s.concat(this._findTransitionsFromState(al));else switch(this._transitionInterruptionSource){case zq:s=s.concat(this._findTransitionsFromState(this._previousStateName)),s=s.concat(this._findTransitionsFromState(al));break;case kq:s=s.concat(this._findTransitionsFromState(this._activeStateName)),s=s.concat(this._findTransitionsFromState(al));break;case Vq:s=s.concat(this._findTransitionsFromState(this._previousStateName)),s=s.concat(this._findTransitionsFromState(this._activeStateName)),s=s.concat(this._findTransitionsFromState(al));break;case Gq:s=s.concat(this._findTransitionsFromState(this._activeStateName)),s=s.concat(this._findTransitionsFromState(this._previousStateName)),s=s.concat(this._findTransitionsFromState(al));break}if(s=s.filter(i=>{if(i.to===this.activeStateName)return!1;if(i.hasExitTime){let r=this._getActiveStateProgressForTime(this._timeInStateBefore),a=this._getActiveStateProgressForTime(this._timeInState);if(i.exitTime<1&&this.activeState.loop&&(r-=Math.floor(r),a-=Math.floor(a)),a===r){if(a!==i.exitTime)return null}else if(!(i.exitTime>r&&i.exitTime<=a))return null}return this._transitionHasConditionsMet(i)}),s.length>0){const i=s[0];if(i.to===lT){const r=this._findTransitionsFromState(Md)[0];i.to=r.to}return i}return null}updateStateFromTransition(e){let t,s,i;this.previousState=e.from?this.activeStateName:null,this.activeState=e.to,this._activeStateDurationDirty=!0;for(let u=0;u<e.conditions.length;u++){const f=e.conditions[u];this._findParameter(f.parameterName).type===L_&&this._consumeTrigger(f.parameterName)}if(this.previousState){this._isTransitioning||(this._transitionPreviousStates=[]),this._transitionPreviousStates.push({name:this._previousStateName,weight:1});const u=Math.min(this._totalTransitionTime!==0?this._currTransitionTime/this._totalTransitionTime:1,1);for(let f=0;f<this._transitionPreviousStates.length;f++){this._isTransitioning?f!==this._transitionPreviousStates.length-1?this._transitionPreviousStates[f].weight*=1-u:this._transitionPreviousStates[f].weight=u:this._transitionPreviousStates[f].weight=1,t=this._findState(this._transitionPreviousStates[f].name);for(let m=0;m<t.animations.length;m++)s=t.animations[m],i=this._animEvaluator.findClip(`${s.name}.previous.${f}`),i||(i=this._animEvaluator.findClip(s.name),i.name=`${s.name}.previous.${f}`),f!==this._transitionPreviousStates.length-1&&i.pause()}}this._isTransitioning=!0,this._totalTransitionTime=e.time,this._currTransitionTime=0,this._transitionInterruptionSource=e.interruptionSource;const r=this.activeState,a=e.transitionOffset&&e.transitionOffset>0&&e.transitionOffset<1;let o=0,h=0;if(a){const u=r.timelineDuration*e.transitionOffset;o=u,h=u}this._timeInState=o,this._timeInStateBefore=h;for(let u=0;u<r.animations.length;u++){if(i=this._animEvaluator.findClip(r.animations[u].name),i)i.reset();else{const f=Number.isFinite(r.animations[u].speed)?r.animations[u].speed:r.speed;i=new Fh(r.animations[u].animTrack,this._timeInState,f,!0,r.loop,this._eventHandler),i.name=r.animations[u].name,this._animEvaluator.addClip(i)}if(e.time>0?i.blendWeight=0:i.blendWeight=r.animations[u].normalizedWeight,i.play(),a)i.time=r.timelineDuration*e.transitionOffset;else{const f=r.speed>=0?0:this.activeStateDuration;i.time=f}}}_transitionToState(e){if(!this._findState(e))return;let t=this._findTransition(this._activeStateName,e);t||(this._animEvaluator.removeClips(),t=new xg({from:null,to:e})),this.updateStateFromTransition(t)}assignAnimation(e,t,s,i){const r=e.split(".");let a=this._findState(r[0]);a||(a=new XP(this,r[0],s),this._states[r[0]]=a,this._stateNames.push(r[0])),a.addAnimation(r,t),this._animEvaluator.updateClipTrack(a.name,t),s!==void 0&&(a.speed=s),i!==void 0&&(a.loop=i),!this._playing&&this._activate&&this.playable&&this.play(),this._activeStateDurationDirty=!0}removeNodeAnimations(e){if(yg.indexOf(e)!==-1)return!1;const t=this._findState(e);return t?(t.animations=[],!0):!1}play(e){e&&this._transitionToState(e),this._playing=!0}pause(){this._playing=!1}reset(){this._previousStateName=null,this._activeStateName=Md,this._playing=!1,this._currTransitionTime=1,this._totalTransitionTime=1,this._isTransitioning=!1,this._timeInState=0,this._timeInStateBefore=0,this._animEvaluator.removeClips()}rebind(){this._animEvaluator.rebind()}update(e){if(!this._playing)return;let t,s,i;(this.activeState.loop||this._timeInState<this.activeStateDuration)&&(this._timeInStateBefore=this._timeInState,this._timeInState+=e*this.activeState.speed,!this.activeState.loop&&this._timeInState>this.activeStateDuration&&(this._timeInState=this.activeStateDuration,e=this.activeStateDuration-this._timeInStateBefore));const r=this._findTransition(this._activeStateName);if(r&&this.updateStateFromTransition(r),this._isTransitioning)if(this._currTransitionTime+=e,this._currTransitionTime<=this._totalTransitionTime){const a=this._totalTransitionTime!==0?this._currTransitionTime/this._totalTransitionTime:1;for(let o=0;o<this._transitionPreviousStates.length;o++){t=this._findState(this._transitionPreviousStates[o].name);const h=this._transitionPreviousStates[o].weight;for(let u=0;u<t.animations.length;u++)s=t.animations[u],i=this._animEvaluator.findClip(`${s.name}.previous.${o}`),i&&(i.blendWeight=(1-a)*s.normalizedWeight*h)}t=this.activeState;for(let o=0;o<t.animations.length;o++)s=t.animations[o],this._animEvaluator.findClip(s.name).blendWeight=a*s.normalizedWeight}else{this._isTransitioning=!1;const a=this.activeStateAnimations.length,o=this._animEvaluator.clips.length;for(let h=0;h<o-a;h++)this._animEvaluator.removeClip(0);this._transitionPreviousStates=[],t=this.activeState;for(let h=0;h<t.animations.length;h++)s=t.animations[h],i=this._animEvaluator.findClip(s.name),i&&(i.blendWeight=s.normalizedWeight)}else if(this.activeState._blendTree.constructor!==pf){t=this.activeState;for(let a=0;a<t.animations.length;a++)s=t.animations[a],i=this._animEvaluator.findClip(s.name),i&&(i.blendWeight=s.normalizedWeight,s.parent.syncAnimations&&(i.speed=s.speed))}this._animEvaluator.update(e,this.activeState.hasAnimations)}constructor(e,t,s,i,r,a,o){this._states={},this._stateNames=[],this._findTransitionsFromStateCache={},this._findTransitionsBetweenStatesCache={},this._previousStateName=null,this._activeStateName=Md,this._activeStateDuration=0,this._activeStateDurationDirty=!0,this._playing=!1,this._currTransitionTime=1,this._totalTransitionTime=1,this._isTransitioning=!1,this._transitionInterruptionSource=AL,this._transitionPreviousStates=[],this._timeInState=0,this._timeInStateBefore=0,this.findParameter=h=>this._findParameter(h),this._animEvaluator=e,this._eventHandler=r,this._findParameter=a,this._consumeTrigger=o;for(let h=0;h<t.length;h++)this._states[t[h].name]=new XP(this,t[h].name,t[h].speed,t[h].loop,t[h].blendTree),this._stateNames.push(t[h].name);this._transitions=s.map(h=>new xg({...h})),this._activate=i}}const tx=new ne,s_=new D,gd=new me,vd=new ue,Sd=new pe;class Da extends Hn{static _packFloat(e){return e[0]}static _packBoolean(e){return!!e[0]}static _packVec2(e){return tx.x=e[0],tx.y=e[1],tx}static _packVec3(e){return s_.x=e[0],s_.y=e[1],s_.z=e[2],s_}static _packVec4(e){return gd.x=e[0],gd.y=e[1],gd.z=e[2],gd.w=e[3],gd}static _packColor(e){return vd.r=e[0],vd.g=e[1],vd.b=e[2],vd.a=e[3],vd}static _packQuat(e){return Sd.x=e[0],Sd.y=e[1],Sd.z=e[2],Sd.w=e[3],Sd}resolve(e){const t=dh.encode(e.entityPath,e.component,e.propertyPath);let s=this.targetCache[t];if(s)return s;let i,r,a;switch(e.component){case"entity":i=this._getEntityFromHierarchy(e.entityPath),a=dh.encode(i.path,"entity",e.propertyPath),r=i;break;case"graph":if(r=this.findNode(e),!r)return null;a=dh.encode(r.path,"graph",e.propertyPath);break;default:if(i=this._getEntityFromHierarchy(e.entityPath),r=i.findComponent(e.component),!r)return null;a=dh.encode(i.path,e.component,e.propertyPath);break}return s=this._createAnimTargetForProperty(r,e.propertyPath,a),this.targetCache[t]=s,s}update(e){const t=this.activeNodes;if(t)for(let s=0;s<t.length;s++)t[s]._dirtifyLocal()}_getEntityFromHierarchy(e){if(!this.animComponent.entity.name===e[0])return null;const t=this.animComponent.entity;return e.length===1?t:t._parent.findByPath(e)}_resolvePath(e,t,s){const i=t.length-(s?0:1);for(let r=0;r<i;r++)e=e[t[r]];return e}_setter(e,t,s){const i=this._resolvePath(e,t),r=t[t.length-1],a=`set${r.substring(0,1).toUpperCase()}${r.substring(1)}`;if(i[a]){let u=i[`get${r.substring(0,1).toUpperCase()}${r.substring(1)}`].bind(i)();u=[u.x,u.y,u.z,u.w];const f=i[a].bind(i);return{set:m=>{f(s(m))},get:()=>u}}const o=i[r];if(typeof o=="object"&&o.hasOwnProperty("copy"))return function(h){o.copy(s(h))};if([ne,D,me,ue,pe].indexOf(i.constructor)!==-1&&t.length>1){const h=t.length>2?this._resolvePath(e,t.slice(0,-1)):e,u=t[t.length-2];return function(f){i[r]=s(f),h[u]=i}}return function(h){i[r]=s(h)}}_createAnimTargetForProperty(e,t,s){if(this.handlers&&t[0].startsWith("weight."))return this.handlers.weight(e,t[0].replace("weight.",""));if(this.handlers&&t[0]==="material"&&t.length===2){const h=t[1];if(h.endsWith("Map"))return this.handlers.materialTexture(e,h)}const i=this._resolvePath(e,t,!0);if(typeof i>"u")return null;let r,a,o;if(typeof i=="number")r=this._setter(e,t,Da._packFloat),a="vector",o=1;else if(typeof i=="boolean")r=this._setter(e,t,Da._packBoolean),a="vector",o=1;else if(typeof i=="object")switch(i.constructor){case ne:r=this._setter(e,t,Da._packVec2),a="vector",o=2;break;case D:r=this._setter(e,t,Da._packVec3),a="vector",o=3;break;case me:r=this._setter(e,t,Da._packVec4),a="vector",o=4;break;case ue:r=this._setter(e,t,Da._packColor),a="vector",o=4;break;case pe:r=this._setter(e,t,Da._packQuat),a="quaternion",o=4;break;default:return null}return t.indexOf("material")!==-1?new cT(h=>{r(h),e.material.update()},a,o,s):new cT(r,a,o,s)}rebind(){this.targetCache={},this.animComponent.rootBone?this.graph=this.animComponent.rootBone:this.graph=this.animComponent.entity;const e={},t=function(s){e[s.name]=s;for(let i=0;i<s.children.length;++i)t(s.children[i])};t(this.graph),this.nodes=e}constructor(e,t,s,i,r){super(t),this.animComponent=e,this._mask=i,this.layerName=s,this.layerIndex=r}}class aY{get name(){return this._name}set playing(e){this._controller.playing=e}get playing(){return this._controller.playing}get playable(){return this._controller.playable}get activeState(){return this._controller.activeStateName}get previousState(){return this._controller.previousStateName}get activeStateProgress(){return this._controller.activeStateProgress}get activeStateDuration(){return this._controller.activeStateDuration}set activeStateCurrentTime(e){const t=this._controller,s=t.playing;t.playing=!0,t.activeStateCurrentTime=e,s||t.update(0),t.playing=s}get activeStateCurrentTime(){return this._controller.activeStateCurrentTime}get transitioning(){return this._controller.transitioning}get transitionProgress(){return this.transitioning?this._controller.transitionProgress:null}get states(){return this._controller.states}set weight(e){this._weight=e,this._component.dirtifyTargets()}get weight(){return this._weight}set blendType(e){e!==this._blendType&&(this._blendType=e,this._controller.normalizeWeights&&this._component.rebind())}get blendType(){return this._blendType}set mask(e){this._controller.assignMask(e)&&this._component.rebind(),this._mask=e}get mask(){return this._mask}play(e){this._controller.play(e)}pause(){this._controller.pause()}reset(){this._controller.reset()}rebind(){this._controller.rebind()}update(e){this._blendTime&&(this._blendTimeElapsed<this._blendTime?(this.weight=J.lerp(this._startingWeight,this._targetWeight,this._blendTimeElapsed/this._blendTime),this._blendTimeElapsed+=e):(this.weight=this._targetWeight,this._blendTime=0,this._blendTimeElapsed=0,this._startingWeight=0,this._targetWeight=0)),this._controller.update(e)}blendToWeight(e,t){this._startingWeight=this.weight,this._targetWeight=e,this._blendTime=Math.max(0,t),this._blendTimeElapsed=0}assignAnimation(e,t,s,i){t instanceof Qa&&(this._controller.assignAnimation(e,t,s,i),this._controller._transitions.length===0&&this._controller._transitions.push(new xg({from:"START",to:e})),this._component.activate&&this._component.playable&&(this._component.playing=!0))}removeNodeAnimations(e){this._controller.removeNodeAnimations(e)&&(this._component.playing=!1)}getAnimationAsset(e){return this._component.animationAssets[`${this.name}:${e}`]}transition(e,t=0,s=null){this._controller.updateStateFromTransition(new xg({from:this._controller.activeStateName,to:e,time:t,transitionOffset:s}))}constructor(e,t,s,i=1,r=wL){this._mask=null,this._blendTime=0,this._blendTimeElapsed=0,this._startingWeight=0,this._targetWeight=0,this._name=e,this._controller=t,this._component=s,this._weight=i,this._blendType=r}}class I_{get parameters(){return Object.assign({},this._parameters)}get layers(){return this._layers}constructor(e){if(this._layers=[],this._parameters={},Array.isArray(e.layers))this._layers=e.layers;else for(const t in e.layers){const s=e.layers[t],i={name:s.name,blendType:s.blendType,weight:s.weight,states:[],transitions:[]};for(let r=0;r<s.states.length;r++)i.states.push(e.states[s.states[r]]);for(let r=0;r<s.transitions.length;r++){const a=e.transitions[s.transitions[r]];if(a.conditions&&!Array.isArray(a.conditions)){const o=Object.keys(a.conditions),h=[];for(let u=0;u<o.length;u++){const f=a.conditions[o[u]];f.parameterName&&h.push(f)}a.conditions=h}Number.isInteger(a.from)&&(a.from=e.states[a.from].name),Number.isInteger(a.to)&&(a.to=e.states[a.to].name),i.transitions.push(a)}this._layers.push(i)}for(const t in e.parameters){const s=e.parameters[t];this._parameters[s.name]={type:s.type,value:s.value}}}}class RL extends ke{set stateGraphAsset(e){if(e===null){this.removeStateGraph();return}this._stateGraphAsset&&this.system.app.assets.get(this._stateGraphAsset).off("change",this._onStateGraphAssetChangeEvent,this);let t,s;e instanceof Ee?(t=e.id,s=this.system.app.assets.get(t),s||(this.system.app.assets.add(e),s=this.system.app.assets.get(t))):(t=e,s=this.system.app.assets.get(t)),!(!s||this._stateGraphAsset===t)&&(s.resource?(this._stateGraph=s.resource,this.loadStateGraph(this._stateGraph),s.on("change",this._onStateGraphAssetChangeEvent,this)):(s.once("load",i=>{this._stateGraph=i.resource,this.loadStateGraph(this._stateGraph)}),s.on("change",this._onStateGraphAssetChangeEvent,this),this.system.app.assets.load(s)),this._stateGraphAsset=t)}get stateGraphAsset(){return this._stateGraphAsset}set normalizeWeights(e){this._normalizeWeights=e,this.unbind()}get normalizeWeights(){return this._normalizeWeights}set animationAssets(e){this._animationAssets=e,this.loadAnimationAssets()}get animationAssets(){return this._animationAssets}set speed(e){this._speed=e}get speed(){return this._speed}set activate(e){this._activate=e}get activate(){return this._activate}set playing(e){this._playing=e}get playing(){return this._playing}set rootBone(e){if(typeof e=="string"){const t=this.entity.root.findByGuid(e);this._rootBone=t}else e instanceof Nt?this._rootBone=e:this._rootBone=null;this.rebind()}get rootBone(){return this._rootBone}set stateGraph(e){this._stateGraph=e}get stateGraph(){return this._stateGraph}get layers(){return this._layers}set layerIndices(e){this._layerIndices=e}get layerIndices(){return this._layerIndices}set parameters(e){this._parameters=e}get parameters(){return this._parameters}set targets(e){this._targets=e}get targets(){return this._targets}get playable(){for(let e=0;e<this._layers.length;e++)if(!this._layers[e].playable)return!1;return!0}get baseLayer(){return this._layers.length>0?this._layers[0]:null}_onStateGraphAssetChangeEvent(e){const t=this.animationAssets,s=this.layers.map(i=>i.mask);this.removeStateGraph(),this._stateGraph=new I_(e._data),this.loadStateGraph(this._stateGraph),this.animationAssets=t,this.loadAnimationAssets(),this.layers.forEach((i,r)=>{i.mask=s[r]}),this.rebind()}dirtifyTargets(){const e=Object.values(this._targets);for(let t=0;t<e.length;t++)e[t].dirty=!0}_addLayer({name:e,states:t,transitions:s,weight:i,mask:r,blendType:a}){let o;this.rootBone?o=this.rootBone:o=this.entity;const h=this._layers.length,u=new Da(this,o,e,r,h),f=new CL(u),m=new rY(f,t,s,this._activate,this,this.findParameter,this.consumeTrigger);return this._layers.push(new aY(e,m,this,i,a)),this._layerIndices[e]=h,this._layers[h]}addLayer(e,t,s,i){const r=this.findAnimationLayer(e);if(r)return r;const a=[{name:"START",speed:1}],o=[];return this._addLayer({name:e,states:a,transitions:o,weight:t,mask:s,blendType:i})}_assignParameters(e){this._parameters={};const t=Object.keys(e.parameters);for(let s=0;s<t.length;s++){const i=t[s];this._parameters[i]={type:e.parameters[i].type,value:e.parameters[i].value}}}loadStateGraph(e){this._stateGraph=e,this._assignParameters(e),this._layers=[];let t=!1;for(let s=0;s<e.layers.length;s++){const i=e.layers[s];this._addLayer({...i}),i.states.some(r=>r.blendTree)&&(t=!0)}t||this.setupAnimationAssets()}setupAnimationAssets(){for(let e=0;e<this._layers.length;e++){const t=this._layers[e],s=t.name;for(let i=0;i<t.states.length;i++){const r=t.states[i];if(yg.indexOf(r)===-1){const a=`${s}:${r}`;this._animationAssets[a]||(this._animationAssets[a]={asset:null})}}}this.loadAnimationAssets()}loadAnimationAssets(){for(let e=0;e<this._layers.length;e++){const t=this._layers[e];for(let s=0;s<t.states.length;s++){const i=t.states[s];if(yg.indexOf(i)!==-1)continue;const r=this._animationAssets[`${t.name}:${i}`];if(!r||!r.asset){this.findAnimationLayer(t.name).assignAnimation(i,Qa.EMPTY);continue}const a=r.asset,o=this.system.app.assets.get(a);o&&(o.resource?this.onAnimationAssetLoaded(t.name,i,o):(o.once("load",(function(h,u){return(function(f){this.onAnimationAssetLoaded(h,u,f)}).bind(this)}).bind(this)(t.name,i)),this.system.app.assets.load(o)))}}}onAnimationAssetLoaded(e,t,s){this.findAnimationLayer(e).assignAnimation(t,s.resource)}removeStateGraph(){this._stateGraph=null,this._stateGraphAsset=null,this._animationAssets={},this._layers=[],this._layerIndices={},this._parameters={},this._playing=!1,this.unbind(),this._targets={}}reset(){this._assignParameters(this._stateGraph);for(let e=0;e<this._layers.length;e++){const t=this._layers[e].playing;this._layers[e].reset(),this._layers[e].playing=t}}unbind(){this._normalizeWeights||Object.keys(this._targets).forEach(e=>{this._targets[e].unbind()})}rebind(){this._targets={};for(let e=0;e<this._layers.length;e++)this._layers[e].rebind()}findAnimationLayer(e){const t=this._layerIndices[e];return this._layers[t]||null}addAnimationState(e,t,s=1,i=!0,r="Base"){this._stateGraph||this.loadStateGraph(new I_({layers:[{name:r,states:[{name:"START",speed:1},{name:e,speed:s,loop:i,defaultState:!0}],transitions:[{from:"START",to:e}]}],parameters:{}}));const a=this.findAnimationLayer(r);a?a.assignAnimation(e,t,s,i):this.addLayer(r)?.assignAnimation(e,t,s,i)}assignAnimation(e,t,s,i=1,r=!0){if(!this._stateGraph&&e.indexOf(".")===-1){this.loadStateGraph(new I_({layers:[{name:"Base",states:[{name:"START",speed:1},{name:e,speed:i,loop:r,defaultState:!0}],transitions:[{from:"START",to:e}]}],parameters:{}})),this.baseLayer.assignAnimation(e,t);return}const a=s?this.findAnimationLayer(s):this.baseLayer;a&&a.assignAnimation(e,t,i,r)}removeNodeAnimations(e,t){const s=t?this.findAnimationLayer(t):this.baseLayer;s&&s.removeNodeAnimations(e)}getParameterValue(e,t){const s=this._parameters[e];if(s&&s.type===t)return s.value}setParameterValue(e,t,s){const i=this._parameters[e];if(i&&i.type===t){i.value=s;return}}getFloat(e){return this.getParameterValue(e,HP)}setFloat(e,t){this.setParameterValue(e,HP,t)}getInteger(e){return this.getParameterValue(e,GP)}setInteger(e,t){typeof t=="number"&&t%1===0&&this.setParameterValue(e,GP,t)}getBoolean(e){return this.getParameterValue(e,WP)}setBoolean(e,t){this.setParameterValue(e,WP,!!t)}getTrigger(e){return this.getParameterValue(e,L_)}setTrigger(e,t=!1){this.setParameterValue(e,L_,!0),t&&this._consumedTriggers.add(e)}resetTrigger(e){this.setParameterValue(e,L_,!1)}onBeforeRemove(){Number.isFinite(this._stateGraphAsset)&&this.system.app.assets.get(this._stateGraphAsset).off("change",this._onStateGraphAssetChangeEvent,this)}update(e){for(let t=0;t<this.layers.length;t++)this.layers[t].update(e*this.speed);this._consumedTriggers.forEach(t=>{this.parameters[t].value=!1}),this._consumedTriggers.clear()}resolveDuplicatedEntityReferenceProperties(e,t){e.rootBone&&t[e.rootBone.getGuid()]?this.rootBone=t[e.rootBone.getGuid()]:this.rebind()}constructor(...e){super(...e),this._stateGraphAsset=null,this._animationAssets={},this._speed=1,this._activate=!0,this._playing=!1,this._rootBone=null,this._stateGraph=null,this._layers=[],this._layerIndices={},this._parameters={},this._targets={},this._consumedTriggers=new Set,this._normalizeWeights=!1,this.findParameter=t=>this._parameters[t],this.consumeTrigger=t=>{this._consumedTriggers.add(t)}}}class nY{constructor(){this.enabled=!0}}const uT=["enabled"];class oY extends Ht{initializeComponentData(e,t,s){super.initializeComponentData(e,t,uT);const i=["animationAssets","stateGraph","layers","masks"];Object.keys(t).forEach(r=>{i.includes(r)||(e[r]=t[r])}),t.stateGraph&&(e.stateGraph=t.stateGraph,e.loadStateGraph(e.stateGraph)),t.layers&&t.layers.forEach((r,a)=>{r._controller.states.forEach(o=>{r._controller._states[o]._animationList.forEach(h=>{if(!h.animTrack||h.animTrack===Qa.EMPTY){const u=this.app.assets.get(r._component._animationAssets[`${r.name}:${h.name}`].asset);u&&!u.loaded&&u.once("load",()=>{e.layers[a].assignAnimation(h.name,u.resource)})}else e.layers[a].assignAnimation(h.name,h.animTrack)})})}),t.animationAssets&&(e.animationAssets=Object.assign(e.animationAssets,t.animationAssets)),t.masks&&Object.keys(t.masks).forEach(r=>{if(e.layers[r]){const a=t.masks[r].mask,o={};Object.keys(a).forEach(h=>{o[decodeURI(h)]=a[h]}),e.layers[r].mask=o}})}onAnimationUpdate(e){const t=this.store;for(const s in t)if(t.hasOwnProperty(s)){const i=t[s].entity.anim;i.data.enabled&&i.entity.enabled&&i.playing&&i.update(e)}}cloneComponent(e,t){let s;(!e.anim.rootBone||e.anim.rootBone===e)&&(s={},e.anim.layers.forEach((r,a)=>{if(r.mask){const o={};Object.keys(r.mask).forEach(h=>{const u=h.split("/");u.shift();const f=[t.name,...u].join("/");o[f]=r.mask[h]}),s[a]={mask:o}}}));const i={enabled:e.anim.enabled,stateGraphAsset:e.anim.stateGraphAsset,animationAssets:e.anim.animationAssets,speed:e.anim.speed,activate:e.anim.activate,playing:e.anim.playing,rootBone:e.anim.rootBone,stateGraph:e.anim.stateGraph,layers:e.anim.layers,layerIndices:e.anim.layerIndices,parameters:e.anim.parameters,normalizeWeights:e.anim.normalizeWeights,masks:s};return this.addComponent(t,i)}onBeforeRemove(e,t){t.onBeforeRemove()}destroy(){super.destroy(),this.app.systems.off("animationUpdate",this.onAnimationUpdate,this)}constructor(e){super(e),this.id="anim",this.ComponentType=RL,this.DataType=nY,this.schema=uT,this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("animationUpdate",this.onAnimationUpdate,this)}}ke._buildAccessors(RL.prototype,uT);class ML extends ke{setCurrentListener(){if(this.enabled&&this.entity.audiolistener&&this.entity.enabled){this.system.current=this.entity;const e=this.system.current.getPosition();this.system.manager.listener.setPosition(e)}}onEnable(){this.setCurrentListener()}onDisable(){this.system.current===this.entity&&(this.system.current=null)}}class lY{constructor(){this.enabled=!0}}const LL=["enabled"];class cY extends Ht{initializeComponentData(e,t,s){s=["enabled"],super.initializeComponentData(e,t,s)}onUpdate(e){if(this.current){const t=this.current.getPosition();this.manager.listener.setPosition(t);const s=this.current.getWorldTransform();this.manager.listener.setOrientation(s)}}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}constructor(e){super(e),this.id="audiolistener",this.ComponentType=ML,this.DataType=lY,this.schema=LL,this.manager=e.soundManager,this.current=null,this.app.systems.on("update",this.onUpdate,this)}}ke._buildAccessors(ML.prototype,LL);const dT=0,qP=1,O_="group",fT="image",IL="text",N_="stretch",hY="contain",uY="cover",jt={DEFAULT:"DEFAULT",HOVER:"HOVER",PRESSED:"PRESSED",INACTIVE:"INACTIVE"},Zf={};Zf[jt.DEFAULT]="_defaultTint";Zf[jt.HOVER]="hoverTint";Zf[jt.PRESSED]="pressedTint";Zf[jt.INACTIVE]="inactiveTint";const Qf={};Qf[jt.DEFAULT]="_defaultSpriteAsset";Qf[jt.HOVER]="hoverSpriteAsset";Qf[jt.PRESSED]="pressedSpriteAsset";Qf[jt.INACTIVE]="inactiveSpriteAsset";const Jf={};Jf[jt.DEFAULT]="_defaultSpriteFrame";Jf[jt.HOVER]="hoverSpriteFrame";Jf[jt.PRESSED]="pressedSpriteFrame";Jf[jt.INACTIVE]="inactiveSpriteFrame";class Ss extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){this._setValue("enabled",e)}get enabled(){return this.data.enabled}set active(e){this._setValue("active",e)}get active(){return this.data.active}set imageEntity(e){if(this._imageEntity!==e){const t=typeof e=="string";if(this._imageEntity&&t&&this._imageEntity.getGuid()===e)return;this._imageEntity&&this._imageEntityUnsubscribe(),e instanceof Dt?this._imageEntity=e:t?this._imageEntity=this.system.app.getEntityFromIndex(e)||null:this._imageEntity=null,this._imageEntity&&this._imageEntitySubscribe(),this._imageEntity?this.data.imageEntity=this._imageEntity.getGuid():t&&e&&(this.data.imageEntity=e)}}get imageEntity(){return this._imageEntity}set hitPadding(e){this._setValue("hitPadding",e)}get hitPadding(){return this.data.hitPadding}set transitionMode(e){this._setValue("transitionMode",e)}get transitionMode(){return this.data.transitionMode}set hoverTint(e){this._setValue("hoverTint",e)}get hoverTint(){return this.data.hoverTint}set pressedTint(e){this._setValue("pressedTint",e)}get pressedTint(){return this.data.pressedTint}set inactiveTint(e){this._setValue("inactiveTint",e)}get inactiveTint(){return this.data.inactiveTint}set fadeDuration(e){this._setValue("fadeDuration",e)}get fadeDuration(){return this.data.fadeDuration}set hoverSpriteAsset(e){this._setValue("hoverSpriteAsset",e)}get hoverSpriteAsset(){return this.data.hoverSpriteAsset}set hoverSpriteFrame(e){this._setValue("hoverSpriteFrame",e)}get hoverSpriteFrame(){return this.data.hoverSpriteFrame}set pressedSpriteAsset(e){this._setValue("pressedSpriteAsset",e)}get pressedSpriteAsset(){return this.data.pressedSpriteAsset}set pressedSpriteFrame(e){this._setValue("pressedSpriteFrame",e)}get pressedSpriteFrame(){return this.data.pressedSpriteFrame}set inactiveSpriteAsset(e){this._setValue("inactiveSpriteAsset",e)}get inactiveSpriteAsset(){return this.data.inactiveSpriteAsset}set inactiveSpriteFrame(e){this._setValue("inactiveSpriteFrame",e)}get inactiveSpriteFrame(){return this.data.inactiveSpriteFrame}_setValue(e,t){const s=this.data,i=s[e];s[e]=t,this.fire("set",e,i,t)}_toggleLifecycleListeners(e,t){this[e]("set_active",this._onSetActive,this),this[e]("set_transitionMode",this._onSetTransitionMode,this),this[e]("set_hoverTint",this._onSetTransitionValue,this),this[e]("set_pressedTint",this._onSetTransitionValue,this),this[e]("set_inactiveTint",this._onSetTransitionValue,this),this[e]("set_hoverSpriteAsset",this._onSetTransitionValue,this),this[e]("set_hoverSpriteFrame",this._onSetTransitionValue,this),this[e]("set_pressedSpriteAsset",this._onSetTransitionValue,this),this[e]("set_pressedSpriteFrame",this._onSetTransitionValue,this),this[e]("set_inactiveSpriteAsset",this._onSetTransitionValue,this),this[e]("set_inactiveSpriteFrame",this._onSetTransitionValue,this),e==="on"?this._evtElementAdd=this.entity.on("element:add",this._onElementComponentAdd,this):(this._evtElementAdd?.off(),this._evtElementAdd=null)}_onSetActive(e,t,s){t!==s&&this._updateVisualState()}_onSetTransitionMode(e,t,s){t!==s&&(this._cancelTween(),this._resetToDefaultVisualState(t),this._forceReapplyVisualState())}_onSetTransitionValue(e,t,s){t!==s&&this._forceReapplyVisualState()}_imageEntitySubscribe(){this._evtImageEntityElementAdd=this._imageEntity.on("element:add",this._onImageElementGain,this),this._imageEntity.element&&this._onImageElementGain()}_imageEntityUnsubscribe(){this._evtImageEntityElementAdd?.off(),this._evtImageEntityElementAdd=null,this._imageEntity?.element&&this._onImageElementLose()}_imageEntityElementSubscribe(){const e=this._imageEntity.element;this._evtImageEntityElementRemove=e.once("beforeremove",this._onImageElementLose,this),this._evtImageEntityElementColor=e.on("set:color",this._onSetColor,this),this._evtImageEntityElementOpacity=e.on("set:opacity",this._onSetOpacity,this),this._evtImageEntityElementSpriteAsset=e.on("set:spriteAsset",this._onSetSpriteAsset,this),this._evtImageEntityElementSpriteFrame=e.on("set:spriteFrame",this._onSetSpriteFrame,this)}_imageEntityElementUnsubscribe(){this._evtImageEntityElementRemove?.off(),this._evtImageEntityElementRemove=null,this._evtImageEntityElementColor?.off(),this._evtImageEntityElementColor=null,this._evtImageEntityElementOpacity?.off(),this._evtImageEntityElementOpacity=null,this._evtImageEntityElementSpriteAsset?.off(),this._evtImageEntityElementSpriteAsset=null,this._evtImageEntityElementSpriteFrame?.off(),this._evtImageEntityElementSpriteFrame=null}_onElementComponentRemove(){this._toggleHitElementListeners("off")}_onElementComponentAdd(){this._toggleHitElementListeners("on")}_onImageElementLose(){this._imageEntityElementUnsubscribe(),this._cancelTween(),this._resetToDefaultVisualState(this.transitionMode)}_onImageElementGain(){this._imageEntityElementSubscribe(),this._storeDefaultVisualState(),this._forceReapplyVisualState()}_toggleHitElementListeners(e){if(this.entity.element){const t=e==="on";if(t&&this._hasHitElementListeners)return;this.entity.element[e]("beforeremove",this._onElementComponentRemove,this),this.entity.element[e]("mouseenter",this._onMouseEnter,this),this.entity.element[e]("mouseleave",this._onMouseLeave,this),this.entity.element[e]("mousedown",this._onMouseDown,this),this.entity.element[e]("mouseup",this._onMouseUp,this),this.entity.element[e]("touchstart",this._onTouchStart,this),this.entity.element[e]("touchend",this._onTouchEnd,this),this.entity.element[e]("touchleave",this._onTouchLeave,this),this.entity.element[e]("touchcancel",this._onTouchCancel,this),this.entity.element[e]("selectstart",this._onSelectStart,this),this.entity.element[e]("selectend",this._onSelectEnd,this),this.entity.element[e]("selectenter",this._onSelectEnter,this),this.entity.element[e]("selectleave",this._onSelectLeave,this),this.entity.element[e]("click",this._onClick,this),this._hasHitElementListeners=t}}_storeDefaultVisualState(){const e=this._imageEntity?.element;!e||e.type===O_||(this._storeDefaultColor(e.color),this._storeDefaultOpacity(e.opacity),this._storeDefaultSpriteAsset(e.spriteAsset),this._storeDefaultSpriteFrame(e.spriteFrame))}_storeDefaultColor(e){this._defaultTint.r=e.r,this._defaultTint.g=e.g,this._defaultTint.b=e.b}_storeDefaultOpacity(e){this._defaultTint.a=e}_storeDefaultSpriteAsset(e){this._defaultSpriteAsset=e}_storeDefaultSpriteFrame(e){this._defaultSpriteFrame=e}_onSetColor(e){this._isApplyingTint||(this._storeDefaultColor(e),this._forceReapplyVisualState())}_onSetOpacity(e){this._isApplyingTint||(this._storeDefaultOpacity(e),this._forceReapplyVisualState())}_onSetSpriteAsset(e){this._isApplyingSprite||(this._storeDefaultSpriteAsset(e),this._forceReapplyVisualState())}_onSetSpriteFrame(e){this._isApplyingSprite||(this._storeDefaultSpriteFrame(e),this._forceReapplyVisualState())}_onMouseEnter(e){this._isHovering=!0,this._updateVisualState(),this._fireIfActive("mouseenter",e)}_onMouseLeave(e){this._isHovering=!1,this._isPressed=!1,this._updateVisualState(),this._fireIfActive("mouseleave",e)}_onMouseDown(e){this._isPressed=!0,this._updateVisualState(),this._fireIfActive("mousedown",e)}_onMouseUp(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("mouseup",e)}_onTouchStart(e){this._isPressed=!0,this._updateVisualState(),this._fireIfActive("touchstart",e)}_onTouchEnd(e){e.event.preventDefault(),this._isPressed=!1,this._updateVisualState(),this._fireIfActive("touchend",e)}_onTouchLeave(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("touchleave",e)}_onTouchCancel(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("touchcancel",e)}_onSelectStart(e){this._isPressed=!0,this._updateVisualState(),this._fireIfActive("selectstart",e)}_onSelectEnd(e){this._isPressed=!1,this._updateVisualState(),this._fireIfActive("selectend",e)}_onSelectEnter(e){this._hoveringCounter++,this._hoveringCounter===1&&(this._isHovering=!0,this._updateVisualState()),this._fireIfActive("selectenter",e)}_onSelectLeave(e){this._hoveringCounter--,this._hoveringCounter===0&&(this._isHovering=!1,this._isPressed=!1,this._updateVisualState()),this._fireIfActive("selectleave",e)}_onClick(e){this._fireIfActive("click",e)}_fireIfActive(e,t){this.data.active&&this.fire(e,t)}_updateVisualState(e){const t=this._visualState,s=this._determineVisualState();if((t!==s||e)&&this.enabled)switch(this._visualState=s,t===jt.HOVER&&this._fireIfActive("hoverend"),t===jt.PRESSED&&this._fireIfActive("pressedend"),s===jt.HOVER&&this._fireIfActive("hoverstart"),s===jt.PRESSED&&this._fireIfActive("pressedstart"),this.transitionMode){case dT:{const i=Zf[this._visualState],r=this[i];this._applyTint(r);break}case qP:{const i=Qf[this._visualState],r=Jf[this._visualState],a=this[i],o=this[r];this._applySprite(a,o);break}}}_forceReapplyVisualState(){this._updateVisualState(!0)}_resetToDefaultVisualState(e){if(this._imageEntity?.element)switch(e){case dT:this._cancelTween(),this._applyTintImmediately(this._defaultTint);break;case qP:this._applySprite(this._defaultSpriteAsset,this._defaultSpriteFrame);break}}_determineVisualState(){if(this.active){if(this._isPressed)return jt.PRESSED;if(this._isHovering)return jt.HOVER}else return jt.INACTIVE;return jt.DEFAULT}_applySprite(e,t){const s=this._imageEntity?.element;s&&(t=t||0,this._isApplyingSprite=!0,s.spriteAsset!==e&&(s.spriteAsset=e),s.spriteFrame!==t&&(s.spriteFrame=t),this._isApplyingSprite=!1)}_applyTint(e){this._cancelTween(),this.fadeDuration===0?this._applyTintImmediately(e):this._applyTintWithTween(e)}_applyTintImmediately(e){const t=this._imageEntity?.element;if(!e||!t||t.type===O_)return;const s=YP(e);this._isApplyingTint=!0,s.equals(t.color)||(t.color=s),t.opacity!==e.a&&(t.opacity=e.a),this._isApplyingTint=!1}_applyTintWithTween(e){const t=this._imageEntity?.element;if(!e||!t||t.type===O_)return;const s=YP(e),i=t.color,r=t.opacity;s.equals(i)&&e.a===r||(this._tweenInfo={startTime:vs(),from:new ue(i.r,i.g,i.b,r),to:e.clone(),lerpColor:new ue})}_updateTintTween(){const e=vs()-this._tweenInfo.startTime;let t=this.fadeDuration===0?1:e/this.fadeDuration;if(t=J.clamp(t,0,1),Math.abs(t-1)>1e-5){const s=this._tweenInfo.lerpColor;s.lerp(this._tweenInfo.from,this._tweenInfo.to,t),this._applyTintImmediately(new ue(s.r,s.g,s.b,s.a))}else this._applyTintImmediately(this._tweenInfo.to),this._cancelTween()}_cancelTween(){delete this._tweenInfo}onUpdate(){this._tweenInfo&&this._updateTintTween()}onEnable(){this._isHovering=!1,this._hoveringCounter=0,this._isPressed=!1,this._toggleHitElementListeners("on"),this._forceReapplyVisualState()}onDisable(){this._toggleHitElementListeners("off"),this._resetToDefaultVisualState(this.transitionMode)}onRemove(){this._imageEntityUnsubscribe(),this._toggleLifecycleListeners("off",this.system),this.onDisable()}resolveDuplicatedEntityReferenceProperties(e,t){e.imageEntity&&(this.imageEntity=t[e.imageEntity.getGuid()])}constructor(e,t){super(e,t),this._visualState=jt.DEFAULT,this._isHovering=!1,this._hoveringCounter=0,this._isPressed=!1,this._defaultTint=new ue(1,1,1,1),this._defaultSpriteAsset=null,this._defaultSpriteFrame=0,this._imageEntity=null,this._evtElementAdd=null,this._evtImageEntityElementAdd=null,this._evtImageEntityElementRemove=null,this._evtImageEntityElementColor=null,this._evtImageEntityElementOpacity=null,this._evtImageEntityElementSpriteAsset=null,this._evtImageEntityElementSpriteFrame=null,this._visualState=jt.DEFAULT,this._isHovering=!1,this._hoveringCounter=0,this._isPressed=!1,this._defaultTint=new ue(1,1,1,1),this._defaultSpriteAsset=null,this._defaultSpriteFrame=0,this._toggleLifecycleListeners("on",e)}}Ss.EVENT_MOUSEDOWN="mousedown";Ss.EVENT_MOUSEUP="mouseup";Ss.EVENT_MOUSEENTER="mouseenter";Ss.EVENT_MOUSELEAVE="mouseleave";Ss.EVENT_CLICK="click";Ss.EVENT_TOUCHSTART="touchstart";Ss.EVENT_TOUCHEND="touchend";Ss.EVENT_TOUCHCANCEL="touchcancel";Ss.EVENT_TOUCHLEAVE="touchleave";Ss.EVENT_SELECTSTART="selectstart";Ss.EVENT_SELECTEND="selectend";Ss.EVENT_SELECTENTER="selectenter";Ss.EVENT_SELECTLEAVE="selectleave";Ss.EVENT_HOVERSTART="hoverstart";Ss.EVENT_HOVEREND="hoverend";Ss.EVENT_PRESSEDSTART="pressedstart";Ss.EVENT_PRESSEDEND="pressedend";function YP(c){return new ue(c.r,c.g,c.b)}class dY{constructor(){this.enabled=!0,this.active=!0,this.imageEntity=null,this.hitPadding=new me,this.transitionMode=dT,this.hoverTint=new ue(.75,.75,.75),this.pressedTint=new ue(.5,.5,.5),this.inactiveTint=new ue(.25,.25,.25),this.fadeDuration=0,this.hoverSpriteAsset=null,this.hoverSpriteFrame=0,this.pressedSpriteAsset=null,this.pressedSpriteFrame=0,this.inactiveSpriteAsset=null,this.inactiveSpriteFrame=0}}const jP=["enabled","active",{name:"hitPadding",type:"vec4"},"transitionMode",{name:"hoverTint",type:"rgba"},{name:"pressedTint",type:"rgba"},{name:"inactiveTint",type:"rgba"},"fadeDuration","hoverSpriteAsset","hoverSpriteFrame","pressedSpriteAsset","pressedSpriteFrame","inactiveSpriteAsset","inactiveSpriteFrame"];class fY extends Ht{initializeComponentData(e,t,s){e.imageEntity=t.imageEntity,super.initializeComponentData(e,t,jP)}onUpdate(e){const t=this.store;for(const s in t){const i=t[s].entity,r=i.button;r.enabled&&i.enabled&&r.onUpdate()}}_onRemoveComponent(e,t){t.onRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}constructor(e){super(e),this.id="button",this.ComponentType=Ss,this.DataType=dY,this.schema=jP,this.on("beforeremove",this._onRemoveComponent,this),this.app.systems.on("update",this.onUpdate,this)}}const $P=new D,KP=new pe;class Jh extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){this._setValue("enabled",e)}get enabled(){return this.data.enabled}set type(e){this._setValue("type",e)}get type(){return this.data.type}set halfExtents(e){this._setValue("halfExtents",e)}get halfExtents(){return this.data.halfExtents}set linearOffset(e){this._setValue("linearOffset",e)}get linearOffset(){return this.data.linearOffset}set angularOffset(e){this._setValue("angularOffset",e)}get angularOffset(){return this.data.angularOffset}set radius(e){this._setValue("radius",e)}get radius(){return this.data.radius}set axis(e){this._setValue("axis",e)}get axis(){return this.data.axis}set height(e){this._setValue("height",e)}get height(){return this.data.height}set asset(e){this._setValue("asset",e)}get asset(){return this.data.asset}set renderAsset(e){this._setValue("renderAsset",e)}get renderAsset(){return this.data.renderAsset}set convexHull(e){this._setValue("convexHull",e)}get convexHull(){return this.data.convexHull}set shape(e){this._setValue("shape",e)}get shape(){return this.data.shape}set model(e){this._setValue("model",e)}get model(){return this.data.model}set render(e){this._setValue("render",e)}get render(){return this.data.render}set checkVertexDuplicates(e){this._setValue("checkVertexDuplicates",e)}get checkVertexDuplicates(){return this.data.checkVertexDuplicates}_setValue(e,t){const s=this.data,i=s[e];s[e]=t,this.fire("set",e,i,t)}onSetType(e,t,s){t!==s&&this.system.changeType(this,t,s)}onSetHalfExtents(e,t,s){const i=this.data.type;this.data.initialized&&i==="box"&&this.system.recreatePhysicalShapes(this)}onSetOffset(e,t,s){this._hasOffset=!this.data.linearOffset.equals(D.ZERO)||!this.data.angularOffset.equals(pe.IDENTITY),this.data.initialized&&this.system.recreatePhysicalShapes(this)}onSetRadius(e,t,s){const i=this.data.type;this.data.initialized&&(i==="sphere"||i==="capsule"||i==="cylinder"||i==="cone")&&this.system.recreatePhysicalShapes(this)}onSetHeight(e,t,s){const i=this.data.type;this.data.initialized&&(i==="capsule"||i==="cylinder"||i==="cone")&&this.system.recreatePhysicalShapes(this)}onSetAxis(e,t,s){const i=this.data.type;this.data.initialized&&(i==="capsule"||i==="cylinder"||i==="cone")&&this.system.recreatePhysicalShapes(this)}onSetAsset(e,t,s){const i=this.system.app.assets;if(t){const r=i.get(t);r&&r.off("remove",this.onAssetRemoved,this)}if(s){s instanceof Ee&&(this.data.asset=s.id);const r=i.get(this.data.asset);r&&(r.off("remove",this.onAssetRemoved,this),r.on("remove",this.onAssetRemoved,this))}this.data.initialized&&this.data.type==="mesh"&&(s||(this.data.model=null),this.system.recreatePhysicalShapes(this))}onSetRenderAsset(e,t,s){const i=this.system.app.assets;if(t){const r=i.get(t);r&&r.off("remove",this.onRenderAssetRemoved,this)}if(s){s instanceof Ee&&(this.data.renderAsset=s.id);const r=i.get(this.data.renderAsset);r&&(r.off("remove",this.onRenderAssetRemoved,this),r.on("remove",this.onRenderAssetRemoved,this))}this.data.initialized&&this.data.type==="mesh"&&(s||(this.data.render=null),this.system.recreatePhysicalShapes(this))}onSetModel(e,t,s){this.data.initialized&&this.data.type==="mesh"&&this.system.implementations.mesh.doRecreatePhysicalShape(this)}onSetRender(e,t,s){this.onSetModel(e,t,s)}onAssetRemoved(e){e.off("remove",this.onAssetRemoved,this),this.data.asset===e.id&&(this.asset=null)}onRenderAssetRemoved(e){e.off("remove",this.onRenderAssetRemoved,this),this.data.renderAsset===e.id&&(this.renderAsset=null)}getCompoundChildShapeIndex(e){const t=this.data.shape,s=t.getNumChildShapes();for(let i=0;i<s;i++){const r=t.getChildShape(i);if(Ammo.getPointer(r)===Ammo.getPointer(e))return i}return null}_onInsert(e){if(!(typeof Ammo>"u")){if(this._compoundParent)this.system.recreatePhysicalShapes(this);else if(!this.entity.rigidbody){let t=this.entity.parent;for(;t;){if(t.collision&&t.collision.type==="compound"){t.collision.shape.getNumChildShapes()===0?this.system.recreatePhysicalShapes(t.collision):this.system.recreatePhysicalShapes(this);break}t=t.parent}}}}_updateCompound(){const e=this.entity;if(e._dirtyWorld){let t=e._dirtyLocal,s=e;for(;s&&!t&&!(s.collision&&s.collision===this._compoundParent);)s._dirtyLocal&&(t=!0),s=s.parent;if(t){e.forEach(this.system.implementations.compound._updateEachDescendantTransform,e);const i=this._compoundParent.entity.rigidbody;i&&i.activate()}}}getShapePosition(){const e=this.entity.getPosition();if(this._hasOffset){const t=this.entity.getRotation(),s=this.data.linearOffset;return KP.copy(t).transformVector(s,$P),$P.add(e)}return e}getShapeRotation(){const e=this.entity.getRotation();return this._hasOffset?KP.copy(e).mul(this.data.angularOffset):e}onEnable(){if(this.data.type==="mesh"&&(this.data.asset||this.data.renderAsset)&&this.data.initialized){const e=this.system.app.assets.get(this.data.asset||this.data.renderAsset);if(e&&(!e.resource||!this.data.shape)){this.system.recreatePhysicalShapes(this);return}}if(this.entity.rigidbody)this.entity.rigidbody.enabled&&this.entity.rigidbody.enableSimulation();else if(this._compoundParent&&this!==this._compoundParent)if(this._compoundParent.shape.getNumChildShapes()===0)this.system.recreatePhysicalShapes(this._compoundParent);else{const e=this.system._getNodeTransform(this.entity,this._compoundParent.entity);this._compoundParent.shape.addChildShape(e,this.data.shape),Ammo.destroy(e),this._compoundParent.entity.rigidbody&&this._compoundParent.entity.rigidbody.activate()}else this.entity.trigger&&this.entity.trigger.enable()}onDisable(){this.entity.rigidbody?this.entity.rigidbody.disableSimulation():this._compoundParent&&this!==this._compoundParent?this._compoundParent.entity._destroying||(this.system._removeCompoundChild(this._compoundParent,this.data.shape),this._compoundParent.entity.rigidbody&&this._compoundParent.entity.rigidbody.activate()):this.entity.trigger&&this.entity.trigger.disable()}onBeforeRemove(){this.asset&&(this.asset=null),this.renderAsset&&(this.renderAsset=null),this.entity.off("insert",this._onInsert,this),this.off()}constructor(e,t){super(e,t),this._compoundParent=null,this._hasOffset=!1,this.entity.on("insert",this._onInsert,this),this.on("set_type",this.onSetType,this),this.on("set_convexHull",this.onSetModel,this),this.on("set_halfExtents",this.onSetHalfExtents,this),this.on("set_linearOffset",this.onSetOffset,this),this.on("set_angularOffset",this.onSetOffset,this),this.on("set_radius",this.onSetRadius,this),this.on("set_height",this.onSetHeight,this),this.on("set_axis",this.onSetAxis,this),this.on("set_asset",this.onSetAsset,this),this.on("set_renderAsset",this.onSetRenderAsset,this),this.on("set_model",this.onSetModel,this),this.on("set_render",this.onSetRender,this)}}Jh.EVENT_CONTACT="contact";Jh.EVENT_COLLISIONSTART="collisionstart";Jh.EVENT_COLLISIONEND="collisionend";Jh.EVENT_TRIGGERENTER="triggerenter";Jh.EVENT_TRIGGERLEAVE="triggerleave";class mY{constructor(){this.enabled=!0,this.type="box",this.halfExtents=new D(.5,.5,.5),this.linearOffset=new D,this.angularOffset=new pe,this.radius=.5,this.axis=1,this.height=2,this.convexHull=!1,this.asset=null,this.renderAsset=null,this.checkVertexDuplicates=!0,this.shape=null,this.model=null,this.render=null,this.initialized=!1}}const yd="static",ar="dynamic",Hc="kinematic",pY=2,Ld=4,mT=1,ZP=4,OL=5,_Y=1,QP=2,gY=4,JP=16,eR=65535,pT=65533;let nr,qo,Wc;class NL{initialize(e){const t=this.entity,s=e.shape;if(s&&typeof Ammo<"u"){t.trigger&&t.trigger.destroy();const i=1,r=this.component;if(r){const o=r.getShapePosition(),h=r.getShapeRotation();nr.setValue(o.x,o.y,o.z),qo.setValue(h.x,h.y,h.z,h.w)}else{const o=t.getPosition(),h=t.getRotation();nr.setValue(o.x,o.y,o.z),qo.setValue(h.x,h.y,h.z,h.w)}Wc.setOrigin(nr),Wc.setRotation(qo);const a=this.app.systems.rigidbody.createBody(i,s,Wc);a.setRestitution(0),a.setFriction(0),a.setDamping(0,0),nr.setValue(0,0,0),a.setLinearFactor(nr),a.setAngularFactor(nr),a.setCollisionFlags(a.getCollisionFlags()|Ld),a.entity=t,this.body=a,this.component.enabled&&t.enabled&&this.enable()}}destroy(){this.body&&(this.disable(),this.app.systems.rigidbody.destroyBody(this.body),this.body=null)}_getEntityTransform(e){const t=this.component;if(t){const s=t.getShapePosition(),i=t.getShapeRotation();nr.setValue(s.x,s.y,s.z),qo.setValue(i.x,i.y,i.z,i.w)}else{const s=this.entity.getPosition(),i=this.entity.getRotation();nr.setValue(s.x,s.y,s.z),qo.setValue(i.x,i.y,i.z,i.w)}e.setOrigin(nr),e.setRotation(qo)}updateTransform(){this._getEntityTransform(Wc);const e=this.body;e.setWorldTransform(Wc),e.activate()}enable(){const e=this.body;if(!e)return;const t=this.app.systems.rigidbody;t._triggers.indexOf(this)<0&&(t.addBody(e,JP,pT^JP),t._triggers.push(this)),e.forceActivationState(mT),this.updateTransform()}disable(){const e=this.body;if(!e)return;const t=this.app.systems.rigidbody,s=t._triggers.indexOf(this);s>-1&&(t.removeBody(e),t._triggers.splice(s,1)),e.forceActivationState(OL)}constructor(e,t,s){this.entity=t.entity,this.component=t,this.app=e,typeof Ammo<"u"&&!nr&&(nr=new Ammo.btVector3,qo=new Ammo.btQuaternion,Wc=new Ammo.btTransform),this.initialize(s)}}const i_=new fe,vY=new D,SY=new D,Yo=new pe,tR=new Dt,yY=["enabled","type","halfExtents","linearOffset","angularOffset","radius","axis","height","convexHull","asset","renderAsset","shape","model","render","checkVertexDuplicates"];class Bl{beforeInitialize(e,t){t.shape=null,t.model=new rn,t.model.graph=new Dt}afterInitialize(e,t){this.recreatePhysicalShapes(e),e.data.initialized=!0}reset(e,t){this.beforeInitialize(e,t),this.afterInitialize(e,t)}recreatePhysicalShapes(e){const t=e.entity,s=e.data;if(typeof Ammo<"u"){t.trigger&&(t.trigger.destroy(),delete t.trigger),s.shape&&(e._compoundParent&&(e!==e._compoundParent&&this.system._removeCompoundChild(e._compoundParent,s.shape),e._compoundParent.entity.rigidbody&&e._compoundParent.entity.rigidbody.activate()),this.destroyShape(s)),s.shape=this.createPhysicalShape(e.entity,s);const i=!e._compoundParent;if(s.type==="compound"&&(!e._compoundParent||e===e._compoundParent))e._compoundParent=e,t.forEach(this._addEachDescendant,e);else if(s.type!=="compound"&&!e.rigidbody){e._compoundParent=null;let r=t.parent;for(;r;){if(r.collision&&r.collision.type==="compound"){e._compoundParent=r.collision;break}r=r.parent}}e._compoundParent&&e!==e._compoundParent&&(i&&e._compoundParent.shape.getNumChildShapes()===0?this.system.recreatePhysicalShapes(e._compoundParent):(this.system.updateCompoundChildTransform(t,!0),e._compoundParent.entity.rigidbody&&e._compoundParent.entity.rigidbody.activate())),t.rigidbody?(t.rigidbody.disableSimulation(),t.rigidbody.createBody(),t.enabled&&t.rigidbody.enabled&&t.rigidbody.enableSimulation()):e._compoundParent||(t.trigger?t.trigger.initialize(s):t.trigger=new NL(this.system.app,e,s))}}createPhysicalShape(e,t){}updateTransform(e,t,s,i){e.entity.trigger&&e.entity.trigger.updateTransform()}destroyShape(e){e.shape&&(Ammo.destroy(e.shape),e.shape=null)}beforeRemove(e,t){t.data.shape&&(t._compoundParent&&!t._compoundParent.entity._destroying&&(this.system._removeCompoundChild(t._compoundParent,t.data.shape),t._compoundParent.entity.rigidbody&&t._compoundParent.entity.rigidbody.activate()),t._compoundParent=null,this.destroyShape(t.data))}remove(e,t){e.rigidbody&&e.rigidbody.body&&e.rigidbody.disableSimulation(),e.trigger&&(e.trigger.destroy(),delete e.trigger)}clone(e,t){const s=this.system.store[e.getGuid()],i={enabled:s.data.enabled,type:s.data.type,halfExtents:[s.data.halfExtents.x,s.data.halfExtents.y,s.data.halfExtents.z],linearOffset:[s.data.linearOffset.x,s.data.linearOffset.y,s.data.linearOffset.z],angularOffset:[s.data.angularOffset.x,s.data.angularOffset.y,s.data.angularOffset.z,s.data.angularOffset.w],radius:s.data.radius,axis:s.data.axis,height:s.data.height,convexHull:s.data.convexHull,asset:s.data.asset,renderAsset:s.data.renderAsset,model:s.data.model,render:s.data.render,checkVertexDuplicates:s.data.checkVertexDuplicates};return this.system.addComponent(t,i)}constructor(e){this.system=e}}class xY extends Bl{createPhysicalShape(e,t){if(typeof Ammo<"u"){const s=t.halfExtents,i=new Ammo.btVector3(s?s.x:.5,s?s.y:.5,s?s.z:.5),r=new Ammo.btBoxShape(i);return Ammo.destroy(i),r}}}class TY extends Bl{createPhysicalShape(e,t){if(typeof Ammo<"u")return new Ammo.btSphereShape(t.radius)}}class EY extends Bl{createPhysicalShape(e,t){const s=t.axis??1,i=t.radius??.5,r=Math.max((t.height??2)-2*i,0);let a=null;if(typeof Ammo<"u")switch(s){case 0:a=new Ammo.btCapsuleShapeX(i,r);break;case 1:a=new Ammo.btCapsuleShape(i,r);break;case 2:a=new Ammo.btCapsuleShapeZ(i,r);break}return a}}class bY extends Bl{createPhysicalShape(e,t){const s=t.axis??1,i=t.radius??.5,r=t.height??1;let a=null,o=null;if(typeof Ammo<"u")switch(s){case 0:a=new Ammo.btVector3(r*.5,i,i),o=new Ammo.btCylinderShapeX(a);break;case 1:a=new Ammo.btVector3(i,r*.5,i),o=new Ammo.btCylinderShape(a);break;case 2:a=new Ammo.btVector3(i,i,r*.5),o=new Ammo.btCylinderShapeZ(a);break}return a&&Ammo.destroy(a),o}}class AY extends Bl{createPhysicalShape(e,t){const s=t.axis??1,i=t.radius??.5,r=t.height??1;let a=null;if(typeof Ammo<"u")switch(s){case 0:a=new Ammo.btConeShapeX(i,r);break;case 1:a=new Ammo.btConeShape(i,r);break;case 2:a=new Ammo.btConeShapeZ(i,r);break}return a}}class wY extends Bl{beforeInitialize(e,t){}createAmmoHull(e,t,s,i){const r=new Ammo.btConvexHullShape,a=new Ammo.btVector3,o=[];e.getPositions(o);for(let u=0;u<o.length;u+=3)a.setValue(o[u]*i.x,o[u+1]*i.y,o[u+2]*i.z),r.addPoint(a,!1);Ammo.destroy(a),r.recalcLocalAabb(),r.setMargin(.01);const h=this.system._getNodeTransform(t);s.addChildShape(h,r),Ammo.destroy(h)}createAmmoMesh(e,t,s,i,r=!0){const a=this.system;let o;if(a._triMeshCache[e.id])o=a._triMeshCache[e.id];else{const f=e.vertexBuffer,m=f.getFormat();let _,g;for(let G=0;G<m.elements.length;G++){const H=m.elements[G];if(H.name===He){g=new Float32Array(f.lock(),H.offset),_=H.stride/4;break}}const S=[];e.getIndices(S);const x=e.primitive[0].count/3,T=new Ammo.btVector3;let E,b,C;const w=e.primitive[0].base;o=new Ammo.btTriangleMesh,a._triMeshCache[e.id]=o;const P=new Map,I=o.getIndexedMeshArray();I.at(0).m_numTriangles=x;const M=i?i.x:1,R=i?i.y:1,L=i?i.z:1,B=G=>{const H=g[G*_]*M,ee=g[G*_+1]*R,j=g[G*_+2]*L;let ae;if(r){const k=`${H}:${ee}:${j}`;if(ae=P.get(k),ae!==void 0)return ae;T.setValue(H,ee,j),ae=o.findOrAddVertex(T,!1),P.set(k,ae)}else T.setValue(H,ee,j),ae=o.findOrAddVertex(T,!1);return ae};for(let G=0;G<x;G++)E=B(S[w+G*3]),b=B(S[w+G*3+1]),C=B(S[w+G*3+2]),o.addIndex(E),o.addIndex(b),o.addIndex(C);Ammo.destroy(T)}const h=new Ammo.btBvhTriangleMeshShape(o,!0);if(!i){const f=a._getNodeScaling(t);h.setLocalScaling(f),Ammo.destroy(f)}const u=a._getNodeTransform(t);s.addChildShape(u,h),Ammo.destroy(u)}createPhysicalShape(e,t){if(!(typeof Ammo>"u")&&(t.model||t.render)){const s=new Ammo.btCompoundShape,r=e.getWorldTransform().getScale();if(t.render){const a=t.render.meshes;for(let o=0;o<a.length;o++)t.convexHull?this.createAmmoHull(a[o],tR,s,r):this.createAmmoMesh(a[o],tR,s,r,t.checkVertexDuplicates)}else if(t.model){const a=t.model.meshInstances;for(let h=0;h<a.length;h++)this.createAmmoMesh(a[h].mesh,a[h].node,s,null,t.checkVertexDuplicates);const o=new Ammo.btVector3(r.x,r.y,r.z);s.setLocalScaling(o),Ammo.destroy(o)}return s}}recreatePhysicalShapes(e){const t=e.data;if((t.renderAsset||t.asset)&&e.enabled&&e.entity.enabled){this.loadAsset(e,t.renderAsset||t.asset,t.renderAsset?"render":"model");return}this.doRecreatePhysicalShape(e)}loadAsset(e,t,s){const i=e.data,r=this.system.app.assets,a=i[s],o=f=>{i[s]===a&&(i[s]=f.resource,this.doRecreatePhysicalShape(e))},h=f=>{f.ready(m=>{if(m.data.containerAsset){const _=r.get(m.data.containerAsset);_.loaded?o(m):(_.ready(()=>{o(m)}),r.load(_))}else o(m)}),r.load(f)},u=r.get(t);u?h(u):r.once(`add:${t}`,h)}doRecreatePhysicalShape(e){const t=e.entity,s=e.data;s.model||s.render?(this.destroyShape(s),s.shape=this.createPhysicalShape(t,s),t.rigidbody?(t.rigidbody.disableSimulation(),t.rigidbody.createBody(),t.enabled&&t.rigidbody.enabled&&t.rigidbody.enableSimulation()):t.trigger?t.trigger.initialize(s):t.trigger=new NL(this.system.app,e,s)):(this.beforeRemove(t,e),this.remove(t,s))}updateTransform(e,t,s,i){if(e.shape){const a=e.entity.getWorldTransform().getScale(),o=e.shape.getLocalScaling();(a.x!==o.x()||a.y!==o.y()||a.z!==o.z())&&this.doRecreatePhysicalShape(e)}super.updateTransform(e,t,s,i)}destroyShape(e){if(!e.shape)return;const t=e.shape.getNumChildShapes();for(let s=0;s<t;s++){const i=e.shape.getChildShape(s);Ammo.destroy(i)}Ammo.destroy(e.shape),e.shape=null}}class CY extends Bl{createPhysicalShape(e,t){if(typeof Ammo<"u")return new Ammo.btCompoundShape}_addEachDescendant(e){!e.collision||e.rigidbody||(e.collision._compoundParent=this,e!==this.entity&&e.collision.system.recreatePhysicalShapes(e.collision))}_updateEachDescendant(e){e.collision&&e.collision._compoundParent===this&&(e.collision._compoundParent=null,e!==this.entity&&!e.rigidbody&&e.collision.system.recreatePhysicalShapes(e.collision))}_updateEachDescendantTransform(e){!e.collision||e.collision._compoundParent!==this.collision._compoundParent||this.collision.system.updateCompoundChildTransform(e,!1)}}class DY extends Ht{initializeComponentData(e,t,s){s=["type","halfExtents","radius","axis","height","convexHull","shape","model","asset","render","renderAsset","enabled","linearOffset","angularOffset","checkVertexDuplicates"];const i={};for(let o=0,h=s.length;o<h;o++){const u=s[o];i[u]=t[u]}let r;if(t.hasOwnProperty("asset")?(r=s.indexOf("model"),r!==-1&&s.splice(r,1),r=s.indexOf("render"),r!==-1&&s.splice(r,1)):t.hasOwnProperty("model")&&(r=s.indexOf("asset"),r!==-1&&s.splice(r,1)),i.type||(i.type=e.data.type),e.data.type=i.type,Array.isArray(i.halfExtents)&&(i.halfExtents=new D(i.halfExtents)),Array.isArray(i.linearOffset)&&(i.linearOffset=new D(i.linearOffset)),Array.isArray(i.angularOffset)){const o=i.angularOffset;o.length===3?i.angularOffset=new pe().setFromEulerAngles(o[0],o[1],o[2]):i.angularOffset=new pe(i.angularOffset)}const a=this._createImplementation(i.type);a.beforeInitialize(e,i),super.initializeComponentData(e,i,s),a.afterInitialize(e,i)}_createImplementation(e){if(this.implementations[e]===void 0){let t;switch(e){case"box":t=new xY(this);break;case"sphere":t=new TY(this);break;case"capsule":t=new EY(this);break;case"cylinder":t=new bY(this);break;case"cone":t=new AY(this);break;case"mesh":t=new wY(this);break;case"compound":t=new CY(this);break}this.implementations[e]=t}return this.implementations[e]}_getImplementation(e){return this.implementations[e.collision.data.type]}cloneComponent(e,t){return this._getImplementation(e).clone(e,t)}onBeforeRemove(e,t){this.implementations[t.data.type].beforeRemove(e,t),t.onBeforeRemove()}onRemove(e,t){this.implementations[t.type].remove(e,t)}updateCompoundChildTransform(e,t){const s=e.collision._compoundParent;if(s!==e.collision&&e.enabled&&e.collision.enabled&&(e._dirtyLocal||t)){const i=this._getNodeTransform(e,s.entity),r=s.getCompoundChildShapeIndex(e.collision.shape);r===null?s.shape.addChildShape(i,e.collision.data.shape):s.shape.updateChildTransform(r,i,!0),Ammo.destroy(i)}}_removeCompoundChild(e,t){if(e.shape.getNumChildShapes()!==0)if(e.shape.removeChildShape)e.shape.removeChildShape(t);else{const s=e.getCompoundChildShapeIndex(t);s!==null&&e.shape.removeChildShapeByIndex(s)}}onTransformChanged(e,t,s,i){this.implementations[e.data.type].updateTransform(e,t,s,i)}changeType(e,t,s){this.implementations[t].beforeRemove(e.entity,e),this.implementations[t].remove(e.entity,e.data),this._createImplementation(s).reset(e,e.data)}recreatePhysicalShapes(e){this.implementations[e.data.type].recreatePhysicalShapes(e)}_calculateNodeRelativeTransform(e,t){if(e===t){const s=e.getWorldTransform().getScale();i_.setScale(s.x,s.y,s.z)}else this._calculateNodeRelativeTransform(e.parent,t),i_.mul(e.getLocalTransform())}_getNodeScaling(e){const s=e.getWorldTransform().getScale();return new Ammo.btVector3(s.x,s.y,s.z)}_getNodeTransform(e,t){let s,i;t?(this._calculateNodeRelativeTransform(e,t),s=vY,i=Yo,i_.getTranslation(s),i.setFromMat4(i_)):(s=e.getPosition(),i=e.getRotation());const r=new Ammo.btQuaternion,a=new Ammo.btTransform;a.setIdentity();const o=a.getOrigin(),h=e.collision;if(h&&h._hasOffset){const u=h.data.linearOffset,f=h.data.angularOffset,m=SY;Yo.copy(i).transformVector(u,m),m.add(s),Yo.copy(i).mul(f),o.setValue(m.x,m.y,m.z),r.setValue(Yo.x,Yo.y,Yo.z,Yo.w)}else o.setValue(s.x,s.y,s.z),r.setValue(i.x,i.y,i.z,i.w);return a.setRotation(r),Ammo.destroy(r),a}destroy(){for(const e in this._triMeshCache)Ammo.destroy(this._triMeshCache[e]);this._triMeshCache=null,super.destroy()}constructor(e){super(e),this.id="collision",this.ComponentType=Jh,this.DataType=mY,this.schema=yY,this.implementations={},this._triMeshCache={},this.on("beforeremove",this.onBeforeRemove,this),this.on("remove",this.onRemove,this)}}const r_=new ue,PY=new ks;class RY{destroy(){this.setMaterial(null),this._element.removeModelFromLayers(this.model),this.model.destroy(),this.model=null,this.node=null,this.mesh=null,this.meshInstance?.destroy(),this.meshInstance=null,this.unmaskMeshInstance?.destroy(),this.unmaskMeshInstance=null,this._entity=null,this._element=null}setMesh(e){this.meshInstance&&(this.mesh=e,this.meshInstance.mesh=e,this.meshInstance.visible=!!e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.mesh=e),this.forceUpdateAabb())}setMask(e){if(this.meshInstance){if(this._entity.enabled&&this._element.enabled&&this._element.removeModelFromLayers(this.model),e){this.unmaskMeshInstance=new lt(this.mesh,this.meshInstance.material,this.node),this.unmaskMeshInstance.name=`Unmask: ${this._entity.name}`,this.unmaskMeshInstance.castShadow=!1,this.unmaskMeshInstance.receiveShadow=!1,this.unmaskMeshInstance.pick=!1,this.model.meshInstances.push(this.unmaskMeshInstance);for(const t in this.meshInstance.parameters)this.unmaskMeshInstance.setParameter(t,this.meshInstance.parameters[t].data)}else{const t=this.model.meshInstances.indexOf(this.unmaskMeshInstance);t>=0&&this.model.meshInstances.splice(t,1)}this._entity.enabled&&this._element.enabled&&this._element.addModelToLayers(this.model),e||(this.unmaskMeshInstance?.destroy(),this.unmaskMeshInstance=null)}}setMaterial(e){this.meshInstance&&(this.meshInstance.material=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.material=e))}setParameter(e,t){this.meshInstance&&(this.meshInstance.setParameter(e,t),this.unmaskMeshInstance&&this.unmaskMeshInstance.setParameter(e,t))}deleteParameter(e){this.meshInstance&&(this.meshInstance.deleteParameter(e),this.unmaskMeshInstance&&this.unmaskMeshInstance.deleteParameter(e))}setUnmaskDrawOrder(){if(!this.meshInstance)return;const e=function(t){let s;const i=t.children,r=i.length;if(r){for(let o=0;o<r;o++)i[o].element&&(s=i[o]);if(!s)return null;const a=e(s);return a||s}return null};if(this.unmaskMeshInstance){const t=e(this._entity);t&&t.element?this.unmaskMeshInstance.drawOrder=t.element.drawOrder+t.element.getMaskOffset():this.unmaskMeshInstance.drawOrder=this.meshInstance.drawOrder+this._element.getMaskOffset()}}setDrawOrder(e){this.meshInstance&&(this.meshInstance.drawOrder=e)}setCull(e){if(!this.meshInstance)return;const t=this._element;let s=null;e&&t._isScreenSpace()&&(s=function(i){return t.isVisibleForCamera(i)}),this.meshInstance.cull=e,this.meshInstance.isVisibleFunc=s,this.unmaskMeshInstance&&(this.unmaskMeshInstance.cull=e,this.unmaskMeshInstance.isVisibleFunc=s)}setScreenSpace(e){this.meshInstance&&(this.meshInstance.screenSpace=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.screenSpace=e))}setLayer(e){this.meshInstance&&(this.meshInstance.layer=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance.layer=e))}forceUpdateAabb(e){this.meshInstance&&(this.meshInstance._aabbVer=-1,this.unmaskMeshInstance&&(this.unmaskMeshInstance._aabbVer=-1))}setAabbFunc(e){this.meshInstance&&(this.meshInstance._updateAabbFunc=e,this.unmaskMeshInstance&&(this.unmaskMeshInstance._updateAabbFunc=e))}constructor(e,t,s){this._entity=e,this._element=e.element,this.model=new rn,this.node=new Dt,this.model.graph=this.node,this.mesh=t,this.meshInstance=new lt(this.mesh,s,this.node),this.meshInstance.name=`ImageElement: ${e.name}`,this.meshInstance.castShadow=!1,this.meshInstance.receiveShadow=!1,this._meshDirty=!1,this.model.meshInstances.push(this.meshInstance),this._entity.addChild(this.model.graph),this.model._entity=this._entity,this.unmaskMeshInstance=null}}class MY{destroy(){this.textureAsset=null,this.spriteAsset=null,this.materialAsset=null,this._renderable.setMesh(this._defaultMesh),this._renderable.destroy(),this._defaultMesh=null,this._element.off("resize",this._onParentResizeOrPivotChange,this),this._element.off("set:pivot",this._onParentResizeOrPivotChange,this),this._element.off("screen:set:screenspace",this._onScreenSpaceChange,this),this._element.off("set:screen",this._onScreenChange,this),this._element.off("set:draworder",this._onDrawOrderChange,this),this._element.off("screen:set:resolution",this._onResolutionChange,this)}_onResolutionChange(e){}_onParentResizeOrPivotChange(){this._renderable.mesh&&this._updateMesh(this._renderable.mesh)}_onScreenSpaceChange(e){this._updateMaterial(e)}_onScreenChange(e,t){e?this._updateMaterial(e.screen.screenSpace):this._updateMaterial(!1)}_onDrawOrderChange(e){this._renderable.setDrawOrder(e),this.mask&&this._element.screen&&this._element.screen.screen.once("syncdraworder",function(){this._renderable.setUnmaskDrawOrder()},this)}_hasUserMaterial(){return!!this._materialAsset||!!this._material&&this._system.defaultImageMaterials.indexOf(this._material)===-1}_use9Slicing(){return this.sprite&&(this.sprite.renderMode===hs||this.sprite.renderMode===us)}_updateMaterial(e){const t=!!this._mask,s=!!(this.sprite&&this.sprite.renderMode===hs),i=!!(this.sprite&&this.sprite.renderMode===us);this._hasUserMaterial()||(this._material=this._system.getImageElementMaterial(e,t,s,i)),this._renderable&&(this._renderable.setCull(!this._element._isScreenSpace()||this._element._isScreenCulled()),this._renderable.setMaterial(this._material),this._renderable.setScreenSpace(e),this._renderable.setLayer(e?zk:y2))}_createMesh(){const e=this._element,t=e.calculatedWidth,s=e.calculatedHeight,i=this._rect,r=this._system.app.graphicsDevice,a=new Float32Array([t,0,0,0,0,1,i.x+i.z,1-i.y,t,s,0,0,0,1,i.x+i.z,1-(i.y+i.w),0,0,0,0,0,1,i.x,1-i.y,0,s,0,0,0,1,i.x,1-(i.y+i.w)]),o=PY.get(r,()=>new Ti(r,[{semantic:He,components:3,type:ct},{semantic:si,components:3,type:ct},{semantic:Zi,components:2,type:ct}])),h=new Yr(r,o,4,{data:a.buffer}),u=new Ct(r);return u.vertexBuffer=h,u.primitive[0].type=zr,u.primitive[0].base=0,u.primitive[0].count=4,u.primitive[0].indexed=!1,u.aabb.setMinMax(D.ZERO,new D(t,s,0)),this._updateMesh(u),u}_updateMesh(e){const t=this._element;let s=t.calculatedWidth,i=t.calculatedHeight;if(t.fitMode!==N_&&this._targetAspectRatio>0){const a=t.calculatedWidth/t.calculatedHeight;t.fitMode===hY&&a>this._targetAspectRatio||t.fitMode===uY&&a<this._targetAspectRatio?s=t.calculatedHeight*this._targetAspectRatio:i=t.calculatedWidth/this._targetAspectRatio}const r=t._isScreenSpace();if(this._updateMaterial(r),this._renderable&&this._renderable.forceUpdateAabb(),this.sprite&&(this.sprite.renderMode===hs||this.sprite.renderMode===us)){const a=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]],o=2/a.rect.z,h=2/a.rect.w;this._innerOffset.set(a.border.x*o,a.border.y*h,a.border.z*o,a.border.w*h);const u=this.sprite.atlas.texture;this._atlasRect.set(a.rect.x/u.width,a.rect.y/u.height,a.rect.z/u.width,a.rect.w/u.height);const f=this._pixelsPerUnit!==null?this._pixelsPerUnit:this.sprite.pixelsPerUnit,m=a.rect.z/f,_=a.rect.w/f;this._outerScale.set(Math.max(s,this._innerOffset.x*m),Math.max(i,this._innerOffset.y*_));let g=m,S=_;this._outerScale.x/=m,this._outerScale.y/=_,g*=J.clamp(s/(this._innerOffset.x*m),1e-4,1),S*=J.clamp(i/(this._innerOffset.y*_),1e-4,1),this._renderable&&(this._innerOffsetUniform[0]=this._innerOffset.x,this._innerOffsetUniform[1]=this._innerOffset.y,this._innerOffsetUniform[2]=this._innerOffset.z,this._innerOffsetUniform[3]=this._innerOffset.w,this._renderable.setParameter("innerOffset",this._innerOffsetUniform),this._atlasRectUniform[0]=this._atlasRect.x,this._atlasRectUniform[1]=this._atlasRect.y,this._atlasRectUniform[2]=this._atlasRect.z,this._atlasRectUniform[3]=this._atlasRect.w,this._renderable.setParameter("atlasRect",this._atlasRectUniform),this._outerScaleUniform[0]=this._outerScale.x,this._outerScaleUniform[1]=this._outerScale.y,this._renderable.setParameter("outerScale",this._outerScaleUniform),this._renderable.setAabbFunc(this._updateAabbFunc),this._renderable.node.setLocalScale(g,S,1),this._renderable.node.setLocalPosition((.5-t.pivot.x)*s,(.5-t.pivot.y)*i,0))}else{const a=e.vertexBuffer,o=new Float32Array(a.lock()),h=t.pivot.x,u=t.pivot.y;o[0]=s-h*s,o[1]=0-u*i,o[8]=s-h*s,o[9]=i-u*i,o[16]=0-h*s,o[17]=0-u*i,o[24]=0-h*s,o[25]=i-u*i;let f=1,m=1,_=this._rect;if(this._sprite&&this._sprite.frameKeys[this._spriteFrame]&&this._sprite.atlas){const x=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];x&&(_=x.rect,f=this._sprite.atlas.texture.width,m=this._sprite.atlas.texture.height)}o[6]=(_.x+_.z)/f,o[7]=1-_.y/m,o[14]=(_.x+_.z)/f,o[15]=1-(_.y+_.w)/m,o[22]=_.x/f,o[23]=1-_.y/m,o[30]=_.x/f,o[31]=1-(_.y+_.w)/m,a.unlock();const g=new D(0-h*s,0-u*i,0),S=new D(s-h*s,i-u*i,0);e.aabb.setMinMax(g,S),this._renderable&&(this._renderable.node.setLocalScale(1,1,1),this._renderable.node.setLocalPosition(0,0,0),this._renderable.setAabbFunc(null))}this._meshDirty=!1}_updateSprite(){let e=!1,t=null;if(this._targetAspectRatio=-1,this._sprite&&this._sprite.atlas){t=this._sprite.meshes[this.spriteFrame],e=this._sprite.renderMode===hs||this._sprite.renderMode===us;const s=this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];s?.rect.w>0&&(this._targetAspectRatio=s.rect.z/s.rect.w)}this.mesh=e?t:this._defaultMesh,this.refreshMesh()}refreshMesh(){this.mesh&&(this._element._beingInitialized?this._meshDirty=!0:this._updateMesh(this.mesh))}_updateAabb(e){return e.center.set(0,0,0),e.halfExtents.set(this._outerScale.x*.5,this._outerScale.y*.5,.001),e.setFromTransformedAabb(e,this._renderable.node.getWorldTransform()),e}_toggleMask(){this._element._dirtifyMask();const e=this._element._isScreenSpace();this._updateMaterial(e),this._renderable.setMask(!!this._mask)}_onMaterialLoad(e){this.material=e.resource}_onMaterialAdded(e){this._system.app.assets.off(`add:${e.id}`,this._onMaterialAdded,this),this._materialAsset===e.id&&this._bindMaterialAsset(e)}_bindMaterialAsset(e){this._entity.enabled&&(e.on("load",this._onMaterialLoad,this),e.on("change",this._onMaterialChange,this),e.on("remove",this._onMaterialRemove,this),e.resource?this._onMaterialLoad(e):this._system.app.assets.load(e))}_unbindMaterialAsset(e){e.off("load",this._onMaterialLoad,this),e.off("change",this._onMaterialChange,this),e.off("remove",this._onMaterialRemove,this)}_onMaterialChange(){}_onMaterialRemove(){}_onTextureAdded(e){this._system.app.assets.off(`add:${e.id}`,this._onTextureAdded,this),this._textureAsset===e.id&&this._bindTextureAsset(e)}_bindTextureAsset(e){this._entity.enabled&&(e.on("load",this._onTextureLoad,this),e.on("change",this._onTextureChange,this),e.on("remove",this._onTextureRemove,this),e.resource?this._onTextureLoad(e):this._system.app.assets.load(e))}_unbindTextureAsset(e){e.off("load",this._onTextureLoad,this),e.off("change",this._onTextureChange,this),e.off("remove",this._onTextureRemove,this)}_onTextureLoad(e){this.texture=e.resource}_onTextureChange(e){}_onTextureRemove(e){}_onSpriteAssetAdded(e){this._system.app.assets.off(`add:${e.id}`,this._onSpriteAssetAdded,this),this._spriteAsset===e.id&&this._bindSpriteAsset(e)}_bindSpriteAsset(e){this._entity.enabled&&(e.on("load",this._onSpriteAssetLoad,this),e.on("change",this._onSpriteAssetChange,this),e.on("remove",this._onSpriteAssetRemove,this),e.resource?this._onSpriteAssetLoad(e):this._system.app.assets.load(e))}_unbindSpriteAsset(e){e.off("load",this._onSpriteAssetLoad,this),e.off("change",this._onSpriteAssetChange,this),e.off("remove",this._onSpriteAssetRemove,this),e.data.textureAtlasAsset&&this._system.app.assets.off(`load:${e.data.textureAtlasAsset}`,this._onTextureAtlasLoad,this)}_onSpriteAssetLoad(e){if(!e||!e.resource)this.sprite=null;else if(e.resource.atlas)this.sprite=e.resource;else{const t=e.data.textureAtlasAsset;if(t){const s=this._system.app.assets;s.off(`load:${t}`,this._onTextureAtlasLoad,this),s.once(`load:${t}`,this._onTextureAtlasLoad,this)}}}_onSpriteAssetChange(e){this._onSpriteAssetLoad(e)}_onSpriteAssetRemove(e){}_bindSprite(e){this._evtSetMeshes=e.on("set:meshes",this._onSpriteMeshesChange,this),e.on("set:pixelsPerUnit",this._onSpritePpuChange,this),e.on("set:atlas",this._onAtlasTextureChange,this),e.atlas&&e.atlas.on("set:texture",this._onAtlasTextureChange,this)}_unbindSprite(e){this._evtSetMeshes?.off(),this._evtSetMeshes=null,e.off("set:pixelsPerUnit",this._onSpritePpuChange,this),e.off("set:atlas",this._onAtlasTextureChange,this),e.atlas&&e.atlas.off("set:texture",this._onAtlasTextureChange,this)}_onSpriteMeshesChange(){this._sprite&&(this._spriteFrame=J.clamp(this._spriteFrame,0,this._sprite.frameKeys.length-1)),this._updateSprite()}_onSpritePpuChange(){this.sprite.renderMode!==Nr&&this._pixelsPerUnit===null&&this._updateSprite()}_onAtlasTextureChange(){this.sprite&&this.sprite.atlas&&this.sprite.atlas.texture?(this._renderable.setParameter("texture_emissiveMap",this._sprite.atlas.texture),this._renderable.setParameter("texture_opacityMap",this._sprite.atlas.texture)):(this._renderable.deleteParameter("texture_emissiveMap"),this._renderable.deleteParameter("texture_opacityMap"))}_onTextureAtlasLoad(e){const t=this._spriteAsset;t instanceof Ee?this._onSpriteAssetLoad(t):this._onSpriteAssetLoad(this._system.app.assets.get(t))}onEnable(){if(this._materialAsset){const e=this._system.app.assets.get(this._materialAsset);e&&e.resource!==this._material&&this._bindMaterialAsset(e)}if(this._textureAsset){const e=this._system.app.assets.get(this._textureAsset);e&&e.resource!==this._texture&&this._bindTextureAsset(e)}if(this._spriteAsset){const e=this._system.app.assets.get(this._spriteAsset);e&&e.resource!==this._sprite&&this._bindSpriteAsset(e)}this._element.addModelToLayers(this._renderable.model)}onDisable(){this._element.removeModelFromLayers(this._renderable.model)}_setStencil(e){this._renderable.meshInstance.stencilFront=e,this._renderable.meshInstance.stencilBack=e;let t=0;if(this._element.maskedBy&&(t=this._element.maskedBy.element._image._maskRef),this._renderable.unmaskMeshInstance){const s=new Xi({ref:t+1,func:q_,zpass:kB});this._renderable.unmaskMeshInstance.stencilFront=s,this._renderable.unmaskMeshInstance.stencilBack=s}}_updateRenderableEmissive(){r_.linear(this._color),this._colorUniform[0]=r_.r,this._colorUniform[1]=r_.g,this._colorUniform[2]=r_.b,this._renderable.setParameter("material_emissive",this._colorUniform)}set color(e){const{r:t,g:s,b:i}=e;(this._color.r!==t||this._color.g!==s||this._color.b!==i)&&(this._color.r=t,this._color.g=s,this._color.b=i,this._updateRenderableEmissive()),this._element&&this._element.fire("set:color",this._color)}get color(){return this._color}set opacity(e){e!==this._color.a&&(this._color.a=e,this._renderable.setParameter("material_opacity",e)),this._element&&this._element.fire("set:opacity",e)}get opacity(){return this._color.a}set rect(e){let t,s,i,r;e instanceof me?(t=e.x,s=e.y,i=e.z,r=e.w):(t=e[0],s=e[1],i=e[2],r=e[3]),!(t===this._rect.x&&s===this._rect.y&&i===this._rect.z&&r===this._rect.w)&&(this._rect.set(t,s,i,r),this._renderable.mesh&&(this._element._beingInitialized?this._meshDirty=!0:this._updateMesh(this._renderable.mesh)))}get rect(){return this._rect}_removeMaterialAssetEvents(){if(this._materialAsset){const e=this._system.app.assets;e.off(`add:${this._materialAsset}`,this._onMaterialAdded,this);const t=e.get(this._materialAsset);t&&(t.off("load",this._onMaterialLoad,this),t.off("change",this._onMaterialChange,this),t.off("remove",this._onMaterialRemove,this))}}set material(e){if(this._material!==e){if(!e){const t=this._element._isScreenSpace();this.mask?e=t?this._system.defaultScreenSpaceImageMaskMaterial:this._system.defaultImageMaskMaterial:e=t?this._system.defaultScreenSpaceImageMaterial:this._system.defaultImageMaterial}if(this._material=e,this._materialAsset){const t=this._system.app.assets.get(this._materialAsset);(!t||t.resource!==e)&&(this._removeMaterialAssetEvents(),this._materialAsset=null)}e&&(this._renderable.setMaterial(e),this._hasUserMaterial()?(this._renderable.deleteParameter("material_opacity"),this._renderable.deleteParameter("material_emissive")):(this._updateRenderableEmissive(),this._renderable.setParameter("material_opacity",this._color.a)))}}get material(){return this._material}set materialAsset(e){const t=this._system.app.assets;let s=e;if(e instanceof Ee&&(s=e.id),this._materialAsset!==s)if(this._removeMaterialAssetEvents(),this._materialAsset=s,this._materialAsset){const i=t.get(this._materialAsset);i?this._bindMaterialAsset(i):(this._materialAsset=null,this.material=null,this._materialAsset=s,t.on(`add:${this._materialAsset}`,this._onMaterialAdded,this))}else this._materialAsset=null,this.material=null,this._materialAsset=s}get materialAsset(){return this._materialAsset}set texture(e){if(this._texture!==e){if(this._textureAsset){const t=this._system.app.assets.get(this._textureAsset);t&&t.resource!==e&&(this.textureAsset=null)}if(this._texture=e,e){this._spriteAsset&&(this.spriteAsset=null),this._renderable.setParameter("texture_emissiveMap",this._texture),this._renderable.setParameter("texture_opacityMap",this._texture),this._updateRenderableEmissive(),this._renderable.setParameter("material_opacity",this._color.a);const t=this._texture.width/this._texture.height;t!==this._targetAspectRatio&&(this._targetAspectRatio=t,this._element.fitMode!==N_&&this.refreshMesh())}else this._renderable.deleteParameter("texture_emissiveMap"),this._renderable.deleteParameter("texture_opacityMap"),this._targetAspectRatio=-1,this._element.fitMode!==N_&&this.refreshMesh()}}get texture(){return this._texture}set textureAsset(e){const t=this._system.app.assets;let s=e;if(e instanceof Ee&&(s=e.id),this._textureAsset!==s){if(this._textureAsset){t.off(`add:${this._textureAsset}`,this._onTextureAdded,this);const i=t.get(this._textureAsset);i&&(i.off("load",this._onTextureLoad,this),i.off("change",this._onTextureChange,this),i.off("remove",this._onTextureRemove,this))}if(this._textureAsset=s,this._textureAsset){const i=t.get(this._textureAsset);i?this._bindTextureAsset(i):(this.texture=null,t.on(`add:${this._textureAsset}`,this._onTextureAdded,this))}else this.texture=null}}get textureAsset(){return this._textureAsset}set spriteAsset(e){const t=this._system.app.assets;let s=e;if(e instanceof Ee&&(s=e.id),this._spriteAsset!==s){if(this._spriteAsset){t.off(`add:${this._spriteAsset}`,this._onSpriteAssetAdded,this);const i=t.get(this._spriteAsset);i&&this._unbindSpriteAsset(i)}if(this._spriteAsset=s,this._spriteAsset){const i=t.get(this._spriteAsset);i?this._bindSpriteAsset(i):(this.sprite=null,t.on(`add:${this._spriteAsset}`,this._onSpriteAssetAdded,this))}else this.sprite=null}this._element&&this._element.fire("set:spriteAsset",s)}get spriteAsset(){return this._spriteAsset}set sprite(e){if(this._sprite!==e){if(this._sprite&&this._unbindSprite(this._sprite),this._spriteAsset){const t=this._system.app.assets.get(this._spriteAsset);t&&t.resource!==e&&(this.spriteAsset=null)}this._sprite=e,this._sprite&&(this._bindSprite(this._sprite),this._textureAsset&&(this.textureAsset=null)),this._sprite&&this._sprite.atlas&&this._sprite.atlas.texture?(this._renderable.setParameter("texture_emissiveMap",this._sprite.atlas.texture),this._renderable.setParameter("texture_opacityMap",this._sprite.atlas.texture)):(this._renderable.deleteParameter("texture_emissiveMap"),this._renderable.deleteParameter("texture_opacityMap")),this._sprite&&(this._spriteFrame=J.clamp(this._spriteFrame,0,this._sprite.frameKeys.length-1)),this._updateSprite()}}get sprite(){return this._sprite}set spriteFrame(e){const t=this._spriteFrame;this._sprite?this._spriteFrame=J.clamp(e,0,this._sprite.frameKeys.length-1):this._spriteFrame=e,this._spriteFrame!==t&&this._updateSprite(),this._element&&this._element.fire("set:spriteFrame",e)}get spriteFrame(){return this._spriteFrame}set mesh(e){this._renderable.setMesh(e),this._defaultMesh===e?this._renderable.setAabbFunc(null):this._renderable.setAabbFunc(this._updateAabbFunc)}get mesh(){return this._renderable.mesh}set mask(e){this._mask!==e&&(this._mask=e,this._toggleMask())}get mask(){return this._mask}set pixelsPerUnit(e){this._pixelsPerUnit!==e&&(this._pixelsPerUnit=e,this._sprite&&(this._sprite.renderMode===hs||this._sprite.renderMode===us)&&this._updateSprite())}get pixelsPerUnit(){return this._pixelsPerUnit}get aabb(){return this._renderable.meshInstance?this._renderable.meshInstance.aabb:null}constructor(e){this._evtSetMeshes=null,this._element=e,this._entity=e.entity,this._system=e.system,this._textureAsset=null,this._texture=null,this._materialAsset=null,this._material=null,this._spriteAsset=null,this._sprite=null,this._spriteFrame=0,this._pixelsPerUnit=null,this._targetAspectRatio=-1,this._rect=new me(0,0,1,1),this._mask=!1,this._maskRef=0,this._outerScale=new ne,this._outerScaleUniform=new Float32Array(2),this._innerOffset=new me,this._innerOffsetUniform=new Float32Array(4),this._atlasRect=new me,this._atlasRectUniform=new Float32Array(4),this._defaultMesh=this._createMesh(),this._renderable=new RY(this._entity,this._defaultMesh,this._material),this._color=new ue(1,1,1,1),this._colorUniform=new Float32Array([1,1,1]),this._updateRenderableEmissive(),this._renderable.setParameter("material_opacity",1),this._updateAabbFunc=this._updateAabb.bind(this),this._onScreenChange(this._element.screen),this._element.on("resize",this._onParentResizeOrPivotChange,this),this._element.on("set:pivot",this._onParentResizeOrPivotChange,this),this._element.on("screen:set:screenspace",this._onScreenSpaceChange,this),this._element.on("set:screen",this._onScreenChange,this),this._element.on("set:draworder",this._onDrawOrderChange,this),this._element.on("screen:set:resolution",this._onResolutionChange,this),!e._beingInitialized&&e.enabled&&e.entity.enabled&&this.onEnable()}}class LY extends Pe{set defaultAsset(e){const t=e instanceof Ee?e.id:e;this._defaultAsset!==t&&(this._defaultAsset&&this._unbindDefaultAsset(),this._defaultAsset=t,this._defaultAsset&&this._bindDefaultAsset(),this._onSetLocale(this._app.i18n.locale))}get defaultAsset(){return this._defaultAsset}set localizedAsset(e){const t=e instanceof Ee?e.id:e;this._localizedAsset!==t&&(this._localizedAsset&&(this._app.assets.off(`add:${this._localizedAsset}`,this._onLocalizedAssetAdd,this),this._unbindLocalizedAsset()),this._localizedAsset=t,this._localizedAsset&&(this._app.assets.get(this._localizedAsset)?this._bindLocalizedAsset():this._app.assets.once(`add:${this._localizedAsset}`,this._onLocalizedAssetAdd,this)))}get localizedAsset(){return this._localizedAsset}set autoLoad(e){this._autoLoad!==e&&(this._autoLoad=e,this._autoLoad&&this._localizedAsset&&(this._unbindLocalizedAsset(),this._bindLocalizedAsset()))}get autoLoad(){return this._autoLoad}set disableLocalization(e){this._disableLocalization!==e&&(this._disableLocalization=e,this._onSetLocale(this._app.i18n.locale))}get disableLocalization(){return this._disableLocalization}_bindDefaultAsset(){const e=this._app.assets.get(this._defaultAsset);e?this._onDefaultAssetAdd(e):this._app.assets.once(`add:${this._defaultAsset}`,this._onDefaultAssetAdd,this)}_unbindDefaultAsset(){if(!this._defaultAsset)return;this._app.assets.off(`add:${this._defaultAsset}`,this._onDefaultAssetAdd,this);const e=this._app.assets.get(this._defaultAsset);e&&(e.off("add:localized",this._onLocaleAdd,this),e.off("remove:localized",this._onLocaleRemove,this),e.off("remove",this._onDefaultAssetRemove,this))}_onDefaultAssetAdd(e){this._defaultAsset===e.id&&(e.on("add:localized",this._onLocaleAdd,this),e.on("remove:localized",this._onLocaleRemove,this),e.once("remove",this._onDefaultAssetRemove,this))}_onDefaultAssetRemove(e){this._defaultAsset===e.id&&(e.off("add:localized",this._onLocaleAdd,this),e.off("remove:localized",this._onLocaleAdd,this),this._app.assets.once(`add:${this._defaultAsset}`,this._onDefaultAssetAdd,this))}_bindLocalizedAsset(){if(!this._autoLoad)return;const e=this._app.assets.get(this._localizedAsset);e&&(e.on("load",this._onLocalizedAssetLoad,this),e.on("change",this._onLocalizedAssetChange,this),e.on("remove",this._onLocalizedAssetRemove,this),e.resource?this._onLocalizedAssetLoad(e):this._app.assets.load(e))}_unbindLocalizedAsset(){const e=this._app.assets.get(this._localizedAsset);e&&(e.off("load",this._onLocalizedAssetLoad,this),e.off("change",this._onLocalizedAssetChange,this),e.off("remove",this._onLocalizedAssetRemove,this))}_onLocalizedAssetAdd(e){this._localizedAsset===e.id&&this._bindLocalizedAsset()}_onLocalizedAssetLoad(e){this.fire("load",e)}_onLocalizedAssetChange(e,t,s,i){this.fire("change",e,t,s,i)}_onLocalizedAssetRemove(e){this._localizedAsset===e.id&&(this.localizedAsset=this._defaultAsset),this.fire("remove",e)}_onLocaleAdd(e,t){this._app.i18n.locale===e&&this._onSetLocale(e)}_onLocaleRemove(e,t){this._app.i18n.locale===e&&this._onSetLocale(e)}_onSetLocale(e){if(!this._defaultAsset){this.localizedAsset=null;return}const t=this._app.assets.get(this._defaultAsset);if(!t||this._disableLocalization){this.localizedAsset=this._defaultAsset;return}const s=t.getLocalizedAssetId(e);if(!s){this.localizedAsset=this._defaultAsset;return}this.localizedAsset=s}destroy(){this.defaultAsset=null,this._app.i18n.off(ao.EVENT_CHANGE,this._onSetLocale,this),this.off()}constructor(e){super(),this._app=e,e.i18n.on(ao.EVENT_CHANGE,this._onSetLocale,this),this._autoLoad=!1,this._disableLocalization=!1,this._defaultAsset=null,this._localizedAsset=null}}const Tg="msdf",IY="bitmap",Id=0,ih=1,_T=2,FL=3,gT=4,vT=5,ST=6,yT=7,sR=8,OY=` 	
\r\v\f`,NY=/[\w|/]/;class FY{read(){let e=this._read();for(;e===sR;)e=this._read();return e!==Id&&e!==ih&&(this._last=this._index),e}buf(){return this._buf}last(){return this._last}error(){return this._error}debugPrint(){const e=["EOF","ERROR","TEXT","OPEN_BRACKET","CLOSE_BRACKET","EQUALS","STRING","IDENTIFIER","WHITESPACE"];let t=this.read(),s="";for(;s+=`${(s.length>0?`
`:"")+e[t]} '${this.buf().join("")}'`,!(t===Id||t===ih);)t=this.read();return s}_read(){return this._buf=[],this._eof()?Id:this._mode==="text"?this._text():this._tag()}_text(){for(;;)switch(this._cur){case null:return this._buf.length>0?_T:Id;case"[":return this._mode="tag",this._buf.length>0?_T:this._tag();case"\\":this._next(),this._cur==="["?this._store():this._output("\\");break;default:this._store();break}}_tag(){switch(this._cur){case null:return this._error="unexpected end of input reading tag",ih;case"[":return this._store(),FL;case"]":return this._store(),this._mode="text",gT;case"=":return this._store(),vT;case" ":case"	":case`
`:case"\r":case"\v":case"\f":return this._whitespace();case'"':return this._string();default:return this._isIdentifierSymbol(this._cur)?this._identifier():(this._error="unrecognized character",ih)}}_whitespace(){for(this._store();OY.indexOf(this._cur)!==-1;)this._store();return sR}_string(){for(this._next();;)switch(this._cur){case null:return this._error="unexpected end of input reading string",ih;case'"':return this._next(),ST;default:this._store();break}}_identifier(){for(this._store();this._cur!==null&&this._isIdentifierSymbol(this._cur);)this._store();return yT}_isIdentifierSymbol(e){return e.length===1&&e.match(NY)!==null}_eof(){return this._cur===null}_next(){return this._eof()||(this._index++,this._cur=this._index<this._symbols.length?this._symbols[this._index]:null),this._cur}_store(){return this._buf.push(this._cur),this._next()}_output(e){this._buf.push(e)}constructor(e){this._symbols=e,this._index=0,this._last=0,this._cur=this._symbols.length>0?this._symbols[0]:null,this._buf=[],this._mode="text",this._error=null}}class BY{parse(e,t){for(;;)switch(this._scanner.read()){case Id:return!0;case ih:return!1;case _T:Array.prototype.push.apply(e,this._scanner.buf());break;case FL:if(!this._parseTag(e,t))return!1;break;default:return!1}}error(){return`Error evaluating markup at #${this._scanner.last().toString()} (${this._scanner.error()||this._error})`}_parseTag(e,t){let s=this._scanner.read();if(s!==yT)return this._error="expected identifier",!1;const i=this._scanner.buf().join("");if(i[0]==="/"){for(let a=t.length-1;a>=0;--a)if(i===`/${t[a].name}`&&t[a].end===null)return t[a].end=e.length,s=this._scanner.read(),s!==gT?(this._error="expected close bracket",!1):!0;return this._error="failed to find matching tag",!1}const r={name:i,value:null,attributes:{},start:e.length,end:null};if(s=this._scanner.read(),s===vT){if(s=this._scanner.read(),s!==ST)return this._error="expected string",!1;r.value=this._scanner.buf().join(""),s=this._scanner.read()}for(;;){switch(s){case gT:return t.push(r),!0;case yT:{const a=this._scanner.buf().join("");if(s=this._scanner.read(),s!==vT)return this._error="expected equals",!1;if(s=this._scanner.read(),s!==ST)return this._error="expected string",!1;const o=this._scanner.buf().join("");r.attributes[a]=o;break}default:return this._error="expected close bracket or identifier",!1}s=this._scanner.read()}}constructor(e){this._scanner=new FY(e),this._error=null}}function BL(c,e){for(const t in e){if(!e.hasOwnProperty(t))continue;const s=e[t];s instanceof Object?(c.hasOwnProperty(t)||(c[t]={}),BL(c[t],e[t])):c[t]=s}}function UY(c){if(c.length===0)return null;const e={};for(let t=0;t<c.length;++t){const s=c[t],i={};i[s.name]={value:s.value,attributes:s.attributes},BL(e,i)}return e}function zY(c,e){if(c.length===0)return null;const t={};for(let f=0;f<c.length;++f){const m=c[f];t.hasOwnProperty(m.start)?t[m.start].open===null?t[m.start].open=[m]:t[m.start].open.push(m):t[m.start]={open:[m],close:null},t.hasOwnProperty(m.end)?t[m.end].close===null?t[m.end].close=[m]:t[m.end].close.push(m):t[m.end]={open:null,close:[m]}}let s=[];function i(f){s=s.filter(m=>f.find(_=>_===m)===void 0)}function r(f){for(let m=0;m<f.length;++m)s.push(f[m])}const a=Object.keys(t).sort((f,m)=>f-m),o=[];for(let f=0;f<a.length;++f){const m=t[a[f]];m.close!==null&&i(m.close),m.open!==null&&r(m.open),o.push({start:a[f],tags:UY(s)})}const h=[];let u=null;for(let f=0;f<o.length;++f){const m=o[f];for(;h.length<m.start;)h.push(u?u.tags:null);u=m}for(;h.length<e;)h.push(null);return h}function kY(c){const e=new BY(c),t=[],s=[];if(!e.parse(t,s))return console.warn(e.error()),{symbols:c,tags:null};const i=s.find(a=>a.end===null);if(i)return console.warn(`Markup error: found unclosed tag='${i.name}'`),{symbols:c,tags:null};const r=zY(s,t.length);return{symbols:t,tags:r}}class VY{static evaluate(e){return kY(e)}}class GY{constructor(){this.count=0,this.quad=0,this.lines={},this.positions=[],this.normals=[],this.uvs=[],this.colors=[],this.indices=[],this.outlines=[],this.shadows=[],this.meshInstance=null}}function HY(c,e){const t=new Ct(c);return t.setPositions(e.positions),t.setNormals(e.normals),t.setColors32(e.colors),t.setUvs(0,e.uvs),t.setIndices(e.indices),t.setVertexStream(jd,e.outlines,3,void 0,ct,!1),t.setVertexStream($d,e.shadows,3,void 0,ct,!1),t.update(),t}const iR=/^[\r\n]$/,WY=/^[ \t]$/,rR=/^[ \t\-]|\u200b$/,XY=/^[a-z0-9]$/i,aR=/^[\u1100-\u11ff]|[\u3000-\u9fff\ua960-\ua97f]|[\uac00-\ud7ff]$/,qY=/^[]$/,YY=["","","","","","","","","","","","",""],jY={width:0,height:0,xadvance:0,xoffset:0,yoffset:0},nR=new ue,$Y=new ne,vt=new ue;class KY{destroy(){this._setMaterial(null),this._model&&(this._element.removeModelFromLayers(this._model),this._model.destroy(),this._model=null),this._fontAsset.destroy(),this.font=null,this._element.off("resize",this._onParentResize,this),this._element.off("set:screen",this._onScreenChange,this),this._element.off("screen:set:screenspace",this._onScreenSpaceChange,this),this._element.off("set:draworder",this._onDrawOrderChange,this),this._element.off("set:pivot",this._onPivotChange,this),this._system.app.i18n.off(ao.EVENT_CHANGE,this._onLocaleSet,this),this._system.app.i18n.off("data:add",this._onLocalizationData,this),this._system.app.i18n.off("data:remove",this._onLocalizationData,this)}_onParentResize(e,t){this._noResize||this._font&&this._updateText()}_onScreenChange(e){e?this._updateMaterial(e.screen.screenSpace):this._updateMaterial(!1)}_onScreenSpaceChange(e){this._updateMaterial(e)}_onDrawOrderChange(e){if(this._drawOrder=e,this._model)for(let t=0,s=this._model.meshInstances.length;t<s;t++)this._model.meshInstances[t].drawOrder=e}_onPivotChange(e){this._font&&this._updateText()}_onLocaleSet(e){if(this._i18nKey){if(this.fontAsset){const t=this._system.app.assets.get(this.fontAsset);(!t||!t.resource||t.resource!==this._font)&&(this.font=null)}this._resetLocalizedText()}}_onLocalizationData(e,t){this._i18nKey&&t[this._i18nKey]&&this._resetLocalizedText()}_resetLocalizedText(){this._setText(this._system.app.i18n.getText(this._i18nKey))}_setText(e){if(this.unicodeConverter){const t=this._system.getUnicodeConverter();t?e=t(e):console.warn("Element created with unicodeConverter option but no unicodeConverter function registered")}this._text!==e&&(this._font&&this._updateText(e),this._text=e)}_updateText(e){let t;if(e===void 0&&(e=this._text),this._symbols=T_.getSymbols(e.normalize?e.normalize("NFC"):e),this._symbols.length===0&&(this._symbols=[" "]),this._enableMarkup){const m=VY.evaluate(this._symbols);this._symbols=m.symbols,t=m.tags||[]}if(this._rtlReorder){const m=this._system.app.systems.element.getRtlReorder();if(m){const _=m(this._symbols);this._rtl=_.rtl,this._symbols=_.mapping.map(function(g){return this._symbols[g]},this),t&&(t=_.mapping.map(g=>t[g]))}else console.warn("Element created with rtlReorder option but no rtlReorder function registered")}else this._rtl=!1;const s=(m,_)=>`${m.toString(!0).toLowerCase()}:${_.toFixed(2)}`,i=(m,_)=>`${m.toString(!0).toLowerCase()}:${_.x.toFixed(2)}:${_.y.toFixed(2)}`;if(t){const m={},_={},g={};this._colorPalette=[Math.round(this._color.r*255),Math.round(this._color.g*255),Math.round(this._color.b*255)],this._outlinePalette=[Math.round(this._outlineColor.r*255),Math.round(this._outlineColor.g*255),Math.round(this._outlineColor.b*255),Math.round(this._outlineColor.a*255),Math.round(this._outlineThickness*255)],this._shadowPalette=[Math.round(this._shadowColor.r*255),Math.round(this._shadowColor.g*255),Math.round(this._shadowColor.b*255),Math.round(this._shadowColor.a*255),Math.round(this._shadowOffset.x*127),Math.round(this._shadowOffset.y*127)],this._symbolColors=[],this._symbolOutlineParams=[],this._symbolShadowParams=[],m[this._color.toString(!1).toLowerCase()]=0,_[s(this._outlineColor,this._outlineThickness)]=0,g[i(this._shadowColor,this._shadowOffset)]=0;for(let S=0,x=this._symbols.length;S<x;++S){const T=t[S];let E=0;if(T&&T.color&&T.color.value){const w=T.color.value;if(w.length===7&&w[0]==="#"){const P=w.substring(1).toLowerCase();m.hasOwnProperty(P)?E=m[P]:/^[0-9a-f]{6}$/.test(P)&&(E=this._colorPalette.length/3,m[P]=E,this._colorPalette.push(parseInt(P.substring(0,2),16)),this._colorPalette.push(parseInt(P.substring(2,4),16)),this._colorPalette.push(parseInt(P.substring(4,6),16)))}}this._symbolColors.push(E);let b=0;if(T&&T.outline&&(T.outline.attributes.color||T.outline.attributes.thickness)){let w=T.outline.attributes.color?nR.fromString(T.outline.attributes.color):this._outlineColor,P=Number(T.outline.attributes.thickness);(Number.isNaN(w.r)||Number.isNaN(w.g)||Number.isNaN(w.b)||Number.isNaN(w.a))&&(w=this._outlineColor),Number.isNaN(P)&&(P=this._outlineThickness);const I=s(w,P);_.hasOwnProperty(I)?b=_[I]:(b=this._outlinePalette.length/5,_[I]=b,this._outlinePalette.push(Math.round(w.r*255),Math.round(w.g*255),Math.round(w.b*255),Math.round(w.a*255),Math.round(P*255)))}this._symbolOutlineParams.push(b);let C=0;if(T&&T.shadow&&(T.shadow.attributes.color||T.shadow.attributes.offset||T.shadow.attributes.offsetX||T.shadow.attributes.offsetY)){let w=T.shadow.attributes.color?nR.fromString(T.shadow.attributes.color):this._shadowColor;const P=Number(T.shadow.attributes.offset),I=Number(T.shadow.attributes.offsetX),M=Number(T.shadow.attributes.offsetY);(Number.isNaN(w.r)||Number.isNaN(w.g)||Number.isNaN(w.b)||Number.isNaN(w.a))&&(w=this._shadowColor);const R=$Y.set(Number.isNaN(I)?Number.isNaN(P)?this._shadowOffset.x:P:I,Number.isNaN(M)?Number.isNaN(P)?this._shadowOffset.y:P:M),L=i(w,R);g.hasOwnProperty(L)?C=g[L]:(C=this._shadowPalette.length/6,g[L]=C,this._shadowPalette.push(Math.round(w.r*255),Math.round(w.g*255),Math.round(w.b*255),Math.round(w.a*255),Math.round(R.x*127),Math.round(R.y*127)))}this._symbolShadowParams.push(C)}}else this._colorPalette=[],this._symbolColors=null,this._symbolOutlineParams=null,this._symbolShadowParams=null;this._updateMaterialEmissive(),this._updateMaterialOutline(),this._updateMaterialShadow();const r=this._calculateCharsPerTexture();let a=!1;const o=this._element,h=o._isScreenSpace(),u=o._isScreenCulled(),f=function(m){return o.isVisibleForCamera(m)};for(let m=0,_=this._meshInfo.length;m<_;m++){const g=r[m]||0,S=this._meshInfo[m];if(S.count!==g){if(a||(o.removeModelFromLayers(this._model),a=!0),S.count=g,S.positions.length=S.normals.length=g*3*4,S.indices.length=g*3*2,S.uvs.length=g*2*4,S.colors.length=g*4*4,S.outlines.length=g*4*3,S.shadows.length=g*4*3,S.meshInstance&&this._removeMeshInstance(S.meshInstance),g===0){S.meshInstance=null;continue}for(let E=0;E<g;E++)S.indices[E*3*2+0]=E*4,S.indices[E*3*2+1]=E*4+1,S.indices[E*3*2+2]=E*4+3,S.indices[E*3*2+3]=E*4+2,S.indices[E*3*2+4]=E*4+3,S.indices[E*3*2+5]=E*4+1,S.normals[E*4*3+0]=0,S.normals[E*4*3+1]=0,S.normals[E*4*3+2]=-1,S.normals[E*4*3+3]=0,S.normals[E*4*3+4]=0,S.normals[E*4*3+5]=-1,S.normals[E*4*3+6]=0,S.normals[E*4*3+7]=0,S.normals[E*4*3+8]=-1,S.normals[E*4*3+9]=0,S.normals[E*4*3+10]=0,S.normals[E*4*3+11]=-1;const x=HY(this._system.app.graphicsDevice,S),T=new lt(x,this._material,this._node);if(T.name=`Text Element: ${this._entity.name}`,T.castShadow=!1,T.receiveShadow=!1,T.cull=!h,T.screenSpace=h,T.drawOrder=this._drawOrder,u&&(T.cull=!0,T.isVisibleFunc=f),this._setTextureParams(T,this._font.textures[m]),T.setParameter("material_emissive",this._colorUniform),T.setParameter("material_opacity",this._color.a),T.setParameter("font_sdfIntensity",this._font.intensity),T.setParameter("font_pxrange",this._getPxRange(this._font)),T.setParameter("font_textureWidth",this._font.data.info.maps[m].width),T.setParameter("outline_color",this._outlineColorUniform),T.setParameter("outline_thickness",this._outlineThicknessScale*this._outlineThickness),T.setParameter("shadow_color",this._shadowColorUniform),this._symbolShadowParams)this._shadowOffsetUniform[0]=0,this._shadowOffsetUniform[1]=0;else{const E=-this._font.data.info.maps[m].width/this._font.data.info.maps[m].height;this._shadowOffsetUniform[0]=this._shadowOffsetScale*this._shadowOffset.x,this._shadowOffsetUniform[1]=E*this._shadowOffsetScale*this._shadowOffset.y}T.setParameter("shadow_offset",this._shadowOffsetUniform),S.meshInstance=T,this._model.meshInstances.push(T)}}this._element.maskedBy&&this._element._setMaskedBy(this._element.maskedBy),a&&this._element.enabled&&this._entity.enabled&&this._element.addModelToLayers(this._model),this._updateMeshes(),this._rangeStart=0,this._rangeEnd=this._symbols.length,this._updateRenderRange()}_removeMeshInstance(e){e.destroy();const t=this._model.meshInstances.indexOf(e);t!==-1&&this._model.meshInstances.splice(t,1)}_setMaterial(e){if(this._material=e,this._model)for(let t=0,s=this._model.meshInstances.length;t<s;t++){const i=this._model.meshInstances[t];i.material=e}}_updateMaterial(e){const t=this._element,s=t._isScreenCulled(),i=function(a){return t.isVisibleForCamera(a)},r=this._font&&this._font.type===Tg;if(this._material=this._system.getTextElementMaterial(e,r,this._enableMarkup),this._model)for(let a=0,o=this._model.meshInstances.length;a<o;a++){const h=this._model.meshInstances[a];h.cull=!e,h.material=this._material,h.screenSpace=e,s?(h.cull=!0,h.isVisibleFunc=i):h.isVisibleFunc=null}}_updateMaterialEmissive(){this._symbolColors?(this._colorUniform[0]=1,this._colorUniform[1]=1,this._colorUniform[2]=1):(vt.linear(this._color),this._colorUniform[0]=vt.r,this._colorUniform[1]=vt.g,this._colorUniform[2]=vt.b)}_updateMaterialOutline(){this._symbolOutlineParams?(this._outlineColorUniform[0]=0,this._outlineColorUniform[1]=0,this._outlineColorUniform[2]=0,this._outlineColorUniform[3]=1):(vt.linear(this._outlineColor),this._outlineColorUniform[0]=vt.r,this._outlineColorUniform[1]=vt.g,this._outlineColorUniform[2]=vt.b,this._outlineColorUniform[3]=vt.a)}_updateMaterialShadow(){this._symbolOutlineParams?(this._shadowColorUniform[0]=0,this._shadowColorUniform[1]=0,this._shadowColorUniform[2]=0,this._shadowColorUniform[3]=0):(vt.linear(this._shadowColor),this._shadowColorUniform[0]=vt.r,this._shadowColorUniform[1]=vt.g,this._shadowColorUniform[2]=vt.b,this._shadowColorUniform[3]=vt.a)}_isWordBoundary(e){return rR.test(e)}_isValidNextChar(e){return e!==null&&!qY.test(e)}_isNextCJKBoundary(e,t){return aR.test(e)&&(rR.test(t)||XY.test(t))}_isNextCJKWholeWord(e){return aR.test(e)}_updateMeshes(){const e=this._font.data,t=this,s=Math.min(this._minFontSize,this._maxFontSize),i=this._maxFontSize,r=this._shouldAutoFit();r&&(this._fontSize=this._maxFontSize);const a=32,o=this._symbols.length;let h=0,u=0,f=0,m=0,_=1,g=0,S=0,x=0,T=0,E=0,b=0;const C=Math.abs(this._element.anchor.x-this._element.anchor.z)>=1e-4;let w=this._element.calculatedWidth;(this.autoWidth&&!C||!this._wrapLines)&&(w=Number.POSITIVE_INFINITY);let P=0,I=0,M,R,L,B;function G(O,z,X){t._lineWidths.push(Math.abs(X));const Y=x>z?z+1:x,F=x>z?x+1:z,U=O.slice(Y,F);if(b){let K=U.length;for(;K--&&b>0;)iR.test(U[K])&&(U.splice(K,1),b--)}t._lineContents.push(U.join("")),h=0,u-=t._scaledLineHeight,_++,T=0,E=0,b=0,g=0,x=z}let H=!0;for(;H;){H=!1,r?this._scaledLineHeight=this._lineHeight*this._fontSize/(this._maxFontSize||1e-4):this._scaledLineHeight=this._lineHeight,this.width=0,this.height=0,this._lineWidths=[],this._lineContents=[],h=0,u=0,f=0,m=0,_=1,g=0,S=0,x=0,T=0,E=0,b=0;const O=this._fontSize/a;P=this._fontMinY*O,I=this._fontMaxY*O;for(let de=0;de<this._meshInfo.length;de++)this._meshInfo[de].quad=0,this._meshInfo[de].lines={};let z=255,X=255,Y=255,F=255+255*256,U=255+255*256,K=0,se=255+255*256,le=255+255*256,re=127+127*256;for(let de=0;de<o;de++){if(M=this._symbols[de],B=de+1>=o?null:this._symbols[de+1],iR.test(M)){b++,(!this._wrapLines||this._maxLines<0||_<this._maxLines)&&(G(this._symbols,de,m),S=de+1,x=de+1);continue}let Me=0,et=0,Qe=0,ls=1,xr,ms;if(R=e.chars[M],!R)if(YY.indexOf(M)!==-1)R=jY;else if(e.chars[" "])R=e.chars[" "];else for(const tt in e.chars){R=e.chars[tt];break}if(R){let tt=0;if(E>0){const yo=this._font.data.kerning;if(yo){const Kr=yo[T_.getCodePoint(this._symbols[de-1])||0];Kr&&(tt=Kr[T_.getCodePoint(this._symbols[de])||0]||0)}}xr=R.scale||1,ms=(R.width+R.height)/2,ls=O*ms/xr,Qe=(R.xadvance+tt)*O,Me=(R.xoffset-tt)*O,et=R.yoffset*O}else console.error(`Couldn't substitute missing character: '${M}'`);const $r=WY.test(M),vo=R&&R.map||0,Bv=-this._font.data.info.maps[vo].width/this._font.data.info.maps[vo].height,ve=this._meshInfo[vo],kl=h+this._spacing*Qe;if(kl>w&&E>0&&!$r&&(this._maxLines<0||_<this._maxLines))if(T===0)S=de,G(this._symbols,de,m);else{const tt=Math.max(de-S,0);if(this._meshInfo.length<=1)ve.lines[_-1]-=tt,ve.quad-=tt;else{const yo=S,Kr=de;for(let nu=yo;nu<Kr;nu++){const nm=this._symbols[nu],om=e.chars[nm],lm=this._meshInfo[om&&om.map||0];lm.lines[_-1]-=1,lm.quad-=1}}de-=tt+1,G(this._symbols,S,g);continue}L=ve.quad,ve.lines[_-1]=L;let ln=h-Me,So=ln+ls;const au=u-et,am=au+ls;if(this._rtl){const tt=ls-Me-this._spacing*Qe-Me;ln-=tt,So-=tt}ve.positions[L*4*3+0]=ln,ve.positions[L*4*3+1]=au,ve.positions[L*4*3+2]=f,ve.positions[L*4*3+3]=So,ve.positions[L*4*3+4]=au,ve.positions[L*4*3+5]=f,ve.positions[L*4*3+6]=So,ve.positions[L*4*3+7]=am,ve.positions[L*4*3+8]=f,ve.positions[L*4*3+9]=ln,ve.positions[L*4*3+10]=am,ve.positions[L*4*3+11]=f,this.width=Math.max(this.width,kl);let Wt;if(this._shouldAutoFitWidth()&&this.width>this._element.calculatedWidth&&(Wt=Math.floor(this._element.fontSize*this._element.calculatedWidth/(this.width||1e-4)),Wt=J.clamp(Wt,s,i),Wt!==this._element.fontSize)){this._fontSize=Wt,H=!0;break}if(this.height=Math.max(this.height,I-(u+P)),this._shouldAutoFitHeight()&&this.height>this._element.calculatedHeight&&(Wt=J.clamp(this._fontSize-1,s,i),Wt!==this._element.fontSize)){this._fontSize=Wt,H=!0;break}h+=this._spacing*Qe,$r||(m=h),(this._isWordBoundary(M)||this._isValidNextChar(B)&&(this._isNextCJKBoundary(M,B)||this._isNextCJKWholeWord(B)))&&(T++,g=m,S=de+1),E++;const Tr=this._getUv(M);if(ve.uvs[L*4*2+0]=Tr[0],ve.uvs[L*4*2+1]=1-Tr[1],ve.uvs[L*4*2+2]=Tr[2],ve.uvs[L*4*2+3]=1-Tr[1],ve.uvs[L*4*2+4]=Tr[2],ve.uvs[L*4*2+5]=1-Tr[3],ve.uvs[L*4*2+6]=Tr[0],ve.uvs[L*4*2+7]=1-Tr[3],this._symbolColors){const tt=this._symbolColors[de]*3;z=this._colorPalette[tt],X=this._colorPalette[tt+1],Y=this._colorPalette[tt+2]}if(ve.colors[L*4*4+0]=z,ve.colors[L*4*4+1]=X,ve.colors[L*4*4+2]=Y,ve.colors[L*4*4+3]=255,ve.colors[L*4*4+4]=z,ve.colors[L*4*4+5]=X,ve.colors[L*4*4+6]=Y,ve.colors[L*4*4+7]=255,ve.colors[L*4*4+8]=z,ve.colors[L*4*4+9]=X,ve.colors[L*4*4+10]=Y,ve.colors[L*4*4+11]=255,ve.colors[L*4*4+12]=z,ve.colors[L*4*4+13]=X,ve.colors[L*4*4+14]=Y,ve.colors[L*4*4+15]=255,this._symbolOutlineParams){const tt=this._symbolOutlineParams[de]*5;F=this._outlinePalette[tt]+this._outlinePalette[tt+1]*256,U=this._outlinePalette[tt+2]+this._outlinePalette[tt+3]*256,K=this._outlinePalette[tt+4]}if(ve.outlines[L*4*3+0]=F,ve.outlines[L*4*3+1]=U,ve.outlines[L*4*3+2]=K,ve.outlines[L*4*3+3]=F,ve.outlines[L*4*3+4]=U,ve.outlines[L*4*3+5]=K,ve.outlines[L*4*3+6]=F,ve.outlines[L*4*3+7]=U,ve.outlines[L*4*3+8]=K,ve.outlines[L*4*3+9]=F,ve.outlines[L*4*3+10]=U,ve.outlines[L*4*3+11]=K,this._symbolShadowParams){const tt=this._symbolShadowParams[de]*6;se=this._shadowPalette[tt]+this._shadowPalette[tt+1]*256,le=this._shadowPalette[tt+2]+this._shadowPalette[tt+3]*256,re=this._shadowPalette[tt+4]+127+Math.round(Bv*this._shadowPalette[tt+5]+127)*256}ve.shadows[L*4*3+0]=se,ve.shadows[L*4*3+1]=le,ve.shadows[L*4*3+2]=re,ve.shadows[L*4*3+3]=se,ve.shadows[L*4*3+4]=le,ve.shadows[L*4*3+5]=re,ve.shadows[L*4*3+6]=se,ve.shadows[L*4*3+7]=le,ve.shadows[L*4*3+8]=re,ve.shadows[L*4*3+9]=se,ve.shadows[L*4*3+10]=le,ve.shadows[L*4*3+11]=re,ve.quad++}H||x<o&&G(this._symbols,o,h)}this._noResize=!0,this.autoWidth=this._autoWidth,this.autoHeight=this._autoHeight,this._noResize=!1;const ee=this._element.pivot.x,j=this._element.pivot.y,ae=this._alignment.x,k=this._alignment.y;for(let O=0;O<this._meshInfo.length;O++){if(this._meshInfo[O].count===0)continue;let z=0;for(const U in this._meshInfo[O].lines){const K=this._meshInfo[O].lines[U],se=this._lineWidths[parseInt(U,10)],le=-ee*this._element.calculatedWidth+ae*(this._element.calculatedWidth-se)*(this._rtl?-1:1),re=(1-j)*this._element.calculatedHeight-I-(1-k)*(this._element.calculatedHeight-this.height);for(let de=z;de<=K;de++)this._meshInfo[O].positions[de*4*3]+=le,this._meshInfo[O].positions[de*4*3+3]+=le,this._meshInfo[O].positions[de*4*3+6]+=le,this._meshInfo[O].positions[de*4*3+9]+=le,this._meshInfo[O].positions[de*4*3+1]+=re,this._meshInfo[O].positions[de*4*3+4]+=re,this._meshInfo[O].positions[de*4*3+7]+=re,this._meshInfo[O].positions[de*4*3+10]+=re;if(this._rtl)for(let de=z;de<=K;de++){const ye=de*4*3;for(let Qe=0;Qe<4;++Qe)this._meshInfo[O].positions[ye+Qe*3]=this._element.calculatedWidth-this._meshInfo[O].positions[ye+Qe*3]+le*2;const Me=this._meshInfo[O].positions[ye+3],et=this._meshInfo[O].positions[ye+6];this._meshInfo[O].positions[ye+3]=this._meshInfo[O].positions[ye+0],this._meshInfo[O].positions[ye+6]=this._meshInfo[O].positions[ye+9],this._meshInfo[O].positions[ye+0]=Me,this._meshInfo[O].positions[ye+9]=et}z=K+1}const X=this._meshInfo[O].count*4,Y=this._meshInfo[O].quad*4,F=new zd(this._meshInfo[O].meshInstance.mesh.vertexBuffer);for(let U=0;U<X;U++)U>=Y?(F.element[He].set(0,0,0),F.element[Zi].set(0,0),F.element[Rs].set(0,0,0,0),F.element[jd].set(0,0,0,0),F.element[$d].set(0,0,0,0)):(F.element[He].set(this._meshInfo[O].positions[U*3+0],this._meshInfo[O].positions[U*3+1],this._meshInfo[O].positions[U*3+2]),F.element[Zi].set(this._meshInfo[O].uvs[U*2+0],this._meshInfo[O].uvs[U*2+1]),F.element[Rs].set(this._meshInfo[O].colors[U*4+0],this._meshInfo[O].colors[U*4+1],this._meshInfo[O].colors[U*4+2],this._meshInfo[O].colors[U*4+3]),F.element[jd].set(this._meshInfo[O].outlines[U*3+0],this._meshInfo[O].outlines[U*3+1],this._meshInfo[O].outlines[U*3+2]),F.element[$d].set(this._meshInfo[O].shadows[U*3+0],this._meshInfo[O].shadows[U*3+1],this._meshInfo[O].shadows[U*3+2])),F.next();F.end(),this._meshInfo[O].meshInstance.mesh.aabb.compute(this._meshInfo[O].positions),this._meshInfo[O].meshInstance._aabbVer=-1}this._aabbDirty=!0}_onFontRender(){this.font=this._font}_onFontLoad(e){this.font!==e.resource&&(this.font=e.resource)}_onFontChange(e,t,s,i){if(t==="data"){this._font.data=s;const r=this._font.data.info.maps.length;for(let a=0;a<r;a++){if(!this._meshInfo[a])continue;const o=this._meshInfo[a].meshInstance;o&&(o.setParameter("font_sdfIntensity",this._font.intensity),o.setParameter("font_pxrange",this._getPxRange(this._font)),o.setParameter("font_textureWidth",this._font.data.info.maps[a].width))}}}_onFontRemove(e){}_setTextureParams(e,t){this._font&&(this._font.type===Tg?(e.deleteParameter("texture_emissiveMap"),e.deleteParameter("texture_opacityMap"),e.setParameter("texture_msdfMap",t)):this._font.type===IY&&(e.deleteParameter("texture_msdfMap"),e.setParameter("texture_emissiveMap",t),e.setParameter("texture_opacityMap",t)))}_getPxRange(e){const t=Object.keys(this._font.data.chars);for(let s=0;s<t.length;s++){const i=this._font.data.chars[t[s]];if(i.range)return(i.scale||1)*i.range}return 2}_getUv(e){const t=this._font.data;if(!t.chars[e])return t.chars[" "]?this._getUv(" "):[0,0,0,0];const s=t.chars[e].map,i=t.info.maps[s].width,r=t.info.maps[s].height,a=t.chars[e].x,o=t.chars[e].y,h=a,u=o,f=a+t.chars[e].width,m=o-t.chars[e].height,_=1-t.chars[e].height/r;return[h/i,_-u/r,f/i,_-m/r]}onEnable(){this._fontAsset.autoLoad=!0,this._model&&this._element.addModelToLayers(this._model)}onDisable(){this._fontAsset.autoLoad=!1,this._model&&this._element.removeModelFromLayers(this._model)}_setStencil(e){if(this._model){const t=this._model.meshInstances;for(let s=0;s<t.length;s++)t[s].stencilFront=e,t[s].stencilBack=e}}_shouldAutoFitWidth(){return this._autoFitWidth&&!this._autoWidth}_shouldAutoFitHeight(){return this._autoFitHeight&&!this._autoHeight}_shouldAutoFit(){return this._autoFitWidth&&!this._autoWidth||this._autoFitHeight&&!this._autoHeight}_calculateCharsPerTexture(e){const t={};e===void 0&&(e=this._symbols.length);for(let s=0,i=e;s<i;s++){const r=this._symbols[s];let a=this._font.data.chars[r];a||(a=this._font.data.chars[" "],a||(a=this._font.data.chars[Object.keys(this._font.data.chars)[0]]));const o=a.map;t[o]?t[o]++:t[o]=1}return t}_updateRenderRange(){const e=this._rangeStart===0?0:this._calculateCharsPerTexture(this._rangeStart),t=this._rangeEnd===0?0:this._calculateCharsPerTexture(this._rangeEnd);for(let s=0,i=this._meshInfo.length;s<i;s++){const r=e[s]||0,a=t[s]||0,o=this._meshInfo[s].meshInstance;if(o){const h=o.mesh;h&&(h.primitive[0].base=r*3*2,h.primitive[0].count=(a-r)*3*2)}}}set text(e){this._i18nKey=null;const t=e!=null&&e.toString()||"";this._setText(t)}get text(){return this._text}set key(e){const t=e!==null?e.toString():null;this._i18nKey!==t&&(this._i18nKey=t,t?(this._fontAsset.disableLocalization=!1,this._resetLocalizedText()):this._fontAsset.disableLocalization=!0)}get key(){return this._i18nKey}set color(e){const t=e.r,s=e.g,i=e.b;if(!(this._color.r===t&&this._color.g===s&&this._color.b===i)&&(this._color.r=t,this._color.g=s,this._color.b=i,!!this._model)){if(this._symbolColors)this._font&&this._updateText();else{vt.linear(this._color),this._colorUniform[0]=vt.r,this._colorUniform[1]=vt.g,this._colorUniform[2]=vt.b;for(let r=0,a=this._model.meshInstances.length;r<a;r++)this._model.meshInstances[r].setParameter("material_emissive",this._colorUniform)}this._element&&this._element.fire("set:color",this._color)}}get color(){return this._color}set opacity(e){if(this._color.a!==e&&(this._color.a=e,this._model))for(let t=0,s=this._model.meshInstances.length;t<s;t++)this._model.meshInstances[t].setParameter("material_opacity",e);this._element&&this._element.fire("set:opacity",e)}get opacity(){return this._color.a}set lineHeight(e){const t=this._lineHeight;this._lineHeight=e,this._scaledLineHeight=e,t!==e&&this._font&&this._updateText()}get lineHeight(){return this._lineHeight}set wrapLines(e){const t=this._wrapLines;this._wrapLines=e,t!==e&&this._font&&this._updateText()}get wrapLines(){return this._wrapLines}get lines(){return this._lineContents}set spacing(e){const t=this._spacing;this._spacing=e,t!==e&&this._font&&this._updateText()}get spacing(){return this._spacing}set fontSize(e){const t=this._fontSize;this._fontSize=e,this._originalFontSize=e,t!==e&&this._font&&this._updateText()}get fontSize(){return this._fontSize}set fontAsset(e){this._fontAsset.defaultAsset=e}get fontAsset(){return this._fontAsset.localizedAsset}set font(e){let t;if(this._font&&(t=this._font.type,this._font.off&&this._font.off("render",this._onFontRender,this)),this._font=e,this._fontMinY=0,this._fontMaxY=0,!e)return;const s=this._font.data;for(const r in s.chars){const a=s.chars[r];a.bounds&&(this._fontMinY=Math.min(this._fontMinY,a.bounds[1]),this._fontMaxY=Math.max(this._fontMaxY,a.bounds[3]))}if(this._font.on&&this._font.on("render",this._onFontRender,this),this._fontAsset.localizedAsset&&this._system.app.assets.get(this._fontAsset.localizedAsset).resource!==this._font&&(this._fontAsset.defaultAsset=null),e.type!==t){const r=this._element._isScreenSpace();this._updateMaterial(r)}for(let r=0,a=this._font.textures.length;r<a;r++)if(!this._meshInfo[r])this._meshInfo[r]=new GY;else{const o=this._meshInfo[r].meshInstance;o&&(o.setParameter("font_sdfIntensity",this._font.intensity),o.setParameter("font_pxrange",this._getPxRange(this._font)),o.setParameter("font_textureWidth",this._font.data.info.maps[r].width),this._setTextureParams(o,this._font.textures[r]))}let i=!1;for(let r=this._font.textures.length;r<this._meshInfo.length;r++)this._meshInfo[r].meshInstance&&(i||(this._element.removeModelFromLayers(this._model),i=!0),this._removeMeshInstance(this._meshInfo[r].meshInstance));this._meshInfo.length>this._font.textures.length&&(this._meshInfo.length=this._font.textures.length),this._updateText()}get font(){return this._font}set alignment(e){e instanceof ne?this._alignment.set(e.x,e.y):this._alignment.set(e[0],e[1]),this._font&&this._updateText()}get alignment(){return this._alignment}set autoWidth(e){const t=this._autoWidth;if(this._autoWidth=e,e&&Math.abs(this._element.anchor.x-this._element.anchor.z)<1e-4&&(this._element.width=this.width),t!==e){const s=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;s!==this._fontSize&&(this._fontSize=s,this._font&&this._updateText())}}get autoWidth(){return this._autoWidth}set autoHeight(e){const t=this._autoHeight;if(this._autoHeight=e,e&&Math.abs(this._element.anchor.y-this._element.anchor.w)<1e-4&&(this._element.height=this.height),t!==e){const s=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize;s!==this._fontSize&&(this._fontSize=s,this._font&&this._updateText())}}get autoHeight(){return this._autoHeight}set rtlReorder(e){this._rtlReorder!==e&&(this._rtlReorder=e,this._font&&this._updateText())}get rtlReorder(){return this._rtlReorder}set unicodeConverter(e){this._unicodeConverter!==e&&(this._unicodeConverter=e,this._setText(this._text))}get unicodeConverter(){return this._unicodeConverter}get aabb(){if(this._aabbDirty){let e=!1;for(let t=0;t<this._meshInfo.length;t++)this._meshInfo[t].meshInstance&&(e?this._aabb.add(this._meshInfo[t].meshInstance.aabb):(this._aabb.copy(this._meshInfo[t].meshInstance.aabb),e=!0));this._aabbDirty=!1}return this._aabb}set outlineColor(e){const t=e instanceof ue?e.r:e[0],s=e instanceof ue?e.g:e[1],i=e instanceof ue?e.b:e[2],r=e instanceof ue?e.a:e[3];if(!(this._outlineColor.r===t&&this._outlineColor.g===s&&this._outlineColor.b===i&&this._outlineColor.a===r)&&(this._outlineColor.r=t,this._outlineColor.g=s,this._outlineColor.b=i,this._outlineColor.a=r,!!this._model)){if(this._symbolOutlineParams)this._font&&this._updateText();else{vt.linear(this._outlineColor),this._outlineColorUniform[0]=vt.r,this._outlineColorUniform[1]=vt.g,this._outlineColorUniform[2]=vt.b,this._outlineColorUniform[3]=vt.a;for(let a=0,o=this._model.meshInstances.length;a<o;a++)this._model.meshInstances[a].setParameter("outline_color",this._outlineColorUniform)}this._element&&this._element.fire("set:outline",this._color)}}get outlineColor(){return this._outlineColor}set outlineThickness(e){const t=this._outlineThickness;if(this._outlineThickness=e,t!==e&&this._font){if(!this._model)return;if(this._symbolOutlineParams)this._font&&this._updateText();else for(let s=0,i=this._model.meshInstances.length;s<i;s++)this._model.meshInstances[s].setParameter("outline_thickness",this._outlineThicknessScale*this._outlineThickness)}}get outlineThickness(){return this._outlineThickness}set shadowColor(e){const t=e instanceof ue?e.r:e[0],s=e instanceof ue?e.g:e[1],i=e instanceof ue?e.b:e[2],r=e instanceof ue?e.a:e[3];if(!(this._shadowColor.r===t&&this._shadowColor.g===s&&this._shadowColor.b===i&&this._shadowColor.a===r)&&(this._shadowColor.r=t,this._shadowColor.g=s,this._shadowColor.b=i,this._shadowColor.a=r,!!this._model))if(this._symbolShadowParams)this._font&&this._updateText();else{vt.linear(this._shadowColor),this._shadowColorUniform[0]=vt.r,this._shadowColorUniform[1]=vt.g,this._shadowColorUniform[2]=vt.b,this._shadowColorUniform[3]=vt.a;for(let a=0,o=this._model.meshInstances.length;a<o;a++)this._model.meshInstances[a].setParameter("shadow_color",this._shadowColorUniform)}}get shadowColor(){return this._shadowColor}set shadowOffset(e){const t=e instanceof ne?e.x:e[0],s=e instanceof ne?e.y:e[1];if(!(this._shadowOffset.x===t&&this._shadowOffset.y===s)&&(this._shadowOffset.set(t,s),this._font&&this._model))if(this._symbolShadowParams)this._updateText();else for(let i=0,r=this._model.meshInstances.length;i<r;i++){const a=-this._font.data.info.maps[i].width/this._font.data.info.maps[i].height;this._shadowOffsetUniform[0]=this._shadowOffsetScale*this._shadowOffset.x,this._shadowOffsetUniform[1]=a*this._shadowOffsetScale*this._shadowOffset.y,this._model.meshInstances[i].setParameter("shadow_offset",this._shadowOffsetUniform)}}get shadowOffset(){return this._shadowOffset}set minFontSize(e){this._minFontSize!==e&&(this._minFontSize=e,this.font&&this._shouldAutoFit()&&this._updateText())}get minFontSize(){return this._minFontSize}set maxFontSize(e){this._maxFontSize!==e&&(this._maxFontSize=e,this.font&&this._shouldAutoFit()&&this._updateText())}get maxFontSize(){return this._maxFontSize}set autoFitWidth(e){this._autoFitWidth!==e&&(this._autoFitWidth=e,this._fontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize,this.font&&this._updateText())}get autoFitWidth(){return this._autoFitWidth}set autoFitHeight(e){this._autoFitHeight!==e&&(this._autoFitHeight=e,this._fontSize=this._shouldAutoFit()?this._maxFontSize:this._originalFontSize,this.font&&this._updateText())}get autoFitHeight(){return this._autoFitHeight}set maxLines(e){this._maxLines!==e&&(e===null&&this._maxLines===-1||(this._maxLines=e===null?-1:e,this.font&&this._wrapLines&&this._updateText()))}get maxLines(){return this._maxLines}set enableMarkup(e){if(e=!!e,this._enableMarkup===e)return;this._enableMarkup=e,this.font&&this._updateText();const t=this._element._isScreenSpace();this._updateMaterial(t)}get enableMarkup(){return this._enableMarkup}get symbols(){return this._symbols}get symbolColors(){return this._symbolColors===null?null:this._symbolColors.map(function(e){return this._colorPalette.slice(e*3,e*3+3)},this)}get symbolOutlineParams(){return this._symbolOutlineParams===null?null:this._symbolOutlineParams.map(function(e){return this._outlinePalette.slice(e*5,e*5+5)},this)}get symbolShadowParams(){return this._symbolShadowParams===null?null:this._symbolShadowParams.map(function(e){return this._shadowPalette.slice(e*6,e*6+6)},this)}get rtl(){return this._rtl}set rangeStart(e){e=Math.max(0,Math.min(e,this._symbols.length)),e!==this._rangeStart&&(this._rangeStart=e,this._updateRenderRange())}get rangeStart(){return this._rangeStart}set rangeEnd(e){e=Math.max(this._rangeStart,Math.min(e,this._symbols.length)),e!==this._rangeEnd&&(this._rangeEnd=e,this._updateRenderRange())}get rangeEnd(){return this._rangeEnd}constructor(e){this._element=e,this._system=e.system,this._entity=e.entity,this._text="",this._symbols=[],this._colorPalette=[],this._outlinePalette=[],this._shadowPalette=[],this._symbolColors=null,this._symbolOutlineParams=null,this._symbolShadowParams=null,this._i18nKey=null,this._fontAsset=new LY(this._system.app),this._fontAsset.disableLocalization=!0,this._fontAsset.on("load",this._onFontLoad,this),this._fontAsset.on("change",this._onFontChange,this),this._fontAsset.on("remove",this._onFontRemove,this),this._font=null,this._color=new ue(1,1,1,1),this._colorUniform=new Float32Array(3),this._spacing=1,this._fontSize=32,this._fontMinY=0,this._fontMaxY=0,this._originalFontSize=32,this._maxFontSize=32,this._minFontSize=8,this._autoFitWidth=!1,this._autoFitHeight=!1,this._maxLines=-1,this._lineHeight=32,this._scaledLineHeight=32,this._wrapLines=!1,this._drawOrder=0,this._alignment=new ne(.5,.5),this._autoWidth=!0,this._autoHeight=!0,this.width=0,this.height=0,this._node=new Dt,this._model=new rn,this._model.graph=this._node,this._entity.addChild(this._node),this._meshInfo=[],this._material=null,this._aabbDirty=!0,this._aabb=new Ge,this._noResize=!1,this._currentMaterialType=null,this._maskedMaterialSrc=null,this._rtlReorder=!1,this._unicodeConverter=!1,this._rtl=!1,this._outlineColor=new ue(0,0,0,1),this._outlineColorUniform=new Float32Array(4),this._outlineThicknessScale=.2,this._outlineThickness=0,this._shadowColor=new ue(0,0,0,1),this._shadowColorUniform=new Float32Array(4),this._shadowOffsetScale=.005,this._shadowOffset=new ne(0,0),this._shadowOffsetUniform=new Float32Array(2),this._enableMarkup=!1,this._onScreenChange(this._element.screen),e.on("resize",this._onParentResize,this),e.on("set:screen",this._onScreenChange,this),e.on("screen:set:screenspace",this._onScreenSpaceChange,this),e.on("set:draworder",this._onDrawOrderChange,this),e.on("set:pivot",this._onPivotChange,this),this._system.app.i18n.on(ao.EVENT_CHANGE,this._onLocaleSet,this),this._system.app.i18n.on("data:add",this._onLocalizationData,this),this._system.app.i18n.on("data:remove",this._onLocalizationData,this),this._rangeStart=0,this._rangeEnd=0,!e._beingInitialized&&e.enabled&&e.entity.enabled&&this.onEnable()}}const sx=new D,oR=new fe,Ta=new D,ZY=new D,Ui=new fe,a_=new fe,n_=new fe,Xc=new fe;class bi extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){const t=this.data,s=t.enabled;t.enabled=e,this.fire("set","enabled",s,e)}get enabled(){return this.data.enabled}get _absLeft(){return this._localAnchor.x+this._margin.x}get _absRight(){return this._localAnchor.z-this._margin.z}get _absTop(){return this._localAnchor.w-this._margin.w}get _absBottom(){return this._localAnchor.y+this._margin.y}get _hasSplitAnchorsX(){return Math.abs(this._anchor.x-this._anchor.z)>.001}get _hasSplitAnchorsY(){return Math.abs(this._anchor.y-this._anchor.w)>.001}get aabb(){return this._image?this._image.aabb:this._text?this._text.aabb:null}set anchor(e){e instanceof me?this._anchor.copy(e):this._anchor.set(...e),!this.entity._parent&&!this.screen?this._calculateLocalAnchors():this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY),this._anchorDirty=!0,this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:anchor",this._anchor)}get anchor(){return this._anchor}set batchGroupId(e){this._batchGroupId!==e&&(this.entity.enabled&&this._batchGroupId>=0&&this.system.app.batcher?.remove(Jt.ELEMENT,this.batchGroupId,this.entity),this.entity.enabled&&e>=0&&this.system.app.batcher?.insert(Jt.ELEMENT,e,this.entity),e<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled&&(this._image&&this._image._renderable.model?this.addModelToLayers(this._image._renderable.model):this._text&&this._text._model&&this.addModelToLayers(this._text._model)),this._batchGroupId=e)}get batchGroupId(){return this._batchGroupId}set bottom(e){this._margin.y=e;const t=this.entity.getLocalPosition(),s=this._absTop,i=this._localAnchor.y+e;this._setHeight(s-i),t.y=e+this._calculatedHeight*this._pivot.y,this.entity.setLocalPosition(t)}get bottom(){return this._margin.y}set calculatedWidth(e){this._setCalculatedWidth(e,!0)}get calculatedWidth(){return this._calculatedWidth}set calculatedHeight(e){this._setCalculatedHeight(e,!0)}get calculatedHeight(){return this._calculatedHeight}get canvasCorners(){if(!this._canvasCornersDirty||!this.screen||!this.screen.screen.screenSpace)return this._canvasCorners;const e=this.system.app.graphicsDevice,t=this.screenCorners,s=e.canvas.clientWidth/e.width,i=e.canvas.clientHeight/e.height;for(let r=0;r<4;r++)this._canvasCorners[r].set(t[r].x*s,(e.height-t[r].y)*i);return this._canvasCornersDirty=!1,this._canvasCorners}set drawOrder(e){let t=0;this.screen&&(t=this.screen.screen.priority),e>16777215&&(e=16777215),this._drawOrder=(t<<24)+e,this.fire("set:draworder",this._drawOrder)}get drawOrder(){return this._drawOrder}set height(e){this._height=e,this._hasSplitAnchorsY||this._setCalculatedHeight(e,!0),this.fire("set:height",this._height)}get height(){return this._height}set layers(e){if(this._addedModels.length)for(let t=0;t<this._layers.length;t++){const s=this.system.app.scene.layers.getLayerById(this._layers[t]);if(s)for(let i=0;i<this._addedModels.length;i++)s.removeMeshInstances(this._addedModels[i].meshInstances)}if(this._layers=e,!(!this.enabled||!this.entity.enabled||!this._addedModels.length))for(let t=0;t<this._layers.length;t++){const s=this.system.app.scene.layers.getLayerById(this._layers[t]);if(s)for(let i=0;i<this._addedModels.length;i++)s.addMeshInstances(this._addedModels[i].meshInstances)}}get layers(){return this._layers}set left(e){this._margin.x=e;const t=this.entity.getLocalPosition(),s=this._absRight,i=this._localAnchor.x+e;this._setWidth(s-i),t.x=e+this._calculatedWidth*this._pivot.x,this.entity.setLocalPosition(t)}get left(){return this._margin.x}set margin(e){this._margin.copy(e),this._calculateSize(!0,!0),this.fire("set:margin",this._margin)}get margin(){return this._margin}get maskedBy(){return this._maskedBy}set pivot(e){const{pivot:t,margin:s}=this,i=t.x,r=t.y;e instanceof ne?t.copy(e):t.set(...e);const a=s.x+s.z,o=t.x-i;s.x+=a*o,s.z-=a*o;const h=s.y+s.w,u=t.y-r;s.y+=h*u,s.w-=h*u,this._anchorDirty=!0,this._cornersDirty=!0,this._worldCornersDirty=!0,this._calculateSize(!1,!1),this._flagChildrenAsDirty(),this.fire("set:pivot",t)}get pivot(){return this._pivot}set right(e){this._margin.z=e;const t=this.entity.getLocalPosition(),s=this._absLeft,i=this._localAnchor.z-e;this._setWidth(i-s),t.x=this._localAnchor.z-this._localAnchor.x-e-this._calculatedWidth*(1-this._pivot.x),this.entity.setLocalPosition(t)}get right(){return this._margin.z}get screenCorners(){if(!this._cornersDirty||!this.screen)return this._screenCorners;const e=this.entity.parent&&this.entity.parent.element&&this.entity.parent.element.screenCorners[0];this._screenCorners[0].set(this._absLeft,this._absBottom,0),this._screenCorners[1].set(this._absRight,this._absBottom,0),this._screenCorners[2].set(this._absRight,this._absTop,0),this._screenCorners[3].set(this._absLeft,this._absTop,0);const t=this.screen.screen.screenSpace;for(let s=0;s<4;s++)this._screenTransform.transformPoint(this._screenCorners[s],this._screenCorners[s]),t&&this._screenCorners[s].mulScalar(this.screen.screen.scale),e&&this._screenCorners[s].add(e);return this._cornersDirty=!1,this._canvasCornersDirty=!0,this._worldCornersDirty=!0,this._screenCorners}get textWidth(){return this._text?this._text.width:0}get textHeight(){return this._text?this._text.height:0}set top(e){this._margin.w=e;const t=this.entity.getLocalPosition(),s=this._absBottom,i=this._localAnchor.w-e;this._setHeight(i-s),t.y=this._localAnchor.w-this._localAnchor.y-e-this._calculatedHeight*(1-this._pivot.y),this.entity.setLocalPosition(t)}get top(){return this._margin.w}set type(e){e!==this._type&&(this._type=e,this._image&&(this._image.destroy(),this._image=null),this._text&&(this._text.destroy(),this._text=null),e===fT?this._image=new MY(this):e===IL&&(this._text=new KY(this)))}get type(){return this._type}set useInput(e){this._useInput!==e&&(this._useInput=e,this.system.app.elementInput?e?this.enabled&&this.entity.enabled&&this.system.app.elementInput.addElement(this):this.system.app.elementInput.removeElement(this):this._useInput,this.fire("set:useInput",e))}get useInput(){return this._useInput}set fitMode(e){this._fitMode=e,this._calculateSize(!0,!0),this._image&&this._image.refreshMesh()}get fitMode(){return this._fitMode}set width(e){this._width=e,this._hasSplitAnchorsX||this._setCalculatedWidth(e,!0),this.fire("set:width",this._width)}get width(){return this._width}get worldCorners(){if(!this._worldCornersDirty)return this._worldCorners;if(this.screen){const e=this.screenCorners;if(!this.screen.screen.screenSpace){Ui.copy(this.screen.screen._screenMatrix),Ui.data[13]=-Ui.data[13],Ui.mul2(this.screen.getWorldTransform(),Ui);for(let t=0;t<4;t++)Ui.transformPoint(e[t],this._worldCorners[t])}}else{const e=this.entity.getLocalPosition();Ui.setTranslate(-e.x,-e.y,-e.z),a_.setTRS(D.ZERO,this.entity.getLocalRotation(),this.entity.getLocalScale()),n_.setTranslate(e.x,e.y,e.z);const t=this.entity.parent?this.entity.parent:this.entity;Xc.copy(t.getWorldTransform()),Xc.mul(n_).mul(a_).mul(Ui),Ta.set(e.x-this.pivot.x*this.calculatedWidth,e.y-this.pivot.y*this.calculatedHeight,e.z),Xc.transformPoint(Ta,this._worldCorners[0]),Ta.set(e.x+(1-this.pivot.x)*this.calculatedWidth,e.y-this.pivot.y*this.calculatedHeight,e.z),Xc.transformPoint(Ta,this._worldCorners[1]),Ta.set(e.x+(1-this.pivot.x)*this.calculatedWidth,e.y+(1-this.pivot.y)*this.calculatedHeight,e.z),Xc.transformPoint(Ta,this._worldCorners[2]),Ta.set(e.x-this.pivot.x*this.calculatedWidth,e.y+(1-this.pivot.y)*this.calculatedHeight,e.z),Xc.transformPoint(Ta,this._worldCorners[3])}return this._worldCornersDirty=!1,this._worldCorners}set fontSize(e){this._setValue("fontSize",e)}get fontSize(){return this._text?this._text.fontSize:null}set minFontSize(e){this._setValue("minFontSize",e)}get minFontSize(){return this._text?this._text.minFontSize:null}set maxFontSize(e){this._setValue("maxFontSize",e)}get maxFontSize(){return this._text?this._text.maxFontSize:null}set maxLines(e){this._setValue("maxLines",e)}get maxLines(){return this._text?this._text.maxLines:null}set autoFitWidth(e){this._setValue("autoFitWidth",e)}get autoFitWidth(){return this._text?this._text.autoFitWidth:null}set autoFitHeight(e){this._setValue("autoFitHeight",e)}get autoFitHeight(){return this._text?this._text.autoFitHeight:null}set color(e){this._setValue("color",e)}get color(){return this._text?this._text.color:this._image?this._image.color:null}set font(e){this._setValue("font",e)}get font(){return this._text?this._text.font:null}set fontAsset(e){this._setValue("fontAsset",e)}get fontAsset(){return this._text&&typeof this._text.fontAsset=="number"?this._text.fontAsset:null}set spacing(e){this._setValue("spacing",e)}get spacing(){return this._text?this._text.spacing:null}set lineHeight(e){this._setValue("lineHeight",e)}get lineHeight(){return this._text?this._text.lineHeight:null}set wrapLines(e){this._setValue("wrapLines",e)}get wrapLines(){return this._text?this._text.wrapLines:null}set lines(e){this._setValue("lines",e)}get lines(){return this._text?this._text.lines:null}set alignment(e){this._setValue("alignment",e)}get alignment(){return this._text?this._text.alignment:null}set autoWidth(e){this._setValue("autoWidth",e)}get autoWidth(){return this._text?this._text.autoWidth:null}set autoHeight(e){this._setValue("autoHeight",e)}get autoHeight(){return this._text?this._text.autoHeight:null}set rtlReorder(e){this._setValue("rtlReorder",e)}get rtlReorder(){return this._text?this._text.rtlReorder:null}set unicodeConverter(e){this._setValue("unicodeConverter",e)}get unicodeConverter(){return this._text?this._text.unicodeConverter:null}set text(e){this._setValue("text",e)}get text(){return this._text?this._text.text:null}set key(e){this._setValue("key",e)}get key(){return this._text?this._text.key:null}set texture(e){this._setValue("texture",e)}get texture(){return this._image?this._image.texture:null}set textureAsset(e){this._setValue("textureAsset",e)}get textureAsset(){return this._image?this._image.textureAsset:null}set material(e){this._setValue("material",e)}get material(){return this._image?this._image.material:null}set materialAsset(e){this._setValue("materialAsset",e)}get materialAsset(){return this._image?this._image.materialAsset:null}set sprite(e){this._setValue("sprite",e)}get sprite(){return this._image?this._image.sprite:null}set spriteAsset(e){this._setValue("spriteAsset",e)}get spriteAsset(){return this._image?this._image.spriteAsset:null}set spriteFrame(e){this._setValue("spriteFrame",e)}get spriteFrame(){return this._image?this._image.spriteFrame:null}set pixelsPerUnit(e){this._setValue("pixelsPerUnit",e)}get pixelsPerUnit(){return this._image?this._image.pixelsPerUnit:null}set opacity(e){this._setValue("opacity",e)}get opacity(){return this._text?this._text.opacity:this._image?this._image.opacity:null}set rect(e){this._setValue("rect",e)}get rect(){return this._image?this._image.rect:null}set mask(e){this._setValue("mask",e)}get mask(){return this._image?this._image.mask:null}set outlineColor(e){this._setValue("outlineColor",e)}get outlineColor(){return this._text?this._text.outlineColor:null}set outlineThickness(e){this._setValue("outlineThickness",e)}get outlineThickness(){return this._text?this._text.outlineThickness:null}set shadowColor(e){this._setValue("shadowColor",e)}get shadowColor(){return this._text?this._text.shadowColor:null}set shadowOffset(e){this._setValue("shadowOffset",e)}get shadowOffset(){return this._text?this._text.shadowOffset:null}set enableMarkup(e){this._setValue("enableMarkup",e)}get enableMarkup(){return this._text?this._text.enableMarkup:null}set rangeStart(e){this._setValue("rangeStart",e)}get rangeStart(){return this._text?this._text.rangeStart:null}set rangeEnd(e){this._setValue("rangeEnd",e)}get rangeEnd(){return this._text?this._text.rangeEnd:null}_setValue(e,t){this._text?(this._text[e]!==t&&this._dirtyBatch(),this._text[e]=t):this._image&&(this._image[e]!==t&&this._dirtyBatch(),this._image[e]=t)}_patch(){this.entity._sync=this._sync,this.entity.setPosition=this._setPosition,this.entity.setLocalPosition=this._setLocalPosition}_unpatch(){this.entity._sync=Nt.prototype._sync,this.entity.setPosition=Nt.prototype.setPosition,this.entity.setLocalPosition=Nt.prototype.setLocalPosition}_setPosition(e,t,s){if(!this.element.screen){Nt.prototype.setPosition.call(this,e,t,s);return}e instanceof D?sx.copy(e):sx.set(e,t,s),this.getWorldTransform(),oR.copy(this.element._screenToWorld).invert(),oR.transformPoint(sx,this.localPosition),this._dirtyLocal||this._dirtifyLocal()}_setLocalPosition(e,t,s){e instanceof D?this.localPosition.copy(e):this.localPosition.set(e,t,s);const i=this.element,r=this.localPosition,a=i._pivot;i._margin.x=r.x-i._calculatedWidth*a.x,i._margin.z=i._localAnchor.z-i._localAnchor.x-i._calculatedWidth-i._margin.x,i._margin.y=r.y-i._calculatedHeight*a.y,i._margin.w=i._localAnchor.w-i._localAnchor.y-i._calculatedHeight-i._margin.y,this._dirtyLocal||this._dirtifyLocal()}_sync(){const e=this.element,t=e.screen;if(t){if(e._anchorDirty){let s=0,i=0,r=0,a=1;if(this._parent&&this._parent.element)s=this._parent.element.calculatedWidth,i=this._parent.element.calculatedHeight,r=this._parent.element.pivot.x,a=this._parent.element.pivot.y;else{const o=t.screen.resolution;s=o.x/t.screen.scale,i=o.y/t.screen.scale}e._anchorTransform.setTranslate(s*(e.anchor.x-r),-(i*(a-e.anchor.y)),0),e._anchorDirty=!1,e._calculateLocalAnchors()}e._sizeDirty&&e._calculateSize(!1,!1)}if(this._dirtyLocal){this.localTransform.setTRS(this.localPosition,this.localRotation,this.localScale);const s=this.localPosition,i=e._pivot;e._margin.x=s.x-e._calculatedWidth*i.x,e._margin.z=e._localAnchor.z-e._localAnchor.x-e._calculatedWidth-e._margin.x,e._margin.y=s.y-e._calculatedHeight*i.y,e._margin.w=e._localAnchor.w-e._localAnchor.y-e._calculatedHeight-e._margin.y,this._dirtyLocal=!1}if(!t){this._dirtyWorld&&(e._cornersDirty=!0,e._canvasCornersDirty=!0,e._worldCornersDirty=!0),Nt.prototype._sync.call(this);return}if(this._dirtyWorld){if(this._parent===null)this.worldTransform.copy(this.localTransform);else if(this._parent.element?e._screenToWorld.mul2(this._parent.element._modelTransform,e._anchorTransform):e._screenToWorld.copy(e._anchorTransform),e._modelTransform.mul2(e._screenToWorld,this.localTransform),t){e._screenToWorld.mul2(t.screen._screenMatrix,e._screenToWorld),t.screen.screenSpace||e._screenToWorld.mul2(t.worldTransform,e._screenToWorld),this.worldTransform.mul2(e._screenToWorld,this.localTransform);const s=e._parentWorldTransform;s.setIdentity();const i=this._parent;i&&i.element&&i!==t&&(Ui.setTRS(D.ZERO,i.getLocalRotation(),i.getLocalScale()),s.mul2(i.element._parentWorldTransform,Ui));const r=Ta;r.set(0,0,this.localPosition.z);const a=ZY;a.set(e._absLeft+e._pivot.x*e.calculatedWidth,e._absBottom+e._pivot.y*e.calculatedHeight,0),Ui.setTranslate(-a.x,-a.y,-a.z),a_.setTRS(r,this.getLocalRotation(),this.getLocalScale()),n_.setTranslate(a.x,a.y,a.z),e._screenTransform.mul2(e._parentWorldTransform,n_).mul(a_).mul(Ui),e._cornersDirty=!0,e._canvasCornersDirty=!0,e._worldCornersDirty=!0}else this.worldTransform.copy(e._modelTransform);this._dirtyWorld=!1}}_onInsert(e){const t=this._parseUpToScreen();this.entity._dirtifyWorld(),this._updateScreen(t.screen),this._dirtifyMask()}_dirtifyMask(){let e=this.entity;for(;e;){const t=e.parent;if((t===null||t.screen)&&e.element){(!this.system._prerender||!this.system._prerender.length)&&(this.system._prerender=[],this.system.app.once("prerender",this._onPrerender,this));const s=this.system._prerender.indexOf(this.entity);s>=0&&this.system._prerender.splice(s,1),this.system._prerender.indexOf(e)<0&&this.system._prerender.push(e)}e=t}}_onPrerender(){for(let e=0;e<this.system._prerender.length;e++){const t=this.system._prerender[e];t.element&&t.element.syncMask(1)}this.system._prerender.length=0}_bindScreen(e){e._bindElement(this)}_unbindScreen(e){e._unbindElement(this)}_updateScreen(e){this.screen&&this.screen!==e&&this._unbindScreen(this.screen.screen);const t=this.screen;this.screen=e,this.screen&&this._bindScreen(this.screen.screen),this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY),this.fire("set:screen",this.screen,t),this._anchorDirty=!0;const s=this.entity.children;for(let i=0,r=s.length;i<r;i++)s[i].element&&s[i].element._updateScreen(e);this.screen&&this.screen.screen.syncDrawOrder()}syncMask(e){const t=this._parseUpToScreen();this._updateMask(t.mask,e)}_setMaskedBy(e){const t=this._image||this._text;if(e){const s=e.element._image._maskRef;t?._setStencil(new Xi({ref:s,func:q_})),this._maskedBy=e}else t?._setStencil(null),this._maskedBy=null}_updateMask(e,t){if(e){if(this._setMaskedBy(e),this.mask){const i=e.element._image._maskRef,r=new Xi({ref:i,func:q_,zpass:zB});this._image._setStencil(r),this._image._maskRef=t,t++,e=this.entity}const s=this.entity.children;for(let i=0,r=s.length;i<r;i++)s[i].element?._updateMask(e,t);this.mask&&t--}else{if(this._setMaskedBy(null),this.mask){const i=new Xi({ref:t,func:$a,zpass:UB});this._image._setStencil(i),this._image._maskRef=t,t++,e=this.entity}const s=this.entity.children;for(let i=0,r=s.length;i<r;i++)s[i].element?._updateMask(e,t);this.mask&&t--}}_parseUpToScreen(){const e={screen:null,mask:null};let t=this.entity._parent;for(;t&&!t.screen;)t.element&&t.element.mask&&(e.mask||(e.mask=t)),t=t.parent;return t&&t.screen&&(e.screen=t),e}_onScreenResize(e){this._anchorDirty=!0,this._cornersDirty=!0,this._worldCornersDirty=!0,this._calculateSize(this._hasSplitAnchorsX,this._hasSplitAnchorsY),this.fire("screen:set:resolution",e)}_onScreenSpaceChange(){this.fire("screen:set:screenspace",this.screen.screen.screenSpace)}_onScreenRemove(){this.screen&&(this.screen._destroying?this.screen=null:this._updateScreen(null))}_calculateLocalAnchors(){let e=1e3,t=1e3;const s=this.entity._parent;if(s&&s.element)e=s.element.calculatedWidth,t=s.element.calculatedHeight;else if(this.screen){const i=this.screen.screen.resolution,r=this.screen.screen.scale;e=i.x/r,t=i.y/r}this._localAnchor.set(this._anchor.x*e,this._anchor.y*t,this._anchor.z*e,this._anchor.w*t)}getOffsetPosition(e,t){const s=this.entity.getLocalPosition().clone();return s.x+=e,s.y+=t,this._screenToWorld.transformPoint(s,s),s}onLayersChanged(e,t){this.addModelToLayers(this._image?this._image._renderable.model:this._text._model),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||(this._image?e.addMeshInstances(this._image._renderable.model.meshInstances):this._text&&e.addMeshInstances(this._text._model.meshInstances))}onLayerRemoved(e){this.layers.indexOf(e.id)<0||(this._image?e.removeMeshInstances(this._image._renderable.model.meshInstances):this._text&&e.removeMeshInstances(this._text._model.meshInstances))}onEnable(){const e=this.system.app.scene,t=e.layers;this._image&&this._image.onEnable(),this._text&&this._text.onEnable(),this._group&&this._group.onEnable(),this.useInput&&this.system.app.elementInput&&this.system.app.elementInput.addElement(this),this._evtLayersChanged=e.on("set:layers",this.onLayersChanged,this),t&&(this._evtLayerAdded=t.on("add",this.onLayerAdded,this),this._evtLayerRemoved=t.on("remove",this.onLayerRemoved,this)),this._batchGroupId>=0&&this.system.app.batcher?.insert(Jt.ELEMENT,this.batchGroupId,this.entity),this.fire("enableelement")}onDisable(){const t=this.system.app.scene.layers;this._evtLayersChanged?.off(),this._evtLayersChanged=null,t&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this._image&&this._image.onDisable(),this._text&&this._text.onDisable(),this._group&&this._group.onDisable(),this.system.app.elementInput&&this.useInput&&this.system.app.elementInput.removeElement(this),this._batchGroupId>=0&&this.system.app.batcher?.remove(Jt.ELEMENT,this.batchGroupId,this.entity),this.fire("disableelement")}onRemove(){this.entity.off("insert",this._onInsert,this),this._unpatch(),this._image&&this._image.destroy(),this._text&&this._text.destroy(),this.system.app.elementInput&&this.useInput&&this.system.app.elementInput.removeElement(this),this.screen&&this.screen.screen&&(this._unbindScreen(this.screen.screen),this.screen.screen.syncDrawOrder()),this.off()}_calculateSize(e,t){if(!this.entity._parent&&!this.screen)return;this._calculateLocalAnchors();const s=this._absRight-this._absLeft,i=this._absTop-this._absBottom;e?this._setWidth(s):this._setCalculatedWidth(s,!1),t?this._setHeight(i):this._setCalculatedHeight(i,!1);const r=this.entity.getLocalPosition();r.x=this._margin.x+this._calculatedWidth*this._pivot.x,r.y=this._margin.y+this._calculatedHeight*this._pivot.y,this.entity.setLocalPosition(r),this._sizeDirty=!1}_setWidth(e){this._width=e,this._setCalculatedWidth(e,!1),this.fire("set:width",this._width)}_setHeight(e){this._height=e,this._setCalculatedHeight(e,!1),this.fire("set:height",this._height)}_setCalculatedWidth(e,t){if(!(Math.abs(e-this._calculatedWidth)<=1e-4)){if(this._calculatedWidth=e,this.entity._dirtifyLocal(),t){const s=this.entity.getLocalPosition(),i=this._pivot;this._margin.x=s.x-this._calculatedWidth*i.x,this._margin.z=this._localAnchor.z-this._localAnchor.x-this._calculatedWidth-this._margin.x}this._flagChildrenAsDirty(),this.fire("set:calculatedWidth",this._calculatedWidth),this.fire("resize",this._calculatedWidth,this._calculatedHeight)}}_setCalculatedHeight(e,t){if(!(Math.abs(e-this._calculatedHeight)<=1e-4)){if(this._calculatedHeight=e,this.entity._dirtifyLocal(),t){const s=this.entity.getLocalPosition(),i=this._pivot;this._margin.y=s.y-this._calculatedHeight*i.y,this._margin.w=this._localAnchor.w-this._localAnchor.y-this._calculatedHeight-this._margin.y}this._flagChildrenAsDirty(),this.fire("set:calculatedHeight",this._calculatedHeight),this.fire("resize",this._calculatedWidth,this._calculatedHeight)}}_flagChildrenAsDirty(){const e=this.entity._children;for(let t=0,s=e.length;t<s;t++)e[t].element&&(e[t].element._anchorDirty=!0,e[t].element._sizeDirty=!0)}addModelToLayers(e){this._addedModels.push(e);for(let t=0;t<this.layers.length;t++){const s=this.system.app.scene.layers.getLayerById(this.layers[t]);s&&s.addMeshInstances(e.meshInstances)}}removeModelFromLayers(e){const t=this._addedModels.indexOf(e);t>=0&&this._addedModels.splice(t,1);for(let s=0;s<this.layers.length;s++){const i=this.system.app.scene.layers.getLayerById(this.layers[s]);i&&i.removeMeshInstances(e.meshInstances)}}getMaskOffset(){const e=this.system.app.frame;this._offsetReadAt!==e&&(this._maskOffset=.5,this._offsetReadAt=e);const t=this._maskOffset;return this._maskOffset-=.001,t}isVisibleForCamera(e){let t,s,i,r;if(this.maskedBy){const m=this.maskedBy.element.screenCorners;t=Math.min(Math.min(m[0].x,m[1].x),Math.min(m[2].x,m[3].x)),s=Math.max(Math.max(m[0].x,m[1].x),Math.max(m[2].x,m[3].x)),r=Math.min(Math.min(m[0].y,m[1].y),Math.min(m[2].y,m[3].y)),i=Math.max(Math.max(m[0].y,m[1].y),Math.max(m[2].y,m[3].y))}else{const m=this.system.app.graphicsDevice.width,_=this.system.app.graphicsDevice.height,g=e._rect.z*m,S=e._rect.w*_;t=e._rect.x*m,s=t+g,i=(1-e._rect.y)*_,r=i-S}const a=this.screenCorners,o=Math.min(Math.min(a[0].x,a[1].x),Math.min(a[2].x,a[3].x)),h=Math.max(Math.max(a[0].x,a[1].x),Math.max(a[2].x,a[3].x)),u=Math.min(Math.min(a[0].y,a[1].y),Math.min(a[2].y,a[3].y)),f=Math.max(Math.max(a[0].y,a[1].y),Math.max(a[2].y,a[3].y));return!(h<t||o>s||u>i||f<r)}_isScreenSpace(){return this.screen&&this.screen.screen?this.screen.screen.screenSpace:!1}_isScreenCulled(){return this.screen&&this.screen.screen?this.screen.screen.cull:!1}_dirtyBatch(){this.batchGroupId!==-1&&this.system.app.batcher?.markGroupDirty(this.batchGroupId)}constructor(e,t){super(e,t),this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._beingInitialized=!1,this._anchor=new me,this._localAnchor=new me,this._pivot=new ne,this._width=this._calculatedWidth=32,this._height=this._calculatedHeight=32,this._margin=new me(0,0,-32,-32),this._modelTransform=new fe,this._screenToWorld=new fe,this._anchorTransform=new fe,this._anchorDirty=!0,this._parentWorldTransform=new fe,this._screenTransform=new fe,this._screenCorners=[new D,new D,new D,new D],this._canvasCorners=[new ne,new ne,new ne,new ne],this._worldCorners=[new D,new D,new D,new D],this._cornersDirty=!0,this._canvasCornersDirty=!0,this._worldCornersDirty=!0,this.entity.on("insert",this._onInsert,this),this._patch(),this.screen=null,this._type=O_,this._image=null,this._text=null,this._group=null,this._drawOrder=0,this._fitMode=N_,this._useInput=!1,this._layers=[Cv],this._addedModels=[],this._batchGroupId=-1,this._offsetReadAt=0,this._maskOffset=.5,this._maskedBy=null}}bi.EVENT_MOUSEDOWN="mousedown";bi.EVENT_MOUSEUP="mouseup";bi.EVENT_MOUSEENTER="mouseenter";bi.EVENT_MOUSELEAVE="mouseleave";bi.EVENT_MOUSEMOVE="mousemove";bi.EVENT_MOUSEWHEEL="mousewheel";bi.EVENT_CLICK="click";bi.EVENT_TOUCHSTART="touchstart";bi.EVENT_TOUCHEND="touchend";bi.EVENT_TOUCHMOVE="touchmove";bi.EVENT_TOUCHCANCEL="touchcancel";class QY{constructor(){this.enabled=!0}}const JY=["enabled"];class ej extends Ht{destroy(){super.destroy(),this._defaultTexture.destroy()}initializeComponentData(e,t,s){e._beingInitialized=!0,t.anchor!==void 0&&(t.anchor instanceof me?e.anchor.copy(t.anchor):e.anchor.set(t.anchor[0],t.anchor[1],t.anchor[2],t.anchor[3])),t.pivot!==void 0&&(t.pivot instanceof ne?e.pivot.copy(t.pivot):e.pivot.set(t.pivot[0],t.pivot[1]));const i=Math.abs(e.anchor.x-e.anchor.z)>.001,r=Math.abs(e.anchor.y-e.anchor.w)>.001;let a=!1,o;t.margin!==void 0&&(t.margin instanceof me?e.margin.copy(t.margin):e._margin.set(t.margin[0],t.margin[1],t.margin[2],t.margin[3]),a=!0),t.left!==void 0&&(e._margin.x=t.left,a=!0),t.bottom!==void 0&&(e._margin.y=t.bottom,a=!0),t.right!==void 0&&(e._margin.z=t.right,a=!0),t.top!==void 0&&(e._margin.w=t.top,a=!0),a&&(e.margin=e._margin);let h=!1;t.width!==void 0&&!i?e.width=t.width:i&&(h=!0),t.height!==void 0&&!r?e.height=t.height:r&&(h=!0),h&&(e.anchor=e.anchor),t.enabled!==void 0&&(e.enabled=t.enabled),t.useInput!==void 0&&(e.useInput=t.useInput),t.fitMode!==void 0&&(e.fitMode=t.fitMode),e.batchGroupId=t.batchGroupId===void 0||t.batchGroupId===null?-1:t.batchGroupId,t.layers&&Array.isArray(t.layers)&&(e.layers=t.layers.slice(0)),t.type!==void 0&&(e.type=t.type),e.type===fT?(t.rect!==void 0&&(e.rect=t.rect),t.color!==void 0&&(o=t.color,o instanceof ue||(o=new ue(t.color[0],t.color[1],t.color[2])),e.color=o),t.opacity!==void 0&&(e.opacity=t.opacity),t.textureAsset!==void 0&&(e.textureAsset=t.textureAsset),t.texture&&(e.texture=t.texture),t.spriteAsset!==void 0&&(e.spriteAsset=t.spriteAsset),t.sprite&&(e.sprite=t.sprite),t.spriteFrame!==void 0&&(e.spriteFrame=t.spriteFrame),t.pixelsPerUnit!==void 0&&t.pixelsPerUnit!==null&&(e.pixelsPerUnit=t.pixelsPerUnit),t.materialAsset!==void 0&&(e.materialAsset=t.materialAsset),t.material&&(e.material=t.material),t.mask!==void 0&&(e.mask=t.mask)):e.type===IL&&(t.autoWidth!==void 0&&(e.autoWidth=t.autoWidth),t.autoHeight!==void 0&&(e.autoHeight=t.autoHeight),t.rtlReorder!==void 0&&(e.rtlReorder=t.rtlReorder),t.unicodeConverter!==void 0&&(e.unicodeConverter=t.unicodeConverter),t.text!==null&&t.text!==void 0?e.text=t.text:t.key!==null&&t.key!==void 0&&(e.key=t.key),t.color!==void 0&&(o=t.color,o instanceof ue||(o=new ue(o[0],o[1],o[2])),e.color=o),t.opacity!==void 0&&(e.opacity=t.opacity),t.spacing!==void 0&&(e.spacing=t.spacing),t.fontSize!==void 0&&(e.fontSize=t.fontSize,t.lineHeight||(e.lineHeight=t.fontSize)),t.lineHeight!==void 0&&(e.lineHeight=t.lineHeight),t.maxLines!==void 0&&(e.maxLines=t.maxLines),t.wrapLines!==void 0&&(e.wrapLines=t.wrapLines),t.minFontSize!==void 0&&(e.minFontSize=t.minFontSize),t.maxFontSize!==void 0&&(e.maxFontSize=t.maxFontSize),t.autoFitWidth&&(e.autoFitWidth=t.autoFitWidth),t.autoFitHeight&&(e.autoFitHeight=t.autoFitHeight),t.fontAsset!==void 0&&(e.fontAsset=t.fontAsset),t.font!==void 0&&(e.font=t.font),t.alignment!==void 0&&(e.alignment=t.alignment),t.outlineColor!==void 0&&(e.outlineColor=t.outlineColor),t.outlineThickness!==void 0&&(e.outlineThickness=t.outlineThickness),t.shadowColor!==void 0&&(e.shadowColor=t.shadowColor),t.shadowOffset!==void 0&&(e.shadowOffset=t.shadowOffset),t.enableMarkup!==void 0&&(e.enableMarkup=t.enableMarkup));const u=e._parseUpToScreen();u.screen&&e._updateScreen(u.screen),super.initializeComponentData(e,t,s),e._beingInitialized=!1,e.type===fT&&e._image._meshDirty&&e._image._updateMesh(e._image.mesh)}onAddComponent(e,t){e.fire("element:add")}onRemoveComponent(e,t){t.onRemove()}cloneComponent(e,t){const s=e.element,i={enabled:s.enabled,width:s.width,height:s.height,anchor:s.anchor.clone(),pivot:s.pivot.clone(),margin:s.margin.clone(),alignment:s.alignment&&s.alignment.clone()||s.alignment,autoWidth:s.autoWidth,autoHeight:s.autoHeight,type:s.type,rect:s.rect&&s.rect.clone()||s.rect,rtlReorder:s.rtlReorder,unicodeConverter:s.unicodeConverter,materialAsset:s.materialAsset,material:s.material,color:s.color&&s.color.clone()||s.color,opacity:s.opacity,textureAsset:s.textureAsset,texture:s.texture,spriteAsset:s.spriteAsset,sprite:s.sprite,spriteFrame:s.spriteFrame,pixelsPerUnit:s.pixelsPerUnit,spacing:s.spacing,lineHeight:s.lineHeight,wrapLines:s.wrapLines,layers:s.layers,fontSize:s.fontSize,minFontSize:s.minFontSize,maxFontSize:s.maxFontSize,autoFitWidth:s.autoFitWidth,autoFitHeight:s.autoFitHeight,maxLines:s.maxLines,fontAsset:s.fontAsset,font:s.font,useInput:s.useInput,fitMode:s.fitMode,batchGroupId:s.batchGroupId,mask:s.mask,outlineColor:s.outlineColor&&s.outlineColor.clone()||s.outlineColor,outlineThickness:s.outlineThickness,shadowColor:s.shadowColor&&s.shadowColor.clone()||s.shadowColor,shadowOffset:s.shadowOffset&&s.shadowOffset.clone()||s.shadowOffset,enableMarkup:s.enableMarkup};return s.key!==void 0&&s.key!==null?i.key=s.key:i.text=s.text,this.addComponent(t,i)}getTextElementMaterial(e,t,s){const i=(e&&1)|(t&&2)|(s&&4);let r=this._defaultTextMaterials[i];if(r)return r;let a="TextMaterial";return r=new vr,t?(r.msdfMap=this._defaultTexture,r.msdfTextAttribute=s,r.emissive.set(1,1,1)):(a=`Bitmap${a}`,r.emissive.set(1,1,1),r.emissiveMap=this._defaultTexture,r.opacityMap=this._defaultTexture,r.opacityMapChannel="a"),e&&(a=`ScreenSpace${a}`,r.depthTest=!1),r.name=`default${a}`,r.useLighting=!1,r.useTonemap=!1,r.useFog=!1,r.useSkybox=!1,r.diffuse.set(0,0,0),r.opacity=.5,r.blendType=ro,r.depthWrite=!1,r.emissiveVertexColor=!0,r.update(),this._defaultTextMaterials[i]=r,r}_createBaseImageMaterial(){const e=new vr;return e.diffuse.set(0,0,0),e.emissive.set(1,1,1),e.emissiveMap=this._defaultTexture,e.opacityMap=this._defaultTexture,e.opacityMapChannel="a",e.useLighting=!1,e.useTonemap=!1,e.useFog=!1,e.useSkybox=!1,e.blendType=ro,e.depthWrite=!1,e}getImageElementMaterial(e,t,s,i){return e?t?s?(this.defaultScreenSpaceImageMask9SlicedMaterial||(this.defaultScreenSpaceImageMask9SlicedMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImageMask9SlicedMaterial.name="defaultScreenSpaceImageMask9SlicedMaterial",this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode=hs,this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest=1,this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite=!1,this.defaultScreenSpaceImageMask9SlicedMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial)),this.defaultScreenSpaceImageMask9SlicedMaterial):i?(this.defaultScreenSpaceImageMask9TiledMaterial||(this.defaultScreenSpaceImageMask9TiledMaterial=this.defaultScreenSpaceImage9TiledMaterial.clone(),this.defaultScreenSpaceImageMask9TiledMaterial.name="defaultScreenSpaceImageMask9TiledMaterial",this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode=us,this.defaultScreenSpaceImageMask9TiledMaterial.depthTest=!1,this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest=1,this.defaultScreenSpaceImageMask9TiledMaterial.redWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite=!1,this.defaultScreenSpaceImageMask9TiledMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial)),this.defaultScreenSpaceImageMask9TiledMaterial):(this.defaultScreenSpaceImageMaskMaterial||(this.defaultScreenSpaceImageMaskMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImageMaskMaterial.name="defaultScreenSpaceImageMaskMaterial",this.defaultScreenSpaceImageMaskMaterial.depthTest=!1,this.defaultScreenSpaceImageMaskMaterial.alphaTest=1,this.defaultScreenSpaceImageMaskMaterial.redWrite=!1,this.defaultScreenSpaceImageMaskMaterial.greenWrite=!1,this.defaultScreenSpaceImageMaskMaterial.blueWrite=!1,this.defaultScreenSpaceImageMaskMaterial.alphaWrite=!1,this.defaultScreenSpaceImageMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial)),this.defaultScreenSpaceImageMaskMaterial):s?(this.defaultScreenSpaceImage9SlicedMaterial||(this.defaultScreenSpaceImage9SlicedMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImage9SlicedMaterial.name="defaultScreenSpaceImage9SlicedMaterial",this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode=hs,this.defaultScreenSpaceImage9SlicedMaterial.depthTest=!1,this.defaultScreenSpaceImage9SlicedMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial)),this.defaultScreenSpaceImage9SlicedMaterial):i?(this.defaultScreenSpaceImage9TiledMaterial||(this.defaultScreenSpaceImage9TiledMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImage9TiledMaterial.name="defaultScreenSpaceImage9TiledMaterial",this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode=us,this.defaultScreenSpaceImage9TiledMaterial.depthTest=!1,this.defaultScreenSpaceImage9TiledMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial)),this.defaultScreenSpaceImage9TiledMaterial):(this.defaultScreenSpaceImageMaterial||(this.defaultScreenSpaceImageMaterial=this._createBaseImageMaterial(),this.defaultScreenSpaceImageMaterial.name="defaultScreenSpaceImageMaterial",this.defaultScreenSpaceImageMaterial.depthTest=!1,this.defaultScreenSpaceImageMaterial.update(),this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial)),this.defaultScreenSpaceImageMaterial):t?s?(this.defaultImage9SlicedMaskMaterial||(this.defaultImage9SlicedMaskMaterial=this._createBaseImageMaterial(),this.defaultImage9SlicedMaskMaterial.name="defaultImage9SlicedMaskMaterial",this.defaultImage9SlicedMaskMaterial.nineSlicedMode=hs,this.defaultImage9SlicedMaskMaterial.alphaTest=1,this.defaultImage9SlicedMaskMaterial.redWrite=!1,this.defaultImage9SlicedMaskMaterial.greenWrite=!1,this.defaultImage9SlicedMaskMaterial.blueWrite=!1,this.defaultImage9SlicedMaskMaterial.alphaWrite=!1,this.defaultImage9SlicedMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial)),this.defaultImage9SlicedMaskMaterial):i?(this.defaultImage9TiledMaskMaterial||(this.defaultImage9TiledMaskMaterial=this._createBaseImageMaterial(),this.defaultImage9TiledMaskMaterial.name="defaultImage9TiledMaskMaterial",this.defaultImage9TiledMaskMaterial.nineSlicedMode=us,this.defaultImage9TiledMaskMaterial.alphaTest=1,this.defaultImage9TiledMaskMaterial.redWrite=!1,this.defaultImage9TiledMaskMaterial.greenWrite=!1,this.defaultImage9TiledMaskMaterial.blueWrite=!1,this.defaultImage9TiledMaskMaterial.alphaWrite=!1,this.defaultImage9TiledMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial)),this.defaultImage9TiledMaskMaterial):(this.defaultImageMaskMaterial||(this.defaultImageMaskMaterial=this._createBaseImageMaterial(),this.defaultImageMaskMaterial.name="defaultImageMaskMaterial",this.defaultImageMaskMaterial.alphaTest=1,this.defaultImageMaskMaterial.redWrite=!1,this.defaultImageMaskMaterial.greenWrite=!1,this.defaultImageMaskMaterial.blueWrite=!1,this.defaultImageMaskMaterial.alphaWrite=!1,this.defaultImageMaskMaterial.update(),this.defaultImageMaterials.push(this.defaultImageMaskMaterial)),this.defaultImageMaskMaterial):s?(this.defaultImage9SlicedMaterial||(this.defaultImage9SlicedMaterial=this._createBaseImageMaterial(),this.defaultImage9SlicedMaterial.name="defaultImage9SlicedMaterial",this.defaultImage9SlicedMaterial.nineSlicedMode=hs,this.defaultImage9SlicedMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial)),this.defaultImage9SlicedMaterial):i?(this.defaultImage9TiledMaterial||(this.defaultImage9TiledMaterial=this._createBaseImageMaterial(),this.defaultImage9TiledMaterial.name="defaultImage9TiledMaterial",this.defaultImage9TiledMaterial.nineSlicedMode=us,this.defaultImage9TiledMaterial.update(),this.defaultImageMaterials.push(this.defaultImage9TiledMaterial)),this.defaultImage9TiledMaterial):(this.defaultImageMaterial||(this.defaultImageMaterial=this._createBaseImageMaterial(),this.defaultImageMaterial.name="defaultImageMaterial",this.defaultImageMaterial.update(),this.defaultImageMaterials.push(this.defaultImageMaterial)),this.defaultImageMaterial)}registerUnicodeConverter(e){this._unicodeConverter=e}registerRtlReorder(e){this._rtlReorder=e}getUnicodeConverter(){return this._unicodeConverter}getRtlReorder(){return this._rtlReorder}constructor(e){super(e),this.id="element",this.ComponentType=bi,this.DataType=QY,this.schema=JY,this._unicodeConverter=null,this._rtlReorder=null,this._defaultTexture=new De(e.graphicsDevice,{width:1,height:1,format:Us,name:"element-system"});const t=this._defaultTexture.lock(),s=new Uint8Array(4);s[0]=255,s[1]=255,s[2]=255,s[3]=255,t.set(s),this._defaultTexture.unlock(),this.defaultImageMaterial=null,this.defaultImage9SlicedMaterial=null,this.defaultImage9TiledMaterial=null,this.defaultImageMaskMaterial=null,this.defaultImage9SlicedMaskMaterial=null,this.defaultImage9TiledMaskMaterial=null,this.defaultScreenSpaceImageMaterial=null,this.defaultScreenSpaceImage9SlicedMaterial=null,this.defaultScreenSpaceImage9TiledMaterial=null,this.defaultScreenSpaceImageMask9SlicedMaterial=null,this.defaultScreenSpaceImageMask9TiledMaterial=null,this.defaultScreenSpaceImageMaskMaterial=null,this._defaultTextMaterials={},this.defaultImageMaterials=[],this.on("add",this.onAddComponent,this),this.on("beforeremove",this.onRemoveComponent,this)}}const qc="free",Yc="limited",jc="locked",tj=["angularDampingX","angularDampingY","angularDampingZ","angularEquilibriumX","angularEquilibriumY","angularEquilibriumZ","angularLimitsX","angularLimitsY","angularLimitsZ","angularMotionX","angularMotionY","angularMotionZ","angularSpringX","angularSpringY","angularSpringZ","angularStiffnessX","angularStiffnessY","angularStiffnessZ","breakForce","enableCollision","enabled","entityA","entityB","linearDampingX","linearDampingY","linearDampingZ","linearEquilibriumX","linearEquilibriumY","linearEquilibriumZ","linearLimitsX","linearLimitsY","linearLimitsZ","linearMotionX","linearMotionY","linearMotionZ","linearSpringX","linearSpringY","linearSpringZ","linearStiffnessX","linearStiffnessY","linearStiffnessZ"];class nb extends ke{set entityA(e){this._destroyConstraint(),this._entityA=e,this._createConstraint()}get entityA(){return this._entityA}set entityB(e){this._destroyConstraint(),this._entityB=e,this._createConstraint()}get entityB(){return this._entityB}set breakForce(e){this._constraint&&this._breakForce!==e&&(this._constraint.setBreakingImpulseThreshold(e),this._breakForce=e)}get breakForce(){return this._breakForce}set enableCollision(e){this._destroyConstraint(),this._enableCollision=e,this._createConstraint()}get enableCollision(){return this._enableCollision}set angularLimitsX(e){this._angularLimitsX.equals(e)||(this._angularLimitsX.copy(e),this._updateAngularLimits())}get angularLimitsX(){return this._angularLimitsX}set angularMotionX(e){this._angularMotionX!==e&&(this._angularMotionX=e,this._updateAngularLimits())}get angularMotionX(){return this._angularMotionX}set angularLimitsY(e){this._angularLimitsY.equals(e)||(this._angularLimitsY.copy(e),this._updateAngularLimits())}get angularLimitsY(){return this._angularLimitsY}set angularMotionY(e){this._angularMotionY!==e&&(this._angularMotionY=e,this._updateAngularLimits())}get angularMotionY(){return this._angularMotionY}set angularLimitsZ(e){this._angularLimitsZ.equals(e)||(this._angularLimitsZ.copy(e),this._updateAngularLimits())}get angularLimitsZ(){return this._angularLimitsZ}set angularMotionZ(e){this._angularMotionZ!==e&&(this._angularMotionZ=e,this._updateAngularLimits())}get angularMotionZ(){return this._angularMotionZ}set linearLimitsX(e){this._linearLimitsX.equals(e)||(this._linearLimitsX.copy(e),this._updateLinearLimits())}get linearLimitsX(){return this._linearLimitsX}set linearMotionX(e){this._linearMotionX!==e&&(this._linearMotionX=e,this._updateLinearLimits())}get linearMotionX(){return this._linearMotionX}set linearLimitsY(e){this._linearLimitsY.equals(e)||(this._linearLimitsY.copy(e),this._updateLinearLimits())}get linearLimitsY(){return this._linearLimitsY}set linearMotionY(e){this._linearMotionY!==e&&(this._linearMotionY=e,this._updateLinearLimits())}get linearMotionY(){return this._linearMotionY}set linearLimitsZ(e){this._linearLimitsZ.equals(e)||(this._linearLimitsZ.copy(e),this._updateLinearLimits())}get linearLimitsZ(){return this._linearLimitsZ}set linearMotionZ(e){this._linearMotionZ!==e&&(this._linearMotionZ=e,this._updateLinearLimits())}get linearMotionZ(){return this._linearMotionZ}_convertTransform(e,t){const s=e.getTranslation(),i=new pe;i.setFromMat4(e);const r=new Ammo.btVector3(s.x,s.y,s.z),a=new Ammo.btQuaternion(i.x,i.y,i.z,i.w);t.setOrigin(r),t.setRotation(a),Ammo.destroy(r),Ammo.destroy(a)}_updateAngularLimits(){const e=this._constraint;if(e){let t,s,i,r,a,o;this._angularMotionX===Yc?(t=this._angularLimitsX.x*J.DEG_TO_RAD,r=this._angularLimitsX.y*J.DEG_TO_RAD):this._angularMotionX===qc?(t=1,r=0):t=r=0,this._angularMotionY===Yc?(s=this._angularLimitsY.x*J.DEG_TO_RAD,a=this._angularLimitsY.y*J.DEG_TO_RAD):this._angularMotionY===qc?(s=1,a=0):s=a=0,this._angularMotionZ===Yc?(i=this._angularLimitsZ.x*J.DEG_TO_RAD,o=this._angularLimitsZ.y*J.DEG_TO_RAD):this._angularMotionZ===qc?(i=1,o=0):i=o=0;const h=new Ammo.btVector3(t,s,i);e.setAngularLowerLimit(h),h.setValue(r,a,o),e.setAngularUpperLimit(h),Ammo.destroy(h)}}_updateLinearLimits(){const e=this._constraint;if(e){let t,s,i,r,a,o;this._linearMotionX===Yc?(t=this._linearLimitsX.x,r=this._linearLimitsX.y):this._linearMotionX===qc?(t=1,r=0):t=r=0,this._linearMotionY===Yc?(s=this._linearLimitsY.x,a=this._linearLimitsY.y):this._linearMotionY===qc?(s=1,a=0):s=a=0,this._linearMotionZ===Yc?(i=this._linearLimitsZ.x,o=this._linearLimitsZ.y):this._linearMotionZ===qc?(i=1,o=0):i=o=0;const h=new Ammo.btVector3(t,s,i);e.setLinearLowerLimit(h),h.setValue(r,a,o),e.setLinearUpperLimit(h),Ammo.destroy(h)}}_createConstraint(){if(this._entityA&&this._entityA.rigidbody){this._destroyConstraint();const e=new fe,t=this._entityA.rigidbody.body;t.activate();const s=this.entity.getWorldTransform(),r=this._entityA.getWorldTransform().clone().invert();e.mul2(r,s);const a=new Ammo.btTransform;if(this._convertTransform(e,a),this._entityB&&this._entityB.rigidbody){const f=this._entityB.rigidbody.body;f.activate();const _=this._entityB.getWorldTransform().clone().invert();e.mul2(_,s);const g=new Ammo.btTransform;this._convertTransform(e,g),this._constraint=new Ammo.btGeneric6DofSpringConstraint(t,f,a,g,!this._enableCollision),Ammo.destroy(g)}else this._constraint=new Ammo.btGeneric6DofSpringConstraint(t,a,!this._enableCollision);Ammo.destroy(a);const o=["X","Y","Z","X","Y","Z"];for(let f=0;f<6;f++){const m=f<3?"_linear":"_angular";this._constraint.enableSpring(f,this[`${m}Spring${o[f]}`]),this._constraint.setDamping(f,this[`${m}Damping${o[f]}`]),this._constraint.setEquilibriumPoint(f,this[`${m}Equilibrium${o[f]}`]),this._constraint.setStiffness(f,this[`${m}Stiffness${o[f]}`])}this._constraint.setBreakingImpulseThreshold(this._breakForce),this._updateLinearLimits(),this._updateAngularLimits(),this.system.app.systems.rigidbody.dynamicsWorld.addConstraint(this._constraint,!this._enableCollision)}}_destroyConstraint(){this._constraint&&(this.system.app.systems.rigidbody.dynamicsWorld.removeConstraint(this._constraint),Ammo.destroy(this._constraint),this._constraint=null)}initFromData(e){for(const t of tj)e.hasOwnProperty(t)&&(e[t]instanceof ne?this[`_${t}`].copy(e[t]):this[`_${t}`]=e[t]);this._createConstraint()}onEnable(){this._createConstraint()}onDisable(){this._destroyConstraint()}_onSetEnabled(e,t,s){}_onBeforeRemove(){this.fire("remove")}constructor(e,t){super(e,t),this._constraint=null,this._entityA=null,this._entityB=null,this._breakForce=34e37,this._enableCollision=!0,this._linearMotionX=jc,this._linearLimitsX=new ne(0,0),this._linearSpringX=!1,this._linearStiffnessX=0,this._linearDampingX=1,this._linearEquilibriumX=0,this._linearMotionY=jc,this._linearLimitsY=new ne(0,0),this._linearSpringY=!1,this._linearStiffnessY=0,this._linearDampingY=1,this._linearEquilibriumY=0,this._linearMotionZ=jc,this._linearLimitsZ=new ne(0,0),this._linearSpringZ=!1,this._linearStiffnessZ=0,this._linearDampingZ=1,this._linearEquilibriumZ=0,this._angularMotionX=jc,this._angularLimitsX=new ne(0,0),this._angularSpringX=!1,this._angularStiffnessX=0,this._angularDampingX=1,this._angularEquilibriumX=0,this._angularMotionY=jc,this._angularLimitsY=new ne(0,0),this._angularSpringY=!1,this._angularStiffnessY=0,this._angularDampingY=1,this._angularEquilibriumY=0,this._angularMotionZ=jc,this._angularLimitsZ=new ne(0,0),this._angularSpringZ=!1,this._angularEquilibriumZ=0,this._angularDampingZ=1,this._angularStiffnessZ=0,this.on("set_enabled",this._onSetEnabled,this)}}const sj={Damping:"setDamping",Equilibrium:"setEquilibriumPoint",Spring:"enableSpring",Stiffness:"setStiffness"};["linear","angular"].forEach(c=>{["Damping","Equilibrium","Spring","Stiffness"].forEach(e=>{["X","Y","Z"].forEach(t=>{const s=c+e+t,i=`_${s}`;let r=c==="linear"?0:3;t==="Y"&&(r+=1),t==="Z"&&(r+=2),Object.defineProperty(nb.prototype,s,{get:function(){return this[i]},set:function(a){this[i]!==a&&(this[i]=a,this._constraint[sj[e]](r,a))}})})})});class ij{constructor(){this.enabled=!0}}const xT=["enabled"];class rj extends Ht{initializeComponentData(e,t,s){e.initFromData(t),super.initializeComponentData(e,t,xT)}constructor(e){super(e),this.id="joint",this.app=e,this.ComponentType=nb,this.DataType=ij,this.schema=xT}}ke._buildAccessors(nb.prototype,xT);class UL extends ke{set minWidth(e){e!==this._minWidth&&(this._minWidth=e,this.fire("resize"))}get minWidth(){return this._minWidth}set minHeight(e){e!==this._minHeight&&(this._minHeight=e,this.fire("resize"))}get minHeight(){return this._minHeight}set maxWidth(e){e!==this._maxWidth&&(this._maxWidth=e,this.fire("resize"))}get maxWidth(){return this._maxWidth}set maxHeight(e){e!==this._maxHeight&&(this._maxHeight=e,this.fire("resize"))}get maxHeight(){return this._maxHeight}set fitWidthProportion(e){e!==this._fitWidthProportion&&(this._fitWidthProportion=e,this.fire("resize"))}get fitWidthProportion(){return this._fitWidthProportion}set fitHeightProportion(e){e!==this._fitHeightProportion&&(this._fitHeightProportion=e,this.fire("resize"))}get fitHeightProportion(){return this._fitHeightProportion}set excludeFromLayout(e){e!==this._excludeFromLayout&&(this._excludeFromLayout=e,this.fire("resize"))}get excludeFromLayout(){return this._excludeFromLayout}constructor(...e){super(...e),this._minWidth=0,this._minHeight=0,this._maxWidth=null,this._maxHeight=null,this._fitWidthProportion=0,this._fitHeightProportion=0,this._excludeFromLayout=!1}}class aj{constructor(){this.enabled=!0}}const zL=["enabled"];class nj extends Ht{initializeComponentData(e,t,s){t.enabled!==void 0&&(e.enabled=t.enabled),t.minWidth!==void 0&&(e.minWidth=t.minWidth),t.minHeight!==void 0&&(e.minHeight=t.minHeight),t.maxWidth!==void 0&&(e.maxWidth=t.maxWidth),t.maxHeight!==void 0&&(e.maxHeight=t.maxHeight),t.fitWidthProportion!==void 0&&(e.fitWidthProportion=t.fitWidthProportion),t.fitHeightProportion!==void 0&&(e.fitHeightProportion=t.fitHeightProportion),t.excludeFromLayout!==void 0&&(e.excludeFromLayout=t.excludeFromLayout),super.initializeComponentData(e,t,s)}cloneComponent(e,t){const s=e.layoutchild;return this.addComponent(t,{enabled:s.enabled,minWidth:s.minWidth,minHeight:s.minHeight,maxWidth:s.maxWidth,maxHeight:s.maxHeight,fitWidthProportion:s.fitWidthProportion,fitHeightProportion:s.fitHeightProportion,excludeFromLayout:s.excludeFromLayout})}constructor(e){super(e),this.id="layoutchild",this.ComponentType=UL,this.DataType=aj,this.schema=zL}}ke._buildAccessors(UL.prototype,zL);const TT=0,oj=1,lR=2,lj=3,Eg={};Eg[We]={axis:"x",size:"width",calculatedSize:"calculatedWidth",minSize:"minWidth",maxSize:"maxWidth",fitting:"widthFitting",fittingProportion:"fitWidthProportion"};Eg[Tt]={axis:"y",size:"height",calculatedSize:"calculatedHeight",minSize:"minHeight",maxSize:"maxHeight",fitting:"heightFitting",fittingProportion:"fitHeightProportion"};const ob={};ob[We]=Tt;ob[Tt]=We;const cj={minWidth:0,minHeight:0,maxWidth:Number.POSITIVE_INFINITY,maxHeight:Number.POSITIVE_INFINITY,width:null,height:null,fitWidthProportion:0,fitHeightProportion:0},_i={NONE:"NONE",APPLY_STRETCHING:"APPLY_STRETCHING",APPLY_SHRINKING:"APPLY_SHRINKING"},gi=new ne;function kL(c){let e;const t=Eg[c],s=Eg[ob[c]];function i(O,z){return-z[t.size]*O.pivot[t.axis]}function r(O,z){return-z[s.size]*O.pivot[s.axis]}function a(O,z){return z[t.size]*(1-O.pivot[t.axis])}function o(O,z){O=O.filter(h),e=z,gi.x=e.containerSize.x-e.padding.x-e.padding.z,gi.y=e.containerSize.y-e.padding.y-e.padding.w,u(O);const X=m(f(O)),Y=g(X,_(X)),F=C(X,Y);return w(X,Y,F),P(X,Y,F),I(X)}function h(O){const z=O.entity.layoutchild;return!z||!z.enabled||!z.excludeFromLayout}function u(O){for(let z=0;z<O.length;++z){const X=O[z],Y=X.anchor;(Y.x!==0||Y.y!==0||Y.z!==0||Y.w!==0)&&(X.anchor=me.ZERO)}}function f(O){if(!e.wrap)return[O];const z=[[]],X=M(O);let Y=0;const F=e[t.fitting]===lR;for(let U=0;U<O.length;++U){z[z.length-1].length>0&&(Y+=e.spacing[t.axis]);const K=X[U][t.size];Y+=K,!F&&Y>gi[t.axis]&&z[z.length-1].length!==0&&(Y=K,z.push([])),z[z.length-1].push(O[U]),F&&Y>gi[t.axis]&&U!==O.length-1&&(Y=0,z.push([]))}return z}function m(O){const z=e.orientation===We&&e.reverseX||e.orientation===Tt&&e.reverseY,X=e.orientation===We&&e.reverseY||e.orientation===Tt&&e.reverseX;if(z)for(let Y=0;Y<O.length;++Y)z&&O[Y].reverse();return X&&O.reverse(),O}function _(O){const z=[];for(let X=0;X<O.length;++X){const Y=O[X],F=M(Y),U=x(F,t),K=S(e[t.fitting],U,gi[t.axis]);K===_i.APPLY_STRETCHING?T(F,U,t):K===_i.APPLY_SHRINKING&&E(F,U,t),z.push(F)}return z}function g(O,z){const X=[],Y=[];for(let K=0;K<O.length;++K){const se=O[K];se.largestElement=null,se.largestSize={width:Number.NEGATIVE_INFINITY,height:Number.NEGATIVE_INFINITY};for(let le=0;le<se.length;++le){const re=z[K][le];re[s.size]>se.largestSize[s.size]&&(se.largestElement=se[le],se.largestSize=re)}X.push(se.largestElement),Y.push(se.largestSize)}const F=x(Y,s),U=S(e[s.fitting],F,gi[s.axis]);U===_i.APPLY_STRETCHING?T(Y,F,s):U===_i.APPLY_SHRINKING&&E(Y,F,s);for(let K=0;K<O.length;++K){const se=O[K];for(let le=0;le<se.length;++le){const re=z[K][le],de=re[s.size],ye=O.length===1?gi[s.axis]:se.largestSize[s.size],Me=S(e[s.fitting],de,ye);Me===_i.APPLY_STRETCHING?re[s.size]=Math.min(ye,re[s.maxSize]):Me===_i.APPLY_SHRINKING&&(re[s.size]=Math.max(ye,re[s.minSize]))}}return z}function S(O,z,X){switch(O){case TT:return _i.NONE;case oj:return z<X?_i.APPLY_STRETCHING:_i.NONE;case lR:return z>=X?_i.APPLY_SHRINKING:_i.NONE;case lj:return z<X?_i.APPLY_STRETCHING:_i.APPLY_SHRINKING;default:throw new Error(`Unrecognized fitting mode: ${O}`)}}function x(O,z){const X=B(O,z.size),Y=(O.length-1)*e.spacing[z.axis];return X+Y}function T(O,z,X){const Y=ee(O,X.maxSize),F=G(O,X.fittingProportion),U=k(F,Y);let K=gi[X.axis]-z;for(let se=0;se<O.length;++se){const le=Y[se],re=b(le,K,F,U),de=O[le][X.size]+re,ye=O[le][X.maxSize],Me=Math.min(de,ye);O[le][X.size]=Me;const et=Math.max(de-Me,0),Qe=re-et;K-=Qe}}function E(O,z,X){const Y=ee(O,X.minSize,!0),F=G(O,X.fittingProportion),U=H(F),K=k(U,Y);let se=z-gi[X.axis];for(let le=0;le<O.length;++le){const re=Y[le],de=b(re,se,U,K),ye=O[re][X.size]-de,Me=O[re][X.minSize],et=Math.max(ye,Me);O[re][X.size]=et;const Qe=Math.max(et-ye,0),ls=de-Qe;se-=ls}}function b(O,z,X,Y){const F=X[O],U=Y[O];return Math.abs(F)<1e-5&&Math.abs(U)<1e-5?z:z*F/U}function C(O,z){const X={};X[t.axis]=0,X[s.axis]=0,O[t.size]=Number.NEGATIVE_INFINITY;const Y=[];for(let F=0;F<O.length;++F){const U=O[F];if(U.length===0){Y.push([]);continue}const K=[],se=z[F];for(let le=0;le<U.length;++le){const re=U[le],de=se[le];X[s.axis]-=r(re,de),X[t.axis]-=i(re,de),K[le]={},K[le][t.axis]=X[t.axis],K[le][s.axis]=X[s.axis],X[s.axis]+=r(re,de),X[t.axis]+=a(re,de)+e.spacing[t.axis]}U[t.size]=X[t.axis]-e.spacing[t.axis],U[s.size]=U.largestSize[s.size],O[t.size]=Math.max(O[t.size],U[t.size]),X[t.axis]=0,X[s.axis]+=U[s.size]+e.spacing[s.axis],Y.push(K)}return O[s.size]=X[s.axis]-e.spacing[s.axis],Y}function w(O,z,X){const Y=e.alignment[t.axis],F=e.alignment[s.axis],U=e.padding[t.axis],K=e.padding[s.axis];for(let se=0;se<O.length;++se){const le=O[se],re=z[se],de=X[se],ye=(gi[t.axis]-le[t.size])*Y+U,Me=(gi[s.axis]-O[s.size])*F+K;for(let et=0;et<le.length;++et){const Qe=(le[s.size]-re[et][s.size])*e.alignment[s.axis];de[et][t.axis]+=ye,de[et][s.axis]+=Me+Qe}}}function P(O,z,X){for(let Y=0;Y<O.length;++Y){const F=O[Y],U=z[Y],K=X[Y];for(let se=0;se<F.length;++se){const le=F[se];le[t.calculatedSize]=U[se][t.size],le[s.calculatedSize]=U[se][s.size],e.orientation===We?le.entity.setLocalPosition(K[se][t.axis],K[se][s.axis],le.entity.getLocalPosition().z):le.entity.setLocalPosition(K[se][s.axis],K[se][t.axis],le.entity.getLocalPosition().z)}}}function I(O){const z=O.width,X=O.height,Y=(gi.x-z)*e.alignment.x+e.padding.x,F=(gi.y-X)*e.alignment.y+e.padding.y;return{bounds:new me(Y,F,z,X)}}function M(O){const z=[];for(let X=0;X<O.length;++X){const Y=O[X],F=Math.max(R(Y,"minWidth"),0),U=Math.max(R(Y,"minHeight"),0),K=Math.max(R(Y,"maxWidth"),F),se=Math.max(R(Y,"maxHeight"),U),le=L(R(Y,"width"),F,K),re=L(R(Y,"height"),U,se),de=R(Y,"fitWidthProportion"),ye=R(Y,"fitHeightProportion");z.push({minWidth:F,minHeight:U,maxWidth:K,maxHeight:se,width:le,height:re,fitWidthProportion:de,fitHeightProportion:ye})}return z}function R(O,z){const X=O.entity.layoutchild;return X&&X.enabled&&X[z]!==void 0&&X[z]!==null?X[z]:O[z]!==void 0?O[z]:cj[z]}function L(O,z,X){return Math.min(Math.max(O,z),X)}function B(O,z){return O.reduce((X,Y)=>X+Y[z],0)}function G(O,z){const X=B(O,z),Y=[],F=O.length;if(X===0)for(let U=0;U<F;++U)Y.push(1/F);else for(let U=0;U<F;++U)Y.push(O[U][z]/X);return Y}function H(O){if(O.length===1)return[1];const z=[],X=O.length;for(let Y=0;Y<X;++Y)z.push((1-O[Y])/(X-1));return z}function ee(O,z,X){return O.forEach(j),O.slice().sort((Y,F)=>X?F[z]-Y[z]:Y[z]-F[z]).map(ae)}function j(O,z){O.index=z}function ae(O){return O.index}function k(O,z){const X=[];X[z[O.length-1]]=O[z[O.length-1]];for(let Y=O.length-2;Y>=0;--Y)X[z[Y]]=X[z[Y+1]]+O[z[Y]];return X}return o}const lb={};lb[We]=kL(We);lb[Tt]=kL(Tt);class hj{calculateLayout(e,t){const s=lb[t.orientation];if(s)return s(e,t);throw new Error(`Unrecognized orientation value: ${t.orientation}`)}}function cR(c){return c.element}function uj(c){return c.enabled&&c.element&&c.element.enabled}class VL extends ke{set orientation(e){e!==this._orientation&&(this._orientation=e,this._scheduleReflow())}get orientation(){return this._orientation}set reverseX(e){e!==this._reverseX&&(this._reverseX=e,this._scheduleReflow())}get reverseX(){return this._reverseX}set reverseY(e){e!==this._reverseY&&(this._reverseY=e,this._scheduleReflow())}get reverseY(){return this._reverseY}set alignment(e){e.equals(this._alignment)||(this._alignment.copy(e),this._scheduleReflow())}get alignment(){return this._alignment}set padding(e){e.equals(this._padding)||(this._padding.copy(e),this._scheduleReflow())}get padding(){return this._padding}set spacing(e){e.equals(this._spacing)||(this._spacing.copy(e),this._scheduleReflow())}get spacing(){return this._spacing}set widthFitting(e){e!==this._widthFitting&&(this._widthFitting=e,this._scheduleReflow())}get widthFitting(){return this._widthFitting}set heightFitting(e){e!==this._heightFitting&&(this._heightFitting=e,this._scheduleReflow())}get heightFitting(){return this._heightFitting}set wrap(e){e!==this._wrap&&(this._wrap=e,this._scheduleReflow())}get wrap(){return this._wrap}_isSelfOrChild(e){return e===this.entity||this.entity.children.indexOf(e)!==-1}_listenForReflowEvents(e,t){e.element&&(e.element[t]("enableelement",this._scheduleReflow,this),e.element[t]("disableelement",this._scheduleReflow,this),e.element[t]("resize",this._scheduleReflow,this),e.element[t]("set:pivot",this._scheduleReflow,this)),e.layoutchild&&(e.layoutchild[t]("set_enabled",this._scheduleReflow,this),e.layoutchild[t]("resize",this._scheduleReflow,this))}_onElementOrLayoutComponentAdd(e){this._isSelfOrChild(e)&&(this._listenForReflowEvents(e,"on"),this._scheduleReflow())}_onElementOrLayoutComponentRemove(e){this._isSelfOrChild(e)&&(this._listenForReflowEvents(e,"off"),this._scheduleReflow())}_onChildInsert(e){this._listenForReflowEvents(e,"on"),this._scheduleReflow()}_onChildRemove(e){this._listenForReflowEvents(e,"off"),this._scheduleReflow()}_scheduleReflow(){this.enabled&&this.entity&&this.entity.enabled&&!this._isPerformingReflow&&this.system.scheduleReflow(this)}reflow(){const e=cR(this.entity),t=this.entity.children.filter(uj).map(cR);if(!e||t.length===0)return;const s=Math.max(e.calculatedWidth,0),i=Math.max(e.calculatedHeight,0),r={orientation:this._orientation,reverseX:this._reverseX,reverseY:this._reverseY,alignment:this._alignment,padding:this._padding,spacing:this._spacing,widthFitting:this._widthFitting,heightFitting:this._heightFitting,wrap:this._wrap,containerSize:new ne(s,i)};this._isPerformingReflow=!0;const a=this._layoutCalculator.calculateLayout(t,r);this._isPerformingReflow=!1,this.fire("reflow",a)}onEnable(){this._scheduleReflow()}onRemove(){this.entity.off("childinsert",this._onChildInsert,this),this.entity.off("childremove",this._onChildRemove,this),this._listenForReflowEvents(this.entity,"off"),this.entity.children.forEach(e=>{this._listenForReflowEvents(e,"off")}),this.system.app.systems.element.off("add",this._onElementOrLayoutComponentAdd,this),this.system.app.systems.element.off("beforeremove",this._onElementOrLayoutComponentRemove,this),this.system.app.systems.layoutchild.off("add",this._onElementOrLayoutComponentAdd,this),this.system.app.systems.layoutchild.off("beforeremove",this._onElementOrLayoutComponentRemove,this)}constructor(e,t){super(e,t),this._orientation=We,this._reverseX=!1,this._reverseY=!0,this._alignment=new ne(0,1),this._padding=new me,this._spacing=new ne,this._widthFitting=TT,this._heightFitting=TT,this._wrap=!1,this._layoutCalculator=new hj,this._listenForReflowEvents(this.entity,"on"),this.entity.children.forEach(s=>{this._listenForReflowEvents(s,"on")}),this.entity.on("childinsert",this._onChildInsert,this),this.entity.on("childremove",this._onChildRemove,this),e.app.systems.element.on("add",this._onElementOrLayoutComponentAdd,this),e.app.systems.element.on("beforeremove",this._onElementOrLayoutComponentRemove,this),e.app.systems.layoutchild.on("add",this._onElementOrLayoutComponentAdd,this),e.app.systems.layoutchild.on("beforeremove",this._onElementOrLayoutComponentRemove,this)}}class dj{constructor(){this.enabled=!0}}const GL=["enabled"],fj=100;class mj extends Ht{initializeComponentData(e,t,s){t.enabled!==void 0&&(e.enabled=t.enabled),t.orientation!==void 0&&(e.orientation=t.orientation),t.reverseX!==void 0&&(e.reverseX=t.reverseX),t.reverseY!==void 0&&(e.reverseY=t.reverseY),t.alignment!==void 0&&(e.alignment=Array.isArray(t.alignment)?new ne(t.alignment):t.alignment),t.padding!==void 0&&(e.padding=Array.isArray(t.padding)?new me(t.padding):t.padding),t.spacing!==void 0&&(e.spacing=Array.isArray(t.spacing)?new ne(t.spacing):t.spacing),t.widthFitting!==void 0&&(e.widthFitting=t.widthFitting),t.heightFitting!==void 0&&(e.heightFitting=t.heightFitting),t.wrap!==void 0&&(e.wrap=t.wrap),super.initializeComponentData(e,t,s)}cloneComponent(e,t){const s=e.layoutgroup;return this.addComponent(t,{enabled:s.enabled,orientation:s.orientation,reverseX:s.reverseX,reverseY:s.reverseY,alignment:s.alignment,padding:s.padding,spacing:s.spacing,widthFitting:s.widthFitting,heightFitting:s.heightFitting,wrap:s.wrap})}scheduleReflow(e){this._reflowQueue.indexOf(e)===-1&&this._reflowQueue.push(e)}_onPostUpdate(){this._processReflowQueue()}_processReflowQueue(){if(this._reflowQueue.length===0)return;let e=0;for(;this._reflowQueue.length>0;){const t=this._reflowQueue.slice();this._reflowQueue.length=0,t.sort((s,i)=>s.entity.graphDepth-i.entity.graphDepth);for(let s=0;s<t.length;++s)t[s].reflow();if(++e>=fj){console.warn("Max reflow iterations limit reached, bailing.");break}}}_onRemoveComponent(e,t){t.onRemove()}destroy(){super.destroy(),this.app.systems.off("postUpdate",this._onPostUpdate,this)}constructor(e){super(e),this.id="layoutgroup",this.ComponentType=VL,this.DataType=dj,this.schema=GL,this._reflowQueue=[],this.on("beforeremove",this._onRemoveComponent,this),this.app.systems.on("postUpdate",this._onPostUpdate,this)}}ke._buildAccessors(VL.prototype,GL);class pj{destroy(e){this.map.forEach(t=>t.mesh.destroy())}constructor(){this.map=new Map}}const _j=new ks,HL=(c,e)=>{const t=_j.get(c,()=>new pj);let s=t.map.get(e);if(!s){let i,r;switch(e){case"box":i=Ct.fromGeometry(c,new sT),r={x:2,y:2,z:2,uv:2/3};break;case"capsule":i=Ct.fromGeometry(c,new YG({radius:.5,height:2})),r={x:Math.PI*2,y:Math.PI,z:Math.PI*2,uv:1/3+1/3/3*2};break;case"cone":i=Ct.fromGeometry(c,new jG({baseRadius:.5,peakRadius:0,height:1})),r={x:2.54,y:2.54,z:2.54,uv:1/3+1/3/3};break;case"cylinder":i=Ct.fromGeometry(c,new $G({radius:.5,height:1})),r={x:Math.PI,y:.79*2,z:Math.PI,uv:1/3+1/3/3*2};break;case"plane":i=Ct.fromGeometry(c,new KG({halfExtents:new ne(.5,.5),widthSegments:1,lengthSegments:1})),r={x:0,y:1,z:0,uv:1};break;case"sphere":i=Ct.fromGeometry(c,new aL({radius:.5})),r={x:Math.PI,y:Math.PI,z:Math.PI,uv:1};break;case"torus":i=Ct.fromGeometry(c,new ZG({tubeRadius:.2,ringRadius:.3})),r={x:Math.PI*.5*.5-Math.PI*.1*.1,y:.4,z:.4,uv:1};break;default:throw new Error(`Invalid primitive type: ${e}`)}i.incRefCount(),s={mesh:i,area:r},t.map.set(e,s)}return s};class WL extends ke{set meshInstances(e){this._model&&(this._model.meshInstances=e)}get meshInstances(){return this._model?this._model.meshInstances:null}set customAabb(e){if(this._customAabb=e,this._model){const t=this._model.meshInstances;if(t)for(let s=0;s<t.length;s++)t[s].setCustomAabb(this._customAabb)}}get customAabb(){return this._customAabb}set type(e){if(this._type!==e)if(this._area=null,this._type=e,e==="asset")this._asset!==null?this._bindModelAsset(this._asset):this.model=null;else{const t=HL(this.system.app.graphicsDevice,e);this._area=t.area;const s=t.mesh,i=new Dt,r=new rn;r.graph=i,r.meshInstances=[new lt(s,this._material,i)],this.model=r,this._asset=null}}get type(){return this._type}set asset(e){const t=this.system.app.assets;let s=e;if(e instanceof Ee&&(s=e.id),this._asset!==s){if(this._asset){t.off(`add:${this._asset}`,this._onModelAssetAdded,this);const i=t.get(this._asset);i&&this._unbindModelAsset(i)}if(this._asset=s,this._asset){const i=t.get(this._asset);i?this._bindModelAsset(i):(this.model=null,t.on(`add:${this._asset}`,this._onModelAssetAdded,this))}else this.model=null}}get asset(){return this._asset}set model(e){if(this._model!==e&&!(e&&e._immutable)&&(this._model&&(this._model._immutable=!1,this.removeModelFromLayers(),this._model.getGraph().destroy(),delete this._model._entity,this._clonedModel&&(this._model.destroy(),this._clonedModel=!1)),this._model=e,this._model)){this._model._immutable=!0;const t=this._model.meshInstances;for(let s=0;s<t.length;s++)t[s].castShadow=this._castShadows,t[s].receiveShadow=this._receiveShadows,t[s].setCustomAabb(this._customAabb);this.lightmapped=this._lightmapped,this.entity.addChild(this._model.graph),this.enabled&&this.entity.enabled&&this.addModelToLayers(),this._model._entity=this.entity,this.entity.animation&&this.entity.animation.setModel(this._model),this.entity.anim&&this.entity.anim.rebind(),this.type==="asset"?this.mapping=this._mapping:this._unsetMaterialEvents()}}get model(){return this._model}set lightmapped(e){if(e!==this._lightmapped&&(this._lightmapped=e,this._model)){const t=this._model.meshInstances;for(let s=0;s<t.length;s++)t[s].setLightmapped(e)}}get lightmapped(){return this._lightmapped}set castShadows(e){if(this._castShadows===e)return;const t=this._model;if(t){const s=this.layers,i=this.system.app.scene;if(this._castShadows&&!e)for(let a=0;a<s.length;a++){const o=this.system.app.scene.layers.getLayerById(this.layers[a]);o&&o.removeShadowCasters(t.meshInstances)}const r=t.meshInstances;for(let a=0;a<r.length;a++)r[a].castShadow=e;if(!this._castShadows&&e)for(let a=0;a<s.length;a++){const o=i.layers.getLayerById(s[a]);o&&o.addShadowCasters(t.meshInstances)}}this._castShadows=e}get castShadows(){return this._castShadows}set receiveShadows(e){if(this._receiveShadows!==e&&(this._receiveShadows=e,this._model)){const t=this._model.meshInstances;for(let s=0,i=t.length;s<i;s++)t[s].receiveShadow=e}}get receiveShadows(){return this._receiveShadows}set castShadowsLightmap(e){this._castShadowsLightmap=e}get castShadowsLightmap(){return this._castShadowsLightmap}set lightmapSizeMultiplier(e){this._lightmapSizeMultiplier=e}get lightmapSizeMultiplier(){return this._lightmapSizeMultiplier}set layers(e){const t=this.system.app.scene.layers;if(this.meshInstances)for(let s=0;s<this._layers.length;s++){const i=t.getLayerById(this._layers[s]);i&&i.removeMeshInstances(this.meshInstances)}this._layers.length=0;for(let s=0;s<e.length;s++)this._layers[s]=e[s];if(!(!this.enabled||!this.entity.enabled||!this.meshInstances))for(let s=0;s<this._layers.length;s++){const i=t.getLayerById(this._layers[s]);i&&i.addMeshInstances(this.meshInstances)}}get layers(){return this._layers}set batchGroupId(e){this._batchGroupId!==e&&(this.entity.enabled&&this._batchGroupId>=0&&this.system.app.batcher?.remove(Jt.MODEL,this.batchGroupId,this.entity),this.entity.enabled&&e>=0&&this.system.app.batcher?.insert(Jt.MODEL,e,this.entity),e<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled&&this.addModelToLayers(),this._batchGroupId=e)}get batchGroupId(){return this._batchGroupId}set materialAsset(e){let t=e;e instanceof Ee&&(t=e.id);const s=this.system.app.assets;if(t!==this._materialAsset){if(this._materialAsset){s.off(`add:${this._materialAsset}`,this._onMaterialAssetAdd,this);const i=s.get(this._materialAsset);i&&this._unbindMaterialAsset(i)}if(this._materialAsset=t,this._materialAsset){const i=s.get(this._materialAsset);i?this._bindMaterialAsset(i):(this._setMaterial(this.system.defaultMaterial),s.on(`add:${this._materialAsset}`,this._onMaterialAssetAdd,this))}else this._setMaterial(this.system.defaultMaterial)}}get materialAsset(){return this._materialAsset}set material(e){this._material!==e&&(this.materialAsset=null,this._setMaterial(e))}get material(){return this._material}set mapping(e){if(this._type!=="asset"||(this._unsetMaterialEvents(),e||(e={}),this._mapping=e,!this._model))return;const t=this._model.meshInstances,s=this.asset?this.system.app.assets.get(this.asset):null,i=s?s.data.mapping:null;let r=null;for(let a=0,o=t.length;a<o;a++)if(e[a]!==void 0)e[a]?(r=this.system.app.assets.get(e[a]),this._loadAndSetMeshInstanceMaterial(r,t[a],a)):t[a].material=this.system.defaultMaterial;else if(i)if(i[a]&&(i[a].material||i[a].path)){if(i[a].material!==void 0)r=this.system.app.assets.get(i[a].material);else if(i[a].path!==void 0){const h=this._getMaterialAssetUrl(i[a].path);h&&(r=this.system.app.assets.getByUrl(h))}this._loadAndSetMeshInstanceMaterial(r,t[a],a)}else t[a].material=this.system.defaultMaterial}get mapping(){return this._mapping}addModelToLayers(){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const s=e.getLayerById(this._layers[t]);s&&s.addMeshInstances(this.meshInstances)}}removeModelFromLayers(){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const s=e.getLayerById(this._layers[t]);s&&s.removeMeshInstances(this.meshInstances)}}onRemoveChild(){this._model&&this.removeModelFromLayers()}onInsertChild(){this._model&&this.enabled&&this.entity.enabled&&this.addModelToLayers()}onRemove(){this.asset=null,this.model=null,this.materialAsset=null,this._unsetMaterialEvents(),this.entity.off("remove",this.onRemoveChild,this),this.entity.off("insert",this.onInsertChild,this)}onLayersChanged(e,t){this.addModelToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||e.addMeshInstances(this.meshInstances)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||e.removeMeshInstances(this.meshInstances)}_setMaterialEvent(e,t,s,i){const r=`${t}:${s}`;this.system.app.assets.on(r,i,this),this._materialEvents||(this._materialEvents=[]),this._materialEvents[e]||(this._materialEvents[e]={}),this._materialEvents[e][r]={id:s,handler:i}}_unsetMaterialEvents(){const e=this.system.app.assets,t=this._materialEvents;if(t){for(let s=0,i=t.length;s<i;s++){if(!t[s])continue;const r=t[s];for(const a in r)e.off(a,r[a].handler,this)}this._materialEvents=null}}_getAssetByIdOrPath(e){let t=null;if(!isNaN(parseInt(e,10)))t=this.system.app.assets.get(e);else if(this.asset){const i=this._getMaterialAssetUrl(e);i&&(t=this.system.app.assets.getByUrl(i))}return t}_getMaterialAssetUrl(e){if(!this.asset)return null;const t=this.system.app.assets.get(this.asset);return t?t.getAbsoluteUrl(e):null}_loadAndSetMeshInstanceMaterial(e,t,s){const i=this.system.app.assets;e&&(e.resource?(t.material=e.resource,this._setMaterialEvent(s,"remove",e.id,function(){t.material=this.system.defaultMaterial})):(this._setMaterialEvent(s,"load",e.id,function(r){t.material=r.resource,this._setMaterialEvent(s,"remove",e.id,function(){t.material=this.system.defaultMaterial})}),this.enabled&&this.entity.enabled&&i.load(e)))}onEnable(){const e=this.system.app,t=e.scene,s=t?.layers;this._evtLayersChanged=t.on("set:layers",this.onLayersChanged,this),s&&(this._evtLayerAdded=s.on("add",this.onLayerAdded,this),this._evtLayerRemoved=s.on("remove",this.onLayerRemoved,this));const i=this._type==="asset";let r;if(this._model?this.addModelToLayers():i&&this._asset&&(r=e.assets.get(this._asset),r&&r.resource!==this._model&&this._bindModelAsset(r)),this._materialAsset&&(r=e.assets.get(this._materialAsset),r&&r.resource!==this._material&&this._bindMaterialAsset(r)),i&&this._mapping)for(const a in this._mapping)this._mapping[a]&&(r=this._getAssetByIdOrPath(this._mapping[a]),r&&!r.resource&&e.assets.load(r));this._batchGroupId>=0&&e.batcher?.insert(Jt.MODEL,this.batchGroupId,this.entity)}onDisable(){const e=this.system.app,s=e.scene.layers;this._evtLayersChanged?.off(),this._evtLayersChanged=null,s&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this._batchGroupId>=0&&e.batcher?.remove(Jt.MODEL,this.batchGroupId,this.entity),this._model&&this.removeModelFromLayers()}hide(){if(this._model){const e=this._model.meshInstances;for(let t=0,s=e.length;t<s;t++)e[t].visible=!1}}show(){if(this._model){const e=this._model.meshInstances;for(let t=0,s=e.length;t<s;t++)e[t].visible=!0}}_bindMaterialAsset(e){if(e.on("load",this._onMaterialAssetLoad,this),e.on("unload",this._onMaterialAssetUnload,this),e.on("remove",this._onMaterialAssetRemove,this),e.on("change",this._onMaterialAssetChange,this),e.resource)this._onMaterialAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindMaterialAsset(e){e.off("load",this._onMaterialAssetLoad,this),e.off("unload",this._onMaterialAssetUnload,this),e.off("remove",this._onMaterialAssetRemove,this),e.off("change",this._onMaterialAssetChange,this)}_onMaterialAssetAdd(e){this.system.app.assets.off(`add:${e.id}`,this._onMaterialAssetAdd,this),this._materialAsset===e.id&&this._bindMaterialAsset(e)}_onMaterialAssetLoad(e){this._setMaterial(e.resource)}_onMaterialAssetUnload(e){this._setMaterial(this.system.defaultMaterial)}_onMaterialAssetRemove(e){this._onMaterialAssetUnload(e)}_onMaterialAssetChange(e){}_bindModelAsset(e){if(this._unbindModelAsset(e),e.on("load",this._onModelAssetLoad,this),e.on("unload",this._onModelAssetUnload,this),e.on("change",this._onModelAssetChange,this),e.on("remove",this._onModelAssetRemove,this),e.resource)this._onModelAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindModelAsset(e){e.off("load",this._onModelAssetLoad,this),e.off("unload",this._onModelAssetUnload,this),e.off("change",this._onModelAssetChange,this),e.off("remove",this._onModelAssetRemove,this)}_onModelAssetAdded(e){this.system.app.assets.off(`add:${e.id}`,this._onModelAssetAdded,this),e.id===this._asset&&this._bindModelAsset(e)}_onModelAssetLoad(e){this.model=e.resource.clone(),this._clonedModel=!0}_onModelAssetUnload(e){this.model=null}_onModelAssetChange(e,t,s,i){t==="data"&&(this.mapping=this._mapping)}_onModelAssetRemove(e){this.model=null}_setMaterial(e){if(this._material===e)return;this._material=e;const t=this._model;if(t&&this._type!=="asset"){const s=t.meshInstances;for(let i=0,r=s.length;i<r;i++)s[i].material=e}}constructor(e,t){super(e,t),this._type="asset",this._asset=null,this._model=null,this._mapping={},this._castShadows=!0,this._receiveShadows=!0,this._materialAsset=null,this._castShadowsLightmap=!0,this._lightmapped=!1,this._lightmapSizeMultiplier=1,this.isStatic=!1,this._layers=[sn],this._batchGroupId=-1,this._customAabb=null,this._area=null,this._materialEvents=null,this._clonedModel=!1,this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._material=e.defaultMaterial,t.on("remove",this.onRemoveChild,this),t.on("removehierarchy",this.onRemoveChild,this),t.on("insert",this.onInsertChild,this),t.on("inserthierarchy",this.onInsertChild,this)}}class gj{constructor(){this.enabled=!0}}const XL=["enabled"];class vj extends Ht{initializeComponentData(e,t,s){s=["material","materialAsset","asset","castShadows","receiveShadows","castShadowsLightmap","lightmapped","lightmapSizeMultiplier","type","mapping","layers","isStatic","batchGroupId"],(t.batchGroupId===null||t.batchGroupId===void 0)&&(t.batchGroupId=-1),t.layers&&t.layers.length&&(t.layers=t.layers.slice(0));for(let i=0;i<s.length;i++)t.hasOwnProperty(s[i])&&(e[s[i]]=t[s[i]]);t.aabbCenter&&t.aabbHalfExtents&&(e.customAabb=new Ge(new D(t.aabbCenter),new D(t.aabbHalfExtents))),super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const s={type:e.model.type,asset:e.model.asset,castShadows:e.model.castShadows,receiveShadows:e.model.receiveShadows,castShadowsLightmap:e.model.castShadowsLightmap,lightmapped:e.model.lightmapped,lightmapSizeMultiplier:e.model.lightmapSizeMultiplier,isStatic:e.model.isStatic,enabled:e.model.enabled,layers:e.model.layers,batchGroupId:e.model.batchGroupId,mapping:V_({},e.model.mapping)};let i=e.model.materialAsset;!(i instanceof Ee)&&i!=null&&(i=this.app.assets.get(i));const r=e.model.material;(!r||r===this.defaultMaterial||!i||r===i.resource)&&(s.materialAsset=i);const a=this.addComponent(t,s);if(e.model.model&&e.model.type==="asset"&&!e.model.asset&&(a.model=e.model.model.clone(),a._clonedModel=!0),s.materialAsset||(a.material=r),e.model.model){const o=e.model.model.meshInstances,h=a.model.meshInstances;for(let u=0;u<o.length;u++)h[u].mask=o[u].mask,h[u].material=o[u].material,h[u].layer=o[u].layer,h[u].receiveShadow=o[u].receiveShadow}return e.model.customAabb&&(a.customAabb=e.model.customAabb.clone()),a}onRemove(e,t){t.onRemove()}constructor(e){super(e),this.id="model",this.ComponentType=WL,this.DataType=gj,this.schema=XL,this.defaultMaterial=jf(e.graphicsDevice),this.on("beforeremove",this.onRemove,this)}}ke._buildAccessors(WL.prototype,XL);const Sj=["emitterExtents","emitterRadius","emitterExtentsInner","emitterRadiusInner","loop","initialVelocity","animSpeed","normalMap","particleNormal"],yj=["numParticles","lifetime","rate","rate2","startAngle","startAngle2","lighting","halfLambert","intensity","wrap","wrapBounds","depthWrite","noFog","sort","stretch","alignToMotion","preWarm","emitterShape","animTilesX","animTilesY","animStartFrame","animNumFrames","animNumAnimations","animIndex","randomizeAnimIndex","animLoop","colorMap","localSpace","screenSpace","orientation"],xj=["scaleGraph","scaleGraph2","colorGraph","colorGraph2","alphaGraph","alphaGraph2","velocityGraph","velocityGraph2","localVelocityGraph","localVelocityGraph2","rotationSpeedGraph","rotationSpeedGraph2","radialSpeedGraph","radialSpeedGraph2"],o_=["colorMapAsset","normalMapAsset","meshAsset","renderAsset"];let $c;class Tj extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){this._setValue("enabled",e)}get enabled(){return this.data.enabled}set autoPlay(e){this._setValue("autoPlay",e)}get autoPlay(){return this.data.autoPlay}set numParticles(e){this._setValue("numParticles",e)}get numParticles(){return this.data.numParticles}set lifetime(e){this._setValue("lifetime",e)}get lifetime(){return this.data.lifetime}set rate(e){this._setValue("rate",e)}get rate(){return this.data.rate}set rate2(e){this._setValue("rate2",e)}get rate2(){return this.data.rate2}set startAngle(e){this._setValue("startAngle",e)}get startAngle(){return this.data.startAngle}set startAngle2(e){this._setValue("startAngle2",e)}get startAngle2(){return this.data.startAngle2}set loop(e){this._setValue("loop",e)}get loop(){return this.data.loop}set preWarm(e){this._setValue("preWarm",e)}get preWarm(){return this.data.preWarm}set lighting(e){this._setValue("lighting",e)}get lighting(){return this.data.lighting}set halfLambert(e){this._setValue("halfLambert",e)}get halfLambert(){return this.data.halfLambert}set intensity(e){this._setValue("intensity",e)}get intensity(){return this.data.intensity}set depthWrite(e){this._setValue("depthWrite",e)}get depthWrite(){return this.data.depthWrite}set noFog(e){this._setValue("noFog",e)}get noFog(){return this.data.noFog}set depthSoftening(e){this._setValue("depthSoftening",e)}get depthSoftening(){return this.data.depthSoftening}set sort(e){this._setValue("sort",e)}get sort(){return this.data.sort}set blendType(e){this._setValue("blendType",e)}get blendType(){return this.data.blendType}set stretch(e){this._setValue("stretch",e)}get stretch(){return this.data.stretch}set alignToMotion(e){this._setValue("alignToMotion",e)}get alignToMotion(){return this.data.alignToMotion}set emitterShape(e){this._setValue("emitterShape",e)}get emitterShape(){return this.data.emitterShape}set emitterExtents(e){this._setValue("emitterExtents",e)}get emitterExtents(){return this.data.emitterExtents}set emitterExtentsInner(e){this._setValue("emitterExtentsInner",e)}get emitterExtentsInner(){return this.data.emitterExtentsInner}set emitterRadius(e){this._setValue("emitterRadius",e)}get emitterRadius(){return this.data.emitterRadius}set emitterRadiusInner(e){this._setValue("emitterRadiusInner",e)}get emitterRadiusInner(){return this.data.emitterRadiusInner}set initialVelocity(e){this._setValue("initialVelocity",e)}get initialVelocity(){return this.data.initialVelocity}set wrap(e){this._setValue("wrap",e)}get wrap(){return this.data.wrap}set wrapBounds(e){this._setValue("wrapBounds",e)}get wrapBounds(){return this.data.wrapBounds}set localSpace(e){this._setValue("localSpace",e)}get localSpace(){return this.data.localSpace}set screenSpace(e){this._setValue("screenSpace",e)}get screenSpace(){return this.data.screenSpace}set colorMapAsset(e){this._setValue("colorMapAsset",e)}get colorMapAsset(){return this.data.colorMapAsset}set normalMapAsset(e){this._setValue("normalMapAsset",e)}get normalMapAsset(){return this.data.normalMapAsset}set mesh(e){this._setValue("mesh",e)}get mesh(){return this.data.mesh}set meshAsset(e){this._setValue("meshAsset",e)}get meshAsset(){return this.data.meshAsset}set renderAsset(e){this._setValue("renderAsset",e)}get renderAsset(){return this.data.renderAsset}set orientation(e){this._setValue("orientation",e)}get orientation(){return this.data.orientation}set particleNormal(e){this._setValue("particleNormal",e)}get particleNormal(){return this.data.particleNormal}set localVelocityGraph(e){this._setValue("localVelocityGraph",e)}get localVelocityGraph(){return this.data.localVelocityGraph}set localVelocityGraph2(e){this._setValue("localVelocityGraph2",e)}get localVelocityGraph2(){return this.data.localVelocityGraph2}set velocityGraph(e){this._setValue("velocityGraph",e)}get velocityGraph(){return this.data.velocityGraph}set velocityGraph2(e){this._setValue("velocityGraph2",e)}get velocityGraph2(){return this.data.velocityGraph2}set rotationSpeedGraph(e){this._setValue("rotationSpeedGraph",e)}get rotationSpeedGraph(){return this.data.rotationSpeedGraph}set rotationSpeedGraph2(e){this._setValue("rotationSpeedGraph2",e)}get rotationSpeedGraph2(){return this.data.rotationSpeedGraph2}set radialSpeedGraph(e){this._setValue("radialSpeedGraph",e)}get radialSpeedGraph(){return this.data.radialSpeedGraph}set radialSpeedGraph2(e){this._setValue("radialSpeedGraph2",e)}get radialSpeedGraph2(){return this.data.radialSpeedGraph2}set scaleGraph(e){this._setValue("scaleGraph",e)}get scaleGraph(){return this.data.scaleGraph}set scaleGraph2(e){this._setValue("scaleGraph2",e)}get scaleGraph2(){return this.data.scaleGraph2}set colorGraph(e){this._setValue("colorGraph",e)}get colorGraph(){return this.data.colorGraph}set colorGraph2(e){this._setValue("colorGraph2",e)}get colorGraph2(){return this.data.colorGraph2}set alphaGraph(e){this._setValue("alphaGraph",e)}get alphaGraph(){return this.data.alphaGraph}set alphaGraph2(e){this._setValue("alphaGraph2",e)}get alphaGraph2(){return this.data.alphaGraph2}set colorMap(e){this._setValue("colorMap",e)}get colorMap(){return this.data.colorMap}set normalMap(e){this._setValue("normalMap",e)}get normalMap(){return this.data.normalMap}set animTilesX(e){this._setValue("animTilesX",e)}get animTilesX(){return this.data.animTilesX}set animTilesY(e){this._setValue("animTilesY",e)}get animTilesY(){return this.data.animTilesY}set animStartFrame(e){this._setValue("animStartFrame",e)}get animStartFrame(){return this.data.animStartFrame}set animNumFrames(e){this._setValue("animNumFrames",e)}get animNumFrames(){return this.data.animNumFrames}set animNumAnimations(e){this._setValue("animNumAnimations",e)}get animNumAnimations(){return this.data.animNumAnimations}set animIndex(e){this._setValue("animIndex",e)}get animIndex(){return this.data.animIndex}set randomizeAnimIndex(e){this._setValue("randomizeAnimIndex",e)}get randomizeAnimIndex(){return this.data.randomizeAnimIndex}set animSpeed(e){this._setValue("animSpeed",e)}get animSpeed(){return this.data.animSpeed}set animLoop(e){this._setValue("animLoop",e)}get animLoop(){return this.data.animLoop}set layers(e){this._setValue("layers",e)}get layers(){return this.data.layers}set drawOrder(e){this._drawOrder=e,this.emitter&&(this.emitter.drawOrder=e)}get drawOrder(){return this._drawOrder}_setValue(e,t){const s=this.data,i=s[e];s[e]=t,this.fire("set",e,i,t)}addMeshInstanceToLayers(){if(this.emitter)for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&(t.addMeshInstances([this.emitter.meshInstance]),this.emitter._layer=t)}}removeMeshInstanceFromLayers(){if(this.emitter)for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&t.removeMeshInstances([this.emitter.meshInstance])}}onSetLayers(e,t,s){if(this.emitter){for(let i=0;i<t.length;i++){const r=this.system.app.scene.layers.getLayerById(t[i]);r&&r.removeMeshInstances([this.emitter.meshInstance])}if(!(!this.enabled||!this.entity.enabled))for(let i=0;i<s.length;i++){const r=this.system.app.scene.layers.getLayerById(s[i]);r&&r.addMeshInstances([this.emitter.meshInstance])}}}onLayersChanged(e,t){this.addMeshInstanceToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){!this.emitter||this.layers.indexOf(e.id)<0||e.addMeshInstances([this.emitter.meshInstance])}onLayerRemoved(e){!this.emitter||this.layers.indexOf(e.id)<0||e.removeMeshInstances([this.emitter.meshInstance])}_bindColorMapAsset(e){if(e.on("load",this._onColorMapAssetLoad,this),e.on("unload",this._onColorMapAssetUnload,this),e.on("remove",this._onColorMapAssetRemove,this),e.on("change",this._onColorMapAssetChange,this),e.resource)this._onColorMapAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindColorMapAsset(e){e.off("load",this._onColorMapAssetLoad,this),e.off("unload",this._onColorMapAssetUnload,this),e.off("remove",this._onColorMapAssetRemove,this),e.off("change",this._onColorMapAssetChange,this)}_onColorMapAssetLoad(e){this.colorMap=e.resource}_onColorMapAssetUnload(e){this.colorMap=null}_onColorMapAssetRemove(e){this._onColorMapAssetUnload(e)}_onColorMapAssetChange(e){}onSetColorMapAsset(e,t,s){const i=this.system.app.assets;if(t){const r=i.get(t);r&&this._unbindColorMapAsset(r)}if(s){s instanceof Ee&&(this.data.colorMapAsset=s.id,s=s.id);const r=i.get(s);r?this._bindColorMapAsset(r):i.once(`add:${s}`,a=>{this._bindColorMapAsset(a)})}else this.colorMap=null}_bindNormalMapAsset(e){if(e.on("load",this._onNormalMapAssetLoad,this),e.on("unload",this._onNormalMapAssetUnload,this),e.on("remove",this._onNormalMapAssetRemove,this),e.on("change",this._onNormalMapAssetChange,this),e.resource)this._onNormalMapAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindNormalMapAsset(e){e.off("load",this._onNormalMapAssetLoad,this),e.off("unload",this._onNormalMapAssetUnload,this),e.off("remove",this._onNormalMapAssetRemove,this),e.off("change",this._onNormalMapAssetChange,this)}_onNormalMapAssetLoad(e){this.normalMap=e.resource}_onNormalMapAssetUnload(e){this.normalMap=null}_onNormalMapAssetRemove(e){this._onNormalMapAssetUnload(e)}_onNormalMapAssetChange(e){}onSetNormalMapAsset(e,t,s){const i=this.system.app.assets;if(t){const r=i.get(t);r&&this._unbindNormalMapAsset(r)}if(s){s instanceof Ee&&(this.data.normalMapAsset=s.id,s=s.id);const r=i.get(s);r?this._bindNormalMapAsset(r):i.once(`add:${s}`,a=>{this._bindNormalMapAsset(a)})}else this.normalMap=null}_bindMeshAsset(e){if(e.on("load",this._onMeshAssetLoad,this),e.on("unload",this._onMeshAssetUnload,this),e.on("remove",this._onMeshAssetRemove,this),e.on("change",this._onMeshAssetChange,this),e.resource)this._onMeshAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindMeshAsset(e){e.off("load",this._onMeshAssetLoad,this),e.off("unload",this._onMeshAssetUnload,this),e.off("remove",this._onMeshAssetRemove,this),e.off("change",this._onMeshAssetChange,this)}_onMeshAssetLoad(e){this._onMeshChanged(e.resource)}_onMeshAssetUnload(e){this.mesh=null}_onMeshAssetRemove(e){this._onMeshAssetUnload(e)}_onMeshAssetChange(e){}onSetMeshAsset(e,t,s){const i=this.system.app.assets;if(t){const r=i.get(t);r&&this._unbindMeshAsset(r)}if(s){s instanceof Ee&&(this.data.meshAsset=s.id,s=s.id);const r=i.get(s);r&&this._bindMeshAsset(r)}else this._onMeshChanged(null)}onSetMesh(e,t,s){!s||s instanceof Ee||typeof s=="number"?this.meshAsset=s:this._onMeshChanged(s)}_onMeshChanged(e){e&&!(e instanceof Ct)&&(e.meshInstances[0]?e=e.meshInstances[0].mesh:e=null),this.data.mesh=e,this.emitter&&(this.emitter.mesh=e,this.emitter.resetMaterial(),this.rebuild())}onSetRenderAsset(e,t,s){const i=this.system.app.assets;if(t){const r=i.get(t);r&&this._unbindRenderAsset(r)}if(s){s instanceof Ee&&(this.data.renderAsset=s.id,s=s.id);const r=i.get(s);r&&this._bindRenderAsset(r)}else this._onRenderChanged(null)}_bindRenderAsset(e){if(e.on("load",this._onRenderAssetLoad,this),e.on("unload",this._onRenderAssetUnload,this),e.on("remove",this._onRenderAssetRemove,this),e.resource)this._onRenderAssetLoad(e);else{if(!this.enabled||!this.entity.enabled)return;this.system.app.assets.load(e)}}_unbindRenderAsset(e){e.off("load",this._onRenderAssetLoad,this),e.off("unload",this._onRenderAssetUnload,this),e.off("remove",this._onRenderAssetRemove,this),this._evtSetMeshes?.off(),this._evtSetMeshes=null}_onRenderAssetLoad(e){this._onRenderChanged(e.resource)}_onRenderAssetUnload(e){this._onRenderChanged(null)}_onRenderAssetRemove(e){this._onRenderAssetUnload(e)}_onRenderChanged(e){if(!e){this._onMeshChanged(null);return}this._evtSetMeshes?.off(),this._evtSetMeshes=e.on("set:meshes",this._onRenderSetMeshes,this),e.meshes&&this._onRenderSetMeshes(e.meshes)}_onRenderSetMeshes(e){this._onMeshChanged(e&&e[0])}onSetLoop(e,t,s){this.emitter&&(this.emitter[e]=s,this.emitter.resetTime())}onSetBlendType(e,t,s){this.emitter&&(this.emitter[e]=s,this.emitter.material.blendType=s,this.emitter.resetMaterial(),this.rebuild())}_requestDepth(){this._requestedDepth||($c||($c=this.system.app.scene.layers.getLayerById(xi)),$c&&($c.incrementCounter(),this._requestedDepth=!0))}_releaseDepth(){this._requestedDepth&&$c&&($c.decrementCounter(),this._requestedDepth=!1)}onSetDepthSoftening(e,t,s){t!==s&&(s?(this.enabled&&this.entity.enabled&&this._requestDepth(),this.emitter&&(this.emitter[e]=s)):(this.enabled&&this.entity.enabled&&this._releaseDepth(),this.emitter&&(this.emitter[e]=s)),this.emitter&&(this.reset(),this.emitter.resetMaterial(),this.rebuild()))}onSetSimpleProperty(e,t,s){this.emitter&&(this.emitter[e]=s,this.emitter.resetMaterial())}onSetComplexProperty(e,t,s){this.emitter&&(this.emitter[e]=s,this.emitter.resetMaterial(),this.rebuild(),this.reset())}onSetGraphProperty(e,t,s){this.emitter&&(this.emitter[e]=s,this.emitter.rebuildGraphs(),this.emitter.resetMaterial())}onEnable(){const e=this.system.app.scene,t=e.layers,s=this.data;for(let i=0,r=o_.length;i<r;i++){let a=s[o_[i]];if(a){if(!(a instanceof Ee))if(parseInt(a,10)>=0)a=this.system.app.assets.get(a);else continue;a&&!a.resource&&this.system.app.assets.load(a)}}if(!this.system.app.graphicsDevice.disableParticleSystem){if(!this.emitter){let i=s.mesh;i instanceof Ct||(i=null),this.emitter=new j4(this.system.app.graphicsDevice,{numParticles:s.numParticles,emitterExtents:s.emitterExtents,emitterExtentsInner:s.emitterExtentsInner,emitterRadius:s.emitterRadius,emitterRadiusInner:s.emitterRadiusInner,emitterShape:s.emitterShape,initialVelocity:s.initialVelocity,wrap:s.wrap,localSpace:s.localSpace,screenSpace:s.screenSpace,wrapBounds:s.wrapBounds,lifetime:s.lifetime,rate:s.rate,rate2:s.rate2,orientation:s.orientation,particleNormal:s.particleNormal,animTilesX:s.animTilesX,animTilesY:s.animTilesY,animStartFrame:s.animStartFrame,animNumFrames:s.animNumFrames,animNumAnimations:s.animNumAnimations,animIndex:s.animIndex,randomizeAnimIndex:s.randomizeAnimIndex,animSpeed:s.animSpeed,animLoop:s.animLoop,startAngle:s.startAngle,startAngle2:s.startAngle2,scaleGraph:s.scaleGraph,scaleGraph2:s.scaleGraph2,colorGraph:s.colorGraph,colorGraph2:s.colorGraph2,alphaGraph:s.alphaGraph,alphaGraph2:s.alphaGraph2,localVelocityGraph:s.localVelocityGraph,localVelocityGraph2:s.localVelocityGraph2,velocityGraph:s.velocityGraph,velocityGraph2:s.velocityGraph2,rotationSpeedGraph:s.rotationSpeedGraph,rotationSpeedGraph2:s.rotationSpeedGraph2,radialSpeedGraph:s.radialSpeedGraph,radialSpeedGraph2:s.radialSpeedGraph2,colorMap:s.colorMap,normalMap:s.normalMap,loop:s.loop,preWarm:s.preWarm,sort:s.sort,stretch:s.stretch,alignToMotion:s.alignToMotion,lighting:s.lighting,halfLambert:s.halfLambert,intensity:s.intensity,depthSoftening:s.depthSoftening,scene:this.system.app.scene,mesh:i,depthWrite:s.depthWrite,noFog:s.noFog,node:this.entity,blendType:s.blendType}),this.emitter.meshInstance.node=this.entity,this.emitter.drawOrder=this.drawOrder,s.autoPlay||(this.pause(),this.emitter.meshInstance.visible=!1)}this.emitter.colorMap&&this.addMeshInstanceToLayers(),this._evtLayersChanged=e.on("set:layers",this.onLayersChanged,this),t&&(this._evtLayerAdded=t.on("add",this.onLayerAdded,this),this._evtLayerRemoved=t.on("remove",this.onLayerRemoved,this)),this.enabled&&this.entity.enabled&&s.depthSoftening&&this._requestDepth()}}onDisable(){const t=this.system.app.scene.layers;this._evtLayersChanged?.off(),this._evtLayersChanged=null,t&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this.emitter&&(this.removeMeshInstanceFromLayers(),this.data.depthSoftening&&this._releaseDepth(),this.emitter.camera=null)}onBeforeRemove(){this.enabled&&(this.enabled=!1),this.emitter&&(this.emitter.destroy(),this.emitter=null);for(let e=0;e<o_.length;e++){const t=o_[e];this.data[t]&&(this[t]=null)}this.off()}reset(){this.emitter&&this.emitter.reset()}stop(){this.emitter&&(this.emitter.loop=!1,this.emitter.resetTime(),this.emitter.addTime(0,!0))}pause(){this.data.paused=!0}unpause(){this.data.paused=!1}play(){this.data.paused=!1,this.emitter&&(this.emitter.meshInstance.visible=!0,this.emitter.loop=this.data.loop,this.emitter.resetTime())}isPlaying(){return this.data.paused?!1:this.emitter&&this.emitter.loop?!0:Date.now()<=this.emitter.endTime}setInTools(){const{emitter:e}=this;e&&!e.inTools&&(e.inTools=!0,this.rebuild())}rebuild(){const e=this.enabled;this.enabled=!1,this.emitter&&this.emitter.rebuild(),this.enabled=e}constructor(e,t){super(e,t),this._requestedDepth=!1,this._drawOrder=0,this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._evtSetMeshes=null,this.on("set_colorMapAsset",this.onSetColorMapAsset,this),this.on("set_normalMapAsset",this.onSetNormalMapAsset,this),this.on("set_meshAsset",this.onSetMeshAsset,this),this.on("set_mesh",this.onSetMesh,this),this.on("set_renderAsset",this.onSetRenderAsset,this),this.on("set_loop",this.onSetLoop,this),this.on("set_blendType",this.onSetBlendType,this),this.on("set_depthSoftening",this.onSetDepthSoftening,this),this.on("set_layers",this.onSetLayers,this),Sj.forEach(s=>{this.on(`set_${s}`,this.onSetSimpleProperty,this)}),yj.forEach(s=>{this.on(`set_${s}`,this.onSetComplexProperty,this)}),xj.forEach(s=>{this.on(`set_${s}`,this.onSetGraphProperty,this)})}}class Ej{constructor(){this.numParticles=1,this.rate=1,this.rate2=null,this.startAngle=0,this.startAngle2=null,this.lifetime=50,this.emitterExtents=new D,this.emitterExtentsInner=new D,this.emitterRadius=0,this.emitterRadiusInner=0,this.emitterShape=Lr,this.initialVelocity=0,this.wrap=!1,this.wrapBounds=new D,this.localSpace=!1,this.screenSpace=!1,this.colorMap=null,this.colorMapAsset=null,this.normalMap=null,this.normalMapAsset=null,this.loop=!0,this.preWarm=!1,this.sort=0,this.mode=D2,this.scene=null,this.lighting=!1,this.halfLambert=!1,this.intensity=1,this.stretch=0,this.alignToMotion=!1,this.depthSoftening=0,this.renderAsset=null,this.meshAsset=null,this.mesh=null,this.depthWrite=!1,this.noFog=!1,this.orientation=lg,this.particleNormal=new D(0,1,0),this.animTilesX=1,this.animTilesY=1,this.animStartFrame=0,this.animNumFrames=1,this.animNumAnimations=1,this.animIndex=0,this.randomizeAnimIndex=!1,this.animSpeed=1,this.animLoop=!0,this.scaleGraph=null,this.scaleGraph2=null,this.colorGraph=null,this.colorGraph2=null,this.alphaGraph=null,this.alphaGraph2=null,this.localVelocityGraph=null,this.localVelocityGraph2=null,this.velocityGraph=null,this.velocityGraph2=null,this.rotationSpeedGraph=null,this.rotationSpeedGraph2=null,this.radialSpeedGraph=null,this.radialSpeedGraph2=null,this.blendType=jr,this.enabled=!0,this.paused=!1,this.autoPlay=!0,this.layers=[sn]}}var bj=`
varying vec4 texCoordsAlphaLife;
uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;
#ifndef CAMERAPLANES
	#define CAMERAPLANES
	uniform vec4 camera_params;
#endif
#ifdef SOFT
	uniform float softening;
#endif
uniform float colorMult;
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
void main(void) {
	vec4 tex  = texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));
	vec4 ramp = texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0));
	ramp.rgb *= colorMult;
	ramp.a += texCoordsAlphaLife.z;
	vec3 rgb = tex.rgb * ramp.rgb;
	float a  = tex.a * ramp.a;
`,Aj=`
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {
	return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}
vec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex,tc);
	vec4 b = texture2D(tex,tc + graphSampleSize);
	float c = fract(tc.x*graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a, b, c);
}
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
	#ifdef SCREEN_SPACE
		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
	#else
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
vec2 safeNormalize(vec2 v) {
	float l = length(v);
	return (l > 1e-06) ? v / l : v;
}
void main(void) {
	vec3 meshLocalPos = particle_vertexData.xyz;
	float id = floor(particle_vertexData.w);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
	float uv = id / numParticlesPot;
	readInput(uv);
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);
	float particleLifetime = lifetime;
	if (inLife <= 0.0 || inLife > particleLifetime || !inShow)
		meshLocalPos = vec3(0.0);
	vec2 quadXY = meshLocalPos.xy;
	float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);
	vec3 paramDiv;
	vec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);
	float scale = params.y;
	float scaleDiv = paramDiv.x;
	float alphaDiv = paramDiv.z;
	scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);
#ifndef USE_MESH
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
	texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif
	vec3 particlePos = inPos;
	vec3 particlePosMoved = vec3(0.0);
	mat2 rotMatrix;
`,wj=`
	float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`,Cj=`
	float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`,Dj=`
	float animationIndex;
	if (animTexIndexParams.y == 1.0) {
		animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
	} else {
		animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
	}
	float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
	float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
	atlasX = fract(atlasX);
	texCoordsAlphaLife.xy *= animTexTilesParams.xy;
	texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`,Pj=`
void readInput(float uv) {
	vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));
	inPos = tex.xyz;
	inVel = tex2.xyz;
	inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
	inShow = tex.w >= 0.0;
	inLife = tex2.w;
}
`,Rj=`
#define PI2 6.283185307179586
uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;
uniform float maxVel;
float decodeFloatRG(vec2 rg) {
	return rg.y * (1.0 / 255.0) + rg.x;
}
float decodeFloatRGBA( vec4 rgba ) {
	return dot(rgba, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));
}
void readInput(float uv) {
	vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
	vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
	vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));
	inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
	inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;
	inVel = tex2.xyz;
	inVel = (inVel - vec3(0.5)) * maxVel;
	inAngle = decodeFloatRG(tex1.ba) * PI2;
	inShow = tex2.a > 0.5;
	inLife = decodeFloatRGBA(tex3);
	float maxNegLife = max(lifetime, numParticles * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`,Mj=`
void writeOutput() {
	if (gl_FragCoord.y<1.0) {
		gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
	} else {
		gl_FragColor = vec4(outVel, outLife);
	}
}
`,Lj=`
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;
vec2 encodeFloatRG( float v ) {
	vec2 enc = vec2(1.0, 255.0) * v;
	enc = fract(enc);
	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
	return enc;
}
vec4 encodeFloatRGBA( float v ) {
	vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
	enc = fract(enc);
	enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
	return enc;
}
void writeOutput() {
	outPos = outPos * outBoundsMul + outBoundsAdd;
	outAngle = fract(outAngle / PI2);
	outVel = (outVel / maxVel) + vec3(0.5);
	float maxNegLife = max(lifetime, numParticles * (rate+rateDiv));
	float maxPosLife = lifetime+1.0;
	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);
	if (gl_FragCoord.y < 1.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
	} else if (gl_FragCoord.y < 2.0) {
		gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
	} else if (gl_FragCoord.y < 3.0) {
		gl_FragColor = vec4(outVel, visMode*0.5+0.5);
	} else {
		gl_FragColor = encodeFloatRGBA(outLife);
	}
}
`,Ij=`
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	vec3 pos = inBounds - vec3(0.5);
	vec3 posAbs = abs(pos);
	vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));
	vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;
	pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
	pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
	pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);
#ifndef LOCAL_SPACE
	return emitterPos + spawnBounds * pos;
#else
	return spawnBounds * pos;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity -= vec3(0, 0, initialVelocity);
}
`,Oj=`
	writeOutput();
}
`,Nj=`
varying vec2 vUv0;
uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;
uniform mat3 emitterMatrix;
uniform mat3 emitterMatrixInv;
uniform vec3 emitterScale;
uniform vec3 emitterPos;
uniform vec3 frameRandom;
uniform vec3 localVelocityDivMult;
uniform vec3 velocityDivMult;
uniform float delta;
uniform float rate;
uniform float rateDiv;
uniform float lifetime;
uniform float numParticles;
uniform float rotSpeedDivMult;
uniform float radialSpeedDivMult;
uniform float seed;
uniform float startAngle;
uniform float startAngle2;
uniform float initialVelocity;
uniform float graphSampleSize;
uniform float graphNumSamples;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;
vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`,Fj=`
	if (outLife >= lifetime) {
		outLife -= max(lifetime, numParticles * particleRate);
		visMode = -1.0;
	}
`,Bj=`
	visMode = outLife < 0.0? -1.0: visMode;
`,Uj=`
	if (outLife >= lifetime) {
		outLife -= max(lifetime, numParticles * particleRate);
		visMode = 1.0;
	}
	visMode = outLife < 0.0? 1.0: visMode;
`,zj=`
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;
vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
	float rnd4 = fract(rndFactor * 1000.0);
	vec3 norm = normalize(inBounds.xyz - vec3(0.5));
	float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
	return emitterPos + norm * r * spawnBoundsSphere;
#else
	return norm * r * spawnBoundsSphere;
#endif
}
void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
	localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`,kj=`
float saturate(float x) {
	return clamp(x, 0.0, 1.0);
}
vec3 unpack3NFloats(float src) {
	float r = fract(src);
	float g = fract(src * 256.0);
	float b = fract(src * 65536.0);
	return vec3(r, g, b);
}
vec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {
	vec4 a = texture2D(tex, tc);
	vec4 b = texture2D(tex, tc + graphSampleSize);
	float c = fract(tc.x * graphNumSamples);
	vec3 unpackedA = unpack3NFloats(a.w);
	vec3 unpackedB = unpack3NFloats(b.w);
	w = mix(unpackedA, unpackedB, c);
	return mix(a.xyz, b.xyz, c);
}
#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
	vec4 p4 = fract(vec4(p) * HASHSCALE4);
	p4 += dot(p4, p4.wzxy+19.19);
	return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}
void main(void) {
	if (gl_FragCoord.x > numParticles) discard;
	readInput(vUv0.x);
	visMode = inShow? 1.0 : -1.0;
	vec4 rndFactor = hash41(gl_FragCoord.x + seed);
	float particleRate = rate + rateDiv * rndFactor.x;
	outLife = inLife + delta;
	float nlife = clamp(outLife / lifetime, 0.0, 1.0);
	vec3 localVelocityDiv;
	vec3 velocityDiv;
	vec3 paramDiv;
	vec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);
	vec3 velocity =	  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);
	vec3 params =		tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);
	float rotSpeed = params.x;
	float rotSpeedDiv = paramDiv.y;
	vec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);
	float radialSpeed = radialParams.x;
	float radialSpeedDiv = radialParams.y;
	bool respawn = inLife <= 0.0 || outLife >= lifetime;
	inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
	inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;
#ifndef LOCAL_SPACE
	vec3 radialVel = inPos - emitterPos;
#else
	vec3 radialVel = inPos;
#endif
	radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
	radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;
	localVelocity +=	(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
	velocity +=		 (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
	rotSpeed +=		 (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;
	addInitialVelocity(localVelocity, rndFactor.xyz);
#ifndef LOCAL_SPACE
	outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
	outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif
	outPos = inPos + outVel * delta;
	outAngle = inAngle + rotSpeed * delta;
`,Vj=`
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = billboard(particlePos, quadXY);
`,Gj=`
	dBlendModeFogFactor = 0.0;
	rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
	if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`,Hj=`
	rgb = mix(vec3(1.0), rgb, vec3(a));
	if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`,Wj=`
	if (a < 0.01) discard;
`,Xj=`
attribute vec4 particle_vertexData;
attribute vec4 particle_vertexData2;
attribute vec4 particle_vertexData3;
attribute float particle_vertexData4;
#ifndef USE_MESH
	attribute vec2 particle_vertexData5;
#else
	attribute vec4 particle_vertexData5;
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform mat4 matrix_view;
#endif
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 emitterScale;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
#ifdef PARTICLE_GPU
	#ifdef WRAP
		uniform vec3 wrapBounds;
	#endif
#endif
#ifdef PARTICLE_GPU
	uniform highp sampler2D internalTex0;
	uniform highp sampler2D internalTex1;
	uniform highp sampler2D internalTex2;
#endif
uniform vec3 emitterPos;
varying vec4 texCoordsAlphaLife;
vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
	float c = cos(pRotation);
	float s = sin(pRotation);
	mat2 m = mat2(c, -s, s, c);
	rotMatrix = m;
	return m * quadXY;
}
vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
	#ifdef SCREEN_SPACE
		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
	#else
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
	return pos;
}
void main(void)
{
	vec3 particlePos = particle_vertexData.xyz;
	vec3 inPos = particlePos;
	vec3 vertPos = particle_vertexData3.xyz;
	vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);
	float id = floor(particle_vertexData4);
	float rndFactor = fract(sin(id + 1.0 + seed));
	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
#ifdef LOCAL_SPACE
	inVel = mat3(matrix_model) * inVel;
#endif
	vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);
	vec2 quadXY = vertPos.xy;
#ifdef USE_MESH
	texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
	mat2 rotMatrix;
	float inAngle = particle_vertexData2.x;
	vec3 particlePosMoved = vec3(0.0);
	vec3 meshLocalPos = particle_vertexData3.xyz;
`,qj=`
	localPos *= particle_vertexData2.y * emitterScale;
	localPos += particlePos;
	#ifdef SCREEN_SPACE
	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
	#else
	gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
	#endif
`,Yj=`
	quadXY = rotate(quadXY, inAngle, rotMatrix);
	vec3 localPos = customFace(particlePos, quadXY);
`,jj=`
	rgb = addFog(rgb);
	rgb = toneMap(rgb);
	rgb = gammaCorrectOutput(rgb);
	gl_FragColor = vec4(rgb, a);
}
`,$j=`
	localPos *= scale * emitterScale;
	localPos += particlePos;
	#ifdef SCREEN_SPACE
	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
	#else
	gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
	#endif
`,Kj=`
	vec3 negNormal = normal * 0.5 + 0.5;
	vec3 posNormal = -normal * 0.5 + 0.5;
	negNormal *= negNormal;
	posNormal *= posNormal;
`,Zj=`
attribute vec4 particle_vertexData;
#if defined(USE_MESH)
	#if defined(USE_MESH_UV)
		attribute vec2 particle_uv;
	#else
		vec2 particle_uv = vec2(0.0, 0.0);
	#endif
#endif
uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform mat4 matrix_view;
#endif
uniform float numParticles;
uniform float numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 emitterScale;
uniform vec3 emitterPos;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
uniform float rate;
uniform float rateDiv;
uniform float lifetime;
uniform float scaleDivMult;
uniform float alphaDivMult;
uniform float seed;
uniform float delta;
uniform sampler2D particleTexOUT;
uniform sampler2D particleTexIN;
#ifdef PARTICLE_GPU
	#ifdef WRAP
		uniform vec3 wrapBounds;
	#endif
#endif
#ifdef PARTICLE_GPU
	uniform highp sampler2D internalTex0;
	uniform highp sampler2D internalTex1;
	uniform highp sampler2D internalTex2;
#endif
#ifndef CAMERAPLANES
	#define CAMERAPLANES
	uniform vec4 camera_params;
#endif
varying vec4 texCoordsAlphaLife;
vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`,Qj=`
	vec3 negNormal = max(normal, vec3(0.0));
	vec3 posNormal = max(-normal, vec3(0.0));
`,Jj=`
	vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
						negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
						negNormal.z*lightCube[4] + posNormal.z*lightCube[5];
	rgb *= light;
`,e$=`
	particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`,t$=`
	vec3 localPos = meshLocalPos;
	localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
	localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);
	billboard(particlePos, quadXY);
`,s$=`
	Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`,i$=`
	vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
	vec3 normal = ParticleMat * normalMap;
`,r$=`
	inAngle = atan(velocityV.x, velocityV.y);
`,a$=`
	#include "particleUpdaterInitPS"
	#ifdef PACK8
		#include "particleInputRgba8PS"
		#include "particleOutputRgba8PS"
	#else
		#include "particleInputFloatPS"
		#include "particleOutputFloatPS"
	#endif
	#ifdef EMITTERSHAPE_BOX
		#include "particleUpdaterAABBPS"
	#else
		#include "particleUpdaterSpherePS"
	#endif
	#include "particleUpdaterStartPS"
	#ifdef RESPAWN
		#include "particleUpdaterRespawnPS"
	#endif
	#ifdef NO_RESPAWN
		#include "particleUpdaterNoRespawnPS"
	#endif
	#ifdef ON_STOP
		#include "particleUpdaterOnStopPS"
	#endif
	#include "particleUpdaterEndPS"
`,n$=`
	#if NORMAL != NONE
		#if NORMAL == VERTEX
			varying vec3 Normal;
		#endif
		#if NORMAL == MAP
			varying mat3 ParticleMat;
		#endif
		uniform vec3 lightCube[6];
	#endif
	#ifdef SOFT
		varying float vDepth;
		#include "screenDepthPS"
	#endif
	#include "gammaPS"
	#include "tonemappingPS"
	#include "fogPS"
	#if NORMAL == MAP
		uniform sampler2D normalMap;
	#endif
	#include "particlePS"
	#ifdef SOFT
		#include "particle_softPS"
	#endif
	#if NORMAL == VERTEX
		vec3 normal = Normal;
	#endif
	#if NORMAL == MAP
		#include "particle_normalMapPS"
	#endif
	#if NORMAL != NONE
		#ifdef HALF_LAMBERT
			#include "particle_halflambertPS"
		#else
			#include "particle_lambertPS"
		#endif
		#include "particle_lightingPS"
	#endif
	#if BLEND == NORMAL
		#include "particle_blendNormalPS"
	#elif BLEND == ADDITIVE
		#include "particle_blendAddPS"
	#elif BLEND == MULTIPLICATIVE
		#include "particle_blendMultiplyPS"
	#endif
	#include "particle_endPS"
`,o$=`
	#ifdef ANIMTEX
		uniform vec2 animTexTilesParams;
		uniform vec4 animTexParams;
		uniform vec2 animTexIndexParams;
	#endif
	#if NORMAL == MAP
		varying mat3 ParticleMat;
	#endif
	#if NORMAL == VERTEX
		varying vec3 Normal;
	#endif
	#ifdef SOFT
		varying float vDepth;
	#endif
	#ifdef PARTICLE_GPU
		#include "particle_initVS"
		#ifdef PACK8
			#include "particleInputRgba8PS"
		#else
			#include  "particleInputFloatPS"
		#endif
		#ifdef SOFT
			#include "screenDepthPS"
		#endif
		#include "particleVS"
	#else
		#ifdef SOFT
			#include "screenDepthPS"
		#endif
		#include "particle_cpuVS"
	#endif
	#ifdef LOCAL_SPACE
		#include "particle_localShiftVS"
	#endif
	#ifdef ANIMTEX
		#ifdef ANIMTEX_LOOP
			#include "particleAnimFrameLoopVS"
		#else
			#include "particleAnimFrameClampVS"
		#endif
		#include "particleAnimTexVS"
	#endif
	#ifdef PARTICLE_GPU
		#ifdef WRAP
			#include "particle_wrapVS"
		#endif
	#endif
	#ifdef ALIGN_TO_MOTION
		#include "particle_pointAlongVS"
	#endif
	#ifdef USE_MESH
		#include "particle_meshVS"
	#else
		#ifdef CUSTOM_FACE
			#include "particle_customFaceVS"
		#else
			#include "particle_billboardVS"
		#endif
	#endif
	#if NORMAL == VERTEX
		#include "particle_normalVS"
	#endif
	#if NORMAL == MAP
		#include "particle_TBNVS"
	#endif
	#ifdef STRETCH
		#include "particle_stretchVS"
	#endif
	#ifdef PARTICLE_GPU
		#include "particle_endVS"
	#else
		#include "particle_cpu_endVS"
	#endif
	#ifdef SOFT
		#include "particle_softVS"
	#endif
	}
`,l$=`
	float depth = getLinearScreenDepth();
	float particleDepth = vDepth;
	float depthDiff = saturate(abs(particleDepth - depth) * softening);
	a *= depthDiff;
`,c$=`
	vDepth = getLinearDepth(localPos);
`,h$=`
	vec3 moveDir = inVel * stretch;
	vec3 posPrev = particlePos - moveDir;
	posPrev += particlePosMoved;
	vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);
	float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;
	particlePos = mix(particlePos, posPrev, interpolation);
`,u$=`
	mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
	ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`,d$=`
	vec3 origParticlePos = particlePos;
	particlePos -= matrix_model[3].xyz;
	particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
	particlePos += matrix_model[3].xyz;
	particlePosMoved = particlePos - origParticlePos;
`;const f$={particlePS:bj,particleVS:Aj,particleAnimFrameClampVS:wj,particleAnimFrameLoopVS:Cj,particleAnimTexVS:Dj,particleInputFloatPS:Pj,particleInputRgba8PS:Rj,particleOutputFloatPS:Mj,particleOutputRgba8PS:Lj,particleUpdaterAABBPS:Ij,particleUpdaterEndPS:Oj,particleUpdaterInitPS:Nj,particleUpdaterNoRespawnPS:Fj,particleUpdaterOnStopPS:Bj,particleUpdaterRespawnPS:Uj,particleUpdaterSpherePS:zj,particleUpdaterStartPS:kj,particle_billboardVS:Vj,particle_blendAddPS:Gj,particle_blendMultiplyPS:Hj,particle_blendNormalPS:Wj,particle_cpuVS:Xj,particle_cpu_endVS:qj,particle_customFaceVS:Yj,particle_endPS:jj,particle_endVS:$j,particle_halflambertPS:Kj,particle_initVS:Zj,particle_lambertPS:Qj,particle_lightingPS:Jj,particle_localShiftVS:e$,particle_meshVS:t$,particle_normalVS:s$,particle_normalMapPS:i$,particle_pointAlongVS:r$,particle_simulationPS:a$,particle_shaderPS:n$,particle_shaderVS:o$,particle_softPS:l$,particle_softVS:c$,particle_stretchVS:h$,particle_TBNVS:u$,particle_wrapVS:d$};var m$=`
varying texCoordsAlphaLife: vec4f;
var colorMap: texture_2d<f32>;
var colorMapSampler: sampler;
var colorParam: texture_2d<f32>;
var colorParamSampler: sampler;
uniform graphSampleSize: f32;
uniform graphNumSamples: f32;
#ifndef CAMERAPLANES
	#define CAMERAPLANES
	uniform camera_params: vec4f;
#endif
#ifdef SOFT
	uniform softening: f32;
#endif
uniform colorMult: f32;
fn saturate(x: f32) -> f32 {
	return clamp(x, 0.0, 1.0);
}
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	let tex: vec4f  = textureSample(colorMap, colorMapSampler, vec2f(input.texCoordsAlphaLife.x, 1.0 - input.texCoordsAlphaLife.y));
	var ramp: vec4f = textureSample(colorParam, colorParamSampler, vec2f(input.texCoordsAlphaLife.w, 0.0));
	ramp = vec4f(ramp.rgb * uniform.colorMult, ramp.a);
	ramp.a = ramp.a + input.texCoordsAlphaLife.z;
	var rgb: vec3f = tex.rgb * ramp.rgb;
	var a: f32 = tex.a * ramp.a;
`,p$=`
fn unpack3NFloats(src: f32) -> vec3f {
	let r = fract(src);
	let g = fract(src * 256.0);
	let b = fract(src * 65536.0);
	return vec3f(r, g, b);
}
fn saturate(x: f32) -> f32 {
	return clamp(x, 0.0, 1.0);
}
struct TexLerpUnpackResult {
	result: vec4f,
	unpacked: vec3f
}
fn tex1Dlod_lerp_simple(tex: texture_2d<f32>, textureSize: vec2u, tc: vec2f) -> vec4f {
	let tc_next = tc + vec2f(uniform.graphSampleSize);
	let texelA: vec2i = vec2i(tc * vec2f(textureSize));
	let texelB: vec2i = vec2i(tc_next * vec2f(textureSize));
	return mix( textureLoad(tex, texelA, 0), textureLoad(tex, texelB, 0), fract(tc.x * uniform.graphNumSamples) );
}
fn tex1Dlod_lerp_unpack(tex: texture_2d<f32>, textureSize: vec2u, tc: vec2f) -> TexLerpUnpackResult {
	let tc_next = tc + vec2f(uniform.graphSampleSize);
	let texelA: vec2i = vec2i(tc * vec2f(textureSize));
	let texelB: vec2i = vec2i(tc_next * vec2f(textureSize));
	let a = textureLoad(tex, texelA, 0);
	let b = textureLoad(tex, texelB, 0);
	let c = fract(tc.x * uniform.graphNumSamples);
	let unpackedA = unpack3NFloats(a.w);
	let unpackedB = unpack3NFloats(b.w);
	let w_out = mix(unpackedA, unpackedB, c);
	return TexLerpUnpackResult(mix(a, b, c), w_out);
}
struct RotateResult {
	rotatedVec: vec2f,
	matrix: mat2x2f
}
fn rotateWithMatrix(quadXY: vec2f, pRotation: f32) -> RotateResult {
	let c = cos(pRotation);
	let s = sin(pRotation);
	let m = mat2x2f(vec2f(c, -s), vec2f(s, c));
	return RotateResult(m * quadXY, m);
}
fn billboard(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {
	var pos: vec3f;
	#ifdef SCREEN_SPACE
		pos = vec3f(-1.0, 0.0, 0.0) * quadXY.x + vec3f(0.0, -1.0, 0.0) * quadXY.y;
	#else
		pos = -uniform.matrix_viewInverse[0].xyz * quadXY.x + -uniform.matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
fn customFace(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {
	let pos = uniform.faceTangent * quadXY.x + uniform.faceBinorm * quadXY.y;
	return pos;
}
fn safeNormalize(v: vec2f) -> vec2f {
	let l = length(v);
	return select(v, v / l, l > 1e-06);
}
@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
	var output: VertexOutput;
	let meshLocalPos_in = input.particle_vertexData.xyz;
	let id = floor(input.particle_vertexData.w);
	let rndFactor = fract(sin(id + 1.0 + uniform.seed));
	let rndFactor3 = vec3f(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
	let uv = id / uniform.numParticlesPot;
	readInput(uv);
	#ifdef LOCAL_SPACE
		let modelRotation = mat3x3f(uniform.matrix_model[0].xyz, uniform.matrix_model[1].xyz, uniform.matrix_model[2].xyz);
		inVel = modelRotation * inVel;
	#endif
	let viewRotation = mat3x3f(uniform.matrix_view[0].xyz, uniform.matrix_view[1].xyz, uniform.matrix_view[2].xyz);
	let velocityV = safeNormalize((viewRotation * inVel).xy);
	let particleLifetime = uniform.lifetime;
	var meshLocalPos = meshLocalPos_in;
	if (inLife <= 0.0 || inLife > particleLifetime || !inShow) {
		 meshLocalPos = vec3f(0.0);
	}
	let quadXY = meshLocalPos.xy;
	let nlife = clamp(inLife / particleLifetime, 0.0, 1.0);
	let internalTexSize = textureDimensions(internalTex2, 0);
	let lerp_result = tex1Dlod_lerp_unpack(internalTex2, internalTexSize, vec2f(nlife, 0.0));
	let params = lerp_result.result;
	let paramDiv = lerp_result.unpacked;
	var scale = params.y;
	let scaleDiv = paramDiv.x;
	let alphaDiv = paramDiv.z;
	scale = scale + (scaleDiv * 2.0 - 1.0) * uniform.scaleDivMult * fract(rndFactor*10000.0);
	#ifndef USE_MESH
		output.texCoordsAlphaLife = vec4f(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * uniform.alphaDivMult * fract(rndFactor*1000.0), nlife);
	#else
		output.texCoordsAlphaLife = vec4f(particle_uv, (alphaDiv * 2.0 - 1.0) * uniform.alphaDivMult * fract(rndFactor*1000.0), nlife);
	#endif
	var particlePos = inPos;
	var particlePosMoved = vec3f(0.0);
	var rotMatrix: mat2x2f;
`,_$=`
	let animFrame: f32 = min(floor(input.texCoordsAlphaLife.w * uniform.animTexParams.y) + uniform.animTexParams.x, uniform.animTexParams.z);
`,g$=`
	let animFrame: f32 = floor((output.texCoordsAlphaLife.w * uniform.animTexParams.y + uniform.animTexParams.x) % (uniform.animTexParams.z + 1.0));	
`,v$=`
	var animationIndex: f32;
	if (uniform.animTexIndexParams.y == 1.0) {
		animationIndex = floor((uniform.animTexParams.w + 1.0) * rndFactor3.z) * (uniform.animTexParams.z + 1.0);
	} else {
		animationIndex = uniform.animTexIndexParams.x * (uniform.animTexParams.z + 1.0);
	}
	var atlasX: f32 = (animationIndex + animFrame) * uniform.animTexTilesParams.x;
	let atlasY: f32 = 1.0 - floor(atlasX + 1.0) * uniform.animTexTilesParams.y;
	atlasX = fract(atlasX);
	let current_tcal_xy = output.texCoordsAlphaLife.xy;
	let scaled_tcal_xy = current_tcal_xy * uniform.animTexTilesParams.xy;
	let final_tcal_xy = scaled_tcal_xy + vec2f(atlasX, atlasY);
	output.texCoordsAlphaLife = vec4f(final_tcal_xy, output.texCoordsAlphaLife.z, output.texCoordsAlphaLife.w);
`,S$=`
fn readInput(uv: f32) {
	let textureSize = textureDimensions(particleTexIN, 0);
	let texel0: vec2i = vec2i(vec2f(uv, 0.25) * vec2f(textureSize));
	let texel1: vec2i = vec2i(vec2f(uv, 0.75) * vec2f(textureSize));
	let tex: vec4f = textureLoad(particleTexIN, texel0, 0);
	let tex2: vec4f = textureLoad(particleTexIN, texel1, 0);
	inPos = tex.xyz;
	inVel = tex2.xyz;
	inAngle = abs(tex.w) - 1000.0;
	inShow = tex.w >= 0.0;
	inLife = tex2.w;
}
`,y$=`
const PI2: f32 = 6.283185307179586;
uniform inBoundsSize: vec3f;
uniform inBoundsCenter: vec3f;
uniform maxVel: f32;
fn decodeFloatRG(rg: vec2f) -> f32 {
	return rg.y * (1.0 / 255.0) + rg.x;
}
fn decodeFloatRGBA( rgba: vec4f ) -> f32 {
	return dot(rgba, vec4f(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));
}
fn readInput(uv: f32) {
	let textureSize = textureDimensions(particleTexIN, 0);
	let texel0: vec2i = vec2i(vec2f(uv, 0.125) * vec2f(textureSize));
	let texel1: vec2i = vec2i(vec2f(uv, 0.375) * vec2f(textureSize));
	let texel2: vec2i = vec2i(vec2f(uv, 0.625) * vec2f(textureSize));
	let texel3: vec2i = vec2i(vec2f(uv, 0.875) * vec2f(textureSize));
	let tex0 = textureLoad(particleTexIN, texel0, 0);
	let tex1 = textureLoad(particleTexIN, texel1, 0);
	let tex2 = textureLoad(particleTexIN, texel2, 0);
	let tex3 = textureLoad(particleTexIN, texel3, 0);
	inPos = vec3f(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
	inPos = (inPos - vec3f(0.5)) * uniform.inBoundsSize + uniform.inBoundsCenter;
	inVel = tex2.xyz;
	inVel = (inVel - vec3f(0.5)) * uniform.maxVel;
	inAngle = decodeFloatRG(tex1.ba) * PI2;
	inShow = tex2.a > 0.5;
	let life_decoded = decodeFloatRGBA(tex3);
	let maxNegLife = max(uniform.lifetime, uniform.numParticles * (uniform.rate + uniform.rateDiv));
	let maxPosLife = uniform.lifetime + 1.0;
	inLife = life_decoded * (maxNegLife + maxPosLife) - maxNegLife;
}`,x$=`
fn getOutput() -> vec4f {
	if (pcPosition.y < 1.0) {
		return vec4f(outPos, (outAngle + 1000.0) * visMode);
	} else {
		return vec4f(outVel, outLife);
	}
}
`,T$=`
uniform outBoundsMul: vec3f;
uniform outBoundsAdd: vec3f;
fn encodeFloatRG( v: f32 ) -> vec2f {
	var enc: vec2f = vec2f(1.0, 255.0) * v;
	enc = fract(enc);
	enc = enc - enc.yy * (1.0 / 255.0);
	return enc;
}
fn encodeFloatRGBA( v: f32 ) -> vec4f {
	let factors = vec4f(1.0, 255.0, 65025.0, 160581375.0);
	var enc: vec4f = factors * v;
	enc = fract(enc);
	enc = enc - enc.yzww * vec4f(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
	return enc;
}
fn getOutput() -> vec4f {
	outPos = outPos * uniform.outBoundsMul + uniform.outBoundsAdd;
	outAngle = fract(outAngle / PI2);
	outVel = (outVel / uniform.maxVel) + vec3f(0.5);
	let maxNegLife = max(uniform.lifetime, uniform.numParticles * (uniform.rate + uniform.rateDiv));
	let maxPosLife = uniform.lifetime + 1.0;
	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);
	if (pcPosition.y < 1.0) {
		return vec4f(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
	} else if (pcPosition.y < 2.0) {
		return vec4f(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
	} else if (pcPosition.y < 3.0) {
		return vec4f(outVel, visMode * 0.5 + 0.5);
	} else {
		return encodeFloatRGBA(outLife);
	}
}
`,E$=`
uniform spawnBounds: mat3x3f;
uniform spawnPosInnerRatio: vec3f;
fn calcSpawnPosition(inBounds: vec3f, rndFactor: f32) -> vec3f {
	var pos = inBounds - vec3f(0.5);
	let posAbs = abs(pos);
	let maxComp = max(posAbs.x, max(posAbs.y, posAbs.z));
	let maxPos = vec3f(maxComp);
	let edge = maxPos + (vec3f(0.5) - maxPos) * uniform.spawnPosInnerRatio;
	pos.x = edge.x * select(2.0 * pos.x, sign(pos.x), maxPos.x == posAbs.x);
	pos.y = edge.y * select(2.0 * pos.y, sign(pos.y), maxPos.y == posAbs.y);
	pos.z = edge.z * select(2.0 * pos.z, sign(pos.z), maxPos.z == posAbs.z);
	#ifndef LOCAL_SPACE
		return uniform.emitterPos + uniform.spawnBounds * pos;
	#else
		return uniform.spawnBounds * pos;
	#endif
}
fn addInitialVelocity(localVelocity: ptr<function, vec3f>, inBounds: vec3f) {
	*localVelocity = *localVelocity - vec3f(0.0, 0.0, uniform.initialVelocity);
}
`,b$=`
	output.color = getOutput();
	return output;
}
`,A$=`
varying vUv0: vec2f;
var particleTexIN: texture_2d<uff>;
var internalTex0: texture_2d<uff>;
var internalTex1: texture_2d<uff>;
var internalTex2: texture_2d<uff>;
var internalTex3: texture_2d<uff>;
uniform emitterMatrix: mat3x3f;
uniform emitterMatrixInv: mat3x3f;
uniform emitterScale: vec3f;
uniform emitterPos: vec3f;
uniform frameRandom: vec3f;
uniform localVelocityDivMult: vec3f;
uniform velocityDivMult: vec3f;
uniform delta: f32;
uniform rate: f32;
uniform rateDiv: f32;
uniform lifetime: f32;
uniform numParticles: f32;
uniform rotSpeedDivMult: f32;
uniform radialSpeedDivMult: f32;
uniform seed: f32;
uniform startAngle: f32;
uniform startAngle2: f32;
uniform initialVelocity: f32;
uniform graphSampleSize: f32;
uniform graphNumSamples: f32;
var<private> inPos: vec3f;
var<private> inVel: vec3f;
var<private> inAngle: f32;
var<private> inShow: bool;
var<private> inLife: f32;
var<private> visMode: f32;
var<private> outPos: vec3f;
var<private> outVel: vec3f;
var<private> outAngle: f32;
var<private> outShow: bool;
var<private> outLife: f32;
`,w$=`
	if (outLife >= uniform.lifetime) {
		outLife = outLife - max(uniform.lifetime, uniform.numParticles * particleRate);
		visMode = -1.0;
	}
`,C$=`
	visMode = select(visMode, -1.0, outLife < 0.0);
`,D$=`
	if (outLife >= uniform.lifetime) {
		let subtractAmount = max(uniform.lifetime, uniform.numParticles * particleRate);
		outLife = outLife - subtractAmount;
		visMode = 1.0;
	}
	visMode = select(visMode, 1.0, outLife < 0.0);
`,P$=`
uniform spawnBoundsSphere: f32;
uniform spawnBoundsSphereInnerRatio: f32;
fn calcSpawnPosition(inBounds: vec3f, rndFactor: f32) -> vec3f {
	let rnd4: f32 = fract(rndFactor * 1000.0);
	let norm: vec3f = normalize(inBounds.xyz - vec3f(0.5));
	let r: f32 = rnd4 * (1.0 - uniform.spawnBoundsSphereInnerRatio) + uniform.spawnBoundsSphereInnerRatio;
	#ifndef LOCAL_SPACE
		return uniform.emitterPos + norm * r * uniform.spawnBoundsSphere;
	#else
		return norm * r * uniform.spawnBoundsSphere;
	#endif
}
fn addInitialVelocity(localVelocity: ptr<function, vec3f>, inBounds: vec3f) {
	let initialVelOffset: vec3f = normalize(inBounds - vec3f(0.5)) * uniform.initialVelocity;
	*localVelocity = *localVelocity + initialVelOffset;
}
`,R$=`
fn saturate(x: f32) -> f32 {
	return clamp(x, 0.0, 1.0);
}
fn unpack3NFloats(src: f32) -> vec3f {
	let r = fract(src);
	let g = fract(src * 256.0);
	let b = fract(src * 65536.0);
	return vec3f(r, g, b);
}
struct TexLerpUnpackResult {
	result: vec3f,
	unpacked: vec3f
}
fn tex1Dlod_lerp(tex: texture_2d<f32>, textureSize: vec2u, tc: vec2f) -> TexLerpUnpackResult {
	let tc_next = tc + vec2f(uniform.graphSampleSize);
	let texelA: vec2i = vec2i(tc * vec2f(textureSize));
	let texelB: vec2i = vec2i(tc_next * vec2f(textureSize));
	let a = textureLoad(tex, texelA, 0);
	let b = textureLoad(tex, texelB, 0);
	let c = fract(tc.x * uniform.graphNumSamples);
	let unpackedA = unpack3NFloats(a.w);
	let unpackedB = unpack3NFloats(b.w);
	let w_out = mix(unpackedA, unpackedB, c);
	return TexLerpUnpackResult(mix(a.xyz, b.xyz, c), w_out);
}
const HASHSCALE4: vec4f = vec4f(1031.0, 0.1030, 0.0973, 0.1099);
fn hash41(p: f32) -> vec4f {
	var p4 = fract(vec4f(p) * HASHSCALE4);
	p4 = p4 + dot(p4, p4.wzxy + 19.19);
	return fract(vec4f((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}
@fragment
fn fragmentMain(input : FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	if (pcPosition.x > uniform.numParticles) {
		discard;
		return output;
	}
	readInput(input.vUv0.x);
	visMode = select(-1.0, 1.0, inShow);
	let rndFactor = hash41(pcPosition.x + uniform.seed);
	let particleRate = uniform.rate + uniform.rateDiv * rndFactor.x;
	outLife = inLife + uniform.delta;
	let nlife = clamp(outLife / uniform.lifetime, 0.0, 1.0);
	let internalTexSize = textureDimensions(internalTex0, 0);
	let lerpResult0 = tex1Dlod_lerp(internalTex0, internalTexSize, vec2f(nlife, 0.0));
	var localVelocity = lerpResult0.result;
	let localVelocityDiv = lerpResult0.unpacked;
	let lerpResult1 = tex1Dlod_lerp(internalTex1, internalTexSize, vec2f(nlife, 0.0));
	var velocity = lerpResult1.result;
	let velocityDiv = lerpResult1.unpacked;
	let lerpResult2 = tex1Dlod_lerp(internalTex2, internalTexSize, vec2f(nlife, 0.0));
	let params = lerpResult2.result;
	let paramDiv = lerpResult2.unpacked;
	var rotSpeed = params.x;
	let rotSpeedDiv = paramDiv.y;
	let lerpResult3 = tex1Dlod_lerp(internalTex3, internalTexSize, vec2f(nlife, 0.0));
	let radialParams = lerpResult3.result;
	let radialParamDiv = lerpResult3.unpacked;
	let radialSpeed = radialParams.x;
	let radialSpeedDiv = radialParamDiv.y;
	let respawn = inLife <= 0.0 || outLife >= uniform.lifetime;
	inPos = select(inPos, calcSpawnPosition(rndFactor.xyz, rndFactor.x), respawn);
	inAngle = select(inAngle, mix(uniform.startAngle, uniform.startAngle2, rndFactor.x), respawn);
	#ifndef LOCAL_SPACE
		var radialVel: vec3f = inPos - uniform.emitterPos;
	#else
		var radialVel: vec3f = inPos;
	#endif
	radialVel = select(vec3f(0.0), radialSpeed * normalize(radialVel), dot(radialVel, radialVel) > 1.0E-8);
	radialVel = radialVel + (radialSpeedDiv * vec3f(2.0) - vec3f(1.0)) * uniform.radialSpeedDivMult * rndFactor.xyz;
	localVelocity = localVelocity + (localVelocityDiv * vec3f(2.0) - vec3f(1.0)) * uniform.localVelocityDivMult * rndFactor.xyz;
	velocity = velocity + (velocityDiv * vec3f(2.0) - vec3f(1.0)) * uniform.velocityDivMult * rndFactor.xyz;
	rotSpeed = rotSpeed + (rotSpeedDiv * 2.0 - 1.0) * uniform.rotSpeedDivMult * rndFactor.y;
	addInitialVelocity(&localVelocity, rndFactor.xyz);
	#ifndef LOCAL_SPACE
		outVel = uniform.emitterMatrix * localVelocity + (radialVel + velocity) * uniform.emitterScale;
	#else
		outVel = (localVelocity + radialVel) / uniform.emitterScale + uniform.emitterMatrixInv * velocity;
	#endif
	outPos = inPos + outVel * uniform.delta;
	outAngle = inAngle + rotSpeed * uniform.delta;
`,M$=`
	let rotationResult = rotateWithMatrix(quadXY, inAngle);
	let rotatedQuadXY = rotationResult.rotatedVec;
	rotMatrix = rotationResult.matrix;
	var localPos = billboard(particlePos, rotatedQuadXY);
`,L$=`
	dBlendModeFogFactor = 0.0;
	rgb = rgb * saturate(gammaCorrectInput(max(a, 0.0)));
	if ((rgb.r + rgb.g + rgb.b) < 0.000001) {
		discard;
	}	
`,I$=`
	rgb = mix(vec3f(1.0), rgb, a);
	if ((rgb.r + rgb.g + rgb.b) > 2.99) {
		discard;
	}
`,O$=`
	if (a < 0.01) {
		discard;
	}
`,N$=`
attribute particle_vertexData: vec4f;
attribute particle_vertexData2: vec4f;
attribute particle_vertexData3: vec4f;
attribute particle_vertexData4: f32;
#ifndef USE_MESH
	attribute particle_vertexData5: vec2f;
#else
	attribute particle_vertexData5: vec4f;
#endif
uniform matrix_viewProjection: mat4x4f;
uniform matrix_model: mat4x4f;
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform matrix_view: mat4x4f;
#endif
uniform matrix_normal: mat3x3f;
uniform matrix_viewInverse: mat4x4f;
uniform numParticles: f32;
uniform lifetime: f32;
uniform stretch: f32;
uniform seed: f32;
uniform emitterScale: vec3f;
uniform faceTangent: vec3f;
uniform faceBinorm: vec3f;
#ifdef PARTICLE_GPU
	#ifdef WRAP
		uniform wrapBounds: vec3f;
	#endif
#endif
#ifdef PARTICLE_GPU
	var internalTex0: texture_2d<uff>;
	var internalTex1: texture_2d<uff>;
	var internalTex2: texture_2d<uff>;
#endif
uniform emitterPos: vec3f;
varying texCoordsAlphaLife: vec4f;
struct RotateResult {
	rotatedVec: vec2f,
	matrix: mat2x2f
}
fn rotateWithMatrix(quadXY: vec2f, pRotation: f32) -> RotateResult {
	let c = cos(pRotation);
	let s = sin(pRotation);
	let m = mat2x2f(vec2f(c, -s), vec2f(s, c));
	return RotateResult(m * quadXY, m);
}
fn billboard(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {
	var pos: vec3f;
	#ifdef SCREEN_SPACE
		pos = vec3f(-1.0, 0.0, 0.0) * quadXY.x + vec3f(0.0, -1.0, 0.0) * quadXY.y;
	#else
		pos = -uniform.matrix_viewInverse[0].xyz * quadXY.x + -uniform.matrix_viewInverse[1].xyz * quadXY.y;
	#endif
	return pos;
}
fn customFace(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {
	let pos = uniform.faceTangent * quadXY.x + uniform.faceBinorm * quadXY.y;
	return pos;
}
fn safeNormalize(v: vec2f) -> vec2f {
	let l = length(v);
	return select(v, v / l, l > 1e-06);
}
@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
	var output: VertexOutput;
	var particlePos = input.particle_vertexData.xyz;
	let inPos = particlePos;
	let vertPos = input.particle_vertexData3.xyz;
	var inVel = vec3f(input.particle_vertexData2.w, input.particle_vertexData3.w, input.particle_vertexData5.x);
	let id = floor(input.particle_vertexData4);
	let rndFactor = fract(sin(id + 1.0 + uniform.seed));
	let rndFactor3 = vec3f(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));
	#ifdef LOCAL_SPACE
		let modelRotation = mat3x3f(uniform.matrix_model[0].xyz, uniform.matrix_model[1].xyz, uniform.matrix_model[2].xyz);
		inVel = modelRotation * inVel;
	#endif
	let velocityV = safeNormalize((mat3x3f(uniform.matrix_view[0].xyz, uniform.matrix_view[1].xyz, uniform.matrix_view[2].xyz) * inVel).xy);
	let quadXY = vertPos.xy;
	#ifdef USE_MESH
		output.texCoordsAlphaLife = vec4f(input.particle_vertexData5.zw, input.particle_vertexData2.z, input.particle_vertexData.w);
	#else
		output.texCoordsAlphaLife = vec4f(quadXY * -0.5 + 0.5, input.particle_vertexData2.z, input.particle_vertexData.w);
	#endif
	var rotMatrix: mat2x2f;
	var inAngle = input.particle_vertexData2.x;
	var particlePosMoved = vec3f(0.0);
	let meshLocalPos = input.particle_vertexData3.xyz;
`,F$=`
	localPos = localPos * input.particle_vertexData2.y * uniform.emitterScale;
	localPos = localPos + particlePos;
	#ifdef SCREEN_SPACE
		output.position = vec4f(localPos.x, localPos.y, 0.0, 1.0);
	#else
		output.position = uniform.matrix_viewProjection * vec4f(localPos, 1.0);
	#endif
`,B$=`
	let rotationResult = rotateWithMatrix(quadXY, inAngle);
	let rotatedQuadXY = rotationResult.rotatedVec;
	rotMatrix = rotationResult.matrix;
	var localPos = customFace(particlePos, rotatedQuadXY);
`,U$=`
	rgb = addFog(rgb);
	rgb = toneMap(rgb);
	rgb = gammaCorrectOutput(rgb);
	output.color = vec4f(rgb, a);
	return output;
}
`,z$=`
	localPos = localPos * scale * uniform.emitterScale;
	localPos = localPos + particlePos;
	#ifdef SCREEN_SPACE
		output.position = vec4f(localPos.x, localPos.y, 0.0, 1.0);
	#else
		output.position = uniform.matrix_viewProjection * vec4f(localPos.xyz, 1.0);
	#endif
`,k$=`
	var negNormal: vec3f = normal * 0.5 + 0.5;
	var posNormal: vec3f = -normal * 0.5 + 0.5;
	negNormal = negNormal * negNormal;
	posNormal = posNormal * posNormal;
`,V$=`
attribute particle_vertexData: vec4f;
#if defined(USE_MESH)
	#if defined(USE_MESH_UV)
		attribute particle_uv: vec2f;
	#else
		var<private> particle_uv: vec2f = vec2f(0.0, 0.0);
	#endif
#endif
uniform matrix_viewProjection: mat4x4f;
uniform matrix_model: mat4x4f;
uniform matrix_normal: mat3x3f;
uniform matrix_viewInverse: mat4x4f;
#ifndef VIEWMATRIX
	#define VIEWMATRIX
	uniform matrix_view: mat4x4f;
#endif
uniform numParticles: f32;
uniform numParticlesPot: f32;
uniform graphSampleSize: f32;
uniform graphNumSamples: f32;
uniform stretch: f32;
uniform emitterScale: vec3f;
uniform emitterPos: vec3f;
uniform faceTangent: vec3f;
uniform faceBinorm: vec3f;
uniform rate: f32;
uniform rateDiv: f32;
uniform lifetime: f32;
uniform scaleDivMult: f32;
uniform alphaDivMult: f32;
uniform seed: f32;
uniform delta: f32;
#ifdef PARTICLE_GPU
	#ifdef WRAP
		uniform wrapBounds: vec3f;
	#endif
#endif
var particleTexOUT: texture_2d<uff>;
var particleTexIN: texture_2d<uff>;
#ifdef PARTICLE_GPU
	var internalTex0: texture_2d<uff>;
	var internalTex1: texture_2d<uff>;
	var internalTex2: texture_2d<uff>;
#endif
#ifndef CAMERAPLANES
	#define CAMERAPLANES
	uniform camera_params: vec4f;
#endif
varying texCoordsAlphaLife: vec4f;
var<private> inPos: vec3f;
var<private> inVel: vec3f;
var<private> inAngle: f32;
var<private> inShow: bool;
var<private> inLife: f32;
`,G$=`
	var negNormal: vec3f = max(normal, vec3(0.0));
	var posNormal: vec3f = max(-normal, vec3(0.0));
`,H$=`
	let light: vec3f = negNormal.x * uniform.lightCube[0] + posNormal.x * uniform.lightCube[1] +
					   negNormal.y * uniform.lightCube[2] + posNormal.y * uniform.lightCube[3] +
					   negNormal.z * uniform.lightCube[4] + posNormal.z * uniform.lightCube[5];
	rgb = rgb * light;
`,W$=`
particlePos = (uniform.matrix_model * vec4f(particlePos, 1.0)).xyz;
`,X$=`
var localPos = meshLocalPos;
let rotResultXY = rotateWithMatrix(localPos.xy, inAngle);
localPos = vec3f(rotResultXY.rotatedVec, localPos.z);
rotMatrix = rotResultXY.matrix;
let rotResultYZ = rotateWithMatrix(localPos.yz, inAngle);
localPos = vec3f(localPos.x, rotResultYZ.rotatedVec);
rotMatrix = rotResultYZ.matrix;
billboard(particlePos, quadXY);
`,q$=`
output.Normal = normalize(localPos + uniform.matrix_viewInverse[2].xyz);
`,Y$=`
	let sampledNormal: vec4f = textureSample(normalMap, normalMapSampler, vec2f(input.texCoordsAlphaLife.x, 1.0 - input.texCoordsAlphaLife.y));
	let normalMap: vec3f = normalize(sampledNormal.xyz * 2.0 - 1.0);
	let ParticleMat = mat3x3<f32>(ParticleMat0, ParticleMat1, ParticleMat2);
	let normal: vec3f = ParticleMat * normalMap;
`,j$=`
	inAngle = atan2(velocityV.x, velocityV.y);
`,$$=`
	#include "particleUpdaterInitPS"
	#ifdef PACK8
		#include "particleInputRgba8PS"
		#include "particleOutputRgba8PS"
	#else
		#include "particleInputFloatPS"
		#include "particleOutputFloatPS"
	#endif
	#ifdef EMITTERSHAPE_BOX
		#include "particleUpdaterAABBPS"
	#else
		#include "particleUpdaterSpherePS"
	#endif
	#include "particleUpdaterStartPS"
	#ifdef RESPAWN
		#include "particleUpdaterRespawnPS"
	#endif
	#ifdef NO_RESPAWN
		#include "particleUpdaterNoRespawnPS"
	#endif
	#ifdef ON_STOP
		#include "particleUpdaterOnStopPS"
	#endif
	#include "particleUpdaterEndPS"
`,K$=`
	#if NORMAL != NONE
		#if NORMAL == VERTEX
			varying Normal: vec3f;
		#endif
		#if NORMAL == MAP
			varying ParticleMat0: vec3f;
			varying ParticleMat1: vec3f;
			varying ParticleMat2: vec3f;
		#endif
		uniform lightCube: array<vec3f, 6>;
	#endif
	#ifdef SOFT
		varying vDepth: f32;
		#include "screenDepthPS"
	#endif
	#include "gammaPS"
	#include "tonemappingPS"
	#include "fogPS"
	#if NORMAL == MAP
		var normalMap: texture_2d<f32>;
		var normalMapSampler: sampler;
	#endif
	#include "particlePS"
	#ifdef SOFT
		#include "particle_softPS"
	#endif
	#if NORMAL == VERTEX
		var normal: vec3f = Normal;
	#endif
	#if NORMAL == MAP
		#include "particle_normalMapPS"
	#endif
	#if NORMAL != NONE
		#ifdef HALF_LAMBERT
			#include "particle_halflambertPS"
		#else
			#include "particle_lambertPS"
		#endif
		#include "particle_lightingPS"
	#endif
	#if BLEND == NORMAL
		#include "particle_blendNormalPS"
	#elif BLEND == ADDITIVE
		#include "particle_blendAddPS"
	#elif BLEND == MULTIPLICATIVE
		#include "particle_blendMultiplyPS"
	#endif
	#include "particle_endPS"
`,Z$=`
	#ifdef ANIMTEX
		uniform animTexTilesParams: vec2f;
		uniform animTexParams: vec4f;
		uniform animTexIndexParams: vec2f;
	#endif
	#if NORMAL == MAP
		varying ParticleMat0: vec3f;
		varying ParticleMat1: vec3f;
		varying ParticleMat2: vec3f;
	#endif
	#if NORMAL == VERTEX
		varying Normal: vec3f;
	#endif
	#ifdef SOFT
		varying vDepth: f32;
	#endif
	#ifdef PARTICLE_GPU
		#include "particle_initVS"
		#ifdef PACK8
			#include "particleInputRgba8PS"
		#else
			#include  "particleInputFloatPS"
		#endif
		#ifdef SOFT
			#include "screenDepthPS"
		#endif
		#include "particleVS"
	#else
		#ifdef SOFT
			#include "screenDepthPS"
		#endif
		#include "particle_cpuVS"
	#endif
	#ifdef LOCAL_SPACE
		#include "particle_localShiftVS"
	#endif
	#ifdef ANIMTEX
		#ifdef ANIMTEX_LOOP
			#include "particleAnimFrameLoopVS"
		#else
			#include "particleAnimFrameClampVS"
		#endif
		#include "particleAnimTexVS"
	#endif
	#ifdef PARTICLE_GPU
		#ifdef WRAP
			#include "particle_wrapVS"
		#endif
	#endif
	#ifdef ALIGN_TO_MOTION
		#include "particle_pointAlongVS"
	#endif
	#ifdef USE_MESH
		#include "particle_meshVS"
	#else
		#ifdef CUSTOM_FACE
			#include "particle_customFaceVS"
		#else
			#include "particle_billboardVS"
		#endif
	#endif
	#if NORMAL == VERTEX
		#include "particle_normalVS"
	#endif
	#if NORMAL == MAP
		#include "particle_TBNVS"
	#endif
	#ifdef STRETCH
		#include "particle_stretchVS"
	#endif
	#ifdef PARTICLE_GPU
		#include "particle_endVS"
	#else
		#include "particle_cpu_endVS"
	#endif
	#ifdef SOFT
		#include "particle_softVS"
	#endif
	return output;
}
`,Q$=`
	var depth: f32 = getLinearScreenDepthFrag();
	var particleDepth: f32 = vDepth;
	var depthDiff: f32 = saturate(abs(particleDepth - depth) * uniform.softening);
	a = a * depthDiff;
`,J$=`
	output.vDepth = getLinearDepth(localPos);
`,e9=`
	let moveDir: vec3f = inVel * uniform.stretch;
	var posPrev: vec3f = particlePos - moveDir;
	posPrev = posPrev + particlePosMoved;
	let viewRotationTemp: mat3x3f = mat3x3f(uniform.matrix_view[0].xyz, uniform.matrix_view[1].xyz, uniform.matrix_view[2].xyz);
	let centerToVertexV: vec2f = normalize((viewRotationTemp * localPos).xy);
	let interpolation: f32 = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;
	particlePos = mix(particlePos, posPrev, interpolation);
`,t9=`
	let rot3 = mat3x3f(
		vec3f(rotMatrix[0][0], rotMatrix[1][0], 0.0),
		vec3f(rotMatrix[0][1], rotMatrix[1][1], 0.0),
		vec3f(0.0, 0.0, 1.0)
	);
	let viewBasis = mat3x3f(
		-uniform.matrix_viewInverse[0].xyz,
		-uniform.matrix_viewInverse[1].xyz,
		uniform.matrix_viewInverse[2].xyz
	);
	let tempMat = viewBasis * rot3;
	output.ParticleMat0 = tempMat[0];
	output.ParticleMat1 = tempMat[1];
	output.ParticleMat2 = tempMat[2];
`,s9=`
	let origParticlePos: vec3f = particlePos;
	particlePos = particlePos - uniform.matrix_model[3].xyz;
	particlePos = (particlePos % uniform.wrapBounds) - uniform.wrapBounds * 0.5;
	particlePos = particlePos + uniform.matrix_model[3].xyz;
	particlePosMoved = particlePos - origParticlePos;
`;const i9={particlePS:m$,particleVS:p$,particleAnimFrameClampVS:_$,particleAnimFrameLoopVS:g$,particleAnimTexVS:v$,particleInputFloatPS:S$,particleInputRgba8PS:y$,particleOutputFloatPS:x$,particleOutputRgba8PS:T$,particleUpdaterAABBPS:E$,particleUpdaterEndPS:b$,particleUpdaterInitPS:A$,particleUpdaterNoRespawnPS:w$,particleUpdaterOnStopPS:C$,particleUpdaterRespawnPS:D$,particleUpdaterSpherePS:P$,particleUpdaterStartPS:R$,particle_billboardVS:M$,particle_blendAddPS:L$,particle_blendMultiplyPS:I$,particle_blendNormalPS:O$,particle_cpuVS:N$,particle_cpu_endVS:F$,particle_customFaceVS:B$,particle_endPS:U$,particle_endVS:z$,particle_halflambertPS:k$,particle_initVS:V$,particle_lambertPS:G$,particle_lightingPS:H$,particle_localShiftVS:W$,particle_meshVS:X$,particle_normalVS:q$,particle_normalMapPS:Y$,particle_pointAlongVS:j$,particle_simulationPS:$$,particle_shaderPS:K$,particle_shaderVS:Z$,particle_softPS:Q$,particle_softVS:J$,particle_stretchVS:e9,particle_TBNVS:t9,particle_wrapVS:s9},r9=["enabled","autoPlay","numParticles","lifetime","rate","rate2","startAngle","startAngle2","loop","preWarm","lighting","halfLambert","intensity","depthWrite","noFog","depthSoftening","sort","blendType","stretch","alignToMotion","emitterShape","emitterExtents","emitterExtentsInner","emitterRadius","emitterRadiusInner","initialVelocity","wrap","wrapBounds","localSpace","screenSpace","colorMapAsset","normalMapAsset","mesh","meshAsset","renderAsset","orientation","particleNormal","localVelocityGraph","localVelocityGraph2","velocityGraph","velocityGraph2","rotationSpeedGraph","rotationSpeedGraph2","radialSpeedGraph","radialSpeedGraph2","scaleGraph","scaleGraph2","colorGraph","colorGraph2","alphaGraph","alphaGraph2","colorMap","normalMap","animTilesX","animTilesY","animStartFrame","animNumFrames","animNumAnimations","animIndex","randomizeAnimIndex","animSpeed","animLoop","layers"];class a9 extends Ht{initializeComponentData(e,t,s){const i={};s=[];const r=this.propertyTypes;(t.mesh instanceof Ee||typeof t.mesh=="number")&&(t.meshAsset=t.mesh,delete t.mesh);for(const a in t){if(t.hasOwnProperty(a)&&(s.push(a),i[a]=t[a]),r[a]==="vec3")Array.isArray(i[a])&&(i[a]=new D(i[a][0],i[a][1],i[a][2]));else if(r[a]==="curve"){if(!(i[a]instanceof fr)){const o=i[a].type;i[a]=new fr(i[a].keys),i[a].type=o}}else if(r[a]==="curveset"&&!(i[a]instanceof ol)){const o=i[a].type;i[a]=new ol(i[a].keys),i[a].type=o}i.layers&&Array.isArray(i.layers)&&(i.layers=i.layers.slice(0))}super.initializeComponentData(e,i,s)}cloneComponent(e,t){const s=e.particlesystem.data,i=this.schema,r={};for(let a=0,o=i.length;a<o;a++){const h=i[a];let u=s[h];u instanceof D||u instanceof fr||u instanceof ol?(u=u.clone(),r[h]=u):h==="layers"?r.layers=s.layers.slice(0):u!=null&&(r[h]=u)}return this.addComponent(t,r)}onUpdate(e){const t=this.store,s=this.app.stats.particles,i=this.app.scene.layers;for(let r=0;r<i.layerList.length;r++)i.layerList[r].requiresLightCube=!1;for(const r in t)if(t.hasOwnProperty(r)){const a=t[r],o=a.entity,h=a.data;if(h.enabled&&o.enabled){const u=o.particlesystem.emitter;if(!u?.meshInstance.visible)continue;if(u.lighting){const f=h.layers;for(let m=0;m<f.length;m++){const _=i.getLayerById(f[m]);_&&(_.requiresLightCube=!0)}}if(!h.paused){let f=0;if(u.simTime+=e,u.simTime>=u.fixedTimeStep&&(f=Math.floor(u.simTime/u.fixedTimeStep),u.simTime-=f*u.fixedTimeStep),f){f=Math.min(f,u.maxSubSteps);for(let m=0;m<f;m++)u.addTime(u.fixedTimeStep,!1);s._updatesPerFrame+=f,s._frameTime+=u._addTimeTime,u._addTimeTime=0}u.finishFrame()}}}}onBeforeRemove(e,t){t.onBeforeRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}constructor(e){super(e),this.id="particlesystem",this.ComponentType=Tj,this.DataType=Ej,this.schema=r9,this.propertyTypes={emitterExtents:"vec3",emitterExtentsInner:"vec3",particleNormal:"vec3",wrapBounds:"vec3",localVelocityGraph:"curveset",localVelocityGraph2:"curveset",velocityGraph:"curveset",velocityGraph2:"curveset",colorGraph:"curveset",colorGraph2:"curveset",alphaGraph:"curve",alphaGraph2:"curve",rotationSpeedGraph:"curve",rotationSpeedGraph2:"curve",radialSpeedGraph:"curve",radialSpeedGraph2:"curve",scaleGraph:"curve",scaleGraph2:"curve"},this.on("beforeremove",this.onBeforeRemove,this),this.app.systems.on("update",this.onUpdate,this),Ue.get(e.graphicsDevice,ot).add(f$),Ue.get(e.graphicsDevice,Je).add(i9)}}class n9 extends wv{constructor(e,t){super(),this.skin=e,this.skinInstance=t}}class ki{static createCachedSkinInstance(e,t,s){let i=ki.getCachedSkinInstance(e,t);return i||(i=new Yf(e),i.resolve(t,s),ki.addCachedSkinInstance(e,t,i)),i}static getCachedSkinInstance(e,t){let s=null;const i=ki._skinInstanceCache.get(t);if(i){const r=i.find(a=>a.skin===e);r&&(r.incRefCount(),s=r.skinInstance)}return s}static addCachedSkinInstance(e,t,s){let i=ki._skinInstanceCache.get(t);i||(i=[],ki._skinInstanceCache.set(t,i));let r=i.find(a=>a.skin===e);r||(r=new n9(e,s),i.push(r)),r.incRefCount()}static removeCachedSkinInstance(e){if(e){const t=e.rootBone;if(t){const s=ki._skinInstanceCache.get(t);if(s){const i=s.findIndex(r=>r.skinInstance===e);if(i>=0){const r=s[i];r.decRefCount(),r.refCount===0&&(s.splice(i,1),s.length||ki._skinInstanceCache.delete(t),e&&(e.destroy(),r.skinInstance=null))}}}}}}ki._skinInstanceCache=new Map;class _f{set id(e){if(this.url)throw Error("Can't set id and url");this._unbind(),this._id=e,this.asset=this._registry.get(this._id),this._bind()}get id(){return this._id}set url(e){if(this.id)throw Error("Can't set id and url");this._unbind(),this._url=e,this.asset=this._registry.getByUrl(this._url),this._bind()}get url(){return this._url}_bind(){this.id&&(this._onAssetLoad&&(this._evtLoadById=this._registry.on(`load:${this.id}`,this._onLoad,this)),this._onAssetAdd&&(this._evtAddById=this._registry.once(`add:${this.id}`,this._onAdd,this)),this._onAssetRemove&&(this._evtRemoveById=this._registry.on(`remove:${this.id}`,this._onRemove,this)),this._onAssetUnload&&(this._evtUnloadById=this._registry.on(`unload:${this.id}`,this._onUnload,this))),this.url&&(this._onAssetLoad&&(this._evtLoadByUrl=this._registry.on(`load:url:${this.url}`,this._onLoad,this)),this._onAssetAdd&&(this._evtAddByUrl=this._registry.once(`add:url:${this.url}`,this._onAdd,this)),this._onAssetRemove&&(this._evtRemoveByUrl=this._registry.on(`remove:url:${this.url}`,this._onRemove,this)))}_unbind(){this.id&&(this._evtLoadById?.off(),this._evtLoadById=null,this._evtAddById?.off(),this._evtAddById=null,this._evtRemoveById?.off(),this._evtRemoveById=null,this._evtUnloadById?.off(),this._evtUnloadById=null),this.url&&(this._evtLoadByUrl?.off(),this._evtLoadByUrl=null,this._evtAddByUrl?.off(),this._evtAddByUrl=null,this._evtRemoveByUrl?.off(),this._evtRemoveByUrl=null)}_onLoad(e){this._onAssetLoad.call(this._scope,this.propertyName,this.parent,e)}_onAdd(e){this.asset=e,this._onAssetAdd.call(this._scope,this.propertyName,this.parent,e)}_onRemove(e){this._onAssetRemove.call(this._scope,this.propertyName,this.parent,e),this.asset=null}_onUnload(e){this._onAssetUnload.call(this._scope,this.propertyName,this.parent,e)}constructor(e,t,s,i,r){this._evtLoadById=null,this._evtUnloadById=null,this._evtAddById=null,this._evtRemoveById=null,this._evtLoadByUrl=null,this._evtAddByUrl=null,this._evtRemoveByUrl=null,this.propertyName=e,this.parent=t,this._scope=r,this._registry=s,this.id=null,this.url=null,this.asset=null,this._onAssetLoad=i.load,this._onAssetAdd=i.add,this._onAssetRemove=i.remove,this._onAssetUnload=i.unload}}class qL extends ke{set renderStyle(e){this._renderStyle!==e&&(this._renderStyle=e,lt._prepareRenderStyleForArray(this._meshInstances,e))}get renderStyle(){return this._renderStyle}set customAabb(e){this._customAabb=e;const t=this._meshInstances;if(t)for(let s=0;s<t.length;s++)t[s].setCustomAabb(this._customAabb)}get customAabb(){return this._customAabb}set type(e){if(this._type!==e&&(this._area=null,this._type=e,this.destroyMeshInstances(),e!=="asset")){let t=this._material;(!t||t===this.system.defaultMaterial)&&(t=this._materialReferences[0]&&this._materialReferences[0].asset&&this._materialReferences[0].asset.resource);const s=HL(this.system.app.graphicsDevice,e);this._area=s.area,this.meshInstances=[new lt(s.mesh,t||this.system.defaultMaterial,this.entity)]}}get type(){return this._type}set meshInstances(e){if(this.destroyMeshInstances(),this._meshInstances=e,this._meshInstances){const t=this._meshInstances;for(let s=0;s<t.length;s++)t[s].node||(t[s].node=this.entity),t[s].castShadow=this._castShadows,t[s].receiveShadow=this._receiveShadows,t[s].renderStyle=this._renderStyle,t[s].setLightmapped(this._lightmapped),t[s].setCustomAabb(this._customAabb);this.enabled&&this.entity.enabled&&this.addToLayers()}}get meshInstances(){return this._meshInstances}set lightmapped(e){if(e!==this._lightmapped){this._lightmapped=e;const t=this._meshInstances;if(t)for(let s=0;s<t.length;s++)t[s].setLightmapped(e)}}get lightmapped(){return this._lightmapped}set castShadows(e){if(this._castShadows!==e){const t=this._meshInstances;if(t){const s=this.layers,i=this.system.app.scene;if(this._castShadows&&!e)for(let r=0;r<s.length;r++){const a=i.layers.getLayerById(this.layers[r]);a&&a.removeShadowCasters(t)}for(let r=0;r<t.length;r++)t[r].castShadow=e;if(!this._castShadows&&e)for(let r=0;r<s.length;r++){const a=i.layers.getLayerById(s[r]);a&&a.addShadowCasters(t)}}this._castShadows=e}}get castShadows(){return this._castShadows}set receiveShadows(e){if(this._receiveShadows!==e){this._receiveShadows=e;const t=this._meshInstances;if(t)for(let s=0;s<t.length;s++)t[s].receiveShadow=e}}get receiveShadows(){return this._receiveShadows}set castShadowsLightmap(e){this._castShadowsLightmap=e}get castShadowsLightmap(){return this._castShadowsLightmap}set lightmapSizeMultiplier(e){this._lightmapSizeMultiplier=e}get lightmapSizeMultiplier(){return this._lightmapSizeMultiplier}set layers(e){const t=this.system.app.scene.layers;let s;if(this._meshInstances)for(let i=0;i<this._layers.length;i++)s=t.getLayerById(this._layers[i]),s&&s.removeMeshInstances(this._meshInstances);this._layers.length=0;for(let i=0;i<e.length;i++)this._layers[i]=e[i];if(!(!this.enabled||!this.entity.enabled||!this._meshInstances))for(let i=0;i<this._layers.length;i++)s=t.getLayerById(this._layers[i]),s&&s.addMeshInstances(this._meshInstances)}get layers(){return this._layers}set batchGroupId(e){this._batchGroupId!==e&&(this.entity.enabled&&this._batchGroupId>=0&&this.system.app.batcher?.remove(Jt.RENDER,this.batchGroupId,this.entity),this.entity.enabled&&e>=0&&this.system.app.batcher?.insert(Jt.RENDER,e,this.entity),e<0&&this._batchGroupId>=0&&this.enabled&&this.entity.enabled&&this.addToLayers(),this._batchGroupId=e)}get batchGroupId(){return this._batchGroupId}set material(e){if(this._material!==e&&(this._material=e,this._meshInstances&&this._type!=="asset"))for(let t=0;t<this._meshInstances.length;t++)this._meshInstances[t].material=e}get material(){return this._material}set materialAssets(e=[]){if(this._materialReferences.length>e.length){for(let t=e.length;t<this._materialReferences.length;t++)this._materialReferences[t].id=null;this._materialReferences.length=e.length}for(let t=0;t<e.length;t++)if(this._materialReferences[t]||this._materialReferences.push(new _f(t,this,this.system.app.assets,{add:this._onMaterialAdded,load:this._onMaterialLoad,remove:this._onMaterialRemove,unload:this._onMaterialUnload},this)),e[t]){const s=e[t]instanceof Ee?e[t].id:e[t];this._materialReferences[t].id!==s&&(this._materialReferences[t].id=s),this._materialReferences[t].asset&&this._onMaterialAdded(t,this,this._materialReferences[t].asset)}else this._materialReferences[t].id=null,this._meshInstances[t]&&(this._meshInstances[t].material=this.system.defaultMaterial)}get materialAssets(){return this._materialReferences.map(e=>e.id)}set asset(e){const t=e instanceof Ee?e.id:e;this._assetReference.id!==t&&(this._assetReference.asset&&this._assetReference.asset.resource&&this._onRenderAssetRemove(),this._assetReference.id=t,this._assetReference.asset&&this._onRenderAssetAdded())}get asset(){return this._assetReference.id}assignAsset(e){const t=e instanceof Ee?e.id:e;this._assetReference.id=t}set rootBone(e){if(this._rootBone!==e){const t=typeof e=="string";if(this._rootBone&&t&&this._rootBone.getGuid()===e)return;this._rootBone&&this._clearSkinInstances(),e instanceof Dt?this._rootBone=e:t?(this._rootBone=this.system.app.getEntityFromIndex(e)||null,this._rootBone):this._rootBone=null,this._rootBone&&this._cloneSkinInstances()}}get rootBone(){return this._rootBone}destroyMeshInstances(){const e=this._meshInstances;if(e){this.removeFromLayers(),this._clearSkinInstances();for(let t=0;t<e.length;t++)e[t].destroy();this._meshInstances.length=0}}addToLayers(){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const s=e.getLayerById(this._layers[t]);s&&s.addMeshInstances(this._meshInstances)}}removeFromLayers(){if(this._meshInstances&&this._meshInstances.length){const e=this.system.app.scene.layers;for(let t=0;t<this._layers.length;t++){const s=e.getLayerById(this._layers[t]);s&&s.removeMeshInstances(this._meshInstances)}}}onRemoveChild(){this.removeFromLayers()}onInsertChild(){this._meshInstances&&this.enabled&&this.entity.enabled&&this.addToLayers()}onRemove(){this.destroyMeshInstances(),this.asset=null,this.materialAsset=null,this._assetReference.id=null;for(let e=0;e<this._materialReferences.length;e++)this._materialReferences[e].id=null;this.entity.off("remove",this.onRemoveChild,this),this.entity.off("insert",this.onInsertChild,this)}onLayersChanged(e,t){this.addToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||e.addMeshInstances(this._meshInstances)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||e.removeMeshInstances(this._meshInstances)}onEnable(){const e=this.system.app,t=e.scene,s=t.layers;this._rootBone&&this._cloneSkinInstances(),this._evtLayersChanged=t.on("set:layers",this.onLayersChanged,this),s&&(this._evtLayerAdded=s.on("add",this.onLayerAdded,this),this._evtLayerRemoved=s.on("remove",this.onLayerRemoved,this));const i=this._type==="asset";this._meshInstances&&this._meshInstances.length?this.addToLayers():i&&this.asset&&this._onRenderAssetAdded();for(let r=0;r<this._materialReferences.length;r++)this._materialReferences[r].asset&&this.system.app.assets.load(this._materialReferences[r].asset);this._batchGroupId>=0&&e.batcher?.insert(Jt.RENDER,this.batchGroupId,this.entity)}onDisable(){const e=this.system.app,s=e.scene.layers;this._evtLayersChanged?.off(),this._evtLayersChanged=null,this._rootBone&&this._clearSkinInstances(),s&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this._batchGroupId>=0&&e.batcher?.remove(Jt.RENDER,this.batchGroupId,this.entity),this.removeFromLayers()}hide(){if(this._meshInstances)for(let e=0;e<this._meshInstances.length;e++)this._meshInstances[e].visible=!1}show(){if(this._meshInstances)for(let e=0;e<this._meshInstances.length;e++)this._meshInstances[e].visible=!0}_onRenderAssetAdded(){this._assetReference.asset&&(this._assetReference.asset.resource?this._onRenderAssetLoad():this.enabled&&this.entity.enabled&&this.system.app.assets.load(this._assetReference.asset))}_onRenderAssetLoad(){if(this.destroyMeshInstances(),this._assetReference.asset){const e=this._assetReference.asset.resource;this._evtSetMeshes?.off(),this._evtSetMeshes=e.on("set:meshes",this._onSetMeshes,this),e.meshes&&this._onSetMeshes(e.meshes)}}_onSetMeshes(e){this._cloneMeshes(e)}_clearSkinInstances(){for(let e=0;e<this._meshInstances.length;e++){const t=this._meshInstances[e];ki.removeCachedSkinInstance(t.skinInstance),t.skinInstance=null}}_cloneSkinInstances(){if(this._meshInstances.length&&this._rootBone instanceof Dt)for(let e=0;e<this._meshInstances.length;e++){const t=this._meshInstances[e],s=t.mesh;s.skin&&!t.skinInstance&&(t.skinInstance=ki.createCachedSkinInstance(s.skin,this._rootBone,this.entity))}}_cloneMeshes(e){if(e&&e.length){const t=[];for(let s=0;s<e.length;s++){const i=e[s],r=this._materialReferences[s]&&this._materialReferences[s].asset&&this._materialReferences[s].asset.resource,a=new lt(i,r||this.system.defaultMaterial,this.entity);t.push(a),i.morph&&(a.morphInstance=new Pl(i.morph))}this.meshInstances=t,this._cloneSkinInstances()}}_onRenderAssetUnload(){this._type==="asset"&&this.destroyMeshInstances()}_onRenderAssetRemove(){this._evtSetMeshes?.off(),this._evtSetMeshes=null,this._onRenderAssetUnload()}_onMaterialAdded(e,t,s){s.resource?this._onMaterialLoad(e,t,s):this.enabled&&this.entity.enabled&&this.system.app.assets.load(s)}_updateMainMaterial(e,t){e===0&&(this.material=t)}_onMaterialLoad(e,t,s){this._meshInstances[e]&&(this._meshInstances[e].material=s.resource),this._updateMainMaterial(e,s.resource)}_onMaterialRemove(e,t,s){this._meshInstances[e]&&(this._meshInstances[e].material=this.system.defaultMaterial),this._updateMainMaterial(e,this.system.defaultMaterial)}_onMaterialUnload(e,t,s){this._meshInstances[e]&&(this._meshInstances[e].material=this.system.defaultMaterial),this._updateMainMaterial(e,this.system.defaultMaterial)}resolveDuplicatedEntityReferenceProperties(e,t){e.rootBone&&(this.rootBone=t[e.rootBone.getGuid()])}constructor(e,t){super(e,t),this._type="asset",this._castShadows=!0,this._receiveShadows=!0,this._castShadowsLightmap=!0,this._lightmapped=!1,this._lightmapSizeMultiplier=1,this.isStatic=!1,this._batchGroupId=-1,this._layers=[sn],this._renderStyle=lh,this._meshInstances=[],this._customAabb=null,this._area=null,this._materialReferences=[],this._rootBone=null,this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._evtSetMeshes=null,this._assetReference=new _f("asset",this,e.app.assets,{add:this._onRenderAssetAdded,load:this._onRenderAssetLoad,remove:this._onRenderAssetRemove,unload:this._onRenderAssetUnload},this),this._material=e.defaultMaterial,t.on("remove",this.onRemoveChild,this),t.on("removehierarchy",this.onRemoveChild,this),t.on("insert",this.onInsertChild,this),t.on("inserthierarchy",this.onInsertChild,this)}}class o9{constructor(){this.enabled=!0}}const ET=["enabled"],jo=["material","meshInstances","asset","materialAssets","castShadows","receiveShadows","castShadowsLightmap","lightmapped","lightmapSizeMultiplier","renderStyle","type","layers","isStatic","batchGroupId","rootBone"];class l9 extends Ht{initializeComponentData(e,t,s){(t.batchGroupId===null||t.batchGroupId===void 0)&&(t.batchGroupId=-1),t.layers&&t.layers.length&&(t.layers=t.layers.slice(0));for(let i=0;i<jo.length;i++)t.hasOwnProperty(jo[i])&&(e[jo[i]]=t[jo[i]]);t.aabbCenter&&t.aabbHalfExtents&&(e.customAabb=new Ge(new D(t.aabbCenter),new D(t.aabbHalfExtents))),super.initializeComponentData(e,t,ET)}cloneComponent(e,t){const s={};for(let o=0;o<jo.length;o++)s[jo[o]]=e.render[jo[o]];s.enabled=e.render.enabled,delete s.meshInstances;const i=this.addComponent(t,s),r=e.render.meshInstances,a=r.map(o=>o.mesh);i._onSetMeshes(a);for(let o=0;o<r.length;o++)i.meshInstances[o].material=r[o].material;return e.render.customAabb&&(i.customAabb=e.render.customAabb.clone()),i}onRemove(e,t){t.onRemove()}constructor(e){super(e),this.id="render",this.ComponentType=qL,this.DataType=o9,this.schema=ET,this.defaultMaterial=jf(e.graphicsDevice),this.on("beforeremove",this.onRemove,this)}}ke._buildAccessors(qL.prototype,ET);class ix{_resize(e){if(e>this._pool.length)for(let t=this._pool.length;t<e;t++)this._pool[t]=new this._constructor}allocate(){return this._count>=this._pool.length&&this._resize(this._pool.length*2),this._pool[this._count++]}freeAll(){this._count=0}constructor(e,t){this._pool=[],this._count=0,this._constructor=e,this._resize(t)}}let vi,rt,or,Kc;const c9=new pe,h9=new pe,l_=new D;class Ur extends ke{static onLibraryLoaded(){typeof Ammo<"u"&&(vi=new Ammo.btTransform,rt=new Ammo.btVector3,or=new Ammo.btVector3,Kc=new Ammo.btQuaternion)}static onAppDestroy(){Ammo.destroy(vi),Ammo.destroy(rt),Ammo.destroy(or),Ammo.destroy(Kc),vi=null,rt=null,or=null,Kc=null}set angularDamping(e){this._angularDamping!==e&&(this._angularDamping=e,this._body&&this._body.setDamping(this._linearDamping,e))}get angularDamping(){return this._angularDamping}set angularFactor(e){this._angularFactor.equals(e)||(this._angularFactor.copy(e),this._body&&this._type===ar&&(rt.setValue(e.x,e.y,e.z),this._body.setAngularFactor(rt)))}get angularFactor(){return this._angularFactor}set angularVelocity(e){this._body&&this._type===ar&&(this._body.activate(),rt.setValue(e.x,e.y,e.z),this._body.setAngularVelocity(rt),this._angularVelocity.copy(e))}get angularVelocity(){if(this._body&&this._type===ar){const e=this._body.getAngularVelocity();this._angularVelocity.set(e.x(),e.y(),e.z())}return this._angularVelocity}set body(e){this._body!==e&&(this._body=e,e&&this._simulationEnabled&&e.activate())}get body(){return this._body}set friction(e){this._friction!==e&&(this._friction=e,this._body&&this._body.setFriction(e))}get friction(){return this._friction}set group(e){this._group!==e&&(this._group=e,this.enabled&&this.entity.enabled&&(this.disableSimulation(),this.enableSimulation()))}get group(){return this._group}set linearDamping(e){this._linearDamping!==e&&(this._linearDamping=e,this._body&&this._body.setDamping(e,this._angularDamping))}get linearDamping(){return this._linearDamping}set linearFactor(e){this._linearFactor.equals(e)||(this._linearFactor.copy(e),this._body&&this._type===ar&&(rt.setValue(e.x,e.y,e.z),this._body.setLinearFactor(rt)))}get linearFactor(){return this._linearFactor}set linearVelocity(e){this._body&&this._type===ar&&(this._body.activate(),rt.setValue(e.x,e.y,e.z),this._body.setLinearVelocity(rt),this._linearVelocity.copy(e))}get linearVelocity(){if(this._body&&this._type===ar){const e=this._body.getLinearVelocity();this._linearVelocity.set(e.x(),e.y(),e.z())}return this._linearVelocity}set mask(e){this._mask!==e&&(this._mask=e,this.enabled&&this.entity.enabled&&(this.disableSimulation(),this.enableSimulation()))}get mask(){return this._mask}set mass(e){if(this._mass!==e&&(this._mass=e,this._body&&this._type===ar)){const t=this.enabled&&this.entity.enabled;t&&this.disableSimulation(),this._body.getCollisionShape().calculateLocalInertia(e,rt),this._body.setMassProps(e,rt),this._body.updateInertiaTensor(),t&&this.enableSimulation()}}get mass(){return this._mass}set restitution(e){this._restitution!==e&&(this._restitution=e,this._body&&this._body.setRestitution(e))}get restitution(){return this._restitution}set rollingFriction(e){this._rollingFriction!==e&&(this._rollingFriction=e,this._body&&this._body.setRollingFriction(e))}get rollingFriction(){return this._rollingFriction}set type(e){if(this._type!==e){switch(this._type=e,this.disableSimulation(),e){case ar:this._group=_Y,this._mask=eR;break;case Hc:this._group=gY,this._mask=eR;break;case yd:default:this._group=QP,this._mask=pT;break}this.createBody()}}get type(){return this._type}createBody(){const e=this.entity;let t;if(e.collision&&(t=e.collision.shape,e.trigger&&(e.trigger.destroy(),delete e.trigger)),t){this._body&&(this.system.removeBody(this._body),this.system.destroyBody(this._body),this._body=null);const s=this._type===ar?this._mass:0;this._getEntityTransform(vi);const i=this.system.createBody(s,t,vi);if(i.setRestitution(this._restitution),i.setFriction(this._friction),i.setRollingFriction(this._rollingFriction),i.setDamping(this._linearDamping,this._angularDamping),this._type===ar){const r=this._linearFactor;rt.setValue(r.x,r.y,r.z),i.setLinearFactor(rt);const a=this._angularFactor;rt.setValue(a.x,a.y,a.z),i.setAngularFactor(rt)}else this._type===Hc&&(i.setCollisionFlags(i.getCollisionFlags()|pY),i.setActivationState(ZP));i.entity=e,this.body=i,this.enabled&&e.enabled&&this.enableSimulation()}}isActive(){return this._body?this._body.isActive():!1}activate(){this._body&&this._body.activate()}enableSimulation(){const e=this.entity;if(e.collision&&e.collision.enabled&&!this._simulationEnabled){const t=this._body;if(t){switch(this.system.addBody(t,this._group,this._mask),this._type){case ar:this.system._dynamic.push(this),t.forceActivationState(mT),this.syncEntityToBody();break;case Hc:this.system._kinematic.push(this),t.forceActivationState(ZP);break;case yd:t.forceActivationState(mT),this.syncEntityToBody();break}e.collision.type==="compound"&&this.system._compounds.push(e.collision),t.activate(),this._simulationEnabled=!0}}}disableSimulation(){const e=this._body;if(e&&this._simulationEnabled){const t=this.system;let s=t._compounds.indexOf(this.entity.collision);s>-1&&t._compounds.splice(s,1),s=t._dynamic.indexOf(this),s>-1&&t._dynamic.splice(s,1),s=t._kinematic.indexOf(this),s>-1&&t._kinematic.splice(s,1),t.removeBody(e),e.forceActivationState(OL),this._simulationEnabled=!1}}applyForce(e,t,s,i,r,a){const o=this._body;o&&(o.activate(),e instanceof D?rt.setValue(e.x,e.y,e.z):rt.setValue(e,t,s),t instanceof D?or.setValue(t.x,t.y,t.z):i!==void 0?or.setValue(i,r,a):or.setValue(0,0,0),o.applyForce(rt,or))}applyTorque(e,t,s){const i=this._body;i&&(i.activate(),e instanceof D?rt.setValue(e.x,e.y,e.z):rt.setValue(e,t,s),i.applyTorque(rt))}applyImpulse(e,t,s,i,r,a){const o=this._body;o&&(o.activate(),e instanceof D?rt.setValue(e.x,e.y,e.z):rt.setValue(e,t,s),t instanceof D?or.setValue(t.x,t.y,t.z):i!==void 0?or.setValue(i,r,a):or.setValue(0,0,0),o.applyImpulse(rt,or))}applyTorqueImpulse(e,t,s){const i=this._body;i&&(i.activate(),e instanceof D?rt.setValue(e.x,e.y,e.z):rt.setValue(e,t,s),i.applyTorqueImpulse(rt))}isStatic(){return this._type===yd}isStaticOrKinematic(){return this._type===yd||this._type===Hc}isKinematic(){return this._type===Hc}_getEntityTransform(e){const t=this.entity,s=t.collision;if(s){const i=s.getShapePosition(),r=s.getShapeRotation();rt.setValue(i.x,i.y,i.z),Kc.setValue(r.x,r.y,r.z,r.w)}else{const i=t.getPosition(),r=t.getRotation();rt.setValue(i.x,i.y,i.z),Kc.setValue(r.x,r.y,r.z,r.w)}e.setOrigin(rt),e.setRotation(Kc)}syncEntityToBody(){const e=this._body;if(e){if(this._getEntityTransform(vi),e.setWorldTransform(vi),this._type===Hc){const t=e.getMotionState();t&&t.setWorldTransform(vi)}e.activate()}}_updateDynamic(){const e=this._body;if(e.isActive()){const t=e.getMotionState();if(t){const s=this.entity;t.getWorldTransform(vi);const i=vi.getOrigin(),r=vi.getRotation(),a=s.collision;if(a&&a._hasOffset){const o=a.data.linearOffset,h=a.data.angularOffset,u=h9.copy(h).invert(),f=c9.set(r.x(),r.y(),r.z(),r.w()).mul(u);f.transformVector(o,l_),s.setPosition(i.x()-l_.x,i.y()-l_.y,i.z()-l_.z),s.setRotation(f)}else s.setPosition(i.x(),i.y(),i.z()),s.setRotation(r.x(),r.y(),r.z(),r.w())}}}_updateKinematic(){const e=this._body.getMotionState();e&&(this._getEntityTransform(vi),e.setWorldTransform(vi))}teleport(e,t,s,i,r,a){e instanceof D?this.entity.setPosition(e):this.entity.setPosition(e,t,s),t instanceof pe?this.entity.setRotation(t):t instanceof D?this.entity.setEulerAngles(t):i!==void 0&&this.entity.setEulerAngles(i,r,a),this.syncEntityToBody()}onEnable(){this._body||this.createBody(),this.enableSimulation()}onDisable(){this.disableSimulation()}constructor(...e){super(...e),this._angularDamping=0,this._angularFactor=new D(1,1,1),this._angularVelocity=new D,this._body=null,this._friction=.5,this._group=QP,this._linearDamping=0,this._linearFactor=new D(1,1,1),this._linearVelocity=new D,this._mask=pT,this._mass=1,this._restitution=0,this._rollingFriction=0,this._simulationEnabled=!1,this._type=yd}}Ur.EVENT_CONTACT="contact";Ur.EVENT_COLLISIONSTART="collisionstart";Ur.EVENT_COLLISIONEND="collisionend";Ur.EVENT_TRIGGERENTER="triggerenter";Ur.EVENT_TRIGGERLEAVE="triggerleave";Ur.order=-1;class u9{constructor(){this.enabled=!0}}let Ea,ba;class hR{constructor(e,t,s,i){this.entity=e,this.point=t,this.normal=s,this.hitFraction=i}}class d9{constructor(e,t,s){arguments.length!==0?(this.a=e,this.b=t,this.impulse=s.impulse,this.localPointA=s.localPoint,this.localPointB=s.localPointOther,this.pointA=s.point,this.pointB=s.pointOther,this.normal=s.normal):(this.a=null,this.b=null,this.impulse=0,this.localPointA=new D,this.localPointB=new D,this.pointA=new D,this.pointB=new D,this.normal=new D)}}class f9{constructor(e=new D,t=new D,s=new D,i=new D,r=new D,a=0){this.localPoint=e,this.localPointOther=t,this.point=s,this.pointOther=i,this.normal=r,this.impulse=a}}class m9{constructor(e,t){this.other=e,this.contacts=t}}const YL=["enabled"];class jL extends Ht{onLibraryLoaded(){if(typeof Ammo<"u"){if(this.collisionConfiguration=new Ammo.btDefaultCollisionConfiguration,this.dispatcher=new Ammo.btCollisionDispatcher(this.collisionConfiguration),this.overlappingPairCache=new Ammo.btDbvtBroadphase,this.solver=new Ammo.btSequentialImpulseConstraintSolver,this.dynamicsWorld=new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.overlappingPairCache,this.solver,this.collisionConfiguration),this.dynamicsWorld.setInternalTickCallback){const e=Ammo.addFunction(this._checkForCollisions.bind(this),"vif");this.dynamicsWorld.setInternalTickCallback(e)}Ea=new Ammo.btVector3,ba=new Ammo.btVector3,Ur.onLibraryLoaded(),this.contactPointPool=new ix(f9,1),this.contactResultPool=new ix(m9,1),this.singleContactResultPool=new ix(d9,1),this.app.systems.on("update",this.onUpdate,this)}else this.app.systems.off("update",this.onUpdate,this)}initializeComponentData(e,t,s){const i=["mass","linearDamping","angularDamping","linearFactor","angularFactor","friction","rollingFriction","restitution","type","group","mask"];for(const r of i)if(t.hasOwnProperty(r)){const a=t[r];Array.isArray(a)?e[r]=new D(a[0],a[1],a[2]):e[r]=a}super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const s=e.rigidbody,i={enabled:s.enabled,mass:s.mass,linearDamping:s.linearDamping,angularDamping:s.angularDamping,linearFactor:[s.linearFactor.x,s.linearFactor.y,s.linearFactor.z],angularFactor:[s.angularFactor.x,s.angularFactor.y,s.angularFactor.z],friction:s.friction,rollingFriction:s.rollingFriction,restitution:s.restitution,type:s.type,group:s.group,mask:s.mask};return this.addComponent(t,i)}onBeforeRemove(e,t){t.enabled&&(t.enabled=!1),t.body&&(this.destroyBody(t.body),t.body=null)}addBody(e,t,s){t!==void 0&&s!==void 0?this.dynamicsWorld.addRigidBody(e,t,s):this.dynamicsWorld.addRigidBody(e)}removeBody(e){this.dynamicsWorld.removeRigidBody(e)}createBody(e,t,s){const i=new Ammo.btVector3(0,0,0);e!==0&&t.calculateLocalInertia(e,i);const r=new Ammo.btDefaultMotionState(s),a=new Ammo.btRigidBodyConstructionInfo(e,r,t,i),o=new Ammo.btRigidBody(a);return Ammo.destroy(a),Ammo.destroy(i),o}destroyBody(e){const t=e.getMotionState();t&&Ammo.destroy(t),Ammo.destroy(e)}raycastFirst(e,t,s={}){if(s.filterTags||s.filterCallback)return s.sort=!0,this.raycastAll(e,t,s)[0]||null;let i=null;Ea.setValue(e.x,e.y,e.z),ba.setValue(t.x,t.y,t.z);const r=new Ammo.ClosestRayResultCallback(Ea,ba);if(typeof s.filterCollisionGroup=="number"&&r.set_m_collisionFilterGroup(s.filterCollisionGroup),typeof s.filterCollisionMask=="number"&&r.set_m_collisionFilterMask(s.filterCollisionMask),this.dynamicsWorld.rayTest(Ea,ba,r),r.hasHit()){const a=r.get_m_collisionObject(),o=Ammo.castObject(a,Ammo.btRigidBody);if(o){const h=r.get_m_hitPointWorld(),u=r.get_m_hitNormalWorld();i=new hR(o.entity,new D(h.x(),h.y(),h.z()),new D(u.x(),u.y(),u.z()),r.get_m_closestHitFraction())}}return Ammo.destroy(r),i}raycastAll(e,t,s={}){const i=[];Ea.setValue(e.x,e.y,e.z),ba.setValue(t.x,t.y,t.z);const r=new Ammo.AllHitsRayResultCallback(Ea,ba);if(typeof s.filterCollisionGroup=="number"&&r.set_m_collisionFilterGroup(s.filterCollisionGroup),typeof s.filterCollisionMask=="number"&&r.set_m_collisionFilterMask(s.filterCollisionMask),this.dynamicsWorld.rayTest(Ea,ba,r),r.hasHit()){const a=r.get_m_collisionObjects(),o=r.get_m_hitPointWorld(),h=r.get_m_hitNormalWorld(),u=r.get_m_hitFractions(),f=a.size();for(let m=0;m<f;m++){const _=Ammo.castObject(a.at(m),Ammo.btRigidBody);if(_&&_.entity){if(s.filterTags&&!_.entity.tags.has(...s.filterTags)||s.filterCallback&&!s.filterCallback(_.entity))continue;const g=o.at(m),S=h.at(m),x=new hR(_.entity,new D(g.x(),g.y(),g.z()),new D(S.x(),S.y(),S.z()),u.at(m));i.push(x)}}s.sort&&i.sort((m,_)=>m.hitFraction-_.hitFraction)}return Ammo.destroy(r),i}_storeCollision(e,t){let s=!1;const i=e.getGuid();return this.collisions[i]=this.collisions[i]||{others:[],entity:e},this.collisions[i].others.indexOf(t)<0&&(this.collisions[i].others.push(t),s=!0),this.frameCollisions[i]=this.frameCollisions[i]||{others:[],entity:e},this.frameCollisions[i].others.push(t),s}_createContactPointFromAmmo(e){const t=e.get_m_localPointA(),s=e.get_m_localPointB(),i=e.getPositionWorldOnA(),r=e.getPositionWorldOnB(),a=e.get_m_normalWorldOnB(),o=this.contactPointPool.allocate();return o.localPoint.set(t.x(),t.y(),t.z()),o.localPointOther.set(s.x(),s.y(),s.z()),o.point.set(i.x(),i.y(),i.z()),o.pointOther.set(r.x(),r.y(),r.z()),o.normal.set(a.x(),a.y(),a.z()),o.impulse=e.getAppliedImpulse(),o}_createReverseContactPointFromAmmo(e){const t=e.get_m_localPointA(),s=e.get_m_localPointB(),i=e.getPositionWorldOnA(),r=e.getPositionWorldOnB(),a=e.get_m_normalWorldOnB(),o=this.contactPointPool.allocate();return o.localPointOther.set(t.x(),t.y(),t.z()),o.localPoint.set(s.x(),s.y(),s.z()),o.pointOther.set(i.x(),i.y(),i.z()),o.point.set(r.x(),r.y(),r.z()),o.normal.set(a.x(),a.y(),a.z()),o.impulse=e.getAppliedImpulse(),o}_createSingleContactResult(e,t,s){const i=this.singleContactResultPool.allocate();return i.a=e,i.b=t,i.localPointA=s.localPoint,i.localPointB=s.localPointOther,i.pointA=s.point,i.pointB=s.pointOther,i.normal=s.normal,i.impulse=s.impulse,i}_createContactResult(e,t){const s=this.contactResultPool.allocate();return s.other=e,s.contacts=t,s}_cleanOldCollisions(){for(const e in this.collisions)if(this.collisions.hasOwnProperty(e)){const t=this.frameCollisions[e],s=this.collisions[e],i=s.entity,r=i.collision,a=i.rigidbody,o=s.others;let u=o.length;for(;u--;){const f=o[u];(!t||t.others.indexOf(f)<0)&&(o.splice(u,1),i.trigger?(r&&r.fire("triggerleave",f),f.rigidbody&&f.rigidbody.fire("triggerleave",i)):f.trigger||(a&&a.fire("collisionend",f),r&&r.fire("collisionend",f)))}o.length===0&&delete this.collisions[e]}}_hasContactEvent(e){const t=e.collision;if(t&&(t.hasEvent("collisionstart")||t.hasEvent("collisionend")||t.hasEvent("contact")))return!0;const s=e.rigidbody;return s&&(s.hasEvent("collisionstart")||s.hasEvent("collisionend")||s.hasEvent("contact"))}_checkForCollisions(e,t){const i=Ammo.wrapPointer(e,Ammo.btDynamicsWorld).getDispatcher(),r=i.getNumManifolds();this.frameCollisions={};for(let a=0;a<r;a++){const o=i.getManifoldByIndexInternal(a),h=o.getBody0(),u=o.getBody1(),f=Ammo.castObject(h,Ammo.btRigidBody),m=Ammo.castObject(u,Ammo.btRigidBody),_=f.entity,g=m.entity;if(!_||!g)continue;const S=f.getCollisionFlags(),x=m.getCollisionFlags(),T=o.getNumContacts(),E=[],b=[];let C;if(T>0)if(S&Ld||x&Ld){const w=_.collision&&(_.collision.hasEvent("triggerenter")||_.collision.hasEvent("triggerleave")),P=g.collision&&(g.collision.hasEvent("triggerenter")||g.collision.hasEvent("triggerleave")),I=_.rigidbody&&(_.rigidbody.hasEvent("triggerenter")||_.rigidbody.hasEvent("triggerleave")),M=g.rigidbody&&(g.rigidbody.hasEvent("triggerenter")||g.rigidbody.hasEvent("triggerleave"));w&&(C=this._storeCollision(_,g),C&&!(x&Ld)&&_.collision.fire("triggerenter",g)),P&&(C=this._storeCollision(g,_),C&&!(S&Ld)&&g.collision.fire("triggerenter",_)),I&&(C||(C=this._storeCollision(g,_)),C&&_.rigidbody.fire("triggerenter",g)),M&&(C||(C=this._storeCollision(_,g)),C&&g.rigidbody.fire("triggerenter",_))}else{const w=this._hasContactEvent(_),P=this._hasContactEvent(g),I=this.hasEvent("contact");if(I||w||P){for(let M=0;M<T;M++){const R=o.getContactPoint(M),L=this._createContactPointFromAmmo(R);if(w||P){E.push(L);const B=this._createReverseContactPointFromAmmo(R);b.push(B)}if(I){const B=this._createSingleContactResult(_,g,L);this.fire("contact",B)}}if(w){const M=this._createContactResult(g,E);C=this._storeCollision(_,g),_.collision&&(_.collision.fire("contact",M),C&&_.collision.fire("collisionstart",M)),_.rigidbody&&(_.rigidbody.fire("contact",M),C&&_.rigidbody.fire("collisionstart",M))}if(P){const M=this._createContactResult(_,b);C=this._storeCollision(g,_),g.collision&&(g.collision.fire("contact",M),C&&g.collision.fire("collisionstart",M)),g.rigidbody&&(g.rigidbody.fire("contact",M),C&&g.rigidbody.fire("collisionstart",M))}}}}this._cleanOldCollisions(),this.contactPointPool.freeAll(),this.contactResultPool.freeAll(),this.singleContactResultPool.freeAll()}onUpdate(e){let t,s;this._stats.physicsStart=vs(),this._gravityFloat32[0]=this.gravity.x,this._gravityFloat32[1]=this.gravity.y,this._gravityFloat32[2]=this.gravity.z;const i=this.dynamicsWorld.getGravity();(i.x()!==this._gravityFloat32[0]||i.y()!==this._gravityFloat32[1]||i.z()!==this._gravityFloat32[2])&&(i.setValue(this.gravity.x,this.gravity.y,this.gravity.z),this.dynamicsWorld.setGravity(i));const r=this._triggers;for(t=0,s=r.length;t<s;t++)r[t].updateTransform();const a=this._compounds;for(t=0,s=a.length;t<s;t++)a[t]._updateCompound();const o=this._kinematic;for(t=0,s=o.length;t<s;t++)o[t]._updateKinematic();this.dynamicsWorld.stepSimulation(e,this.maxSubSteps,this.fixedTimeStep);const h=this._dynamic;for(t=0,s=h.length;t<s;t++)h[t]._updateDynamic();this.dynamicsWorld.setInternalTickCallback||this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld),e),this._stats.physicsTime=vs()-this._stats.physicsStart}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this),typeof Ammo<"u"&&(Ammo.destroy(this.dynamicsWorld),Ammo.destroy(this.solver),Ammo.destroy(this.overlappingPairCache),Ammo.destroy(this.dispatcher),Ammo.destroy(this.collisionConfiguration),Ammo.destroy(Ea),Ammo.destroy(ba),this.dynamicsWorld=null,this.solver=null,this.overlappingPairCache=null,this.dispatcher=null,this.collisionConfiguration=null,Ea=null,ba=null,Ur.onAppDestroy())}constructor(e){super(e),this.maxSubSteps=10,this.fixedTimeStep=1/60,this.gravity=new D(0,-9.81,0),this._gravityFloat32=new Float32Array(3),this._dynamic=[],this._kinematic=[],this._triggers=[],this._compounds=[],this.id="rigidbody",this._stats=e.stats.frame,this.ComponentType=Ur,this.DataType=u9,this.contactPointPool=null,this.contactResultPool=null,this.singleContactResultPool=null,this.schema=YL,this.collisions={},this.frameCollisions={},this.on("beforeremove",this.onBeforeRemove,this)}}jL.EVENT_CONTACT="contact";ke._buildAccessors(Ur.prototype,YL);const Zc="none",p9="blend",uR=new fe;class $L extends ke{syncDrawOrder(){this.system.queueDrawOrderSync(this.entity.getGuid(),this._processDrawOrderSync,this)}_recurseDrawOrderSync(e,t){if(!(e instanceof Nt))return t;if(e.element){const i=e.element.drawOrder;e.element.drawOrder=t++,e.element._batchGroupId>=0&&i!==e.element.drawOrder&&this.system.app.batcher?.markGroupDirty(e.element._batchGroupId)}e.particlesystem&&(e.particlesystem.drawOrder=t++);const s=e.children;for(let i=0;i<s.length;i++)t=this._recurseDrawOrderSync(s[i],t);return t}_processDrawOrderSync(){this._recurseDrawOrderSync(this.entity,1),this.fire("syncdraworder")}_calcProjectionMatrix(){const e=this._resolution.x/this.scale,t=this._resolution.y/this.scale,s=0,i=e,r=-t;this._screenMatrix.setOrtho(s,i,r,0,1,-1),this._screenSpace||(uR.setScale(.5*e,.5*t,1),this._screenMatrix.mul2(uR,this._screenMatrix))}_updateScale(){this.scale=this._calcScale(this._resolution,this.referenceResolution)}_calcScale(e,t){const s=Math.log2((e.x||1)/t.x),i=Math.log2((e.y||1)/t.y);return Math.pow(2,s*(1-this._scaleBlend)+i*this._scaleBlend)}_onResize(e,t){this._screenSpace&&(this._resolution.set(e,t),this.resolution=this._resolution)}_bindElement(e){this._elements.add(e)}_unbindElement(e){this._elements.delete(e)}onRemove(){this.system.app.graphicsDevice.off("resizecanvas",this._onResize,this),this.fire("remove"),this._elements.forEach(e=>e._onScreenRemove()),this._elements.clear(),this.off()}set resolution(e){this._screenSpace?this._resolution.set(this.system.app.graphicsDevice.width,this.system.app.graphicsDevice.height):this._resolution.set(e.x,e.y),this._updateScale(),this._calcProjectionMatrix(),this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:resolution",this._resolution),this._elements.forEach(t=>t._onScreenResize(this._resolution))}get resolution(){return this._resolution}set referenceResolution(e){this._referenceResolution.set(e.x,e.y),this._updateScale(),this._calcProjectionMatrix(),this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:referenceresolution",this._resolution),this._elements.forEach(t=>t._onScreenResize(this._resolution))}get referenceResolution(){return this._scaleMode===Zc?this._resolution:this._referenceResolution}set screenSpace(e){this._screenSpace=e,this._screenSpace&&this._resolution.set(this.system.app.graphicsDevice.width,this.system.app.graphicsDevice.height),this.resolution=this._resolution,this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:screenspace",this._screenSpace),this._elements.forEach(t=>t._onScreenSpaceChange())}get screenSpace(){return this._screenSpace}set scaleMode(e){e!==Zc&&e!==p9&&(e=Zc),!this._screenSpace&&e!==Zc&&(e=Zc),this._scaleMode=e,this.resolution=this._resolution,this.fire("set:scalemode",this._scaleMode)}get scaleMode(){return this._scaleMode}set scaleBlend(e){this._scaleBlend=e,this._updateScale(),this._calcProjectionMatrix(),this.entity._dirtyLocal||this.entity._dirtifyLocal(),this.fire("set:scaleblend",this._scaleBlend),this._elements.forEach(t=>t._onScreenResize(this._resolution))}get scaleBlend(){return this._scaleBlend}set priority(e){e=J.clamp(e,0,127),this._priority!==e&&(this._priority=e,this.syncDrawOrder())}get priority(){return this._priority}constructor(e,t){super(e,t),this._resolution=new ne(640,320),this._referenceResolution=new ne(640,320),this._scaleMode=Zc,this.scale=1,this._scaleBlend=.5,this._priority=0,this._screenSpace=!1,this.cull=this._screenSpace,this._screenMatrix=new fe,this._elements=new Set,e.app.graphicsDevice.on("resizecanvas",this._onResize,this)}}class _9{constructor(){this.enabled=!0}}const bT=["enabled"];class g9 extends Ht{initializeComponentData(e,t,s){t.priority!==void 0&&(e.priority=t.priority),t.screenSpace!==void 0&&(e.screenSpace=t.screenSpace),e.cull=e.screenSpace,t.scaleMode!==void 0&&(e.scaleMode=t.scaleMode),t.scaleBlend!==void 0&&(e.scaleBlend=t.scaleBlend),t.resolution!==void 0&&(t.resolution instanceof ne?e._resolution.copy(t.resolution):e._resolution.set(t.resolution[0],t.resolution[1]),e.resolution=e._resolution),t.referenceResolution!==void 0&&(t.referenceResolution instanceof ne?e._referenceResolution.copy(t.referenceResolution):e._referenceResolution.set(t.referenceResolution[0],t.referenceResolution[1]),e.referenceResolution=e._referenceResolution),this._updateDescendantElements(e.entity,e.entity),e.syncDrawOrder(),super.initializeComponentData(e,t,bT)}_updateDescendantElements(e,t){const s=e.children;for(let i=0;i<s.length;i++){const r=s[i];r.element&&!r.element.screen&&r.element._updateScreen(t),r.screen||this._updateDescendantElements(r,t)}}destroy(){super.destroy(),this.app.graphicsDevice.off("resizecanvas",this._onResize,this),this.app.systems.off("update",this._onUpdate,this)}_onUpdate(e){const t=this.store;for(const s in t)t[s].entity.screen.update&&t[s].entity.screen.update(e)}_onResize(e,t){this.windowResolution.x=e,this.windowResolution.y=t}cloneComponent(e,t){const s=e.screen;return this.addComponent(t,{enabled:s.enabled,screenSpace:s.screenSpace,scaleMode:s.scaleMode,scaleBlend:s.scaleBlend,priority:s.priority,resolution:s.resolution.clone(),referenceResolution:s.referenceResolution.clone()})}onRemoveComponent(e,t){t.onRemove()}processDrawOrderSyncQueue(){const e=this._drawOrderSyncQueue.list();for(let t=0;t<e.length;t++){const s=e[t];s.callback.call(s.scope)}this._drawOrderSyncQueue.clear()}queueDrawOrderSync(e,t,s){this._drawOrderSyncQueue.list().length||this.app.once("prerender",this.processDrawOrderSyncQueue,this),this._drawOrderSyncQueue.has(e)||this._drawOrderSyncQueue.push(e,{callback:t,scope:s})}constructor(e){super(e),this.id="screen",this.ComponentType=$L,this.DataType=_9,this.schema=bT,this.windowResolution=new ne,this._drawOrderSyncQueue=new lB,this.app.graphicsDevice.on("resizecanvas",this._onResize,this),this.app.systems.on("update",this._onUpdate,this),this.on("beforeremove",this.onRemoveComponent,this)}}ke._buildAccessors($L.prototype,bT);const zn=new ne,dR=new D,$o=new Ux,fR=new zM,mR=new D,xd=new D,v9=new pe,S9={x:"y",y:"x"};class em extends Pe{_toggleLifecycleListeners(e){this._element[e]("mousedown",this._onMouseDownOrTouchStart,this),this._element[e]("touchstart",this._onMouseDownOrTouchStart,this),this._element[e]("selectstart",this._onMouseDownOrTouchStart,this)}_toggleDragListeners(e){const t=e==="on";this._hasDragListeners&&t||(this._app.mouse&&(this._element[e]("mousemove",this._onMove,this),this._element[e]("mouseup",this._onMouseUpOrTouchEnd,this)),Ve.touch&&(this._element[e]("touchmove",this._onMove,this),this._element[e]("touchend",this._onMouseUpOrTouchEnd,this),this._element[e]("touchcancel",this._onMouseUpOrTouchEnd,this)),this._element[e]("selectmove",this._onMove,this),this._element[e]("selectend",this._onMouseUpOrTouchEnd,this),this._hasDragListeners=t)}_onMouseDownOrTouchStart(e){if(this._element&&!this._isDragging&&this.enabled){this._dragCamera=e.camera,this._calculateDragScale();const t=this._screenToLocal(e);t&&(this._toggleDragListeners("on"),this._isDragging=!0,this._dragStartMousePosition.copy(t),this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition()),this.fire("drag:start"))}}_onMouseUpOrTouchEnd(){this._isDragging&&(this._isDragging=!1,this._toggleDragListeners("off"),this.fire("drag:end"))}_screenToLocal(e){return e.inputSource?$o.set(e.inputSource.getOrigin(),e.inputSource.getDirection()):(this._determineInputPosition(e),this._chooseRayOriginAndDirection()),mR.copy(this._element.entity.forward).mulScalar(-1),fR.setFromPointNormal(this._element.entity.getPosition(),mR),fR.intersectsRay($o,xd)?(v9.copy(this._element.entity.getRotation()).invert().transformVector(xd,xd),xd.mul(this._dragScale),xd):null}_determineInputPosition(e){const t=this._app.graphicsDevice.maxPixelRatio;typeof e.x<"u"&&typeof e.y<"u"?(zn.x=e.x*t,zn.y=e.y*t):e.changedTouches?(zn.x=e.changedTouches[0].x*t,zn.y=e.changedTouches[0].y*t):console.warn("Could not determine position from input event")}_chooseRayOriginAndDirection(){this._element.screen&&this._element.screen.screen.screenSpace?($o.origin.set(zn.x,-zn.y,0),$o.direction.copy(D.FORWARD)):(dR.copy(this._dragCamera.screenToWorld(zn.x,zn.y,1)),$o.origin.copy(this._dragCamera.entity.getPosition()),$o.direction.copy(dR).sub($o.origin).normalize())}_calculateDragScale(){let e=this._element.entity.parent;const t=this._element.screen&&this._element.screen.screen,s=t&&t.screenSpace,i=s?t.scale:1,r=this._dragScale;for(r.set(i,i,i);e&&(r.mul(e.getLocalScale()),e=e.parent,!(s&&e.screen)););r.x=1/r.x,r.y=1/r.y,r.z=0}_onMove(e){const{_element:t,_deltaMousePosition:s,_deltaHandlePosition:i,_axis:r}=this;if(t&&this._isDragging&&this.enabled&&t.enabled&&t.entity.enabled){const a=this._screenToLocal(e);if(a){if(s.sub2(a,this._dragStartMousePosition),i.add2(this._dragStartHandlePosition,s),r){const o=t.entity.getLocalPosition(),h=S9[r];i[h]=o[h]}t.entity.setLocalPosition(i),this.fire("drag:move",i)}}}destroy(){this._toggleLifecycleListeners("off"),this._toggleDragListeners("off")}set enabled(e){this._enabled=e}get enabled(){return this._enabled}get isDragging(){return this._isDragging}constructor(e,t){if(super(),!e||!(e instanceof bi))throw new Error("Element was null or not an ElementComponent");if(t&&t!=="x"&&t!=="y")throw new Error(`Unrecognized axis: ${t}`);this._element=e,this._app=e.system.app,this._axis=t||null,this._enabled=!0,this._dragScale=new D,this._dragStartMousePosition=new D,this._dragStartHandlePosition=new D,this._deltaMousePosition=new D,this._deltaHandlePosition=new D,this._isDragging=!1,this._toggleLifecycleListeners("on")}}em.EVENT_DRAGSTART="drag:start";em.EVENT_DRAGEND="drag:end";em.EVENT_DRAGMOVE="drag:move";const y9=0,pR=1,x9=2,T9=0,E9=1,Td=new ne;class KL extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){this._setValue("enabled",e)}get enabled(){return this.data.enabled}set horizontal(e){this._setValue("horizontal",e)}get horizontal(){return this.data.horizontal}set vertical(e){this._setValue("vertical",e)}get vertical(){return this.data.vertical}set scrollMode(e){this._setValue("scrollMode",e)}get scrollMode(){return this.data.scrollMode}set bounceAmount(e){this._setValue("bounceAmount",e)}get bounceAmount(){return this.data.bounceAmount}set friction(e){this._setValue("friction",e)}get friction(){return this.data.friction}set dragThreshold(e){this._setValue("dragThreshold",e)}get dragThreshold(){return this.data.dragThreshold}set useMouseWheel(e){this._setValue("useMouseWheel",e)}get useMouseWheel(){return this.data.useMouseWheel}set mouseWheelSensitivity(e){this._setValue("mouseWheelSensitivity",e)}get mouseWheelSensitivity(){return this.data.mouseWheelSensitivity}set horizontalScrollbarVisibility(e){this._setValue("horizontalScrollbarVisibility",e)}get horizontalScrollbarVisibility(){return this.data.horizontalScrollbarVisibility}set verticalScrollbarVisibility(e){this._setValue("verticalScrollbarVisibility",e)}get verticalScrollbarVisibility(){return this.data.verticalScrollbarVisibility}set viewportEntity(e){if(this._viewportEntity===e)return;const t=typeof e=="string";this._viewportEntity&&t&&this._viewportEntity.getGuid()===e||(this._viewportEntity&&this._viewportEntityUnsubscribe(),e instanceof Dt?this._viewportEntity=e:t?this._viewportEntity=this.system.app.getEntityFromIndex(e)||null:this._viewportEntity=null,this._viewportEntity&&this._viewportEntitySubscribe(),this._viewportEntity?this.data.viewportEntity=this._viewportEntity.getGuid():t&&e&&(this.data.viewportEntity=e))}get viewportEntity(){return this._viewportEntity}set contentEntity(e){if(this._contentEntity===e)return;const t=typeof e=="string";this._contentEntity&&t&&this._contentEntity.getGuid()===e||(this._contentEntity&&this._contentEntityUnsubscribe(),e instanceof Dt?this._contentEntity=e:t?this._contentEntity=this.system.app.getEntityFromIndex(e)||null:this._contentEntity=null,this._contentEntity&&this._contentEntitySubscribe(),this._contentEntity?this.data.contentEntity=this._contentEntity.getGuid():t&&e&&(this.data.contentEntity=e))}get contentEntity(){return this._contentEntity}set horizontalScrollbarEntity(e){if(this._horizontalScrollbarEntity===e)return;const t=typeof e=="string";this._horizontalScrollbarEntity&&t&&this._horizontalScrollbarEntity.getGuid()===e||(this._horizontalScrollbarEntity&&this._horizontalScrollbarEntityUnsubscribe(),e instanceof Dt?this._horizontalScrollbarEntity=e:t?this._horizontalScrollbarEntity=this.system.app.getEntityFromIndex(e)||null:this._horizontalScrollbarEntity=null,this._scrollbarEntities[We]=this._horizontalScrollbarEntity,this._horizontalScrollbarEntity&&this._horizontalScrollbarEntitySubscribe(),this._horizontalScrollbarEntity?this.data.horizontalScrollbarEntity=this._horizontalScrollbarEntity.getGuid():t&&e&&(this.data.horizontalScrollbarEntity=e))}get horizontalScrollbarEntity(){return this._horizontalScrollbarEntity}set verticalScrollbarEntity(e){if(this._verticalScrollbarEntity===e)return;const t=typeof e=="string";this._verticalScrollbarEntity&&t&&this._verticalScrollbarEntity.getGuid()===e||(this._verticalScrollbarEntity&&this._verticalScrollbarEntityUnsubscribe(),e instanceof Dt?this._verticalScrollbarEntity=e:t?this._verticalScrollbarEntity=this.system.app.getEntityFromIndex(e)||null:this._verticalScrollbarEntity=null,this._scrollbarEntities[Tt]=this._verticalScrollbarEntity,this._verticalScrollbarEntity&&this._verticalScrollbarEntitySubscribe(),this._verticalScrollbarEntity?this.data.verticalScrollbarEntity=this._verticalScrollbarEntity.getGuid():t&&e&&(this.data.verticalScrollbarEntity=e))}get verticalScrollbarEntity(){return this._verticalScrollbarEntity}set scroll(e){this._onSetScroll(e.x,e.y)}get scroll(){return this._scroll}_setValue(e,t){const s=this.data,i=s[e];s[e]=t,this.fire("set",e,i,t)}_toggleLifecycleListeners(e){this[e]("set_horizontal",this._onSetHorizontalScrollingEnabled,this),this[e]("set_vertical",this._onSetVerticalScrollingEnabled,this),this.entity[e]("element:add",this._onElementComponentAdd,this)}_toggleElementListeners(e){if(this.entity.element){if(e==="on"&&this._hasElementListeners)return;this.entity.element[e]("resize",this._syncAll,this),this.entity.element[e]("mousewheel",this._onMouseWheel,this),this._hasElementListeners=e==="on"}}_onElementComponentAdd(e){this._evtElementRemove=this.entity.element.once("beforeremove",this._onElementComponentRemove,this),this._toggleElementListeners("on")}_onElementComponentRemove(e){this._evtElementRemove?.off(),this._evtElementRemove=null,this._toggleElementListeners("off")}_viewportEntitySubscribe(){this._evtViewportEntityElementAdd=this._viewportEntity.on("element:add",this._onViewportElementGain,this),this._viewportEntity.element&&this._onViewportElementGain()}_viewportEntityUnsubscribe(){this._evtViewportEntityElementAdd?.off(),this._evtViewportEntityElementAdd=null,this._viewportEntity?.element&&this._onViewportElementLose()}_viewportEntityElementSubscribe(){const e=this._viewportEntity.element;this._evtViewportElementRemove=e.once("beforeremove",this._onViewportElementLose,this),this._evtViewportResize=e.on("resize",this._syncAll,this)}_viewportEntityElementUnsubscribe(){this._evtViewportElementRemove?.off(),this._evtViewportElementRemove=null,this._evtViewportResize?.off(),this._evtViewportResize=null}_onViewportElementGain(){this._viewportEntityElementSubscribe(),this._syncAll()}_onViewportElementLose(){this._viewportEntityElementUnsubscribe()}_contentEntitySubscribe(){this._evtContentEntityElementAdd=this._contentEntity.on("element:add",this._onContentElementGain,this),this._contentEntity.element&&this._onContentElementGain()}_contentEntityUnsubscribe(){this._evtContentEntityElementAdd?.off(),this._evtContentEntityElementAdd=null,this._contentEntity?.element&&this._onContentElementLose()}_contentEntityElementSubscribe(){const e=this._contentEntity.element;this._evtContentElementRemove=e.once("beforeremove",this._onContentElementLose,this),this._evtContentResize=e.on("resize",this._syncAll,this)}_contentEntityElementUnsubscribe(){this._evtContentElementRemove?.off(),this._evtContentElementRemove=null,this._evtContentResize?.off(),this._evtContentResize=null}_onContentElementGain(){this._contentEntityElementSubscribe(),this._destroyDragHelper(),this._contentDragHelper=new em(this._contentEntity.element),this._contentDragHelper.on("drag:start",this._onContentDragStart,this),this._contentDragHelper.on("drag:end",this._onContentDragEnd,this),this._contentDragHelper.on("drag:move",this._onContentDragMove,this),this._prevContentSizes[We]=null,this._prevContentSizes[Tt]=null,this._syncAll()}_onContentElementLose(){this._contentEntityElementUnsubscribe(),this._destroyDragHelper()}_onContentDragStart(){this._contentEntity&&this.enabled&&this.entity.enabled&&this._dragStartPosition.copy(this._contentEntity.getLocalPosition())}_onContentDragEnd(){this._prevContentDragPosition=null,this._enableContentInput()}_onContentDragMove(e){if(this._contentEntity&&this.enabled&&this.entity.enabled&&(this._wasDragged=!0,this._setScrollFromContentPosition(e),this._setVelocityFromContentPositionDelta(e),!this._disabledContentInput)){const t=e.x-this._dragStartPosition.x,s=e.y-this._dragStartPosition.y;(Math.abs(t)>this.dragThreshold||Math.abs(s)>this.dragThreshold)&&this._disableContentInput()}}_horizontalScrollbarEntitySubscribe(){this._evtHorizontalScrollbarAdd=this._horizontalScrollbarEntity.on("scrollbar:add",this._onHorizontalScrollbarGain,this),this._horizontalScrollbarEntity.scrollbar&&this._onHorizontalScrollbarGain()}_verticalScrollbarEntitySubscribe(){this._evtVerticalScrollbarAdd=this._verticalScrollbarEntity.on("scrollbar:add",this._onVerticalScrollbarGain,this),this._verticalScrollbarEntity.scrollbar&&this._onVerticalScrollbarGain()}_horizontalScrollbarEntityUnsubscribe(){this._evtHorizontalScrollbarAdd?.off(),this._evtHorizontalScrollbarAdd=null,this._horizontalScrollbarEntity.scrollbar&&this._onHorizontalScrollbarLose()}_verticalScrollbarEntityUnsubscribe(){this._evtVerticalScrollbarAdd?.off(),this._evtVerticalScrollbarAdd=null,this._verticalScrollbarEntity.scrollbar&&this._onVerticalScrollbarLose()}_onSetHorizontalScrollbarValue(e){!this._scrollbarUpdateFlags[We]&&this.enabled&&this.entity.enabled&&this._onSetScroll(e,null)}_onSetVerticalScrollbarValue(e){!this._scrollbarUpdateFlags[Tt]&&this.enabled&&this.entity.enabled&&this._onSetScroll(null,e)}_onHorizontalScrollbarGain(){const e=this._horizontalScrollbarEntity?.scrollbar;this._evtHorizontalScrollbarRemove=e.on("beforeremove",this._onHorizontalScrollbarLose,this),this._evtHorizontalScrollbarValue=e.on("set:value",this._onSetHorizontalScrollbarValue,this),this._syncScrollbarEnabledState(We),this._syncScrollbarPosition(We)}_onVerticalScrollbarGain(){const e=this._verticalScrollbarEntity?.scrollbar;this._evtVerticalScrollbarRemove=e.on("beforeremove",this._onVerticalScrollbarLose,this),this._evtVerticalScrollbarValue=e.on("set:value",this._onSetVerticalScrollbarValue,this),this._syncScrollbarEnabledState(Tt),this._syncScrollbarPosition(Tt)}_onHorizontalScrollbarLose(){this._evtHorizontalScrollbarRemove?.off(),this._evtHorizontalScrollbarRemove=null,this._evtHorizontalScrollbarValue?.off(),this._evtHorizontalScrollbarValue=null}_onVerticalScrollbarLose(){this._evtVerticalScrollbarRemove?.off(),this._evtVerticalScrollbarRemove=null,this._evtVerticalScrollbarValue?.off(),this._evtVerticalScrollbarValue=null}_onSetHorizontalScrollingEnabled(){this._syncScrollbarEnabledState(We)}_onSetVerticalScrollingEnabled(){this._syncScrollbarEnabledState(Tt)}_onSetScroll(e,t,s){s!==!1&&this._velocity.set(0,0,0);const i=this._updateAxis(e,"x",We),r=this._updateAxis(t,"y",Tt);(i||r)&&this.fire("set:scroll",this._scroll)}_updateAxis(e,t,s){const i=e!==null&&Math.abs(e-this._scroll[t])>1e-5;return(i||this._isDragging()||e===0)&&(this._scroll[t]=this._determineNewScrollValue(e,t,s),this._syncContentPosition(s),this._syncScrollbarPosition(s)),i}_determineNewScrollValue(e,t,s){if(!this._getScrollingEnabled(s))return this._scroll[t];switch(this.scrollMode){case y9:return J.clamp(e,0,this._getMaxScrollValue(s));case pR:return this._setVelocityFromOvershoot(e,t,s),e;case x9:return e;default:return console.warn(`Unhandled scroll mode:${this.scrollMode}`),e}}_syncAll(){this._syncContentPosition(We),this._syncContentPosition(Tt),this._syncScrollbarPosition(We),this._syncScrollbarPosition(Tt),this._syncScrollbarEnabledState(We),this._syncScrollbarEnabledState(Tt)}_syncContentPosition(e){if(!this._contentEntity)return;const t=this._getAxis(e),s=this._getSign(e),i=this._prevContentSizes[e],r=this._getContentSize(e);if(i!==null&&Math.abs(i-r)>1e-4){const h=this._getMaxOffset(e,i),u=this._getMaxOffset(e,r);u===0?this._scroll[t]=1:this._scroll[t]=J.clamp(this._scroll[t]*h/u,0,1)}const a=this._scroll[t]*this._getMaxOffset(e),o=this._contentEntity.getLocalPosition();o[t]=a*s,this._contentEntity.setLocalPosition(o),this._prevContentSizes[e]=r}_syncScrollbarPosition(e){const t=this._scrollbarEntities[e];if(!t?.scrollbar)return;const s=this._getAxis(e);this._scrollbarUpdateFlags[e]=!0,t.scrollbar.value=this._scroll[s],t.scrollbar.handleSize=this._getScrollbarHandleSize(s,e),this._scrollbarUpdateFlags[e]=!1}_syncScrollbarEnabledState(e){const t=this._scrollbarEntities[e];if(!t)return;const s=this._getScrollingEnabled(e),i=this._getScrollbarVisibility(e);switch(i){case T9:t.enabled=s;return;case E9:t.enabled=s&&this._contentIsLargerThanViewport(e);return;default:console.warn(`Unhandled scrollbar visibility:${i}`),t.enabled=s}}_contentIsLargerThanViewport(e){return this._getContentSize(e)>this._getViewportSize(e)}_contentPositionToScrollValue(e){const t=this._getMaxOffset(We),s=this._getMaxOffset(Tt);return t===0?Td.x=0:Td.x=e.x/t,s===0?Td.y=0:Td.y=e.y/-s,Td}_getMaxOffset(e,t){t=t===void 0?this._getContentSize(e):t;const s=this._getViewportSize(e);return t<s?-this._getViewportSize(e):s-t}_getMaxScrollValue(e){return this._contentIsLargerThanViewport(e)?1:0}_getScrollbarHandleSize(e,t){const s=this._getViewportSize(t),i=this._getContentSize(t);if(Math.abs(i)<.001)return 1;const r=Math.min(s/i,1),a=this._toOvershoot(this._scroll[e],t);return a===0?r:r/(1+Math.abs(a))}_getViewportSize(e){return this._getSize(e,this._viewportEntity)}_getContentSize(e){return this._getSize(e,this._contentEntity)}_getSize(e,t){return t?.element?t.element[this._getCalculatedDimension(e)]:0}_getScrollingEnabled(e){if(e===We)return this.horizontal;if(e===Tt)return this.vertical}_getScrollbarVisibility(e){if(e===We)return this.horizontalScrollbarVisibility;if(e===Tt)return this.verticalScrollbarVisibility}_getSign(e){return e===We?1:-1}_getAxis(e){return e===We?"x":"y"}_getCalculatedDimension(e){return e===We?"calculatedWidth":"calculatedHeight"}_destroyDragHelper(){this._contentDragHelper&&this._contentDragHelper.destroy()}onUpdate(){this._contentEntity&&(this._updateVelocity(),this._syncScrollbarEnabledState(We),this._syncScrollbarEnabledState(Tt))}_updateVelocity(){if(!this._isDragging()){if(this.scrollMode===pR&&(this._hasOvershoot("x",We)&&this._setVelocityFromOvershoot(this.scroll.x,"x",We),this._hasOvershoot("y",Tt)&&this._setVelocityFromOvershoot(this.scroll.y,"y",Tt)),Math.abs(this._velocity.x)>1e-4||Math.abs(this._velocity.y)>1e-4){const e=this._contentEntity.getLocalPosition();e.x+=this._velocity.x,e.y+=this._velocity.y,this._contentEntity.setLocalPosition(e),this._setScrollFromContentPosition(e)}this._velocity.x*=1-this.friction,this._velocity.y*=1-this.friction}}_hasOvershoot(e,t){return Math.abs(this._toOvershoot(this.scroll[e],t))>.001}_toOvershoot(e,t){const s=this._getMaxScrollValue(t);return e<0?e:e>s?e-s:0}_setVelocityFromOvershoot(e,t,s){const r=this._toOvershoot(e,s)*this._getMaxOffset(s)*this._getSign(s);Math.abs(r)>0&&(this._velocity[t]=-r/(this.bounceAmount*50+1))}_setVelocityFromContentPositionDelta(e){this._prevContentDragPosition?(this._velocity.sub2(e,this._prevContentDragPosition),this._prevContentDragPosition.copy(e)):(this._velocity.set(0,0,0),this._prevContentDragPosition=e.clone())}_setScrollFromContentPosition(e){let t=this._contentPositionToScrollValue(e);this._isDragging()&&(t=this._applyScrollValueTension(t)),this._onSetScroll(t.x,t.y,!1)}_applyScrollValueTension(e){let s=this._getMaxScrollValue(We),i=this._toOvershoot(e.x,We);return i>0?e.x=s+1*Math.log10(1+i):i<0&&(e.x=-1*Math.log10(1-i)),s=this._getMaxScrollValue(Tt),i=this._toOvershoot(e.y,Tt),i>0?e.y=s+1*Math.log10(1+i):i<0&&(e.y=-1*Math.log10(1-i)),e}_isDragging(){return this._contentDragHelper&&this._contentDragHelper.isDragging}_setScrollbarComponentsEnabled(e){this._horizontalScrollbarEntity?.scrollbar&&(this._horizontalScrollbarEntity.scrollbar.enabled=e),this._verticalScrollbarEntity?.scrollbar&&(this._verticalScrollbarEntity.scrollbar.enabled=e)}_setContentDraggingEnabled(e){this._contentDragHelper&&(this._contentDragHelper.enabled=e)}_onMouseWheel(e){if(!this.useMouseWheel||!this._contentEntity?.element)return;const t=e.event,s=t.deltaX/this._contentEntity.element.calculatedWidth*this.mouseWheelSensitivity.x,i=t.deltaY/this._contentEntity.element.calculatedHeight*this.mouseWheelSensitivity.y,r=J.clamp(this._scroll.x+s,0,this._getMaxScrollValue(We)),a=J.clamp(this._scroll.y+i,0,this._getMaxScrollValue(Tt));this.scroll=new ne(r,a)}_enableContentInput(){for(;this._disabledContentInputEntities.length;){const e=this._disabledContentInputEntities.pop();e.element&&(e.element.useInput=!0)}this._disabledContentInput=!1}_disableContentInput(){const e=t=>{t.element&&t.element.useInput&&(this._disabledContentInputEntities.push(t),t.element.useInput=!1);const s=t.children;for(let i=0,r=s.length;i<r;i++)e(s[i])};if(this._contentEntity){const t=this._contentEntity.children;for(let s=0,i=t.length;s<i;s++)e(t[s])}this._disabledContentInput=!0}onEnable(){this._setScrollbarComponentsEnabled(!0),this._setContentDraggingEnabled(!0),this._syncAll()}onDisable(){this._setScrollbarComponentsEnabled(!1),this._setContentDraggingEnabled(!1)}onRemove(){this._toggleLifecycleListeners("off"),this._toggleElementListeners("off"),this._destroyDragHelper()}resolveDuplicatedEntityReferenceProperties(e,t){e.viewportEntity&&(this.viewportEntity=t[e.viewportEntity.getGuid()]),e.contentEntity&&(this.contentEntity=t[e.contentEntity.getGuid()]),e.horizontalScrollbarEntity&&(this.horizontalScrollbarEntity=t[e.horizontalScrollbarEntity.getGuid()]),e.verticalScrollbarEntity&&(this.verticalScrollbarEntity=t[e.verticalScrollbarEntity.getGuid()])}constructor(e,t){super(e,t),this._viewportEntity=null,this._contentEntity=null,this._horizontalScrollbarEntity=null,this._verticalScrollbarEntity=null,this._evtElementRemove=null,this._evtViewportElementRemove=null,this._evtViewportResize=null,this._evtContentEntityElementAdd=null,this._evtContentElementRemove=null,this._evtContentResize=null,this._evtHorizontalScrollbarAdd=null,this._evtHorizontalScrollbarRemove=null,this._evtHorizontalScrollbarValue=null,this._evtVerticalScrollbarAdd=null,this._evtVerticalScrollbarRemove=null,this._evtVerticalScrollbarValue=null,this._scrollbarUpdateFlags={},this._scrollbarEntities={},this._prevContentSizes={},this._prevContentSizes[We]=null,this._prevContentSizes[Tt]=null,this._scroll=new ne,this._velocity=new D,this._dragStartPosition=new D,this._disabledContentInput=!1,this._disabledContentInputEntities=[],this._toggleLifecycleListeners("on"),this._toggleElementListeners("on")}}KL.EVENT_SETSCROLL="set:scroll";const b9=10;class A9{constructor(){this.enabled=!0,this.dragThreshold=b9,this.useMouseWheel=!0,this.mouseWheelSensitivity=new ne(1,1),this.horizontalScrollbarVisibility=0,this.verticalScrollbarVisibility=0,this.viewportEntity=null,this.contentEntity=null,this.horizontalScrollbarEntity=null,this.verticalScrollbarEntity=null}}const _R=[{name:"enabled",type:"boolean"},{name:"horizontal",type:"boolean"},{name:"vertical",type:"boolean"},{name:"scrollMode",type:"number"},{name:"bounceAmount",type:"number"},{name:"friction",type:"number"},{name:"dragThreshold",type:"number"},{name:"useMouseWheel",type:"boolean"},{name:"mouseWheelSensitivity",type:"vec2"},{name:"horizontalScrollbarVisibility",type:"number"},{name:"verticalScrollbarVisibility",type:"number"}],w9=10;class C9 extends Ht{initializeComponentData(e,t,s){t.dragThreshold===void 0&&(t.dragThreshold=w9),t.useMouseWheel===void 0&&(t.useMouseWheel=!0),t.mouseWheelSensitivity===void 0&&(t.mouseWheelSensitivity=new ne(1,1)),super.initializeComponentData(e,t,_R),e.viewportEntity=t.viewportEntity,e.contentEntity=t.contentEntity,e.horizontalScrollbarEntity=t.horizontalScrollbarEntity,e.verticalScrollbarEntity=t.verticalScrollbarEntity}onUpdate(e){const t=this.store;for(const s in t){const i=t[s].entity,r=i.scrollview;r.enabled&&i.enabled&&r.onUpdate()}}_onRemoveComponent(e,t){t.onRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}constructor(e){super(e),this.id="scrollview",this.ComponentType=KL,this.DataType=A9,this.schema=_R,this.on("beforeremove",this._onRemoveComponent,this),this.app.systems.on("update",this.onUpdate,this)}}class ZL extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){this._setValue("enabled",e)}get enabled(){return this.data.enabled}set orientation(e){this._setValue("orientation",e)}get orientation(){return this.data.orientation}set value(e){this._setValue("value",e)}get value(){return this.data.value}set handleSize(e){this._setValue("handleSize",e)}get handleSize(){return this.data.handleSize}set handleEntity(e){if(this._handleEntity===e)return;const t=typeof e=="string";this._handleEntity&&t&&this._handleEntity.getGuid()===e||(this._handleEntity&&this._handleEntityUnsubscribe(),e instanceof Dt?this._handleEntity=e:t?this._handleEntity=this.system.app.getEntityFromIndex(e)||null:this._handleEntity=null,this._handleEntity&&this._handleEntitySubscribe(),this._handleEntity?this.data.handleEntity=this._handleEntity.getGuid():t&&e&&(this.data.handleEntity=e))}get handleEntity(){return this._handleEntity}_setValue(e,t){const s=this.data,i=s[e];s[e]=t,this.fire("set",e,i,t)}_toggleLifecycleListeners(e){this[e]("set_value",this._onSetValue,this),this[e]("set_handleSize",this._onSetHandleSize,this),this[e]("set_orientation",this._onSetOrientation,this)}_handleEntitySubscribe(){this._evtHandleEntityElementAdd=this._handleEntity.on("element:add",this._onHandleElementGain,this),this._handleEntity.element&&this._onHandleElementGain()}_handleEntityUnsubscribe(){this._evtHandleEntityElementAdd?.off(),this._evtHandleEntityElementAdd=null,this._handleEntity?.element&&this._onHandleElementLose()}_handleEntityElementSubscribe(){const e=this._handleEntity.element,t=this._evtHandleEntityChanges;t.push(e.once("beforeremove",this._onHandleElementLose,this)),t.push(e.on("set:anchor",this._onSetHandleAlignment,this)),t.push(e.on("set:margin",this._onSetHandleAlignment,this)),t.push(e.on("set:pivot",this._onSetHandleAlignment,this))}_handleEntityElementUnsubscribe(){for(let e=0;e<this._evtHandleEntityChanges.length;e++)this._evtHandleEntityChanges[e].off();this._evtHandleEntityChanges.length=0}_onHandleElementGain(){this._handleEntityElementSubscribe(),this._destroyDragHelper(),this._handleDragHelper=new em(this._handleEntity.element,this._getAxis()),this._handleDragHelper.on("drag:move",this._onHandleDrag,this),this._updateHandlePositionAndSize()}_onHandleElementLose(){this._handleEntityElementUnsubscribe(),this._destroyDragHelper()}_onHandleDrag(e){this._handleEntity&&this.enabled&&this.entity.enabled&&(this.value=this._handlePositionToScrollValue(e[this._getAxis()]))}_onSetValue(e,t,s){Math.abs(s-t)>1e-5&&(this.data.value=J.clamp(s,0,1),this._updateHandlePositionAndSize(),this.fire("set:value",this.data.value))}_onSetHandleSize(e,t,s){Math.abs(s-t)>1e-5&&(this.data.handleSize=J.clamp(s,0,1),this._updateHandlePositionAndSize())}_onSetHandleAlignment(){this._updateHandlePositionAndSize()}_onSetOrientation(e,t,s){s!==t&&this._handleEntity?.element&&(this._handleEntity.element[this._getOppositeDimension()]=0)}_updateHandlePositionAndSize(){const e=this._handleEntity,t=e?.element;if(e){const s=e.getLocalPosition();s[this._getAxis()]=this._getHandlePosition(),e.setLocalPosition(s)}t&&(t[this._getDimension()]=this._getHandleLength())}_handlePositionToScrollValue(e){return e*this._getSign()/this._getUsableTrackLength()}_scrollValueToHandlePosition(e){return e*this._getSign()*this._getUsableTrackLength()}_getUsableTrackLength(){return Math.max(this._getTrackLength()-this._getHandleLength(),.001)}_getTrackLength(){return this.entity.element?this.orientation===We?this.entity.element.calculatedWidth:this.entity.element.calculatedHeight:0}_getHandleLength(){return this._getTrackLength()*this.handleSize}_getHandlePosition(){return this._scrollValueToHandlePosition(this.value)}_getSign(){return this.orientation===We?1:-1}_getAxis(){return this.orientation===We?"x":"y"}_getDimension(){return this.orientation===We?"width":"height"}_getOppositeDimension(){return this.orientation===We?"height":"width"}_destroyDragHelper(){this._handleDragHelper&&this._handleDragHelper.destroy()}_setHandleDraggingEnabled(e){this._handleDragHelper&&(this._handleDragHelper.enabled=e)}onEnable(){this._setHandleDraggingEnabled(!0)}onDisable(){this._setHandleDraggingEnabled(!1)}onRemove(){this._destroyDragHelper(),this._toggleLifecycleListeners("off")}resolveDuplicatedEntityReferenceProperties(e,t){e.handleEntity&&(this.handleEntity=t[e.handleEntity.getGuid()])}constructor(e,t){super(e,t),this._handleEntity=null,this._evtHandleEntityElementAdd=null,this._evtHandleEntityChanges=[],this._toggleLifecycleListeners("on")}}ZL.EVENT_SETVALUE="set:value";class D9{constructor(){this.enabled=!0,this.orientation=We,this.value=0,this.handleSize=0,this.handleEntity=null}}const gR=[{name:"enabled",type:"boolean"},{name:"orientation",type:"number"},{name:"value",type:"number"},{name:"handleSize",type:"number"}];class P9 extends Ht{initializeComponentData(e,t,s){super.initializeComponentData(e,t,gR),e.handleEntity=t.handleEntity}_onAddComponent(e){e.fire("scrollbar:add")}_onRemoveComponent(e,t){t.onRemove()}constructor(e){super(e),this.id="scrollbar",this.ComponentType=ZL,this.DataType=D9,this.schema=gR,this.on("add",this._onAddComponent,this),this.on("beforeremove",this._onRemoveComponent,this)}}const R9={volume:0,pitch:0,loop:!1,startTime:0,duration:0,position:new D,maxDistance:0,refDistance:0,rollOffFactor:0,distanceModel:0,onPlay:null,onPause:null,onResume:null,onStop:null,onEnd:null};class qa extends Pe{play(){if(this.overlap||this.stop(),!this.isLoaded&&!this._hasAsset())return;const e=this._createInstance();if(this.instances.push(e),this.isLoaded)e.play();else{const t=function(s){const i=e._playWhenLoaded;e.sound=s,i&&e.play()};this.off("load",t),this.once("load",t),this.load()}return e}pause(){let e=!1;const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].pause()&&(e=!0);return e}resume(){let e=!1;const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].resume()&&(e=!0);return e}stop(){let e=!1;const t=this.instances;let s=t.length;for(;s--;)t[s].stop(),e=!0;return t.length=0,e}load(){if(!this._hasAsset())return;const e=this._assets.get(this._asset);if(!e){this._assets.off(`add:${this._asset}`,this._onAssetAdd,this),this._assets.once(`add:${this._asset}`,this._onAssetAdd,this);return}if(e.off("remove",this._onAssetRemoved,this),e.on("remove",this._onAssetRemoved,this),!e.resource){e.off("load",this._onAssetLoad,this),e.once("load",this._onAssetLoad,this),this._assets.load(e);return}this.fire("load",e.resource)}setExternalNodes(e,t){if(!e){console.error("The firstNode must have a valid AudioNode");return}if(t||(t=e),this._firstNode=e,this._lastNode=t,!this._overlap){const s=this.instances;for(let i=0,r=s.length;i<r;i++)s[i].setExternalNodes(e,t)}}clearExternalNodes(){if(this._firstNode=null,this._lastNode=null,!this._overlap){const e=this.instances;for(let t=0,s=e.length;t<s;t++)e[t].clearExternalNodes()}}getExternalNodes(){return[this._firstNode,this._lastNode]}_hasAsset(){return this._asset!=null}_createInstance(){let e=null;const t=this._component;let s=null;if(this._hasAsset()){const r=this._assets.get(this._asset);r&&(s=r.resource)}const i=R9;return i.volume=this._volume*t.volume,i.pitch=this._pitch*t.pitch,i.loop=this._loop,i.startTime=this._startTime,i.duration=this._duration,i.onPlay=this._onInstancePlayHandler,i.onPause=this._onInstancePauseHandler,i.onResume=this._onInstanceResumeHandler,i.onStop=this._onInstanceStopHandler,i.onEnd=this._onInstanceEndHandler,t.positional?(i.position.copy(t.entity.getPosition()),i.maxDistance=t.maxDistance,i.refDistance=t.refDistance,i.rollOffFactor=t.rollOffFactor,i.distanceModel=t.distanceModel,e=new sh(this._manager,s,i)):e=new Vi(this._manager,s,i),this._firstNode&&e.setExternalNodes(this._firstNode,this._lastNode),e}_onInstancePlay(e){this.fire("play",e),this._component.fire("play",this,e)}_onInstancePause(e){this.fire("pause",e),this._component.fire("pause",this,e)}_onInstanceResume(e){this.fire("resume",e),this._component.fire("resume",this,e)}_onInstanceStop(e){const t=this.instances.indexOf(e);t!==-1&&this.instances.splice(t,1),this.fire("stop",e),this._component.fire("stop",this,e)}_onInstanceEnd(e){const t=this.instances.indexOf(e);t!==-1&&this.instances.splice(t,1),this.fire("end",e),this._component.fire("end",this,e)}_onAssetAdd(e){this.load()}_onAssetLoad(e){this.load()}_onAssetRemoved(e){e.off("remove",this._onAssetRemoved,this),this._assets.off(`add:${e.id}`,this._onAssetAdd,this),this.stop()}updatePosition(e){const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].position=e}set asset(e){const t=this._asset;if(t){this._assets.off(`add:${t}`,this._onAssetAdd,this);const s=this._assets.get(t);s&&s.off("remove",this._onAssetRemoved,this)}this._asset=e,this._asset instanceof Ee&&(this._asset=this._asset.id),this._hasAsset()&&this._component.enabled&&this._component.entity.enabled&&this.load()}get asset(){return this._asset}set autoPlay(e){this._autoPlay=!!e}get autoPlay(){return this._autoPlay}set duration(e){if(this._duration=Math.max(0,Number(e)||0)||null,!this._overlap){const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].duration=this._duration}}get duration(){let e=0;if(this._hasAsset()){const t=this._assets.get(this._asset);e=t?.resource?t.resource.duration:0}return this._duration!=null?this._duration%(e||1):e}get isLoaded(){if(this._hasAsset()){const e=this._assets.get(this._asset);if(e)return!!e.resource}return!1}get isPaused(){const e=this.instances,t=e.length;if(t===0)return!1;for(let s=0;s<t;s++)if(!e[s].isPaused)return!1;return!0}get isPlaying(){const e=this.instances;for(let t=0,s=e.length;t<s;t++)if(e[t].isPlaying)return!0;return!1}get isStopped(){const e=this.instances;for(let t=0,s=e.length;t<s;t++)if(!e[t].isStopped)return!1;return!0}set loop(e){this._loop=!!e;const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].loop=this._loop}get loop(){return this._loop}set overlap(e){this._overlap=!!e}get overlap(){return this._overlap}set pitch(e){if(this._pitch=Math.max(Number(e)||0,.01),!this._overlap){const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].pitch=this.pitch*this._component.pitch}}get pitch(){return this._pitch}set startTime(e){if(this._startTime=Math.max(0,Number(e)||0),!this._overlap){const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].startTime=this._startTime}}get startTime(){return this._startTime}set volume(e){if(this._volume=J.clamp(Number(e)||0,0,1),!this._overlap){const t=this.instances;for(let s=0,i=t.length;s<i;s++)t[s].volume=this._volume*this._component.volume}}get volume(){return this._volume}constructor(e,t="Untitled",s={}){super(),this.instances=[],this._component=e,this._assets=e.system.app.assets,this._manager=e.system.manager,this.name=t,this._volume=s.volume!==void 0?J.clamp(Number(s.volume)||0,0,1):1,this._pitch=s.pitch!==void 0?Math.max(.01,Number(s.pitch)||0):1,this._loop=!!(s.loop!==void 0&&s.loop),this._duration=s.duration>0?s.duration:null,this._startTime=Math.max(0,Number(s.startTime)||0),this._overlap=!!s.overlap,this._autoPlay=!!s.autoPlay,this._firstNode=null,this._lastNode=null,this._asset=s.asset,this._asset instanceof Ee&&(this._asset=this._asset.id),this._onInstancePlayHandler=this._onInstancePlay.bind(this),this._onInstancePauseHandler=this._onInstancePause.bind(this),this._onInstanceResumeHandler=this._onInstanceResume.bind(this),this._onInstanceStopHandler=this._onInstanceStop.bind(this),this._onInstanceEndHandler=this._onInstanceEnd.bind(this)}}qa.EVENT_PLAY="play";qa.EVENT_PAUSE="pause";qa.EVENT_RESUME="resume";qa.EVENT_STOP="stop";qa.EVENT_END="end";qa.EVENT_LOAD="load";class Ul extends ke{_updateSoundInstances(e,t,s){const i=this._slots;for(const r in i){const a=i[r];if(!a.overlap){const o=a.instances;for(let h=0,u=o.length;h<u;h++)o[h][e]=s?a[e]*t:t}}}set distanceModel(e){this._distanceModel=e,this._updateSoundInstances("distanceModel",e,!1)}get distanceModel(){return this._distanceModel}set maxDistance(e){this._maxDistance=e,this._updateSoundInstances("maxDistance",e,!1)}get maxDistance(){return this._maxDistance}set refDistance(e){this._refDistance=e,this._updateSoundInstances("refDistance",e,!1)}get refDistance(){return this._refDistance}set rollOffFactor(e){this._rollOffFactor=e,this._updateSoundInstances("rollOffFactor",e,!1)}get rollOffFactor(){return this._rollOffFactor}set pitch(e){this._pitch=e,this._updateSoundInstances("pitch",e,!0)}get pitch(){return this._pitch}set volume(e){this._volume=e,this._updateSoundInstances("volume",e,!0)}get volume(){return this._volume}set positional(e){this._positional=e;const t=this._slots;for(const s in t){const i=t[s];if(!i.overlap){const r=i.instances,a=r.length;for(let o=a-1;o>=0;o--){const h=r[o].isPlaying||r[o].isSuspended,u=r[o].currentTime;h&&r[o].stop();const f=i._createInstance();h&&(f.play(),f.currentTime=u),r.push(f)}}}}get positional(){return this._positional}set slots(e){const t=this._slots;if(t)for(const i in t)t[i].stop();const s={};for(const i in e)e[i]instanceof qa?s[e[i].name]=e[i]:e[i].name&&(s[e[i].name]=new qa(this,e[i].name,e[i]));this._slots=s,this.enabled&&this.entity.enabled&&this.onEnable()}get slots(){return this._slots}onEnable(){if(this.system._inTools)return;const e=this._slots,t=this._playingBeforeDisable;for(const s in e){const i=e[s];i.autoPlay&&i.isStopped?i.play():t[s]?i.resume():i.isLoaded||i.load()}}onDisable(){const e=this._slots,t={};for(const s in e)e[s].overlap||e[s].isPlaying&&(e[s].pause(),t[s]=!0);this._playingBeforeDisable=t}onRemove(){this.off()}addSlot(e,t){const s=this._slots;if(s[e])return null;const i=new qa(this,e,t);return s[e]=i,i.autoPlay&&this.enabled&&this.entity.enabled&&i.play(),i}removeSlot(e){const t=this._slots;t[e]&&(t[e].stop(),delete t[e])}slot(e){return this._slots[e]}_getSlotProperty(e,t){if(!this.enabled||!this.entity.enabled)return;const s=this._slots[e];if(s)return s[t]}isPlaying(e){return this._getSlotProperty(e,"isPlaying")||!1}isLoaded(e){return this._getSlotProperty(e,"isLoaded")||!1}isPaused(e){return this._getSlotProperty(e,"isPaused")||!1}isStopped(e){return this._getSlotProperty(e,"isStopped")||!1}play(e){if(!this.enabled||!this.entity.enabled)return null;const t=this._slots[e];return t?t.play():null}pause(e){const t=this._slots;if(e){const s=t[e];if(!s)return;s.pause()}else for(const s in t)t[s].pause()}resume(e){const t=this._slots;if(e){const s=t[e];if(!s)return;s.isPaused&&s.resume()}else for(const s in t)t[s].resume()}stop(e){const t=this._slots;if(e){const s=t[e];if(!s)return;s.stop()}else for(const s in t)t[s].stop()}constructor(...e){super(...e),this._volume=1,this._pitch=1,this._positional=!0,this._refDistance=1,this._maxDistance=1e4,this._rollOffFactor=1,this._distanceModel=CE,this._slots={},this._playingBeforeDisable={}}}Ul.EVENT_PLAY="play";Ul.EVENT_PAUSE="pause";Ul.EVENT_RESUME="resume";Ul.EVENT_STOP="stop";Ul.EVENT_END="end";class M9{constructor(){this.enabled=!0}}const QL=["enabled"];class L9 extends Ht{set volume(e){this.manager.volume=e}get volume(){return this.manager.volume}get context(){return Wf()?this.manager.context:null}initializeComponentData(e,t,s){s=["volume","pitch","positional","refDistance","maxDistance","rollOffFactor","distanceModel","slots"];for(let i=0;i<s.length;i++)t.hasOwnProperty(s[i])&&(e[s[i]]=t[s[i]]);super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const s=e.sound,i=s.slots,r={};for(const o in i){const h=i[o];r[o]={name:h.name,volume:h.volume,pitch:h.pitch,loop:h.loop,duration:h.duration,startTime:h.startTime,overlap:h.overlap,autoPlay:h.autoPlay,asset:h.asset}}const a={distanceModel:s.distanceModel,enabled:s.enabled,maxDistance:s.maxDistance,pitch:s.pitch,positional:s.positional,refDistance:s.refDistance,rollOffFactor:s.rollOffFactor,slots:r,volume:s.volume};return this.addComponent(t,a)}onUpdate(e){const t=this.store;for(const s in t)if(t.hasOwnProperty(s)){const r=t[s].entity;if(r.enabled){const a=r.sound;if(a.enabled&&a.positional){const o=r.getPosition(),h=a.slots;for(const u in h)h[u].updatePosition(o)}}}}onBeforeRemove(e,t){const s=t.slots;for(const i in s)s[i].overlap||s[i].stop();t.onRemove()}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this)}constructor(e){super(e),this.id="sound",this.ComponentType=Ul,this.DataType=M9,this.schema=QL,this.manager=e.soundManager,this.app.systems.on("update",this.onUpdate,this),this.on("beforeremove",this.onBeforeRemove,this)}}ke._buildAccessors(Ul.prototype,QL);const vR="simple",SR="animated";class Ya extends Pe{get duration(){if(this._sprite){const e=this.fps||Number.MIN_VALUE;return this._sprite.frameKeys.length/Math.abs(e)}return 0}set frame(e){this._setFrame(e);const t=this.fps||Number.MIN_VALUE;this._setTime(this._frame/t)}get frame(){return this._frame}get isPaused(){return this._paused}get isPlaying(){return this._playing}set sprite(e){if(this._sprite&&(this._evtSetMeshes?.off(),this._evtSetMeshes=null,this._sprite.off("set:pixelsPerUnit",this._onSpritePpuChanged,this),this._sprite.off("set:atlas",this._onSpriteMeshesChange,this),this._sprite.atlas&&this._sprite.atlas.off("set:texture",this._onSpriteMeshesChange,this)),this._sprite=e,this._sprite&&(this._evtSetMeshes=this._sprite.on("set:meshes",this._onSpriteMeshesChange,this),this._sprite.on("set:pixelsPerUnit",this._onSpritePpuChanged,this),this._sprite.on("set:atlas",this._onSpriteMeshesChange,this),this._sprite.atlas&&this._sprite.atlas.on("set:texture",this._onSpriteMeshesChange,this)),this._component.currentClip===this){let t;!e||!e.atlas?(t=this._component._meshInstance,t&&(t.deleteParameter("texture_emissiveMap"),t.deleteParameter("texture_opacityMap")),this._component._hideModel()):(e.atlas.texture&&(t=this._component._meshInstance,t&&(t.setParameter("texture_emissiveMap",e.atlas.texture),t.setParameter("texture_opacityMap",e.atlas.texture)),this._component.enabled&&this._component.entity.enabled&&this._component._showModel()),this.time&&this.fps?this.time=this.time:this.frame=this.frame)}}get sprite(){return this._sprite}set spriteAsset(e){const t=this._component.system.app.assets;let s=e;if(e instanceof Ee&&(s=e.id),this._spriteAsset!==s){if(this._spriteAsset){const i=t.get(this._spriteAsset);i&&this._unbindSpriteAsset(i)}if(this._spriteAsset=s,this._spriteAsset){const i=t.get(this._spriteAsset);i?this._bindSpriteAsset(i):(this.sprite=null,t.on(`add:${this._spriteAsset}`,this._onSpriteAssetAdded,this))}else this.sprite=null}}get spriteAsset(){return this._spriteAsset}set time(e){this._setTime(e),this._sprite?this.frame=Math.min(this._sprite.frameKeys.length-1,Math.floor(this._time*Math.abs(this.fps))):this.frame=0}get time(){return this._time}_onSpriteAssetAdded(e){this._component.system.app.assets.off(`add:${e.id}`,this._onSpriteAssetAdded,this),this._spriteAsset===e.id&&this._bindSpriteAsset(e)}_bindSpriteAsset(e){e.on("load",this._onSpriteAssetLoad,this),e.on("remove",this._onSpriteAssetRemove,this),e.resource?this._onSpriteAssetLoad(e):this._component.system.app.assets.load(e)}_unbindSpriteAsset(e){e&&(e.off("load",this._onSpriteAssetLoad,this),e.off("remove",this._onSpriteAssetRemove,this),e.resource&&!e.resource.atlas&&this._component.system.app.assets.off(`load:${e.data.textureAtlasAsset}`,this._onTextureAtlasLoad,this))}_onSpriteAssetLoad(e){if(!e.resource)this.sprite=null;else if(e.resource.atlas)this.sprite=e.resource;else{const t=e.data.textureAtlasAsset,s=this._component.system.app.assets;s.off(`load:${t}`,this._onTextureAtlasLoad,this),s.once(`load:${t}`,this._onTextureAtlasLoad,this)}}_onTextureAtlasLoad(e){const t=this._spriteAsset;t instanceof Ee?this._onSpriteAssetLoad(t):this._onSpriteAssetLoad(this._component.system.app.assets.get(t))}_onSpriteAssetRemove(e){this.sprite=null}_onSpriteMeshesChange(){this._component.currentClip===this&&this._component._showFrame(this.frame)}_onSpritePpuChanged(){this._component.currentClip===this&&this.sprite.renderMode!==Nr&&this._component._showFrame(this.frame)}_update(e){if(this.fps===0||!this._playing||this._paused||!this._sprite)return;const t=this.fps<0?-1:1,s=this._time+e*this._component.speed*t,i=this.duration,r=s>i||s<0;this._setTime(s);let a=this.frame;this._sprite?a=Math.floor(this._sprite.frameKeys.length*this._time/i):a=0,a!==this._frame&&this._setFrame(a),r&&(this.loop?(this.fire("loop"),this._component.fire("loop",this)):(this._playing=!1,this._paused=!1,this.fire("end"),this._component.fire("end",this)))}_setTime(e){this._time=e;const t=this.duration;this._time<0?this.loop?this._time=this._time%t+t:this._time=0:this._time>t&&(this.loop?this._time%=t:this._time=t)}_setFrame(e){this._sprite?this._frame=J.clamp(e,0,this._sprite.frameKeys.length-1):this._frame=e,this._component.currentClip===this&&this._component._showFrame(this._frame)}_destroy(){if(this._spriteAsset){const e=this._component.system.app.assets;this._unbindSpriteAsset(e.get(this._spriteAsset))}this._sprite&&(this.sprite=null),this._spriteAsset&&(this.spriteAsset=null)}play(){this._playing||(this._playing=!0,this._paused=!1,this.frame=0,this.fire("play"),this._component.fire("play",this))}pause(){!this._playing||this._paused||(this._paused=!0,this.fire("pause"),this._component.fire("pause",this))}resume(){this._paused&&(this._paused=!1,this.fire("resume"),this._component.fire("resume",this))}stop(){this._playing&&(this._playing=!1,this._paused=!1,this._time=0,this.frame=0,this.fire("stop"),this._component.fire("stop",this))}constructor(e,t){super(),this._evtSetMeshes=null,this._component=e,this._frame=0,this._sprite=null,this._spriteAsset=null,this.spriteAsset=t.spriteAsset,this.name=t.name,this.fps=t.fps||0,this.loop=t.loop||!1,this._playing=!1,this._paused=!1,this._time=0}}Ya.EVENT_PLAY="play";Ya.EVENT_PAUSE="pause";Ya.EVENT_RESUME="resume";Ya.EVENT_STOP="stop";Ya.EVENT_END="end";Ya.EVENT_LOOP="loop";const yR="texture_emissiveMap",xR="texture_opacityMap",TR="material_emissive",ER="material_opacity",I9="innerOffset",O9="outerScale",N9="atlasRect";class _o extends ke{set type(e){this._type!==e&&(this._type=e,this._type===vR?(this.stop(),this._currentClip=this._defaultClip,this.enabled&&this.entity.enabled&&(this._currentClip.frame=this.frame,this._currentClip.sprite?this._showModel():this._hideModel())):this._type===SR&&(this.stop(),this._autoPlayClip&&this._tryAutoPlay(),this._currentClip&&this._currentClip.isPlaying&&this.enabled&&this.entity.enabled?this._showModel():this._hideModel()))}get type(){return this._type}set frame(e){this._currentClip.frame=e}get frame(){return this._currentClip.frame}set spriteAsset(e){this._defaultClip.spriteAsset=e}get spriteAsset(){return this._defaultClip._spriteAsset}set sprite(e){this._currentClip.sprite=e}get sprite(){return this._currentClip.sprite}set material(e){this._material=e,this._meshInstance&&(this._meshInstance.material=e)}get material(){return this._material}set color(e){this._color.r=e.r,this._color.g=e.g,this._color.b=e.b,this._meshInstance&&(this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b,this._meshInstance.setParameter(TR,this._colorUniform))}get color(){return this._color}set opacity(e){this._color.a=e,this._meshInstance&&this._meshInstance.setParameter(ER,e)}get opacity(){return this._color.a}set clips(e){if(!e){for(const t in this._clips)this.removeClip(t);return}for(const t in this._clips){let s=!1;for(const i in e)if(e[i].name===t){s=!0,this._clips[t].fps=e[i].fps,this._clips[t].loop=e[i].loop,e[i].hasOwnProperty("sprite")?this._clips[t].sprite=e[i].sprite:e[i].hasOwnProperty("spriteAsset")&&(this._clips[t].spriteAsset=e[i].spriteAsset);break}s||this.removeClip(t)}for(const t in e)this._clips[e[t].name]||this.addClip(e[t]);this._autoPlayClip&&this._tryAutoPlay(),(!this._currentClip||!this._currentClip.sprite)&&this._hideModel()}get clips(){return this._clips}get currentClip(){return this._currentClip}set speed(e){this._speed=e}get speed(){return this._speed}set flipX(e){this._flipX!==e&&(this._flipX=e,this._updateTransform())}get flipX(){return this._flipX}set flipY(e){this._flipY!==e&&(this._flipY=e,this._updateTransform())}get flipY(){return this._flipY}set width(e){e!==this._width&&(this._width=e,this._outerScale.x=this._width,this.sprite&&(this.sprite.renderMode===us||this.sprite.renderMode===hs)&&this._updateTransform())}get width(){return this._width}set height(e){e!==this._height&&(this._height=e,this._outerScale.y=this.height,this.sprite&&(this.sprite.renderMode===us||this.sprite.renderMode===hs)&&this._updateTransform())}get height(){return this._height}set batchGroupId(e){if(this._batchGroupId===e)return;const t=this._batchGroupId;this._batchGroupId=e,this.entity.enabled&&t>=0&&this.system.app.batcher?.remove(Jt.SPRITE,t,this.entity),this.entity.enabled&&e>=0?this.system.app.batcher?.insert(Jt.SPRITE,e,this.entity):t>=0&&this._currentClip&&this._currentClip.sprite&&this.enabled&&this.entity.enabled&&this._showModel()}get batchGroupId(){return this._batchGroupId}set autoPlayClip(e){this._autoPlayClip=e instanceof Ya?e.name:e,this._tryAutoPlay()}get autoPlayClip(){return this._autoPlayClip}set drawOrder(e){this._drawOrder=e,this._meshInstance&&(this._meshInstance.drawOrder=e)}get drawOrder(){return this._drawOrder}set layers(e){this._addedModel&&this._hideModel(),this._layers=e,this._meshInstance&&this.enabled&&this.entity.enabled&&this._showModel()}get layers(){return this._layers}get aabb(){return this._meshInstance?this._meshInstance.aabb:null}onEnable(){const e=this.system.app,t=e.scene,s=t.layers;this._evtLayersChanged=t.on("set:layers",this._onLayersChanged,this),s&&(this._evtLayerAdded=s.on("add",this._onLayerAdded,this),this._evtLayerRemoved=s.on("remove",this._onLayerRemoved,this)),this._showModel(),this._autoPlayClip&&this._tryAutoPlay(),this._batchGroupId>=0&&e.batcher?.insert(Jt.SPRITE,this._batchGroupId,this.entity)}onDisable(){const e=this.system.app,s=e.scene.layers;this._evtLayersChanged?.off(),this._evtLayersChanged=null,s&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this.stop(),this._hideModel(),this._batchGroupId>=0&&e.batcher?.remove(Jt.SPRITE,this._batchGroupId,this.entity)}onDestroy(){this._currentClip=null,this._defaultClip&&(this._defaultClip._destroy(),this._defaultClip=null);for(const e in this._clips)this._clips[e]._destroy();this._clips=null,this._hideModel(),this._model=null,this._node?.remove(),this._node=null,this._meshInstance&&(this._meshInstance.material=null,this._meshInstance.mesh=null,this._meshInstance=null)}_showModel(){if(this._addedModel||!this._meshInstance)return;const e=[this._meshInstance];for(let t=0,s=this._layers.length;t<s;t++){const i=this.system.app.scene.layers.getLayerById(this._layers[t]);i&&i.addMeshInstances(e)}this._addedModel=!0}_hideModel(){if(!this._addedModel||!this._meshInstance)return;const e=[this._meshInstance];for(let t=0,s=this._layers.length;t<s;t++){const i=this.system.app.scene.layers.getLayerById(this._layers[t]);i&&i.removeMeshInstances(e)}this._addedModel=!1}_showFrame(e){if(!this.sprite)return;const t=this.sprite.meshes[e];if(!t){this._meshInstance&&(this._meshInstance.mesh=null,this._meshInstance.visible=!1);return}let s;if(this.sprite.renderMode===hs?s=this.system.default9SlicedMaterialSlicedMode:this.sprite.renderMode===us?s=this.system.default9SlicedMaterialTiledMode:s=this.system.defaultMaterial,this._meshInstance||(this._meshInstance=new lt(t,this._material,this._node),this._meshInstance.castShadow=!1,this._meshInstance.receiveShadow=!1,this._meshInstance.drawOrder=this._drawOrder,this._model.meshInstances.push(this._meshInstance),this._colorUniform[0]=this._color.r,this._colorUniform[1]=this._color.g,this._colorUniform[2]=this._color.b,this._meshInstance.setParameter(TR,this._colorUniform),this._meshInstance.setParameter(ER,this._color.a),this.enabled&&this.entity.enabled&&this._showModel()),this._meshInstance.material!==s&&(this._meshInstance.material=s),this._meshInstance.mesh!==t&&(this._meshInstance.mesh=t,this._meshInstance.visible=!0,this._meshInstance._aabbVer=-1),this.sprite.atlas&&this.sprite.atlas.texture?(this._meshInstance.setParameter(yR,this.sprite.atlas.texture),this._meshInstance.setParameter(xR,this.sprite.atlas.texture)):(this._meshInstance.deleteParameter(yR),this._meshInstance.deleteParameter(xR)),this.sprite.atlas&&(this.sprite.renderMode===hs||this.sprite.renderMode===us)){this._meshInstance._updateAabbFunc=this._updateAabbFunc;const i=this.sprite.atlas.frames[this.sprite.frameKeys[e]];if(i){const r=2/i.rect.z,a=2/i.rect.w;this._innerOffset.set(i.border.x*r,i.border.y*a,i.border.z*r,i.border.w*a);const o=this.sprite.atlas.texture;this._atlasRect.set(i.rect.x/o.width,i.rect.y/o.height,i.rect.z/o.width,i.rect.w/o.height)}else this._innerOffset.set(0,0,0,0);this._innerOffsetUniform[0]=this._innerOffset.x,this._innerOffsetUniform[1]=this._innerOffset.y,this._innerOffsetUniform[2]=this._innerOffset.z,this._innerOffsetUniform[3]=this._innerOffset.w,this._meshInstance.setParameter(I9,this._innerOffsetUniform),this._atlasRectUniform[0]=this._atlasRect.x,this._atlasRectUniform[1]=this._atlasRect.y,this._atlasRectUniform[2]=this._atlasRect.z,this._atlasRectUniform[3]=this._atlasRect.w,this._meshInstance.setParameter(N9,this._atlasRectUniform)}else this._meshInstance._updateAabbFunc=null;this._updateTransform()}_updateTransform(){let e=this.flipX?-1:1,t=this.flipY?-1:1,s=0,i=0;if(this.sprite&&(this.sprite.renderMode===hs||this.sprite.renderMode===us)){let r=1,a=1;if(this.sprite.atlas){const u=this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];u&&(r=u.rect.z,a=u.rect.w,s=(.5-u.pivot.x)*this._width,i=(.5-u.pivot.y)*this._height)}const o=r/this.sprite.pixelsPerUnit,h=a/this.sprite.pixelsPerUnit;this._outerScale.set(Math.max(this._width,this._innerOffset.x*o),Math.max(this._height,this._innerOffset.y*h)),e*=o,t*=h,this._outerScale.x/=o,this._outerScale.y/=h,e*=J.clamp(this._width/(this._innerOffset.x*o),1e-4,1),t*=J.clamp(this._height/(this._innerOffset.y*h),1e-4,1),this._meshInstance&&(this._outerScaleUniform[0]=this._outerScale.x,this._outerScaleUniform[1]=this._outerScale.y,this._meshInstance.setParameter(O9,this._outerScaleUniform))}this._node.setLocalScale(e,t,1),this._node.setLocalPosition(s,i,0)}_updateAabb(e){return e.center.set(0,0,0),e.halfExtents.set(this._outerScale.x*.5,this._outerScale.y*.5,.001),e.setFromTransformedAabb(e,this._node.getWorldTransform()),e}_tryAutoPlay(){if(!this._autoPlayClip||this.type!==SR)return;const e=this._clips[this._autoPlayClip];e&&!e.isPlaying&&(!this._currentClip||!this._currentClip.isPlaying)&&this.enabled&&this.entity.enabled&&this.play(e.name)}_onLayersChanged(e,t){e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this),this.enabled&&this.entity.enabled&&this._showModel()}_onLayerAdded(e){this.layers.indexOf(e.id)<0||this._addedModel&&this.enabled&&this.entity.enabled&&this._meshInstance&&e.addMeshInstances([this._meshInstance])}_onLayerRemoved(e){!this._meshInstance||this.layers.indexOf(e.id)<0||e.removeMeshInstances([this._meshInstance])}removeModelFromLayers(){for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&t.removeMeshInstances([this._meshInstance])}}addClip(e){const t=new Ya(this,{name:e.name,fps:e.fps,loop:e.loop,spriteAsset:e.spriteAsset});return this._clips[e.name]=t,t.name&&t.name===this._autoPlayClip&&this._tryAutoPlay(),t}removeClip(e){delete this._clips[e]}clip(e){return this._clips[e]}play(e){const t=this._clips[e],s=this._currentClip;return s&&s!==t&&(s._playing=!1),this._currentClip=t,this._currentClip&&(this._currentClip=t,this._currentClip.play()),t}pause(){this._currentClip!==this._defaultClip&&this._currentClip.isPlaying&&this._currentClip.pause()}resume(){this._currentClip!==this._defaultClip&&this._currentClip.isPaused&&this._currentClip.resume()}stop(){this._currentClip!==this._defaultClip&&this._currentClip.stop()}constructor(e,t){super(e,t),this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._type=vR,this._material=e.defaultMaterial,this._color=new ue(1,1,1,1),this._colorUniform=new Float32Array(3),this._speed=1,this._flipX=!1,this._flipY=!1,this._width=1,this._height=1,this._drawOrder=0,this._layers=[sn],this._outerScale=new ne(1,1),this._outerScaleUniform=new Float32Array(2),this._innerOffset=new me,this._innerOffsetUniform=new Float32Array(4),this._atlasRect=new me,this._atlasRectUniform=new Float32Array(4),this._batchGroupId=-1,this._batchGroup=null,this._node=new Dt,this._model=new rn,this._model.graph=this._node,this._meshInstance=null,t.addChild(this._model.graph),this._model._entity=t,this._updateAabbFunc=this._updateAabb.bind(this),this._addedModel=!1,this._autoPlayClip=null,this._clips={},this._defaultClip=new Ya(this,{name:this.entity.name,fps:0,loop:!1,spriteAsset:null}),this._currentClip=this._defaultClip}}_o.EVENT_PLAY="play";_o.EVENT_PAUSE="pause";_o.EVENT_RESUME="resume";_o.EVENT_STOP="stop";_o.EVENT_END="end";_o.EVENT_LOOP="loop";class F9{constructor(){this.enabled=!0}}const JL=["enabled"];class B9 extends Ht{set defaultMaterial(e){this._defaultMaterial=e}get defaultMaterial(){if(!this._defaultMaterial){const e=new De(this.app.graphicsDevice,{width:1,height:1,format:Us,name:"sprite"}),t=new Uint8Array(e.lock());t[0]=t[1]=t[2]=t[3]=255,e.unlock();const s=new vr;s.diffuse.set(0,0,0),s.emissive.set(1,1,1),s.emissiveMap=e,s.opacityMap=e,s.opacityMapChannel="a",s.useLighting=!1,s.useTonemap=!1,s.useFog=!1,s.useSkybox=!1,s.blendType=ro,s.depthWrite=!1,s.pixelSnap=!1,s.cull=Ft,s.update(),this._defaultTexture=e,this._defaultMaterial=s}return this._defaultMaterial}set default9SlicedMaterialSlicedMode(e){this._default9SlicedMaterialSlicedMode=e}get default9SlicedMaterialSlicedMode(){if(!this._default9SlicedMaterialSlicedMode){const e=this.defaultMaterial.clone();e.nineSlicedMode=hs,e.update(),this._default9SlicedMaterialSlicedMode=e}return this._default9SlicedMaterialSlicedMode}set default9SlicedMaterialTiledMode(e){this._default9SlicedMaterialTiledMode=e}get default9SlicedMaterialTiledMode(){if(!this._default9SlicedMaterialTiledMode){const e=this.defaultMaterial.clone();e.nineSlicedMode=us,e.update(),this._default9SlicedMaterialTiledMode=e}return this._default9SlicedMaterialTiledMode}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this),this._defaultTexture&&(this._defaultTexture.destroy(),this._defaultTexture=null)}initializeComponentData(e,t,s){if(t.enabled!==void 0&&(e.enabled=t.enabled),e.type=t.type,t.layers&&Array.isArray(t.layers)&&(e.layers=t.layers.slice(0)),t.drawOrder!==void 0&&(e.drawOrder=t.drawOrder),t.color!==void 0&&(t.color instanceof ue?e.color.set(t.color.r,t.color.g,t.color.b,t.opacity??1):e.color.set(t.color[0],t.color[1],t.color[2],t.opacity??1),e.color=e.color),t.opacity!==void 0&&(e.opacity=t.opacity),t.flipX!==void 0&&(e.flipX=t.flipX),t.flipY!==void 0&&(e.flipY=t.flipY),t.width!==void 0&&(e.width=t.width),t.height!==void 0&&(e.height=t.height),t.spriteAsset!==void 0&&(e.spriteAsset=t.spriteAsset),t.sprite&&(e.sprite=t.sprite),t.frame!==void 0&&(e.frame=t.frame),t.clips)for(const i in t.clips)e.addClip(t.clips[i]);t.speed!==void 0&&(e.speed=t.speed),t.autoPlayClip&&(e.autoPlayClip=t.autoPlayClip),e.batchGroupId=t.batchGroupId===void 0||t.batchGroupId===null?-1:t.batchGroupId,super.initializeComponentData(e,t,s)}cloneComponent(e,t){const s=e.sprite;return this.addComponent(t,{enabled:s.enabled,type:s.type,spriteAsset:s.spriteAsset,sprite:s.sprite,width:s.width,height:s.height,frame:s.frame,color:s.color.clone(),opacity:s.opacity,flipX:s.flipX,flipY:s.flipY,speed:s.speed,clips:s.clips,autoPlayClip:s.autoPlayClip,batchGroupId:s.batchGroupId,drawOrder:s.drawOrder,layers:s.layers.slice(0)})}onUpdate(e){const t=this.store;for(const s in t)if(t.hasOwnProperty(s)){const i=t[s];if(i.data.enabled&&i.entity.enabled){const r=i.entity.sprite;r._currentClip&&r._currentClip._update(e)}}}onBeforeRemove(e,t){t.onDestroy()}constructor(e){super(e),this.id="sprite",this.ComponentType=_o,this.DataType=F9,this.schema=JL,this._defaultTexture=null,this._defaultMaterial=null,this._default9SlicedMaterialSlicedMode=null,this._default9SlicedMaterialTiledMode=null,this.app.systems.on("update",this.onUpdate,this),this.on("beforeremove",this.onBeforeRemove,this)}}ke._buildAccessors(_o.prototype,JL);class eu extends ke{set size(e){e instanceof D?this._size.copy(e):e instanceof Array&&e.length>=3&&this.size.set(e[0],e[1],e[2])}get size(){return this._size}onEnable(){this._checkState()}onDisable(){this._checkState()}_onSetEnabled(e,t,s){this._checkState()}_checkState(){const e=this.enabled&&this.entity.enabled;e!==this._oldState&&(this._oldState=e,this.fire("enable"),this.fire("state",this.enabled))}_onBeforeRemove(){this.fire("remove")}constructor(e,t){super(e,t),this._oldState=!0,this._size=new D,this.on("set_enabled",this._onSetEnabled,this)}}eu.EVENT_ENABLE="enable";eu.EVENT_DISABLE="disable";eu.EVENT_STATE="state";eu.EVENT_REMOVE="remove";class U9{constructor(){this.enabled=!0}}const eI=["enabled"];class z9 extends Ht{initializeComponentData(e,t,s){e.enabled=t.hasOwnProperty("enabled")?!!t.enabled:!0,t.size&&(t.size instanceof D?e.size.copy(t.size):t.size instanceof Array&&t.size.length>=3&&e.size.set(t.size[0],t.size[1],t.size[2]))}cloneComponent(e,t){const s={enabled:e.zone.enabled,size:e.zone.size};return this.addComponent(t,s)}_onBeforeRemove(e,t){t._onBeforeRemove()}constructor(e){super(e),this.id="zone",this.ComponentType=eu,this.DataType=U9,this.schema=eI,this.on("beforeremove",this._onBeforeRemove,this)}}ke._buildAccessors(eu.prototype,eI);class k9{constructor(e,t){this.effect=e,this.inputTarget=t,this.outputTarget=null,this.name=e.constructor.name}}class V9{_allocateColorBuffer(e,t){const s=this.camera.rect,i=this.destinationRenderTarget,r=this.app.graphicsDevice,a=Math.floor(s.z*(i?.width??r.width)),o=Math.floor(s.w*(i?.height??r.height));return new De(r,{name:t,format:e,width:a,height:o,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te})}_createOffscreenTarget(e,t){const s=this.app.graphicsDevice,r=(this.destinationRenderTarget??s.backBuffer).isColorBufferSrgb(0),a=(t&&s.getRenderableHdrFormat([kt,fs],!0))??(r?Us:Ze),o=`${this.camera.entity.name}-posteffect-${this.effects.length}`,h=this._allocateColorBuffer(a,o);return new At({colorBuffer:h,depth:e,stencil:e&&this.app.graphicsDevice.supportsStencil,samples:e?s.samples:1})}_resizeOffscreenTarget(e){const t=e.colorBuffer.format,s=e.colorBuffer.name;e.destroyFrameBuffers(),e.destroyTextureBuffers(),e._colorBuffer=this._allocateColorBuffer(t,s),e._colorBuffers=[e._colorBuffer],e.evaluateDimensions()}_destroyOffscreenTarget(e){e.destroyTextureBuffers(),e.destroy()}addEffect(e){const t=this.effects,s=t.length===0,i=this._createOffscreenTarget(s,e.hdr),r=new k9(e,i);t.push(r),this._sourceTarget=r.inputTarget,t.length>1&&(t[t.length-2].outputTarget=r.inputTarget),this._newPostEffect=e,e.needsDepthBuffer&&this._requestDepthMap(),this.enable(),this._newPostEffect=void 0}removeEffect(e){let t=-1;for(let s=0,i=this.effects.length;s<i;s++)if(this.effects[s].effect===e){t=s;break}t>=0&&(t>0?this.effects[t-1].outputTarget=t+1<this.effects.length?this.effects[t+1].inputTarget:null:this.effects.length>1&&(this.effects[1].inputTarget._depth||(this._destroyOffscreenTarget(this.effects[1].inputTarget),this.effects[1].inputTarget=this._createOffscreenTarget(!0,this.effects[1].hdr),this._sourceTarget=this.effects[1].inputTarget),this.camera.renderTarget=this.effects[1].inputTarget),this._destroyOffscreenTarget(this.effects[t].inputTarget),this.effects.splice(t,1)),this.enabled&&e.needsDepthBuffer&&this._releaseDepthMap(),this.effects.length===0&&this.disable()}_requestDepthMaps(){for(let e=0,t=this.effects.length;e<t;e++){const s=this.effects[e].effect;this._newPostEffect!==s&&s.needsDepthBuffer&&this._requestDepthMap()}}_releaseDepthMaps(){for(let e=0,t=this.effects.length;e<t;e++)this.effects[e].effect.needsDepthBuffer&&this._releaseDepthMap()}_requestDepthMap(){const e=this.app.scene.layers.getLayerById(xi);e&&(e.incrementCounter(),this.camera.requestSceneDepthMap(!0))}_releaseDepthMap(){const e=this.app.scene.layers.getLayerById(xi);e&&(e.decrementCounter(),this.camera.requestSceneDepthMap(!1))}destroy(){for(let e=0,t=this.effects.length;e<t;e++)this.effects[e].inputTarget.destroy();this.effects.length=0,this.disable()}enable(){!this.enabled&&this.effects.length&&(this.enabled=!0,this._requestDepthMaps(),this.app.graphicsDevice.on("resizecanvas",this._onCanvasResized,this),this.destinationRenderTarget=this.camera.renderTarget,this.camera.renderTarget=this.effects[0].inputTarget,this.camera.onPostprocessing=()=>{if(this.enabled){let e=null;const t=this.effects.length;if(t)for(let s=0;s<t;s++){const i=this.effects[s];let r=i.outputTarget;s===t-1&&(e=this.camera.rect,this.destinationRenderTarget&&(r=this.destinationRenderTarget)),i.effect.render(i.inputTarget,r,e)}}})}disable(){this.enabled&&(this.enabled=!1,this.app.graphicsDevice.off("resizecanvas",this._onCanvasResized,this),this._releaseDepthMaps(),this._destroyOffscreenTarget(this._sourceTarget),this.camera.renderTarget=this.destinationRenderTarget,this.camera.onPostprocessing=null)}_onCanvasResized(e,t){const s=this.camera.rect,i=this.destinationRenderTarget;e=i?.width??e,t=i?.height??t,this.camera.camera.aspectRatio=e*s.z/(t*s.w),this.resizeRenderTargets()}resizeRenderTargets(){const e=this.app.graphicsDevice,t=this.destinationRenderTarget,s=t?.width??e.width,i=t?.height??e.height,r=this.camera.rect,a=Math.floor(r.z*s),o=Math.floor(r.w*i),h=this.effects;for(let u=0,f=h.length;u<f;u++){const m=h[u];(m.inputTarget.width!==a||m.inputTarget.height!==o)&&this._resizeOffscreenTarget(m.inputTarget)}}onCameraRectChanged(e,t,s){this.enabled&&this.resizeRenderTargets()}constructor(e,t){this.app=e,this.camera=t,this.destinationRenderTarget=null,this.effects=[],this.enabled=!1,this.depthTarget=null,t.on("set:rect",this.onCameraRectChanged,this)}}class tI extends ke{setShaderPass(e){const t=Gr.get(this.system.app.graphicsDevice),s=e?t.allocate(e,{isForward:!0}):null;return this._camera.shaderPassInfo=s,s.index}getShaderPass(){return this._camera.shaderPassInfo?.name}set renderPasses(e){this._camera.renderPasses=e||[],this.dirtyLayerCompositionCameras(),this.system.app.scene.updateShaders=!0}get renderPasses(){return this._camera.renderPasses}get shaderParams(){return this._camera.shaderParams}set gammaCorrection(e){this.camera.shaderParams.gammaCorrection=e}get gammaCorrection(){return this.camera.shaderParams.gammaCorrection}set toneMapping(e){this.camera.shaderParams.toneMapping=e}get toneMapping(){return this.camera.shaderParams.toneMapping}set fog(e){this._camera.fogParams=e}get fog(){return this._camera.fogParams}set aperture(e){this._camera.aperture=e}get aperture(){return this._camera.aperture}set aspectRatio(e){this._camera.aspectRatio=e}get aspectRatio(){return this._camera.aspectRatio}set aspectRatioMode(e){this._camera.aspectRatioMode=e}get aspectRatioMode(){return this._camera.aspectRatioMode}set calculateProjection(e){this._camera.calculateProjection=e}get calculateProjection(){return this._camera.calculateProjection}set calculateTransform(e){this._camera.calculateTransform=e}get calculateTransform(){return this._camera.calculateTransform}get camera(){return this._camera}set clearColor(e){this._camera.clearColor=e}get clearColor(){return this._camera.clearColor}set clearColorBuffer(e){this._camera.clearColorBuffer=e,this.dirtyLayerCompositionCameras()}get clearColorBuffer(){return this._camera.clearColorBuffer}set clearDepth(e){this._camera.clearDepth=e}get clearDepth(){return this._camera.clearDepth}set clearDepthBuffer(e){this._camera.clearDepthBuffer=e,this.dirtyLayerCompositionCameras()}get clearDepthBuffer(){return this._camera.clearDepthBuffer}set clearStencilBuffer(e){this._camera.clearStencilBuffer=e,this.dirtyLayerCompositionCameras()}get clearStencilBuffer(){return this._camera.clearStencilBuffer}set cullFaces(e){this._camera.cullFaces=e}get cullFaces(){return this._camera.cullFaces}set disablePostEffectsLayer(e){this._disablePostEffectsLayer=e,this.dirtyLayerCompositionCameras()}get disablePostEffectsLayer(){return this._disablePostEffectsLayer}set farClip(e){this._camera.farClip=e}get farClip(){return this._camera.farClip}set flipFaces(e){this._camera.flipFaces=e}get flipFaces(){return this._camera.flipFaces}set fov(e){this._camera.fov=e}get fov(){return this._camera.fov}get frustum(){return this._camera.frustum}set frustumCulling(e){this._camera.frustumCulling=e}get frustumCulling(){return this._camera.frustumCulling}set horizontalFov(e){this._camera.horizontalFov=e}get horizontalFov(){return this._camera.horizontalFov}set layers(e){const t=this._camera.layers,s=this.system.app.scene;t.forEach(i=>{s.layers.getLayerById(i)?.removeCamera(this)}),this._camera.layers=e,this.enabled&&this.entity.enabled&&e.forEach(i=>{s.layers.getLayerById(i)?.addCamera(this)}),this.fire("set:layers")}get layers(){return this._camera.layers}get layersSet(){return this._camera.layersSet}set jitter(e){this._camera.jitter=e}get jitter(){return this._camera.jitter}set nearClip(e){this._camera.nearClip=e}get nearClip(){return this._camera.nearClip}set orthoHeight(e){this._camera.orthoHeight=e}get orthoHeight(){return this._camera.orthoHeight}get postEffects(){return this._postEffects}get postEffectsEnabled(){return this._postEffects.enabled}set priority(e){this._priority=e,this.dirtyLayerCompositionCameras()}get priority(){return this._priority}set projection(e){this._camera.projection=e}get projection(){return this._camera.projection}get projectionMatrix(){return this._camera.projectionMatrix}set rect(e){this._camera.rect=e,this.fire("set:rect",this._camera.rect)}get rect(){return this._camera.rect}set renderSceneColorMap(e){e&&!this._sceneColorMapRequested?(this.requestSceneColorMap(!0),this._sceneColorMapRequested=!0):this._sceneColorMapRequested&&(this.requestSceneColorMap(!1),this._sceneColorMapRequested=!1)}get renderSceneColorMap(){return this._renderSceneColorMap>0}set renderSceneDepthMap(e){e&&!this._sceneDepthMapRequested?(this.requestSceneDepthMap(!0),this._sceneDepthMapRequested=!0):this._sceneDepthMapRequested&&(this.requestSceneDepthMap(!1),this._sceneDepthMapRequested=!1)}get renderSceneDepthMap(){return this._renderSceneDepthMap>0}set renderTarget(e){this._camera.renderTarget=e,this.dirtyLayerCompositionCameras()}get renderTarget(){return this._camera.renderTarget}set scissorRect(e){this._camera.scissorRect=e}get scissorRect(){return this._camera.scissorRect}set sensitivity(e){this._camera.sensitivity=e}get sensitivity(){return this._camera.sensitivity}set shutter(e){this._camera.shutter=e}get shutter(){return this._camera.shutter}get viewMatrix(){return this._camera.viewMatrix}_enableDepthLayer(e){if(this.layers.find(s=>s===xi)){const s=this.system.app.scene.layers.getLayerById(xi);e?s?.incrementCounter():s?.decrementCounter()}else if(e)return!1;return!0}requestSceneColorMap(e){this._renderSceneColorMap+=e?1:-1,this._enableDepthLayer(e),this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice,this.renderSceneColorMap),this.system.app.scene.layers.markDirty()}requestSceneDepthMap(e){this._renderSceneDepthMap+=e?1:-1,this._enableDepthLayer(e),this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice,this.system.app.renderer,this.renderSceneDepthMap),this.system.app.scene.layers.markDirty()}dirtyLayerCompositionCameras(){const e=this.system.app.scene.layers;e._dirty=!0}screenToWorld(e,t,s,i){const r=this.system.app.graphicsDevice,{width:a,height:o}=r.clientRect;return this._camera.screenToWorld(e,t,s,a,o,i)}worldToScreen(e,t){const s=this.system.app.graphicsDevice,{width:i,height:r}=s.clientRect;return this._camera.worldToScreen(e,i,r,t)}onAppPrerender(){this._camera._viewMatDirty=!0,this._camera._viewProjMatDirty=!0}addCameraToLayers(){const e=this.layers;for(let t=0;t<e.length;t++){const s=this.system.app.scene.layers.getLayerById(e[t]);s&&s.addCamera(this)}}removeCameraFromLayers(){const e=this.layers;for(let t=0;t<e.length;t++){const s=this.system.app.scene.layers.getLayerById(e[t]);s&&s.removeCamera(this)}}onLayersChanged(e,t){this.addCameraToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||e.addCamera(this)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||e.removeCamera(this)}onEnable(){const e=this.system.app.scene,t=e.layers;this.system.addCamera(this),this._evtLayersChanged?.off(),this._evtLayersChanged=e.on("set:layers",this.onLayersChanged,this),t&&(this._evtLayerAdded?.off(),this._evtLayerAdded=t.on("add",this.onLayerAdded,this),this._evtLayerRemoved?.off(),this._evtLayerRemoved=t.on("remove",this.onLayerRemoved,this)),this.enabled&&this.entity.enabled&&this.addCameraToLayers(),this.postEffects.enable()}onDisable(){const t=this.system.app.scene.layers;this.postEffects.disable(),this.removeCameraFromLayers(),this._evtLayersChanged?.off(),this._evtLayersChanged=null,t&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this.system.removeCamera(this)}onRemove(){this.onDisable(),this.off(),this.camera.destroy()}calculateAspectRatio(e){const t=this.system.app.graphicsDevice,s=e?e.width:t.width,i=e?e.height:t.height;return s*this.rect.z/(i*this.rect.w)}frameUpdate(e){this.aspectRatioMode===$E&&(this.aspectRatio=this.calculateAspectRatio(e))}startXr(e,t,s){this.system.app.xr.start(this,e,t,s)}endXr(e){if(!this._camera.xr){e&&e(new Error("Camera is not in XR"));return}this._camera.xr.end(e)}copy(e){this.aperture=e.aperture,this.aspectRatio=e.aspectRatio,this.aspectRatioMode=e.aspectRatioMode,this.calculateProjection=e.calculateProjection,this.calculateTransform=e.calculateTransform,this.clearColor=e.clearColor,this.clearColorBuffer=e.clearColorBuffer,this.clearDepthBuffer=e.clearDepthBuffer,this.clearStencilBuffer=e.clearStencilBuffer,this.cullFaces=e.cullFaces,this.disablePostEffectsLayer=e.disablePostEffectsLayer,this.farClip=e.farClip,this.flipFaces=e.flipFaces,this.fov=e.fov,this.frustumCulling=e.frustumCulling,this.horizontalFov=e.horizontalFov,this.layers=e.layers,this.nearClip=e.nearClip,this.orthoHeight=e.orthoHeight,this.priority=e.priority,this.projection=e.projection,this.rect=e.rect,this.renderTarget=e.renderTarget,this.scissorRect=e.scissorRect,this.sensitivity=e.sensitivity,this.shutter=e.shutter}constructor(e,t){super(e,t),this.onPostprocessing=null,this._renderSceneDepthMap=0,this._renderSceneColorMap=0,this._sceneDepthMapRequested=!1,this._sceneColorMapRequested=!1,this._priority=0,this._disablePostEffectsLayer=Cv,this._camera=new KE,this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._camera.node=t,this._postEffects=new V9(e.app,this)}}class G9{constructor(){this.enabled=!0}}const sI=["enabled"];class H9 extends Ht{initializeComponentData(e,t,s){s=["aspectRatio","aspectRatioMode","calculateProjection","calculateTransform","clearColor","clearColorBuffer","clearDepth","clearDepthBuffer","clearStencilBuffer","renderSceneColorMap","renderSceneDepthMap","cullFaces","farClip","flipFaces","fog","fov","frustumCulling","horizontalFov","layers","renderTarget","nearClip","orthoHeight","projection","priority","rect","scissorRect","aperture","shutter","sensitivity","gammaCorrection","toneMapping"];for(let i=0;i<s.length;i++){const r=s[i];if(t.hasOwnProperty(r)){const a=t[r];switch(r){case"rect":case"scissorRect":Array.isArray(a)?e[r]=new me(a[0],a[1],a[2],a[3]):e[r]=a;break;case"clearColor":Array.isArray(a)?e[r]=new ue(a[0],a[1],a[2],a[3]):e[r]=a;break;default:e[r]=a;break}}}super.initializeComponentData(e,t,["enabled"])}cloneComponent(e,t){const s=e.camera;return this.addComponent(t,{aspectRatio:s.aspectRatio,aspectRatioMode:s.aspectRatioMode,calculateProjection:s.calculateProjection,calculateTransform:s.calculateTransform,clearColor:s.clearColor,clearColorBuffer:s.clearColorBuffer,clearDepthBuffer:s.clearDepthBuffer,clearStencilBuffer:s.clearStencilBuffer,renderSceneDepthMap:s.renderSceneDepthMap,renderSceneColorMap:s.renderSceneColorMap,cullFaces:s.cullFaces,enabled:s.enabled,farClip:s.farClip,flipFaces:s.flipFaces,fov:s.fov,frustumCulling:s.frustumCulling,horizontalFov:s.horizontalFov,layers:s.layers,renderTarget:s.renderTarget,nearClip:s.nearClip,orthoHeight:s.orthoHeight,projection:s.projection,priority:s.priority,rect:s.rect,scissorRect:s.scissorRect,aperture:s.aperture,sensitivity:s.sensitivity,shutter:s.shutter,gammaCorrection:s.gammaCorrection,toneMapping:s.toneMapping})}onBeforeRemove(e,t){this.removeCamera(t),t.onRemove()}onAppPrerender(){for(let e=0,t=this.cameras.length;e<t;e++)this.cameras[e].onAppPrerender()}addCamera(e){this.cameras.push(e),df(this.cameras)}removeCamera(e){const t=this.cameras.indexOf(e);t>=0&&(this.cameras.splice(t,1),df(this.cameras))}destroy(){this.app.off("prerender",this.onAppPrerender,this),super.destroy()}constructor(e){super(e),this.cameras=[],this.id="camera",this.ComponentType=tI,this.DataType=G9,this.schema=sI,this.on("beforeremove",this.onBeforeRemove,this),this.app.on("prerender",this.onAppPrerender,this)}}ke._buildAccessors(tI.prototype,sI);class iI{constructor(){this.enabled=!0,this.type="directional",this.color=new ue(1,1,1),this.intensity=1,this.luminance=0,this.shape=_r,this.affectSpecularity=!0,this.castShadows=!1,this.shadowDistance=40,this.shadowIntensity=1,this.shadowResolution=1024,this.shadowBias=.05,this.numCascades=1,this.cascadeBlend=0,this.bakeNumSamples=1,this.bakeArea=0,this.cascadeDistribution=.5,this.normalOffsetBias=0,this.range=10,this.innerConeAngle=40,this.outerConeAngle=45,this.falloffMode=UE,this.shadowType=ur,this.vsmBlurSize=11,this.vsmBlurMode=kE,this.vsmBias=.01*.25,this.cookieAsset=null,this.cookie=null,this.cookieIntensity=1,this.cookieFalloff=!0,this.cookieChannel="rgb",this.cookieAngle=0,this.cookieScale=null,this.cookieOffset=null,this.shadowUpdateMode=jE,this.mask=1,this.affectDynamic=!0,this.affectLightmapped=!1,this.bake=!1,this.bakeDir=!0,this.isStatic=!1,this.layers=[sn],this.penumbraSize=1,this.penumbraFalloff=1,this.shadowSamples=16,this.shadowBlockerSamples=16}}const Gd=Object.keys(new iI);class W9 extends ke{get data(){const e=this.system.store[this.entity.getGuid()];return e?e.data:null}set enabled(e){this._setValue("enabled",e,function(t,s){this.onSetEnabled(null,s,t)})}get enabled(){return this.data.enabled}set light(e){this._setValue("light",e)}get light(){return this.data.light}set type(e){this._setValue("type",e,function(t,s){this.system.changeType(this,s,t),this.refreshProperties()})}get type(){return this.data.type}set color(e){this._setValue("color",e,function(t,s){this.light.setColor(t)},!0)}get color(){return this.data.color}set intensity(e){this._setValue("intensity",e,function(t,s){this.light.intensity=t})}get intensity(){return this.data.intensity}set luminance(e){this._setValue("luminance",e,function(t,s){this.light.luminance=t})}get luminance(){return this.data.luminance}set shape(e){this._setValue("shape",e,function(t,s){this.light.shape=t})}get shape(){return this.data.shape}set affectSpecularity(e){this._setValue("affectSpecularity",e,function(t,s){this.light.affectSpecularity=t})}get affectSpecularity(){return this.data.affectSpecularity}set castShadows(e){this._setValue("castShadows",e,function(t,s){this.light.castShadows=t})}get castShadows(){return this.data.castShadows}set shadowDistance(e){this._setValue("shadowDistance",e,function(t,s){this.light.shadowDistance=t})}get shadowDistance(){return this.data.shadowDistance}set shadowIntensity(e){this._setValue("shadowIntensity",e,function(t,s){this.light.shadowIntensity=t})}get shadowIntensity(){return this.data.shadowIntensity}set shadowResolution(e){this._setValue("shadowResolution",e,function(t,s){this.light.shadowResolution=t})}get shadowResolution(){return this.data.shadowResolution}set shadowBias(e){this._setValue("shadowBias",e,function(t,s){this.light.shadowBias=-.01*J.clamp(t,0,1)})}get shadowBias(){return this.data.shadowBias}set numCascades(e){this._setValue("numCascades",e,function(t,s){this.light.numCascades=J.clamp(Math.floor(t),1,4)})}get numCascades(){return this.data.numCascades}set cascadeBlend(e){this._setValue("cascadeBlend",e,function(t,s){this.light.cascadeBlend=J.clamp(t,0,1)})}get cascadeBlend(){return this.data.cascadeBlend}set bakeNumSamples(e){this._setValue("bakeNumSamples",e,function(t,s){this.light.bakeNumSamples=J.clamp(Math.floor(t),1,255)})}get bakeNumSamples(){return this.data.bakeNumSamples}set bakeArea(e){this._setValue("bakeArea",e,function(t,s){this.light.bakeArea=J.clamp(t,0,180)})}get bakeArea(){return this.data.bakeArea}set cascadeDistribution(e){this._setValue("cascadeDistribution",e,function(t,s){this.light.cascadeDistribution=J.clamp(t,0,1)})}get cascadeDistribution(){return this.data.cascadeDistribution}set normalOffsetBias(e){this._setValue("normalOffsetBias",e,function(t,s){this.light.normalOffsetBias=J.clamp(t,0,1)})}get normalOffsetBias(){return this.data.normalOffsetBias}set range(e){this._setValue("range",e,function(t,s){this.light.attenuationEnd=t})}get range(){return this.data.range}set innerConeAngle(e){this._setValue("innerConeAngle",e,function(t,s){this.light.innerConeAngle=t})}get innerConeAngle(){return this.data.innerConeAngle}set outerConeAngle(e){this._setValue("outerConeAngle",e,function(t,s){this.light.outerConeAngle=t})}get outerConeAngle(){return this.data.outerConeAngle}set falloffMode(e){this._setValue("falloffMode",e,function(t,s){this.light.falloffMode=t})}get falloffMode(){return this.data.falloffMode}set shadowType(e){this._setValue("shadowType",e,function(t,s){this.light.shadowType=t})}get shadowType(){return this.data.shadowType}set vsmBlurSize(e){this._setValue("vsmBlurSize",e,function(t,s){this.light.vsmBlurSize=t})}get vsmBlurSize(){return this.data.vsmBlurSize}set vsmBlurMode(e){this._setValue("vsmBlurMode",e,function(t,s){this.light.vsmBlurMode=t})}get vsmBlurMode(){return this.data.vsmBlurMode}set vsmBias(e){this._setValue("vsmBias",e,function(t,s){this.light.vsmBias=J.clamp(t,0,1)})}get vsmBias(){return this.data.vsmBias}set cookieAsset(e){this._setValue("cookieAsset",e,function(t,s){if(!(this._cookieAssetId&&(t instanceof Ee&&t.id===this._cookieAssetId||t===this._cookieAssetId))){if(this.onCookieAssetRemove(),this._cookieAssetId=null,t instanceof Ee)this.data.cookieAsset=t.id,this._cookieAssetId=t.id,this.onCookieAssetAdd(t);else if(typeof t=="number"){this._cookieAssetId=t;const i=this.system.app.assets.get(t);i?this.onCookieAssetAdd(i):(this._cookieAssetAdd=!0,this.system.app.assets.on(`add:${this._cookieAssetId}`,this.onCookieAssetAdd,this))}}})}get cookieAsset(){return this.data.cookieAsset}set cookie(e){this._setValue("cookie",e,function(t,s){this.light.cookie=t})}get cookie(){return this.data.cookie}set cookieIntensity(e){this._setValue("cookieIntensity",e,function(t,s){this.light.cookieIntensity=J.clamp(t,0,1)})}get cookieIntensity(){return this.data.cookieIntensity}set cookieFalloff(e){this._setValue("cookieFalloff",e,function(t,s){this.light.cookieFalloff=t})}get cookieFalloff(){return this.data.cookieFalloff}set cookieChannel(e){this._setValue("cookieChannel",e,function(t,s){this.light.cookieChannel=t})}get cookieChannel(){return this.data.cookieChannel}set cookieAngle(e){this._setValue("cookieAngle",e,function(t,s){if(t!==0||this.cookieScale!==null){this._cookieMatrix||(this._cookieMatrix=new me);let i=1,r=1;this.cookieScale&&(i=this.cookieScale.x,r=this.cookieScale.y);const a=Math.cos(t*J.DEG_TO_RAD),o=Math.sin(t*J.DEG_TO_RAD);this._cookieMatrix.set(a/i,-o/i,o/r,a/r),this.light.cookieTransform=this._cookieMatrix}else this.light.cookieTransform=null})}get cookieAngle(){return this.data.cookieAngle}set cookieScale(e){this._setValue("cookieScale",e,function(t,s){if(t!==null||this.cookieAngle!==0){this._cookieMatrix||(this._cookieMatrix=new me);const i=t.x,r=t.y,a=Math.cos(this.cookieAngle*J.DEG_TO_RAD),o=Math.sin(this.cookieAngle*J.DEG_TO_RAD);this._cookieMatrix.set(a/i,-o/i,o/r,a/r),this.light.cookieTransform=this._cookieMatrix}else this.light.cookieTransform=null},!0)}get cookieScale(){return this.data.cookieScale}set cookieOffset(e){this._setValue("cookieOffset",e,function(t,s){this.light.cookieOffset=t},!0)}get cookieOffset(){return this.data.cookieOffset}set shadowUpdateMode(e){this._setValue("shadowUpdateMode",e,function(t,s){this.light.shadowUpdateMode=t},!0)}get shadowUpdateMode(){return this.data.shadowUpdateMode}set mask(e){this._setValue("mask",e,function(t,s){this.light.mask=t})}get mask(){return this.data.mask}set affectDynamic(e){this._setValue("affectDynamic",e,function(t,s){t?this.light.mask|=Qi:this.light.mask&=~Qi,this.light.layersDirty()})}get affectDynamic(){return this.data.affectDynamic}set affectLightmapped(e){this._setValue("affectLightmapped",e,function(t,s){t?(this.light.mask|=Ba,this.bake&&(this.light.mask&=~Ua)):(this.light.mask&=~Ba,this.bake&&(this.light.mask|=Ua))})}get affectLightmapped(){return this.data.affectLightmapped}set bake(e){this._setValue("bake",e,function(t,s){t?(this.light.mask|=Ua,this.affectLightmapped&&(this.light.mask&=~Ba)):(this.light.mask&=~Ua,this.affectLightmapped&&(this.light.mask|=Ba)),this.light.layersDirty()})}get bake(){return this.data.bake}set bakeDir(e){this._setValue("bakeDir",e,function(t,s){this.light.bakeDir=t})}get bakeDir(){return this.data.bakeDir}set isStatic(e){this._setValue("isStatic",e,function(t,s){this.light.isStatic=t})}get isStatic(){return this.data.isStatic}set layers(e){this._setValue("layers",e,function(t,s){for(let i=0;i<s.length;i++){const r=this.system.app.scene.layers.getLayerById(s[i]);r&&(r.removeLight(this),this.light.removeLayer(r))}for(let i=0;i<t.length;i++){const r=this.system.app.scene.layers.getLayerById(t[i]);r&&this.enabled&&this.entity.enabled&&(r.addLight(this),this.light.addLayer(r))}})}get layers(){return this.data.layers}set shadowUpdateOverrides(e){this.light.shadowUpdateOverrides=e}get shadowUpdateOverrides(){return this.light.shadowUpdateOverrides}set shadowSamples(e){this.light.shadowSamples=e}get shadowSamples(){return this.light.shadowSamples}set shadowBlockerSamples(e){this.light.shadowBlockerSamples=e}get shadowBlockerSamples(){return this.light.shadowBlockerSamples}set penumbraSize(e){this.light.penumbraSize=e}get penumbraSize(){return this.light.penumbraSize}set penumbraFalloff(e){this.light.penumbraFalloff=e}get penumbraFalloff(){return this.light.penumbraFalloff}_setValue(e,t,s,i){const r=this.data,a=r[e];!i&&a===t||(r[e]=t,s&&s.call(this,t,a))}addLightToLayers(){for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&(t.addLight(this),this.light.addLayer(t))}}removeLightFromLayers(){for(let e=0;e<this.layers.length;e++){const t=this.system.app.scene.layers.getLayerById(this.layers[e]);t&&(t.removeLight(this),this.light.removeLayer(t))}}onLayersChanged(e,t){this.enabled&&this.entity.enabled&&this.addLightToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)>=0&&this.enabled&&this.entity.enabled&&(e.addLight(this),this.light.addLayer(e))}onLayerRemoved(e){this.layers.indexOf(e.id)>=0&&(e.removeLight(this),this.light.removeLayer(e))}refreshProperties(){for(let e=0;e<Gd.length;e++){const t=Gd[e];this[t]=this[t]}this.enabled&&this.entity.enabled&&this.onEnable()}onCookieAssetSet(){let e=!1;this._cookieAsset.type==="cubemap"&&!this._cookieAsset.loadFaces&&(this._cookieAsset.loadFaces=!0,e=!0),(!this._cookieAsset.resource||e)&&this.system.app.assets.load(this._cookieAsset),this._cookieAsset.resource&&this.onCookieAssetLoad()}onCookieAssetAdd(e){this._cookieAssetId===e.id&&(this._cookieAsset=e,this.light.enabled&&this.onCookieAssetSet(),this._cookieAsset.on("load",this.onCookieAssetLoad,this),this._cookieAsset.on("remove",this.onCookieAssetRemove,this))}onCookieAssetLoad(){!this._cookieAsset||!this._cookieAsset.resource||(this.cookie=this._cookieAsset.resource)}onCookieAssetRemove(){this._cookieAssetId&&(this._cookieAssetAdd&&(this.system.app.assets.off(`add:${this._cookieAssetId}`,this.onCookieAssetAdd,this),this._cookieAssetAdd=!1),this._cookieAsset&&(this._cookieAsset.off("load",this.onCookieAssetLoad,this),this._cookieAsset.off("remove",this.onCookieAssetRemove,this),this._cookieAsset=null),this.cookie=null)}onEnable(){const e=this.system.app.scene,t=e.layers;this.light.enabled=!0,this._evtLayersChanged=e.on("set:layers",this.onLayersChanged,this),t&&(this._evtLayerAdded=t.on("add",this.onLayerAdded,this),this._evtLayerRemoved=t.on("remove",this.onLayerRemoved,this)),this.enabled&&this.entity.enabled&&this.addLightToLayers(),this._cookieAsset&&!this.cookie&&this.onCookieAssetSet()}onDisable(){const t=this.system.app.scene.layers;this.light.enabled=!1,this._evtLayersChanged?.off(),this._evtLayersChanged=null,t&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this.removeLightFromLayers()}onRemove(){this.onDisable(),this.light.destroy(),this.cookieAsset=null}constructor(...e){super(...e),this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._cookieAsset=null,this._cookieAssetId=null,this._cookieAssetAdd=!1,this._cookieMatrix=null}}class X9 extends Ht{initializeComponentData(e,t){const s={...t};s.type||(s.type=e.data.type),e.data.type=s.type,s.layers&&Array.isArray(s.layers)&&(s.layers=s.layers.slice(0)),s.color&&Array.isArray(s.color)&&(s.color=new ue(s.color[0],s.color[1],s.color[2])),s.cookieOffset&&s.cookieOffset instanceof Array&&(s.cookieOffset=new ne(s.cookieOffset[0],s.cookieOffset[1])),s.cookieScale&&s.cookieScale instanceof Array&&(s.cookieScale=new ne(s.cookieScale[0],s.cookieScale[1])),s.enable&&(console.warn("WARNING: enable: Property is deprecated. Set enabled property instead."),s.enabled=s.enable),s.shape||(s.shape=_r);const i=new ff(this.app.graphicsDevice,this.app.scene.clusteredLightingEnabled);i.type=Jx[s.type],i._node=e.entity,e.data.light=i,super.initializeComponentData(e,s,Gd)}_onRemoveComponent(e,t){t.onRemove()}cloneComponent(e,t){const s=e.light,i=[];let r;for(let a=0;a<Gd.length;a++)r=Gd[a],r!=="light"&&(s[r]&&s[r].clone?i[r]=s[r].clone():i[r]=s[r]);return this.addComponent(t,i)}changeType(e,t,s){t!==s&&(e.light.type=Jx[s])}constructor(e){super(e),this.id="light",this.ComponentType=W9,this.DataType=iI,this.on("beforeremove",this._onRemoveComponent,this)}}const q9=["x","y","z","w"],Y9=[void 0,void 0,ne,D,me];function Bh(c,e,t,s){switch(e.type){case"boolean":return!!t;case"number":if(typeof t=="number")return t;if(typeof t=="string"){const i=parseInt(t,10);return isNaN(i)?null:i}else if(typeof t=="boolean")return 0+t;return null;case"json":{const i={};if(Array.isArray(e.schema)){(!t||typeof t!="object")&&(t={});for(let r=0;r<e.schema.length;r++){const a=e.schema[r];if(a.name)if(a.array){i[a.name]=[];const o=Array.isArray(t[a.name])?t[a.name]:[];for(let h=0;h<o.length;h++)i[a.name].push(Bh(c,a,o[h]))}else{const o=t.hasOwnProperty(a.name)?t[a.name]:a.default;i[a.name]=Bh(c,a,o)}}}return i}case"asset":return t instanceof Ee?t:typeof t=="number"?c.assets.get(t)||null:typeof t=="string"&&c.assets.get(parseInt(t,10))||null;case"entity":return t instanceof Dt?t:typeof t=="string"?c.getEntityFromIndex(t):null;case"rgb":case"rgba":if(t instanceof ue)return s instanceof ue?(s.copy(t),s):t.clone();if(t instanceof Array&&t.length>=3&&t.length<=4){for(let i=0;i<t.length;i++)if(typeof t[i]!="number")return null;return s||(s=new ue),s.r=t[0],s.g=t[1],s.b=t[2],s.a=t.length===3?1:t[3],s}else if(typeof t=="string"&&/#(?:[0-9a-f]{2}){3,4}/i.test(t))return s||(s=new ue),s.fromString(t),s;return null;case"vec2":case"vec3":case"vec4":{const i=parseInt(e.type.slice(3),10),r=Y9[i];if(t instanceof r)return s instanceof r?(s.copy(t),s):t.clone();if(t instanceof Array&&t.length===i){for(let a=0;a<t.length;a++)if(typeof t[a]!="number")return null;s||(s=new r);for(let a=0;a<i;a++)s[q9[a]]=t[a];return s}return null}case"curve":if(t){let i;if(t instanceof fr||t instanceof ol)i=t.clone();else{const r=t.keys[0]instanceof Array?ol:fr;i=new r(t.keys),i.type=t.type}return i}break}return t}function rI(c,e,t,s){return e.array?t.map((i,r)=>Bh(c,e,i,s?s[r]:null)):Bh(c,e,t,s)}function aI(c,e,t,s){if(t)for(const i in e){const r=e[i],a=t[i];a!==void 0&&(s[i]=rI(c,r,a,s[i]))}}class go{add(e,t){t&&t.type&&(this.index[e]||go.reservedNames.has(e)||(this.index[e]=t,Object.defineProperty(this.scriptType.prototype,e,{get:function(){return this.__attributes[e]},set:function(s){const i="attr",r=`attr:${e}`,a=this.__attributes[e];let o=a;if(a&&t.type!=="json"&&t.type!=="entity"&&a.clone&&(this.hasEvent(i)||this.hasEvent(r))&&(o=a.clone()),t.array){if(this.__attributes[e]=[],s)for(let h=0,u=s.length;h<u;h++)this.__attributes[e].push(Bh(this.app,t,s[h],a?a[h]:null))}else this.__attributes[e]=Bh(this.app,t,s,a);this.fire(i,e,this.__attributes[e],o),this.fire(r,this.__attributes[e],o)}})))}remove(e){return this.index[e]?(delete this.index[e],delete this.scriptType.prototype[e],!0):!1}has(e){return!!this.index[e]}get(e){return this.index[e]||null}constructor(e){this.scriptType=e,this.index={}}}go.assignAttributesToScript=aI;go.attributeToValue=rI;go.reservedNames=new Set(["app","entity","enabled","_enabled","_enabledOld","_destroyed","__attributes","__attributesRaw","__scriptType","__executionOrder","_callbacks","_callbackActive","has","get","on","off","fire","once","hasEvent"]);const AT="initialize",wT="postInitialize",j9="update",$9="postUpdate",K9="swap";let zs=class extends Pe{set enabled(e){this._enabled=!!e,this.enabled!==this._enabledOld&&(this._enabledOld=this.enabled,this.fire(this.enabled?"enable":"disable"),this.fire("state",this.enabled),!this._initialized&&this.enabled&&(this._initialized=!0,this.fire("preInitialize"),this.initialize&&this.entity.script._scriptMethod(this,AT)),this._initialized&&!this._postInitialized&&this.enabled&&!this.entity.script._beingEnabled&&(this._postInitialized=!0,this.postInitialize&&this.entity.script._scriptMethod(this,wT)))}get enabled(){return this._enabled&&!this._destroyed&&this.entity.script.enabled&&this.entity.enabled}initScript(e){const t=this.constructor;this.app=e.app,this.entity=e.entity,this._enabled=typeof e.enabled=="boolean"?e.enabled:!0,this._enabledOld=this.enabled,this.__destroyed=!1,this.__scriptType=t,this.__executionOrder=-1}static set scriptName(e){this.__name=e}static get scriptName(){return this.__name}constructor(e){super(),this.initScript(e)}};zs.EVENT_ENABLE="enable";zs.EVENT_DISABLE="disable";zs.EVENT_STATE="state";zs.EVENT_DESTROY="destroy";zs.EVENT_ATTR="attr";zs.EVENT_ERROR="error";zs.__name=null;zs.__getScriptName=nI;const Z9=/^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s\/]*)\s*/;function nI(c){if(typeof c!="function")return;if(c.scriptName)return c.scriptName;if("name"in Function.prototype)return c.name;if(c===Function||c===Function.prototype.constructor)return"Function";const e=`${c}`.match(Z9);return e?e[1]:void 0}class Hd extends zs{static get attributes(){return this.hasOwnProperty("__attributes")||(this.__attributes=new go(this)),this.__attributes}initScript(e){zs.prototype.initScript.call(this,e),this.__attributes={},this.__attributesRaw=e.attributes||{}}initScriptType(e){this.initScript(e)}__initializeAttributes(e){if(!(!e&&!this.__attributesRaw)){for(const t in this.__scriptType.attributes.index)this.__attributesRaw&&this.__attributesRaw.hasOwnProperty(t)?this[t]=this.__attributesRaw[t]:this.__attributes.hasOwnProperty(t)||(this.__scriptType.attributes.index[t].hasOwnProperty("default")?this[t]=this.__scriptType.attributes.index[t].default:this[t]=null);this.__attributesRaw=null}}static extend(e){for(const t in e)e.hasOwnProperty(t)&&(this.prototype[t]=e[t])}constructor(e){super(e),this.initScriptType(e)}}const Q9=c=>c[0].toLowerCase()+c.substring(1);let nn=class extends ke{set scripts(e){this._scriptsData=e;for(const t in e){if(!e.hasOwnProperty(t))continue;const s=this._scriptsIndex[t];if(s){if(typeof e[t].enabled=="boolean"&&(s.once("preInitialize",()=>{this.initializeAttributes(s)}),s.enabled=!!e[t].enabled),typeof e[t].attributes=="object"){for(const i in e[t].attributes)if(!go.reservedNames.has(i)){if(!s.__attributes.hasOwnProperty(i)){const r=this.system.app.scripts.get(t);r&&r.attributes.add(i,{})}s[i]=e[t].attributes[i]}}}else console.log(this.order)}}get scripts(){return this._scripts}set enabled(e){const t=this._enabled;this._enabled=e,this.fire("set","enabled",t,e)}get enabled(){return this._enabled}onEnable(){this._beingEnabled=!0,this._checkState(),this.entity._beingEnabled||this.onPostStateChange(),this._beingEnabled=!1}onDisable(){this._checkState()}onPostStateChange(){const e=this._beginLooping();for(let t=0,s=this.scripts.length;t<s;t++){const i=this.scripts[t];i._initialized&&!i._postInitialized&&i.enabled&&(i._postInitialized=!0,i.postInitialize&&this._scriptMethod(i,wT))}this._endLooping(e)}_beginLooping(){const e=this._isLoopingThroughScripts;return this._isLoopingThroughScripts=!0,e}_endLooping(e){this._isLoopingThroughScripts=e,this._isLoopingThroughScripts||this._removeDestroyedScripts()}_onSetEnabled(e,t,s){this._beingEnabled=!0,this._checkState(),this._beingEnabled=!1}_checkState(){const e=this.enabled&&this.entity.enabled;if(e===this._oldState)return;this._oldState=e,this.fire(e?"enable":"disable"),this.fire("state",e),e?this.system._addComponentToEnabled(this):this.system._removeComponentFromEnabled(this);const t=this._beginLooping();for(let s=0,i=this.scripts.length;s<i;s++){const r=this.scripts[s];r.once("preInitialize",()=>{this.initializeAttributes(r)}),r.enabled=r._enabled}this._endLooping(t)}_onBeforeRemove(){this.fire("remove");const e=this._beginLooping();for(let t=0;t<this.scripts.length;t++){const s=this.scripts[t];s&&this.destroy(s.__scriptType.__name)}this._endLooping(e)}_removeDestroyedScripts(){const e=this._destroyedScripts.length;if(e){for(let t=0;t<e;t++){const s=this._destroyedScripts[t];this._removeScriptInstance(s)}this._destroyedScripts.length=0,this._resetExecutionOrder(0,this._scripts.length)}}_onInitializeAttributes(){for(let e=0,t=this.scripts.length;e<t;e++){const s=this.scripts[e];this.initializeAttributes(s)}}initializeAttributes(e){if(e instanceof Hd)e.__initializeAttributes();else{const t=e.__scriptType.__name,s=this._attributeDataMap.get(t);if(!s)return;const i=this.system.app.scripts?.getSchema(t);aI(this.system.app,i.attributes,s,e)}}_scriptMethod(e,t,s){e[t](s)}_onInitialize(){const e=this._scripts,t=this._beginLooping();for(let s=0,i=e.length;s<i;s++){const r=e[s];!r._initialized&&r.enabled&&(r._initialized=!0,r.initialize&&this._scriptMethod(r,AT))}this._endLooping(t)}_onPostInitialize(){this.onPostStateChange()}_onUpdate(e){const t=this._updateList;if(!t.length)return;const s=this._beginLooping();for(t.loopIndex=0;t.loopIndex<t.length;t.loopIndex++){const i=t.items[t.loopIndex];i.enabled&&this._scriptMethod(i,j9,e)}this._endLooping(s)}_onPostUpdate(e){const t=this._postUpdateList;if(!t.length)return;const s=this._beginLooping();for(t.loopIndex=0;t.loopIndex<t.length;t.loopIndex++){const i=t.items[t.loopIndex];i.enabled&&this._scriptMethod(i,$9,e)}this._endLooping(s)}_insertScriptInstance(e,t,s){t===-1?(this._scripts.push(e),e.__executionOrder=s,e.update&&this._updateList.append(e),e.postUpdate&&this._postUpdateList.append(e)):(this._scripts.splice(t,0,e),e.__executionOrder=t,this._resetExecutionOrder(t+1,s+1),e.update&&this._updateList.insert(e),e.postUpdate&&this._postUpdateList.insert(e))}_removeScriptInstance(e){const t=this._scripts.indexOf(e);return t===-1||(this._scripts.splice(t,1),e.update&&this._updateList.remove(e),e.postUpdate&&this._postUpdateList.remove(e)),t}_resetExecutionOrder(e,t){for(let s=e;s<t;s++)this._scripts[s].__executionOrder=s}_resolveEntityScriptAttribute(e,t,s,i,r,a){if(e.array){const o=s.length;if(!o)return;const h=s.slice();for(let u=0;u<o;u++){const f=h[u]instanceof Nt?h[u].getGuid():h[u];a[f]&&(h[u]=i?a[f].getGuid():a[f])}r[t]=h}else{if(s instanceof Nt)s=s.getGuid();else if(typeof s!="string")return;a[s]&&(r[t]=a[s])}}has(e){if(typeof e=="string")return!!this._scriptsIndex[e];if(!e)return!1;const t=e,s=t.__name,i=this._scriptsIndex[s];return(i&&i.instance)instanceof t}get(e){if(typeof e=="string"){const a=this._scriptsIndex[e];return a?a.instance:null}if(!e)return null;const t=e,s=t.__name,i=this._scriptsIndex[s],r=i&&i.instance;return r instanceof t?r:null}create(e,t={}){const s=this;let i=e,r=e;if(typeof i=="string")i=this.system.app.scripts.get(i);else if(i){var a;const o=nI(i),h=Q9(o);!(i.prototype instanceof Hd)&&i.scriptName,(a=i).__name??(a.__name=i.scriptName??h),r=i.__name}if(i){if(!this._scriptsIndex[r]||!this._scriptsIndex[r].instance){const o=new i({app:this.system.app,entity:this.entity,enabled:t.hasOwnProperty("enabled")?t.enabled:!0,attributes:t.attributes||{}});t.properties&&typeof t.properties=="object"&&Object.assign(o,t.properties),!(o instanceof Hd)&&t.attributes&&this._attributeDataMap.set(r,{...t.attributes});const h=this._scripts.length;let u=-1;return typeof t.ind=="number"&&t.ind!==-1&&h>t.ind&&(u=t.ind),this._insertScriptInstance(o,u,h),this._scriptsIndex[r]={instance:o,onSwap:function(){s.swap(r)}},this[r]=o,t.preloading||this.initializeAttributes(o),this.fire("create",r,o),this.fire(`create:${r}`,o),this.system.app.scripts.on(`swap:${r}`,this._scriptsIndex[r].onSwap),t.preloading||(o.enabled&&!o._initialized&&(o._initialized=!0,o.initialize&&this._scriptMethod(o,AT)),o.enabled&&!o._postInitialized&&(o._postInitialized=!0,o.postInitialize&&this._scriptMethod(o,wT))),o}}else this._scriptsIndex[r]={awaiting:!0,ind:this._scripts.length};return null}destroy(e){let t=e,s=e;typeof s=="string"?s=this.system.app.scripts.get(s):s&&(t=s.__name);const i=this._scriptsIndex[t];if(delete this._scriptsIndex[t],!i)return!1;this._attributeDataMap.delete(t);const r=i.instance;if(r&&!r._destroyed)if(r.enabled=!1,r._destroyed=!0,this._isLoopingThroughScripts)this._destroyedScripts.push(r);else{const a=this._removeScriptInstance(r);a>=0&&this._resetExecutionOrder(a,this._scripts.length)}return this.system.app.scripts.off(`swap:${t}`,i.onSwap),delete this[t],this.fire("destroy",t,r||null),this.fire(`destroy:${t}`,r||null),r&&r.fire("destroy"),!0}swap(e){let t=e,s=e;typeof s=="string"?s=this.system.app.scripts.get(s):s&&(t=s.__name);const i=this._scriptsIndex[t];if(!i||!i.instance)return!1;const r=i.instance,a=this._scripts.indexOf(r),o=new s({app:this.system.app,entity:this.entity,enabled:r.enabled,attributes:r.__attributes});return o.swap?(this.initializeAttributes(o),this._scripts[a]=o,this._scriptsIndex[t].instance=o,this[t]=o,o.__executionOrder=a,r.update&&this._updateList.remove(r),r.postUpdate&&this._postUpdateList.remove(r),o.update&&this._updateList.insert(o),o.postUpdate&&this._postUpdateList.insert(o),this._scriptMethod(o,K9,r),this.fire("swap",t,o),this.fire(`swap:${t}`,o),!0):!1}resolveDuplicatedEntityReferenceProperties(e,t){const s=this.entity.script;for(const i in e._scriptsIndex){const r=this.system.app.scripts.get(i);if(!r)continue;const a=e._scriptsIndex[i];if(!a||!a.instance)continue;const o=s[i].__attributesRaw??s._attributeDataMap.get(i),h=s[i].__attributes;if(!o&&!h)continue;const u=!!o,f=a.instance.__attributes??s._attributeDataMap.get(i);for(const m in f){if(!f[m])continue;const _=r.attributes?.get(m)??this.system.app.scripts.getSchema(i)?.attributes?.[m];if(_){if(_.type==="entity")this._resolveEntityScriptAttribute(_,m,f[m],u,o||h,t);else if(_.type==="json"&&Array.isArray(_.schema)){const g=f[m],S=o?o[m]:h[m];for(let x=0;x<_.schema.length;x++){const T=_.schema[x];if(T.type==="entity")if(_.array)for(let E=0;E<g.length;E++)this._resolveEntityScriptAttribute(T,T.name,g[E][T.name],u,S[E],t);else this._resolveEntityScriptAttribute(T,T.name,g[T.name],u,S,t)}}}}}}move(e,t){const s=this._scripts.length;if(t>=s||t<0)return!1;let i=e,r=e;typeof r!="string"?r=e.__name:i=null;const a=this._scriptsIndex[r];if(!a||!a.instance)return!1;const o=a.instance;if(i&&!(o instanceof i))return!1;const h=this._scripts.indexOf(o);return h===-1||h===t?!1:(this._scripts.splice(t,0,this._scripts.splice(h,1)[0]),this._resetExecutionOrder(0,s),this._updateList.sort(),this._postUpdateList.sort(),this.fire("move",r,o,t,h),this.fire(`move:${r}`,o,t,h),!0)}constructor(e,t){super(e,t),this._attributeDataMap=new Map,this._scripts=[],this._updateList=new G_({sortBy:"__executionOrder"}),this._postUpdateList=new G_({sortBy:"__executionOrder"}),this._scriptsIndex={},this._destroyedScripts=[],this._destroyed=!1,this._scriptsData=null,this._oldState=!0,this._enabled=!0,this._beingEnabled=!1,this._isLoopingThroughScripts=!1,this._executionOrder=-1,this.on("set_enabled",this._onSetEnabled,this)}};nn.EVENT_CREATE="create";nn.EVENT_DESTROY="destroy";nn.EVENT_ENABLE="enable";nn.EVENT_DISABLE="disable";nn.EVENT_REMOVE="remove";nn.EVENT_STATE="state";nn.EVENT_MOVE="move";nn.EVENT_ERROR="error";class J9{constructor(){this.enabled=!0}}const e7="_onInitializeAttributes",t7="_onInitialize",s7="_onPostInitialize",i7="_onUpdate",r7="_onPostUpdate";let c_=0;class a7 extends Ht{initializeComponentData(e,t){if(e._executionOrder=c_++,this._components.append(e),c_>Number.MAX_SAFE_INTEGER&&this._resetExecutionOrder(),e.enabled=t.hasOwnProperty("enabled")?!!t.enabled:!0,e.enabled&&e.entity.enabled&&this._enabledComponents.append(e),t.hasOwnProperty("order")&&t.hasOwnProperty("scripts")){e._scriptsData=t.scripts;for(let s=0;s<t.order.length;s++)e.create(t.order[s],{enabled:t.scripts[t.order[s]].enabled,attributes:t.scripts[t.order[s]].attributes,preloading:this.preloading})}}cloneComponent(e,t){const s=[],i={};for(let a=0;a<e.script._scripts.length;a++){const o=e.script._scripts[a],h=o.__scriptType.__name;s.push(h);const u=e.script._attributeDataMap?.get(h)||{};for(const f in o.__attributes)u[f]=o.__attributes[f];i[h]={enabled:o._enabled,attributes:u}}for(const a in e.script._scriptsIndex)a.awaiting&&s.splice(a.ind,0,a);const r={enabled:e.script.enabled,order:s,scripts:i};return this.addComponent(t,r)}_resetExecutionOrder(){c_=0;for(let e=0,t=this._components.length;e<t;e++)this._components.items[e]._executionOrder=c_++}_callComponentMethod(e,t,s){for(e.loopIndex=0;e.loopIndex<e.length;e.loopIndex++)e.items[e.loopIndex][t](s)}_onInitialize(){this.preloading=!1,this._callComponentMethod(this._components,e7),this._callComponentMethod(this._enabledComponents,t7)}_onPostInitialize(){this._callComponentMethod(this._enabledComponents,s7)}_onUpdate(e){this._callComponentMethod(this._enabledComponents,i7,e)}_onPostUpdate(e){this._callComponentMethod(this._enabledComponents,r7,e)}_addComponentToEnabled(e){this._enabledComponents.insert(e)}_removeComponentFromEnabled(e){this._enabledComponents.remove(e)}_onBeforeRemove(e,t){this._components.items.indexOf(t)>=0&&t._onBeforeRemove(),this._removeComponentFromEnabled(t),this._components.remove(t)}destroy(){super.destroy(),this.app.systems.off("initialize",this._onInitialize,this),this.app.systems.off("postInitialize",this._onPostInitialize,this),this.app.systems.off("update",this._onUpdate,this),this.app.systems.off("postUpdate",this._onPostUpdate,this)}constructor(e){super(e),this.id="script",this.ComponentType=nn,this.DataType=J9,this._components=new G_({sortBy:"_executionOrder"}),this._enabledComponents=new G_({sortBy:"_executionOrder"}),this.preloading=!0,this.on("beforeremove",this._onBeforeRemove,this),this.app.systems.on("initialize",this._onInitialize,this),this.app.systems.on("postInitialize",this._onPostInitialize,this),this.app.systems.on("update",this._onUpdate,this),this.app.systems.on("postUpdate",this._onPostUpdate,this)}}var n7=`
precision highp usampler2D;
uniform usampler2D uIntervalsTexture;
uniform int uNumIntervals;
uniform int uTextureWidth;
uniform int uActiveSplats;
ivec2 getCoordFromIndex(int index, int textureWidth) {
	return ivec2(index % textureWidth, index / textureWidth);
}
void main() {
	ivec2 coord = ivec2(gl_FragCoord.xy);
	int targetIndex = coord.y * uTextureWidth + coord.x;
	
	if (targetIndex >= uActiveSplats) {
		gl_FragColor = 0u;
		return;
	}
	
	int left = 0;
	int right = uNumIntervals - 1;
	int intervalIndex = 0;
	
	while (left <= right) {
		int mid = (left + right) / 2;
		
		int textureWidth = textureSize(uIntervalsTexture, 0).x;
		ivec2 intervalCoord = getCoordFromIndex(mid, textureWidth);
		uvec2 intervalData = texelFetch(uIntervalsTexture, intervalCoord, 0).rg;
		
		uint accumulatedSum = intervalData.g;
		
		if (uint(targetIndex) < accumulatedSum) {
			intervalIndex = mid;
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	
	int textureWidth = textureSize(uIntervalsTexture, 0).x;
	ivec2 intervalCoord = getCoordFromIndex(intervalIndex, textureWidth);
	uvec2 intervalData = texelFetch(uIntervalsTexture, intervalCoord, 0).rg;
	
	uint intervalStart = intervalData.r;
	uint currentAccSum = intervalData.g;
	
	uint prevAccSum = 0u;
	if (intervalIndex > 0) {
		ivec2 prevCoord = getCoordFromIndex(intervalIndex - 1, textureWidth);
		prevAccSum = texelFetch(uIntervalsTexture, prevCoord, 0).g;
	}
	
	uint offsetInInterval = uint(targetIndex) - prevAccSum;
	uint originalIndex = intervalStart + offsetInInterval;
	
	gl_FragColor = originalIndex;
}
`,o7=`
var uIntervalsTexture: texture_2d<u32>;
uniform uNumIntervals: i32;
uniform uTextureWidth: i32;
uniform uActiveSplats: i32;
fn getCoordFromIndex(index: i32, textureWidth: i32) -> vec2i {
	return vec2i(index % textureWidth, index / textureWidth);
}
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	
	let coord = vec2i(i32(input.position.x), i32(input.position.y));
	let targetIndex = coord.y * uniform.uTextureWidth + coord.x;
	
	if (targetIndex >= uniform.uActiveSplats) {
		output.color = 0u;
		return output;
	}
	
	var left = 0i;
	var right = uniform.uNumIntervals - 1;
	var intervalIndex = 0i;
	
	while (left <= right) {
		let mid = (left + right) / 2;
		
		let textureWidth = i32(textureDimensions(uIntervalsTexture, 0).x);
		let intervalCoord = getCoordFromIndex(mid, textureWidth);
		let intervalData = textureLoad(uIntervalsTexture, intervalCoord, 0).rg;
		
		let accumulatedSum = intervalData.g;
		
		if (u32(targetIndex) < accumulatedSum) {
			intervalIndex = mid;
			right = mid - 1;
		} else {
			left = mid + 1;
		}
	}
	
	let textureWidth = i32(textureDimensions(uIntervalsTexture, 0).x);
	let intervalCoord = getCoordFromIndex(intervalIndex, textureWidth);
	let intervalData = textureLoad(uIntervalsTexture, intervalCoord, 0).rg;
	
	let intervalStart = intervalData.r;
	let currentAccSum = intervalData.g;
	
	var prevAccSum = 0u;
	if (intervalIndex > 0) {
		let prevCoord = getCoordFromIndex(intervalIndex - 1, textureWidth);
		prevAccSum = textureLoad(uIntervalsTexture, prevCoord, 0).g;
	}
	
	let offsetInInterval = u32(targetIndex) - prevAccSum;
	let originalIndex = intervalStart + offsetInInterval;
	
	output.color = originalIndex;
	return output;
}
`;class l7{destroy(){this.texture?.destroy(),this.texture=null,this.rt?.destroy(),this.rt=null,this.intervalsDataTexture?.destroy(),this.intervalsDataTexture=null,this.shader=null}getShader(){return this.shader||(this.shader=ns.createShader(this.device,{uniqueName:"GSplatIntervalsShader",attributes:{aPosition:He},vertexChunk:"quadVS",fragmentGLSL:n7,fragmentWGSL:o7,fragmentOutputTypes:["uint"]})),this.shader}createTexture(e,t,s,i){return new De(this.device,{name:e,width:s,height:i,format:t,cubemap:!1,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te})}update(e,t){const s=this.device.maxTextureSize;let i=Math.ceil(Math.sqrt(t));i=Math.min(i,s);const r=Math.ceil(t/i);this.texture=this.createTexture("intervalsTexture",oo,i,r),this.rt=new At({colorBuffer:this.texture,depth:!1});const a=e.length/2,o=Math.ceil(Math.sqrt(a));this.intervalsDataTexture=this.createTexture("intervalsData",Hh,o,o);const h=this.intervalsDataTexture.lock();let u=0;for(let m=0;m<a;m++){const _=e[m*2],S=e[m*2+1]-_;u+=S,h[m*2]=_,h[m*2+1]=u}this.intervalsDataTexture.unlock();const f=this.device.scope;return f.resolve("uIntervalsTexture").setValue(this.intervalsDataTexture),f.resolve("uNumIntervals").setValue(a),f.resolve("uTextureWidth").setValue(i),f.resolve("uActiveSplats").setValue(t),this.device.setCullMode(Ft),this.device.setBlendState(ht.NOBLEND),this.device.setDepthState(Gt.NODEPTH),gr(this.device,this.rt,this.getShader()),t}constructor(e){this.texture=null,this.rt=null,this.intervalsDataTexture=null,this.shader=null,this.device=e}}const Ko=[];class bR{destroy(){this.intervals.length=0,this.intervalTexture?.destroy()}setLines(e,t,s,i){this.lineStart=e,this.lineCount=t,this.padding=s*t-i,this.viewport.set(0,e,s,t)}updateIntervals(e){const t=this.resource;if(this.intervals.length=0,this.activeSplats=t.numSplats,e.size>0){let s=0,i=0;for(const r of e.values())s+=r.y-r.x+1,Ko[i++]=r;if(s!==this.numSplats){Ko.length=i,Ko.sort((h,u)=>h.x-u.x),this.intervals.length=i*2;let r=0,a=Ko[0].x,o=Ko[0].y;for(let h=1;h<i;h++){const u=Ko[h];u.x===o+1||(this.intervals[r++]=a,this.intervals[r++]=o+1,a=u.x),o=u.y}this.intervals[r++]=a,this.intervals[r++]=o+1,this.intervals.length=r,this.intervalTexture=new l7(this.device),this.activeSplats=this.intervalTexture.update(this.intervals,s)}Ko.length=0}}update(){const e=this.node.getWorldTransform(),t=!this.previousWorldTransform.equals(e);return t&&this.previousWorldTransform.copy(e),t}resetColorAccumulators(e,t){const s=Math.random();this.colorAccumulatedRotation=s*e,this.colorAccumulatedTranslation=s*t}get hasSphericalHarmonics(){return this.resource.gsplatData?.shBands>0}constructor(e,t,s){this.activeSplats=0,this.intervals=[],this.lineStart=0,this.lineCount=0,this.padding=0,this.viewport=new me,this.previousWorldTransform=new fe,this.aabb=new Ge,this.intervalTexture=null,this.colorAccumulatedRotation=0,this.colorAccumulatedTranslation=0,this.device=e,this.resource=t,this.node=s.node,this.lodIndex=s.lodIndex,this.numSplats=t.numSplats,this.aabb.copy(s.aabb),this.updateIntervals(s.intervals)}}function c7(){const c=typeof self<"u"&&self||require("node:worker_threads").parentPort,e=new Map;let t,s,i,r=!1;const a=32,o=new Float32Array(a+1),h=new Float32Array(a+1),u=new GSplatSortBinWeights,f=b=>{for(let C=0;C<a;C++)o[C]=b[C*2],h[C]=b[C*2+1];o[a]=o[a-1]+h[a-1],h[a]=0},m=(b,C,w,P,I,M,R)=>{const{ids:L,lineStarts:B,padding:G,intervals:H,textureSize:ee}=M,j=a/w;for(let ae=0;ae<b.length;ae++){const k=b[ae],O=L[ae],z=e.get(O);z||console.error("UnifiedSortWorker: No centers found for id",O);let X=B[ae]*ee;const Y=H[ae].length>0?H[ae]:[0,z.length/3];for(let U=0;U<Y.length;U+=2){const K=Y[U]*3,se=Y[U+1]*3;X=R(z,k,K,se,X,j,C,w,P,I)}const F=G[ae];I[0]+=F,P.fill(0,X,X+F),X+=F}},_=(b,C,w,P,I,M)=>{m(b,C,w,P,I,M,(R,L,B,G,H,ee,j,ae,k,O)=>{const{transformedDirection:z,offset:X,scale:Y}=L,F=z.x,U=z.y,K=z.z,se=F*Y,le=U*Y,re=K*Y,de=X-j;for(let ye=B;ye<G;ye+=3){const Me=R[ye],et=R[ye+1],Qe=R[ye+2],xr=(Me*se+et*le+Qe*re+de)*ee,ms=xr>>>0,$r=o[ms]+h[ms]*(xr-ms)>>>0;k[H++]=$r,O[$r]++}return H})},g=(b,C,w,P,I,M)=>{m(b,C,w,P,I,M,(R,L,B,G,H,ee,j,ae,k,O)=>{const{transformedPosition:z,scale:X}=L,Y=z.x,F=z.y,U=z.z;for(let K=B;K<G;K+=3){const se=R[K]-Y,le=R[K+1]-F,re=R[K+2]-U,de=se*se+le*le+re*re,ye=Math.sqrt(de)*X,et=(ae-ye)*ee,Qe=et>>>0,ls=o[Qe]+h[Qe]*(et-Qe)>>>0;k[H++]=ls,O[ls]++}return H})},S=(b,C,w,P,I)=>{for(let M=1;M<b;M++)C[M]+=C[M-1];for(let M=0;M<w;M++){const R=P[M],L=--C[R];I[L]=M}},x=b=>{let C=1/0,w=-1/0;for(let P=0;P<b.length;P++){const I=b[P],{transformedDirection:M,offset:R,scale:L,aabbMin:B,aabbMax:G}=I,H=M.x,ee=M.y,j=M.z,ae=H>=0?B[0]:G[0],k=ee>=0?B[1]:G[1],O=j>=0?B[2]:G[2],z=H>=0?G[0]:B[0],X=ee>=0?G[1]:B[1],Y=j>=0?G[2]:B[2],F=ae*H+k*ee+O*j,U=z*H+X*ee+Y*j,K=F*L+R,se=U*L+R,le=Math.min(K,se),re=Math.max(K,se);le<C&&(C=le),re>w&&(w=re)}return C===1/0&&(C=0,w=0),{minDist:C,maxDist:w}},T=b=>{let C=-1/0;for(let P=0;P<b.length;P++){const I=b[P],{transformedPosition:M,scale:R,aabbMin:L,aabbMax:B}=I,G=M.x,H=M.y,ee=M.z;for(let j=0;j<8;j++){const ae=j&1?B[0]:L[0],k=j&2?B[1]:L[1],O=j&4?B[2]:L[2],z=ae-G,X=k-H,Y=O-ee,F=z*z+X*X+Y*Y,U=Math.sqrt(F)*R;U>C&&(C=U)}}const w=0;return C<0&&(C=0),{minDist:w,maxDist:C}},E=(b,C,w)=>{const P=performance.now(),{minDist:I,maxDist:M}=r?T(b):x(b),R=w.totalUsedPixels,B=2**Math.max(10,Math.min(20,Math.round(Math.log2(R/4))))+1;s?.length!==R&&(s=new Uint32Array(R)),!i||i.length!==B?i=new Uint32Array(B):i.fill(0);const G=M-I,H=GSplatSortBinWeights.computeCameraBin(r,I,G),ee=u.compute(H,B);f(ee),r?g(b,I,G,s,i,w):_(b,I,G,s,i,w),S(B,i,R,s,C);const j=R,ae=performance.now()-P,k=[C.buffer],O={order:C.buffer,count:j,version:w.version,sortTime:ae};c.postMessage(O,k)};c.addEventListener("message",b=>{const C=b.data??b;switch(C.command){case"addCenters":{e.set(C.id,new Float32Array(C.centers));break}case"removeCenters":{e.delete(C.id);break}case"sort":{r=C.radialSorting||!1;const w=new Uint32Array(C.order);E(C.sortParams,w,t);break}case"intervals":{t=C;break}}})}let Od=class rh{static get NUM_BINS(){return 32}static get WEIGHT_TIERS(){return[{maxDistance:0,weight:40},{maxDistance:2,weight:20},{maxDistance:5,weight:8},{maxDistance:10,weight:3},{maxDistance:1/0,weight:1}]}static computeCameraBin(e,t,s){const i=rh.NUM_BINS;if(e)return i-1;const a=-t/s*i;return Math.max(0,Math.min(i-1,Math.floor(a)))}compute(e,t){if(e===this.lastCameraBin&&t===this.lastBucketCount)return this.binWeights;this.lastCameraBin=e,this.lastBucketCount=t;const s=rh.NUM_BINS,i=this.bitsPerBin;for(let o=0;o<s;o++){const h=Math.abs(o-e);i[o]=this.weightByDistance[h]}let r=0;for(let o=0;o<s;o++)r+=i[o];let a=0;for(let o=0;o<s;o++){const h=Math.max(1,Math.floor(i[o]/r*t));this.binWeights[o*2]=a,this.binWeights[o*2+1]=h,a+=h}if(a>t){const o=a-t,h=(s-1)*2+1;this.binWeights[h]=Math.max(1,this.binWeights[h]-o)}return this.binWeights}constructor(){this.binWeights=new Float32Array(rh.NUM_BINS*2),this.lastCameraBin=-1,this.lastBucketCount=-1;const e=rh.NUM_BINS,t=rh.WEIGHT_TIERS;this.bitsPerBin=new Float32Array(e),this.weightByDistance=new Float32Array(e);for(let s=0;s<e;s++){let i=1;for(let r=0;r<t.length;r++)if(s<=t[r].maxDistance){i=t[r].weight;break}this.weightByDistance[s]=i}}};const rx=new Set;class h7 extends Pe{onSorted(e){if(this._destroyed)return;const t=e.data??e;this.scene&&t.sortTime!==void 0&&this.scene.fire("gsplat:sorted",t.sortTime);const s=new Uint32Array(t.order);this.jobsInFlight--,this.pendingSorted&&this.releaseOrderData(this.pendingSorted.orderData),this.pendingSorted={count:t.count,version:t.version,orderData:s}}applyPendingSorted(){if(this.pendingSorted){const{count:e,version:t,orderData:s}=this.pendingSorted;this.pendingSorted=null,this.fire("sorted",e,t,s),this.releaseOrderData(s)}}releaseOrderData(e){e.length===this.bufferLength&&this.availableOrderData.push(e)}destroy(){this._destroyed=!0,this.pendingSorted=null,this.worker.terminate(),this.worker=null}setCenters(e,t){if(t){if(!this.centersSet.has(e)){this.centersSet.add(e);const s=t.buffer.slice();this.worker.postMessage({command:"addCenters",id:e,centers:s},[s])}}else this.centersSet.has(e)&&(this.centersSet.delete(e),this.worker.postMessage({command:"removeCenters",id:e}))}updateCentersForSplats(e){for(const t of e){const s=t.resource.id;rx.add(s),this.centersSet.has(s)||this.setCenters(s,t.resource.centers)}for(const t of this.centersSet)rx.has(t)||this.setCenters(t,null);rx.clear()}setSortParameters(e){this.hasNewVersion=!0;const{textureSize:t}=e,s=t*t;s!==this.bufferLength&&(this.bufferLength=s,this.availableOrderData.length=0),this.worker.postMessage(e)}setSortParams(e,t){if(this.hasNewVersion||this.jobsInFlight===0){let s=this.availableOrderData.pop();s||(s=new Uint32Array(this.bufferLength)),this.jobsInFlight++,this.hasNewVersion=!1,this.worker.postMessage({command:"sort",sortParams:e,radialSorting:t,order:s.buffer},[s.buffer])}}constructor(e){super(),this.bufferLength=0,this.availableOrderData=[],this.jobsInFlight=0,this.hasNewVersion=!1,this.pendingSorted=null,this.centersSet=new Set,this._destroyed=!1,this.scene=null,this.scene=e??null;const t=`
						const GSplatSortBinWeights = ${Od.toString()};
						(${c7.toString()})()
				`;Ve.environment==="node"?(this.worker=new Worker(t,{eval:!0}),this.worker.on("message",this.onSorted.bind(this))):(this.worker=new Worker(URL.createObjectURL(new Blob([t],{type:"application/javascript"}))),this.worker.addEventListener("message",this.onSorted.bind(this)))}}class u7{setRenderMode(e){const t=this.renderMode??0,s=(t&ch)!==0,i=(t&hh)!==0,r=(e&ch)!==0,a=(e&hh)!==0;this.meshInstance.castShadow=a,s&&!r&&this.layer.removeMeshInstances([this.meshInstance],!0),i&&!a&&this.layer.removeShadowCasters([this.meshInstance]),!s&&r&&this.layer.addMeshInstances([this.meshInstance],!0),!i&&a&&this.layer.addShadowCasters([this.meshInstance]),this.renderMode=e}destroy(){this.renderMode&&(this.renderMode&ch&&this.layer.removeMeshInstances([this.meshInstance],!0),this.renderMode&hh&&this.layer.removeShadowCasters([this.meshInstance])),this._material.destroy(),this.meshInstance.destroy()}get material(){return this._material}configureMaterial(){const{device:e,workBuffer:t}=this;this._material.setDefine("GSPLAT_WORKBUFFER_DATA",!0),this._material.setDefine("STORAGE_ORDER",e.isWebGPU);const s=t.colorTextureFormat===lo;this._material.setDefine("GSPLAT_COLOR_UINT",s),this._material.setParameter("splatColor",t.colorTexture),this._material.setParameter("splatTexture0",t.splatTexture0),this._material.setParameter("splatTexture1",t.splatTexture1),this._material.setDefine("SH_BANDS","0"),this._material.setParameter("numSplats",0),t.orderTexture&&this._material.setParameter("splatOrder",t.orderTexture),this._material.setParameter("alphaClip",.3),this._material.setDefine("DITHER_NONE",""),this._material.cull=Ft,this._material.blendType=ro,this._material.depthWrite=!1,this._material.update()}update(e,t){this.meshInstance.instancingCount=Math.ceil(e/Js.instanceSize),this._material.setParameter("numSplats",e),this._material.setParameter("splatTextureSize",t),this.meshInstance.visible=e>0}setOrderData(){this.device.isWebGPU?this._material.setParameter("splatOrder",this.workBuffer.orderBuffer):this._material.setParameter("splatOrder",this.workBuffer.orderTexture)}setOrderBuffer(e){this._material.setParameter("splatOrder",e)}frameUpdate(e){e.colorRamp&&this._material.setParameter("colorRampIntensity",e.colorRampIntensity),(this.forceCopyMaterial||e.material.dirty)&&(this.copyMaterialSettings(e.material),this.forceCopyMaterial=!1)}copyMaterialSettings(e){const t=[];this._material.defines.forEach((i,r)=>{this._internalDefines.has(r)||t.push(r)}),t.forEach(i=>this._material.defines.delete(i)),e.defines.forEach((i,r)=>{this._material.defines.set(r,i)});const s=e.parameters;for(const i in s)s.hasOwnProperty(i)&&this._material.setParameter(i,s[i].data);e.hasShaderChunks&&this._material.shaderChunks.copy(e.shaderChunks),this._material.update()}updateOverdrawMode(e){const t=!!e.colorRamp,s=this._material.getDefine("GSPLAT_OVERDRAW");t&&(this._material.setParameter("colorRamp",e.colorRamp),this._material.setParameter("colorRampIntensity",e.colorRampIntensity)),t!==s&&(this._material.setDefine("GSPLAT_OVERDRAW",t),t?(this.originalBlendType=this._material.blendType,this._material.blendType=rf):this._material.blendType=this.originalBlendType,this._material.update())}setMaxNumSplats(e){const t=J.roundUp(e,Js.instanceSize);this.instanceIndicesCount<t&&(this.instanceIndicesCount=t,this.instanceIndices?.destroy(),this.instanceIndices=Js.createInstanceIndices(this.device,e),this.meshInstance.setInstancing(this.instanceIndices,!0),this._material.setParameter("splatTextureSize",this.workBuffer.textureSize))}createMeshInstance(){const e=Js.createMesh(this.device),t=this.workBuffer.textureSize,s=Js.createInstanceIndices(this.device,t*t),i=new lt(e,this._material);i.node=this.node,i.setInstancing(s,!0),i.instancingCount=0;const r=this.cameraNode.camera;return i.isVisibleFunc=a=>{const o=this.renderMode??0;return r.camera===a&&o&ch?!0:o&hh?a.node?.name===W2:!1},i}constructor(e,t,s,i,r){this.instanceIndices=null,this.instanceIndicesCount=0,this.originalBlendType=rf,this._internalDefines=new Set,this.forceCopyMaterial=!0,this.device=e,this.node=t,this.cameraNode=s,this.layer=i,this.workBuffer=r,this._material=new Za({uniqueName:"UnifiedSplatMaterial",vertexGLSL:'#include "gsplatVS"',fragmentGLSL:'#include "gsplatPS"',vertexWGSL:'#include "gsplatVS"',fragmentWGSL:'#include "gsplatPS"',attributes:{vertex_position:He,vertex_id_attrib:uv}}),this.configureMaterial(),this._material.defines.forEach((a,o)=>{this._internalDefines.add(o)}),this.meshInstance=this.createMeshInstance()}}class CT{set aabb(e){this._aabb.copy(e)}get aabb(){return this._aabb}set lodDistances(e){this.resource&&this.resource.octree&&(e?(this.resource.octree?.lodLevels,this._lodDistances=e.slice()):this._lodDistances=null)}get lodDistances(){return this._lodDistances?this._lodDistances.slice():null}constructor(e,t,s=0){this.intervals=new Map,this.lodIndex=0,this._lodDistances=null,this.splatBudget=0,this._aabb=new Ge,this.resource=e,this.node=t,this.lodIndex=s}}const ax=new fe,d7=new D,f7=new D,kn=new D,Vn=[];new Ge;new ue(1,0,0),new ue(0,1,0),new ue(0,0,1),new ue(1,1,0),new ue(1,0,1);class m7{reset(){this.currentLod=-1,this.optimalLod=-1,this.importance=0}constructor(){this.currentLod=-1,this.optimalLod=-1,this.importance=0}}class p7{get pendingLoadCount(){let e=this.pending.size+this.prefetchPending.size;return this.octree.environmentUrl&&!this.environmentPlacement&&e++,e}destroy(){if(this.octree&&!this.octree.destroyed){const e=this.getFileDecrements();for(const t of e)this.octree.decRefCount(t,0);for(const t of this.pending)this.filePlacements[t]||this.octree.unloadResource(t);for(const t of this.prefetchPending)this.filePlacements[t]||this.octree.unloadResource(t);this.environmentPlacement&&this.octree.decEnvironmentRefCount()}this.pending.clear(),this.pendingDecrements.clear(),this.filePlacements.length=0,this.environmentPlacement&&(this.activePlacements.delete(this.environmentPlacement),this.environmentPlacement=null),this._deviceLostEvent?.off(),this._deviceLostEvent=null}_onDeviceLost(){for(let e=0;e<this.filePlacements.length;e++)this.filePlacements[e]&&this.octree.decRefCount(e,0);this.filePlacements.fill(null),this.activePlacements.clear(),this.pending.clear(),this.pendingDecrements.clear(),this.removedCandidates.clear(),this.prefetchPending.clear(),this.pendingVisibleAdds.clear();for(const e of this.nodeInfos)e.reset();this.environmentPlacement&&(this.activePlacements.delete(this.environmentPlacement),this.environmentPlacement=null,this.octree.unloadEnvironmentResource()),this.dirtyModifiedPlacements=!0,this.needsLodUpdate=!0}getFileDecrements(){const e=[];for(let t=0;t<this.filePlacements.length;t++)this.filePlacements[t]&&e.push(t);return e}calculateNodeLod(e,t,s,i,r,a){this.octree.nodes[s].bounds.closestPoint(e,kn),kn.sub(e);let h=kn.length();if(a>1&&h>.01){const u=t.dot(kn)/h;if(u<0){const m=1+-u*(a-1);h*=m}}for(let u=0;u<i;u++)if(h<r[u])return u;return i}selectDesiredLodIndex(e,t,s,i){if(i>0){const r=Math.min(s,t+i);for(let a=t;a<=r;a++){const o=e.lods[a].fileIndex;if(o!==-1&&this.octree.getFileResource(o))return a}for(let a=r;a>=t;a--)if(e.lods[a].fileIndex!==-1)return a}return t}prefetchNextLod(e,t,s){if(t===-1||s===-1)return;if(t===s){const r=e.lods[s].fileIndex;r!==-1&&(this.octree.ensureFileResource(r),this.octree.getFileResource(r)||this.prefetchPending.add(r));return}const i=Math.max(s,t-1);for(let r=i;r>=s;r--){const a=e.lods[r].fileIndex;if(a!==-1){this.octree.ensureFileResource(a),this.octree.getFileResource(a)||this.prefetchPending.add(a);break}}}updateLod(e,t){const s=this.octree.lodLevels-1,i=this.placement.lodDistances||[5,10,15,20,25,30,35,40,45,50,55,60],{lodRangeMin:r,lodRangeMax:a}=t,o=Math.max(0,Math.min(r??0,s)),h=Math.max(o,Math.min(a??s,s)),u=this.evaluateNodeLods(e,s,i,o,h,t);this.splatBudget>0&&this.enforceSplatBudget(u,this.splatBudget,o,h),this.applyLodChanges(s,t)}evaluateNodeLods(e,t,s,i,r,a){const{lodBehindPenalty:o}=a,h=e.getPosition(),u=this.placement.node.getWorldTransform();ax.copy(u).invert();const f=ax.transformPoint(h,d7),m=e.forward,_=ax.transformVector(m,f7).normalize(),g=this.octree.nodes,S=this.nodeInfos;let x=0;const T=s[r]||100;for(let E=0;E<g.length;E++){g[E].bounds.closestPoint(f,kn),kn.sub(f);const C=kn.length();let w=C,P=1;if(o>1&&C>.01){const B=_.dot(kn)/C;if(B<0){const H=1+-B*(o-1);w=C*H,P=1/H}}let I=t;for(let B=0;B<t;B++)if(w<s[B]){I=B;break}I<i&&(I=i),I>r&&(I=r);const R=(1-Math.min(C/T,1))*P;S[E].optimalLod=I,S[E].importance=R;const L=g[E].lods[I];L&&L.count&&(x+=L.count)}return x}enforceSplatBudget(e,t,s,i){const r=this.octree.nodes,a=this.nodeInfos;if(!this._nodeIndices){this._nodeIndices=new Uint32Array(r.length);for(let m=0;m<r.length;m++)this._nodeIndices[m]=m}const o=this._nodeIndices;o.sort((m,_)=>a[m].importance-a[_].importance);let h=e;if(h===t)return;const u=h>t,f=u?1:-1;for(;u?h>t:h<t;){let m=!1;if(u)for(let _=0;_<o.length;_++){const g=o[_],S=a[g],x=r[g],T=S.optimalLod;if(T<i){const E=x.lods[T],b=x.lods[T+1],C=E.count-b.count;if(S.optimalLod+=f,h-=C,m=!0,h<=t)break}}else for(let _=o.length-1;_>=0;_--){const g=o[_],S=a[g],x=r[g],T=S.optimalLod;if(T>s){const E=x.lods[T],C=x.lods[T-1].count-E.count;if(h+C<=t&&(S.optimalLod+=f,h+=C,m=!0,h>=t))break}}if(!m)break}}applyLodChanges(e,t){const s=this.octree.nodes,{lodUnderfillLimit:i=0}=t;for(let r=0;r<s.length;r++){const a=s[r],o=this.nodeInfos[r],h=o.optimalLod,u=o.currentLod,f=this.selectDesiredLodIndex(a,h,e,i);if(f!==u){const m=u>=0?a.lods[u].fileIndex:-1,_=f>=0?a.lods[f].fileIndex:-1,g=m!==-1,S=_!==-1,x=this.pendingDecrements.get(r);if(x&&x.newFileIndex!==_&&(this.filePlacements[x.newFileIndex]&&this.decrementFileRef(x.newFileIndex,r),g&&S?this.pendingDecrements.set(r,{oldFileIndex:x.oldFileIndex,newFileIndex:_}):this.pendingDecrements.delete(r)),!g&&S){const T=this.pendingVisibleAdds.get(r);T!==void 0&&T!==_&&(this.decrementFileRef(T,r),this.pendingVisibleAdds.delete(r)),this.incrementFileRef(_,r,f),this.filePlacements[_]?.resource?(o.currentLod=f,this.pendingVisibleAdds.delete(r)):this.pendingVisibleAdds.set(r,_)}else if(g&&!S){const T=this.pendingDecrements.get(r);T&&(this.decrementFileRef(T.newFileIndex,r),this.pendingDecrements.delete(r)),this.decrementFileRef(m,r),o.currentLod=-1,this.pendingVisibleAdds.delete(r)}else g&&S&&(this.incrementFileRef(_,r,f),this.filePlacements[_]?.resource?(this.decrementFileRef(m,r),this.pendingDecrements.delete(r),o.currentLod=f,this.pendingVisibleAdds.delete(r)):(this.pendingDecrements.set(r,{oldFileIndex:m,newFileIndex:_}),this.pendingVisibleAdds.delete(r)))}this.prefetchNextLod(a,f,h)}}incrementFileRef(e,t,s){if(e===-1)return;let i=this.filePlacements[e];i||(i=new CT(null,this.placement.node,s),this.filePlacements[e]=i,this.removedCandidates.delete(e)||this.octree.incRefCount(e),this.addFilePlacement(e)||(this.octree.ensureFileResource(e),this.pending.add(e)));const o=this.octree.nodes[t].lods[s],h=new ne(o.offset,o.offset+o.count-1);i.intervals.set(t,h),this.dirtyModifiedPlacements=!0}decrementFileRef(e,t){if(e===-1)return;const s=this.filePlacements[e];s&&s&&(s.intervals.delete(t),this.dirtyModifiedPlacements=!0,s.intervals.size===0&&(s.resource&&this.activePlacements.delete(s),this.removedCandidates.add(e),this.filePlacements[e]=null,this.pending.delete(e)))}addFilePlacement(e){const t=this.octree.getFileResource(e);if(t){const s=this.filePlacements[e];if(s)return s.resource=t,s.aabb.copy(t.aabb),this.activePlacements.add(s),this.dirtyModifiedPlacements=!0,this.removedCandidates.delete(e),!0}return!1}testMoved(e){return this.placement.node.getPosition().distance(this.previousPosition)>e}updateMoved(){this.previousPosition.copy(this.placement.node.getPosition())}update(e){const t=this.placement.splatBudget;if(t!==this.splatBudget&&(this.splatBudget=t,this.needsLodUpdate=!0),this.pending.size){for(const i of this.pending)if(this.octree.ensureFileResource(i),this.addFilePlacement(i)){Vn.push(i);for(const[r,{oldFileIndex:a,newFileIndex:o}]of this.pendingDecrements)if(o===i){this.decrementFileRef(a,r),this.pendingDecrements.delete(r);let h=0;const u=this.octree.nodes[r].lods;for(let f=0;f<u.length;f++)if(u[f].fileIndex===o){h=f;break}this.nodeInfos[r].currentLod=h}}Vn.length>0&&(this.needsLodUpdate=!0);for(const i of Vn)this.pending.delete(i);Vn.length=0}if(this.pollPrefetchCompletions(),this.octree.environmentUrl&&!this.environmentPlacement){this.octree.ensureEnvironmentResource();const i=this.octree.environmentResource;i&&(this.environmentPlacement=new CT(i,this.placement.node,0),this.environmentPlacement.aabb.copy(i.aabb),this.activePlacements.add(this.environmentPlacement),this.dirtyModifiedPlacements=!0)}const s=this.dirtyModifiedPlacements;return this.dirtyModifiedPlacements=!1,s}debugRender(e){}consumeNeedsLodUpdate(){const e=this.needsLodUpdate;return this.needsLodUpdate=!1,e}pollPrefetchCompletions(){if(this.prefetchPending.size){for(const e of this.prefetchPending)this.octree.ensureFileResource(e),this.octree.getFileResource(e)&&Vn.push(e);Vn.length>0&&(this.needsLodUpdate=!0);for(const e of Vn)this.prefetchPending.delete(e);Vn.length=0}}constructor(e,t,s){this.activePlacements=new Set,this.dirtyModifiedPlacements=!1,this.pending=new Set,this.pendingDecrements=new Map,this.removedCandidates=new Set,this.previousPosition=new D,this.needsLodUpdate=!1,this.prefetchPending=new Set,this.pendingVisibleAdds=new Map,this.splatBudget=0,this._nodeIndices=null,this.environmentPlacement=null,this._deviceLostEvent=null,this.device=e,this.octree=t,this.placement=s,this.nodeInfos=new Array(t.nodes.length);for(let r=0;r<t.nodes.length;r++)this.nodeInfos[r]=new m7;const i=t.files.length;this.filePlacements=new Array(i).fill(null),t.environmentUrl&&(t.incEnvironmentRefCount(),t.ensureEnvironmentResource()),this._deviceLostEvent=e.on("devicelost",this._onDeviceLost,this)}}const AR=new D,wR=new D;class _7{constructor(e,t){this.bounds=new Ge,this.lods=e,AR.set(t.min[0],t.min[1],t.min[2]),wR.set(t.max[0],t.max[1],t.max[2]),this.bounds.setMinMax(AR,wR)}}const nx=[];class g7{destroy(){this.destroyed=!0,this.fileResources.clear(),this.cooldowns.clear(),this.assetLoader?.destroy(),this.assetLoader=null,this.environmentResource=null}_traceLodCounts(){}_extractLeafNodes(e,t){if(e.lods)t.push({lods:e.lods,bound:e.bound});else if(e.children)for(const s of e.children)this._extractLeafNodes(s,t)}getFileResource(e){return this.fileResources.get(e)}incRefCount(e){const t=this.fileRefCounts[e]+1;this.fileRefCounts[e]=t,this.cooldowns.delete(e)}decRefCount(e,t){const s=this.fileRefCounts[e]-1;this.fileRefCounts[e]=s,s===0&&(t===0?this.unloadResource(e):this.cooldowns.set(e,t))}unloadResource(e){if(!this.assetLoader)return;const t=this.files[e].url;this.assetLoader.unload(t),this.fileResources.has(e)&&(this.fileResources.delete(e),this._traceLodCounts())}updateCooldownTick(e){this.cooldownTicks=e,this.cooldowns.size>0&&(this.cooldowns.forEach((t,s)=>{t<=1?(this.fileRefCounts[s]===0&&this.unloadResource(s),nx.push(s)):this.cooldowns.set(s,t-1)}),nx.forEach(t=>this.cooldowns.delete(t)),nx.length=0)}ensureFileResource(e){if(this.fileResources.has(e))return;const t=this.files[e].url,s=this.assetLoader?.getResource(t);if(s){this.fileResources.set(e,s),this.fileRefCounts[e]===0&&this.cooldowns.set(e,this.cooldownTicks),this._traceLodCounts();return}this.assetLoader?.load(t)}incEnvironmentRefCount(){this.environmentRefCount++}decEnvironmentRefCount(){this.environmentRefCount--,this.environmentRefCount===0&&this.unloadEnvironmentResource()}ensureEnvironmentResource(){if(!this.assetLoader||!this.environmentUrl||this.environmentResource)return;const e=this.assetLoader.getResource(this.environmentUrl);if(e){this.environmentResource=e,this.environmentRefCount===0&&this.unloadEnvironmentResource();return}this.assetLoader.load(this.environmentUrl)}unloadEnvironmentResource(){this.assetLoader&&this.environmentResource&&this.environmentUrl&&(this.assetLoader.unload(this.environmentUrl),this.environmentResource=null)}constructor(e,t){this.fileResources=new Map,this.cooldowns=new Map,this.environmentUrl=null,this.environmentResource=null,this.environmentRefCount=0,this.assetLoader=null,this.destroyed=!1,this.cooldownTicks=100,this.lodLevels=t.lodLevels,this.assetFileUrl=e;const s=Re.getDirectory(e);this.files=t.filenames.map(r=>({url:Re.isRelativePath(r)?Re.join(s,r):r,lodLevel:-1})),this.fileRefCounts=new Int32Array(this.files.length),t.environment&&(this.environmentUrl=Re.isRelativePath(t.environment)?Re.join(s,t.environment):t.environment);const i=[];this._extractLeafNodes(t.tree,i),this.nodes=i.map(r=>{const a=[];for(let o=0;o<this.lodLevels;o++){const h=r.lods[o.toString()];h?(a.push({file:this.files[h.file].url||"",fileIndex:h.file,offset:h.offset||0,count:h.count||0}),this.files[h.file].lodLevel=o):a.push({file:"",fileIndex:-1,offset:0,count:0})}return new _7(a,r.bound)})}}class oI{destroy(){this.octree?.destroy(),this.octree=null}constructor(e,t,s){this.aabb=new Ge,this.octree=new g7(e,t),this.octree.assetLoader=s,this.aabb.setMinMax(new D(t.tree.bound.min),new D(t.tree.bound.max))}}class v7{estimateTextureSize(e,t){const s=o=>{let h=0;for(const u of e)if(h+=Math.ceil(u.activeSplats/o),h>o)return!1;return!0};let i=1,r=t,a=null;for(;i<=r;){const o=Math.floor((i+r)/2);s(o)?(a=o,r=o-1):i=o+1}return a===null?(this.textureSize=0,!1):(this.textureSize=a,!0)}destroy(){this.splats.forEach(e=>e.destroy()),this.splats.length=0}assignLines(e,t){if(e.length===0){this.totalUsedPixels=0;return}let s=0;for(const i of e){const r=i.activeSplats,a=Math.ceil(r/t);i.setLines(s,a,t,r),s+=a}this.totalUsedPixels=s*t}constructor(e,t,s){this.version=0,this.sortParametersSet=!1,this.sortedBefore=!1,this.splats=[],this.textureSize=0,this.totalUsedPixels=0,this.pendingReleases=[],this.version=t,this.splats=s,this.estimateTextureSize(this.splats,e.maxTextureSize),this.assignLines(this.splats,this.textureSize)}}const S7=`
@group(0) @binding(0) var splatTexture0: texture_2d<u32>;
@group(0) @binding(1) var<storage, read_write> sortKeys: array<u32>;
struct SortKeyUniforms {
	cameraPosition: vec3f,
	elementCount: u32,
	cameraDirection: vec3f,
	numBits: u32,
	textureSize: u32,
	minDist: f32,
	invRange: f32,
	numWorkgroupsX: u32,
	numBins: u32
};
@group(0) @binding(2) var<uniform> uniforms: SortKeyUniforms;
struct BinWeight {
	base: f32,
	divider: f32
};
@group(0) @binding(3) var<storage, read> binWeights: array<BinWeight>;
@compute @workgroup_size({WORKGROUP_SIZE_X}, {WORKGROUP_SIZE_Y}, 1)
fn computeSortKey(@builtin(global_invocation_id) global_id: vec3u) {
	let gid = global_id.x + global_id.y * ({WORKGROUP_SIZE_X} * uniforms.numWorkgroupsX);
	
	if (gid >= uniforms.elementCount) {
		return;
	}
	
	let textureSize = uniforms.textureSize;
	let uv = vec2i(i32(gid % textureSize), i32(gid / textureSize));
	
	let packed = textureLoad(splatTexture0, uv, 0);
	let worldCenter = vec3f(
		bitcast<f32>(packed.r),
		bitcast<f32>(packed.g),
		bitcast<f32>(packed.b)
	);
	
	var dist: f32;
	
	#ifdef RADIAL_SORT
		let delta = worldCenter - uniforms.cameraPosition;
		let radialDist = length(delta);
		dist = (1.0 / uniforms.invRange) - radialDist - uniforms.minDist;
	#else
		let toSplat = worldCenter - uniforms.cameraPosition;
		dist = dot(toSplat, uniforms.cameraDirection) - uniforms.minDist;
	#endif
	
	let numBins = uniforms.numBins;
	let d = dist * uniforms.invRange * f32(numBins);
	let binFloat = clamp(d, 0.0, f32(numBins) - 0.001);
	let bin = u32(binFloat);
	let binFrac = binFloat - f32(bin);
	
	let sortKey = u32(binWeights[bin].base + binWeights[bin].divider * binFrac);
	
	sortKeys[gid] = sortKey;
}
`,lI=16,cI=16,y7=lI*cI,x7=new D;class T7{destroy(){this.keysBuffer?.destroy(),this.binWeightsBuffer?.destroy(),this.compute?.shader?.destroy(),this.bindGroupFormat?.destroy(),this.keysBuffer=null,this.binWeightsBuffer=null,this.compute=null,this.bindGroupFormat=null,this.uniformBufferFormat=null}_getCompute(e){if(!this.compute||this.computeRadialSort!==e){this.compute?.shader?.destroy();const t=e?"GSplatSortKeyCompute-Radial":"GSplatSortKeyCompute-Linear",s=new Map([["{WORKGROUP_SIZE_X}",`${lI}`],["{WORKGROUP_SIZE_Y}",`${cI}`]]);e&&s.set("RADIAL_SORT","");const i=new fo(this.device,{name:t,shaderLanguage:Je,cshader:S7,cdefines:s,computeEntryPoint:"computeSortKey",computeBindGroupFormat:this.bindGroupFormat,computeUniformBufferFormats:{uniforms:this.uniformBufferFormat}});this.compute=new sf(this.device,i,t),this.computeRadialSort=e}return this.compute}_createBindGroupFormat(){const e=this.device;this.uniformBufferFormat=new uo(e,[new Be("cameraPosition",Gi),new Be("elementCount",Qs),new Be("cameraDirection",Gi),new Be("numBits",Qs),new Be("textureSize",Qs),new Be("minDist",Bs),new Be("invRange",Bs),new Be("numWorkgroupsX",Qs),new Be("numBins",Qs)]),this.bindGroupFormat=new Vr(e,[new ef("splatTexture0",rs,void 0,to,!1),new Is("sortKeys",rs,!1),new io("uniforms",rs),new Is("binWeights",rs,!0)])}_ensureCapacity(e){e>this.allocatedCount&&(this.keysBuffer?.destroy(),this.allocatedCount=e,this.keysBuffer=new Fs(this.device,e*4,wa))}generate(e,t,s,i,r,a,o){this._ensureCapacity(i);const h=Math.ceil(i/y7),u=Math.min(h,this.device.limits.maxComputeWorkgroupsPerDimension||65535),f=Math.ceil(h/u),m=this._getCompute(s),_=t.getPosition(),S=t.getWorldTransform().getZ(x7).normalize(),x=o-a,T=x>0?1/x:1,E=1<<r,b=Od.computeCameraBin(s,a,x),C=this.binWeightsUtil.compute(b,E);return this.binWeightsBuffer.write(0,C),m.setParameter("splatTexture0",e.splatTexture0),m.setParameter("sortKeys",this.keysBuffer),m.setParameter("binWeights",this.binWeightsBuffer),this.cameraPositionData[0]=_.x,this.cameraPositionData[1]=_.y,this.cameraPositionData[2]=_.z,m.setParameter("cameraPosition",this.cameraPositionData),this.cameraDirectionData[0]=S.x,this.cameraDirectionData[1]=S.y,this.cameraDirectionData[2]=S.z,m.setParameter("cameraDirection",this.cameraDirectionData),m.setParameter("elementCount",i),m.setParameter("numBits",r),m.setParameter("textureSize",e.textureSize),m.setParameter("minDist",a),m.setParameter("invRange",T),m.setParameter("numWorkgroupsX",u),m.setParameter("numBins",Od.NUM_BINS),m.setupDispatch(u,f,1),this.device.computeDispatch([m],"GSplatSortKeyCompute"),this.keysBuffer}constructor(e){this.allocatedCount=0,this.keysBuffer=null,this.binWeightsBuffer=null,this.compute=null,this.computeRadialSort=!1,this.bindGroupFormat=null,this.uniformBufferFormat=null,this.cameraPositionData=new Float32Array(3),this.cameraDirectionData=new Float32Array(3),this.device=e,this.binWeightsUtil=new Od,this.binWeightsBuffer=new Fs(e,Od.NUM_BINS*2*4,wa|Ns),this._createBindGroupFormat()}}const Qc=new D,Ed=new D,CR=new D,Zo=new D,ox=new fe,Jc=new Set,lx=new Set,h_=[],u_=[],bd={rotationDelta:0,translationDelta:0},cx=new Set,DR=[[1,0,0],[0,1,0],[0,0,1],[1,1,0],[1,0,1],[0,1,1],[1,.5,0],[.5,0,1]];new ue(1,0,0),new ue(0,1,0),new ue(0,0,1),new ue(1,1,0),new ue(1,0,1),new ue(0,1,1),new ue(1,.5,0),new ue(.5,0,1);let Qo=null;class E7{setRenderMode(e){this.renderMode=e,this.renderer.setRenderMode(e)}destroy(){this._destroyed=!0;for(const[,e]of this.worldStates){for(const t of e.splats)t.resource.decRefCount();e.destroy()}this.worldStates.clear();for(const[,e]of this.octreeInstances)e.destroy();this.octreeInstances.clear();for(const e of this.octreeInstancesToDestroy)e.destroy();this.octreeInstancesToDestroy.length=0,this.workBuffer.destroy(),this.renderer.destroy(),this.keyGenerator?.destroy(),this.gpuSorter?.destroy(),this.cpuSorter?.destroy()}get material(){return this.renderer.material}createSorter(){const e=new h7(this.scene);return e.on("sorted",(t,s,i)=>{this.onSorted(t,s,i)}),e}reconcile(e){Jc.clear();for(const t of e)t.resource instanceof oI?(this.octreeInstances.has(t)||(this.octreeInstances.set(t,new p7(this.device,t.resource.octree,t)),this.hasNewOctreeInstances=!0),lx.add(t)):Jc.add(t);for(const[t,s]of this.octreeInstances)lx.has(t)||(this.octreeInstances.delete(t),this.layerPlacementsDirty=!0,this.octreeInstancesToDestroy.push(s));if(this.layerPlacementsDirty=this.layerPlacements.length!==Jc.size,!this.layerPlacementsDirty)for(let t=0;t<this.layerPlacements.length;t++){const s=this.layerPlacements[t];if(!Jc.has(s)){this.layerPlacementsDirty=!0;break}}this.layerPlacements.length=0;for(const t of Jc)this.layerPlacements.push(t);Jc.clear(),lx.clear()}updateWorldState(){if(this.layerPlacementsDirty||this.worldStates.size===0){this.lastWorldStateVersion++;const t=[],{colorUpdateAngle:s,colorUpdateDistance:i}=this.scene.gsplat;for(const a of this.layerPlacements){const o=new bR(this.device,a.resource,a);o.resetColorAccumulators(s,i),t.push(o)}for(const[,a]of this.octreeInstances)a.activePlacements.forEach(o=>{if(o.resource){const h=new bR(this.device,o.resource,o);h.resetColorAccumulators(s,i),t.push(h)}});this.cpuSorter?.updateCentersForSplats(t);const r=new v7(this.device,this.lastWorldStateVersion,t);for(const a of r.splats)a.resource.incRefCount();for(const[,a]of this.octreeInstances)if(a.removedCandidates&&a.removedCandidates.size){for(const o of a.removedCandidates)r.pendingReleases.push([a.octree,o]);a.removedCandidates.clear()}if(this.octreeInstancesToDestroy.length){for(const a of this.octreeInstancesToDestroy){const o=a.getFileDecrements();for(const h of o)r.pendingReleases.push([a.octree,h]);a.destroy()}this.octreeInstancesToDestroy.length=0}this.worldStates.set(this.lastWorldStateVersion,r),this.layerPlacementsDirty=!1,this.sortNeeded=!0}}onSorted(e,t,s){this.cleanupOldWorldStates(t),this.sortedVersion=t;const i=this.worldStates.get(t);i&&(i.sortedBefore||(i.sortedBefore=!0,this.rebuildWorkBuffer(i,e)),this.workBuffer.setOrderData(s),this.renderer.setOrderData())}rebuildWorkBuffer(e,t){const s=e.textureSize;s!==this.workBuffer.textureSize&&(this.workBuffer.resize(s),this.renderer.setMaxNumSplats(s*s)),this.workBuffer.render(e.splats,this.cameraNode,this.getDebugColors());const{colorUpdateAngle:i,colorUpdateDistance:r}=this.scene.gsplat;if(e.splats.forEach(a=>{a.update(),a.resetColorAccumulators(i,r)}),this.updateColorCameraTracking(),e.pendingReleases&&e.pendingReleases.length){const a=this.scene.gsplat.cooldownTicks;for(const[o,h]of e.pendingReleases)o.decRefCount(h,a);e.pendingReleases.length=0}this.renderer.update(t,s)}cleanupOldWorldStates(e){for(let t=this.sortedVersion;t<e;t++){const s=this.worldStates.get(t);if(s){for(const i of s.splats)i.resource.decRefCount();this.worldStates.delete(t),s.destroy()}}}applyWorkBufferUpdates(e){const{colorUpdateAngle:t,colorUpdateDistance:s,colorUpdateDistanceLodScale:i,colorUpdateAngleLodScale:r}=this.scene.gsplat,{rotationDelta:a,translationDelta:o}=this.calculateColorCameraDeltas();e.splats.forEach(h=>{if(h.update())h_.push(h),h.resetColorAccumulators(t,s),this.sortNeeded=!0;else if(h.hasSphericalHarmonics){h.colorAccumulatedRotation+=a,h.colorAccumulatedTranslation+=o;const u=h.lodIndex??0,f=s*Math.pow(i,u),m=t*Math.pow(r,u);(h.colorAccumulatedRotation>=m||h.colorAccumulatedTranslation>=f)&&(u_.push(h),h.resetColorAccumulators(m,f))}}),h_.length>0&&(this.workBuffer.render(h_,this.cameraNode,this.getDebugColors()),h_.length=0),u_.length>0&&(this.workBuffer.renderColor(u_,this.cameraNode,this.getDebugColors()),u_.length=0)}testCameraMovedForLod(){const e=this.scene.gsplat.lodUpdateDistance,t=this.cameraNode.getPosition(),s=this.lastLodCameraPos.distance(t)>e;if(s)return!0;let i=!1;const r=this.scene.gsplat.lodUpdateAngle;if(r>0)if(Number.isFinite(this.lastLodCameraFwd.x)){const a=this.cameraNode.forward,o=Math.min(1,Math.max(-1,this.lastLodCameraFwd.dot(a))),h=Math.acos(o),u=r*J.DEG_TO_RAD;i=h>u}else i=!0;return s||i}testCameraMovedForSort(){if(this.scene.gsplat.radialSorting){const t=this.cameraNode.getPosition();return this.lastSortCameraPos.distance(t)>.001}if(Number.isFinite(this.lastSortCameraFwd.x)){const t=this.cameraNode.forward,s=Math.min(1,Math.max(-1,this.lastSortCameraFwd.dot(t)));return Math.acos(s)>.001}return!0}updateColorCameraTracking(){this.lastColorUpdateCameraPos.copy(this.cameraNode.getPosition()),this.lastColorUpdateCameraFwd.copy(this.cameraNode.forward)}getDebugColors(){if(this.scene.gsplat.colorizeColorUpdate){Qo??(Qo=[]);const s=Math.random(),i=Math.random(),r=Math.random();for(let a=0;a<DR.length;a++){var e,t;(e=Qo)[t=a]??(e[t]=[0,0,0]),Qo[a][0]=s,Qo[a][1]=i,Qo[a][2]=r}return Qo}else if(this.scene.gsplat.colorizeLod)return DR}calculateColorCameraDeltas(){if(bd.rotationDelta=0,bd.translationDelta=0,isFinite(this.lastColorUpdateCameraPos.x)){const e=this.cameraNode.forward,t=Math.min(1,Math.max(-1,this.lastColorUpdateCameraFwd.dot(e)));bd.rotationDelta=Math.acos(t)*J.RAD_TO_DEG;const s=this.cameraNode.getPosition();bd.translationDelta=this.lastColorUpdateCameraPos.distance(s)}return bd}fireFrameReadyEvent(){const e=this.sortedVersion===this.lastWorldStateVersion;let t=0;for(const[,s]of this.octreeInstances)t+=s.pendingLoadCount;this.director.eventHandler.fire("frame:ready",this.cameraNode.camera,this.renderer.layer,e,t)}update(){this.cpuSorter&&this.cpuSorter.applyPendingSorted();const e=this.useGpuSorting||this.cpuSorter&&this.cpuSorter.jobsInFlight<3;let t=!1;this.framesTillFullUpdate--,this.framesTillFullUpdate<=0&&(this.framesTillFullUpdate=10,e&&(t=!0));const s=this.hasNewOctreeInstances&&e;s&&(this.hasNewOctreeInstances=!1);let i=!1,r=!1,a=!1;if(t){for(const[,m]of this.octreeInstances){const _=m.update(this.scene);this.layerPlacementsDirty||(this.layerPlacementsDirty=_);const g=m.consumeNeedsLodUpdate();i||(i=g)}const f=this.scene.gsplat.lodUpdateDistance;for(const[,m]of this.octreeInstances){const _=m.testMoved(f);r||(r=_)}a=this.testCameraMovedForLod()}if(this.testCameraMovedForSort()&&(this.sortNeeded=!0),this.scene.gsplat.dirty&&(this.layerPlacementsDirty=!0,this.renderer.updateOverdrawMode(this.scene.gsplat)),a||r||this.scene.gsplat.dirty||i||s){for(const[,f]of this.octreeInstances)f.updateMoved();this.lastLodCameraPos.copy(this.cameraNode.getPosition()),this.lastLodCameraFwd.copy(this.cameraNode.forward);for(const[,f]of this.octreeInstances)f.updateLod(this.cameraNode,this.scene.gsplat)}this.updateWorldState();const o=this.worldStates.get(this.lastWorldStateVersion);if(o&&this.cpuSorter&&!o.sortParametersSet){o.sortParametersSet=!0;const f=this.prepareSortParameters(o);this.cpuSorter.setSortParameters(f)}const h=this.worldStates.get(this.sortedVersion);if(h&&this.applyWorkBufferUpdates(h),this.sortNeeded&&o&&(this.useGpuSorting?this.sortGpu(o):this.sortCpu(o),this.sortNeeded=!1,this.lastSortCameraPos.copy(this.cameraNode.getPosition()),this.lastSortCameraFwd.copy(this.cameraNode.forward)),h&&(this.renderer.frameUpdate(this.scene.gsplat),this.updateColorCameraTracking()),this.octreeInstances.size){const f=this.scene.gsplat.cooldownTicks;for(const[,m]of this.octreeInstances){const _=m.octree;cx.has(_)||(cx.add(_),_.updateCooldownTick(f))}cx.clear()}this.fireFrameReadyEvent();const{textureSize:u}=this.workBuffer;return u*u}sortGpu(e){const t=this.keyGenerator,s=this.gpuSorter;if(!t||!s)return;const i=e.totalUsedPixels;if(i===0)return;e.sortedBefore||(e.sortedBefore=!0,this.rebuildWorkBuffer(e,i),this.cleanupOldWorldStates(e.version),this.sortedVersion=e.version);const r=Math.max(10,Math.min(20,Math.round(Math.log2(i/4)))),a=Math.ceil(r/4)*4,{minDist:o,maxDist:h}=this.computeDistanceRange(e),u=t.generate(this.workBuffer,this.cameraNode,this.scene.gsplat.radialSorting,i,a,o,h),f=s.sort(u,i,a);this.renderer.setOrderBuffer(f),this.renderer.update(i,e.textureSize)}computeDistanceRange(e){const s=this.cameraNode.getWorldTransform();s.getTranslation(Qc),s.getZ(Ed).normalize();const i=this.scene.gsplat.radialSorting;let r=i?0:1/0,a=i?0:-1/0;for(const o of e.splats){const h=o.node.getWorldTransform(),u=o.aabb.getMin(),f=o.aabb.getMax();for(let m=0;m<8;m++)if(Zo.x=m&1?f.x:u.x,Zo.y=m&2?f.y:u.y,Zo.z=m&4?f.z:u.z,h.transformPoint(Zo,Zo),i){const _=Zo.distance(Qc);_>a&&(a=_)}else{const _=Zo.sub(Qc).dot(Ed);_<r&&(r=_),_>a&&(a=_)}}return a===0||a===-1/0?{minDist:0,maxDist:1}:{minDist:r,maxDist:a}}sortCpu(e){if(!this.cpuSorter)return;const s=this.cameraNode.getWorldTransform();s.getTranslation(Qc),s.getZ(Ed).normalize();const i=[];e.splats.forEach(r=>{const a=r.node.getWorldTransform();ox.copy(a).invert();const o=a.getScale().x,h=ox.transformVector(Ed).normalize(),u=ox.transformPoint(Qc);a.getTranslation(CR);const f=CR.sub(Qc).dot(Ed),m=r.aabb.getMin(),_=r.aabb.getMax();i.push({transformedDirection:h,transformedPosition:u,offset:f,scale:o,modelMat:a.data.slice(),aabbMin:[m.x,m.y,m.z],aabbMax:[_.x,_.y,_.z]})}),this.cpuSorter.setSortParams(i,this.scene.gsplat.radialSorting)}prepareSortParameters(e){return{command:"intervals",textureSize:e.textureSize,totalUsedPixels:e.totalUsedPixels,version:e.version,ids:e.splats.map(t=>t.resource.id),lineStarts:e.splats.map(t=>t.lineStart),padding:e.splats.map(t=>t.padding),intervals:e.splats.map(t=>t.intervals)}}constructor(e,t,s,i){this.node=new Dt("GSplatManager"),this.worldStates=new Map,this.lastWorldStateVersion=0,this.useGpuSorting=!1,this.cpuSorter=null,this.keyGenerator=null,this.gpuSorter=null,this.sortedVersion=0,this.framesTillFullUpdate=0,this.lastLodCameraPos=new D(1/0,1/0,1/0),this.lastLodCameraFwd=new D(1/0,1/0,1/0),this.lastSortCameraPos=new D(1/0,1/0,1/0),this.lastSortCameraFwd=new D(1/0,1/0,1/0),this.sortNeeded=!0,this.lastColorUpdateCameraPos=new D(1/0,1/0,1/0),this.lastColorUpdateCameraFwd=new D(1/0,1/0,1/0),this.layerPlacements=[],this.layerPlacementsDirty=!1,this.octreeInstances=new Map,this.octreeInstancesToDestroy=[],this.hasNewOctreeInstances=!1,this.device=e,this.scene=t.scene,this.director=t,this.cameraNode=i,this.workBuffer=new lH(e),this.renderer=new u7(e,this.node,this.cameraNode,s,this.workBuffer),this.useGpuSorting=e.isWebGPU&&t.scene.gsplat.gpuSorting,this.useGpuSorting?(this.keyGenerator=new T7(e),this.gpuSorter=new FG(e)):this.cpuSorter=this.createSorter()}}class b7{static equals(e,t){if(e.size!==t.size)return!1;for(const s of e)if(!t.has(s))return!1;return!0}}const d_=[];class A7{createManager(e,t,s,i,r,a){const o=new E7(e,t,s,i);return o.setRenderMode(a),t.eventHandler&&t.eventHandler.fire("material:created",o.material,r,s),o}updateConfiguration(e,t,s,i){const r=i.node,a=s.gsplatPlacements.length>0,o=s.gsplatShadowCasters.length>0,u=b7.equals(s.gsplatPlacementsSet,s.gsplatShadowCastersSet)&&a,f=u?ch|hh:a?ch:0,m=u?0:o?hh:0;f?this.gsplatManager?this.gsplatManager.setRenderMode(f):this.gsplatManager=this.createManager(e,t,s,r,i,f):this.gsplatManager&&(this.gsplatManager.destroy(),this.gsplatManager=null),m?this.gsplatManagerShadow?this.gsplatManagerShadow.setRenderMode(m):this.gsplatManagerShadow=this.createManager(e,t,s,r,i,m):this.gsplatManagerShadow&&(this.gsplatManagerShadow.destroy(),this.gsplatManagerShadow=null)}destroy(){this.gsplatManager?.destroy(),this.gsplatManager=null,this.gsplatManagerShadow?.destroy(),this.gsplatManagerShadow=null}constructor(e,t,s,i){this.gsplatManager=null,this.gsplatManagerShadow=null,this.updateConfiguration(e,t,s,i)}}class w7{destroy(){this.layersMap.forEach(e=>e.destroy()),this.layersMap.clear()}removeLayerData(e){const t=this.layersMap.get(e);t&&(t.destroy(),this.layersMap.delete(e))}getLayerData(e,t,s,i){let r=this.layersMap.get(s);return r||(r=new A7(e,t,s,i),this.layersMap.set(s,r)),r}constructor(){this.layersMap=new Map}}class C7{destroy(){this.camerasMap.forEach(e=>e.destroy()),this.camerasMap.clear()}getCameraData(e){let t=this.camerasMap.get(e);return t||(t=new w7,this.camerasMap.set(e,t)),t}update(e){this.camerasMap.forEach((i,r)=>{if(!e.camerasSet.has(r))i.destroy(),this.camerasMap.delete(r);else{i.layersMap.forEach((a,o)=>{(!r.layersSet.has(o.id)||!o.enabled)&&d_.push(o)});for(let a=0;a<d_.length;a++){const o=d_[a],h=i.layersMap.get(o);h&&(h.destroy(),i.layersMap.delete(o))}d_.length=0}});let t=0;const s=e.cameras;for(let i=0;i<s.length;i++){const r=s[i].camera;let a=this.camerasMap.get(r);const o=r.layers;for(let h=0;h<o.length;h++){const u=e.getLayerById(o[h]);if(u?.enabled&&(u.gsplatPlacementsDirty||!a)){const f=u.gsplatPlacements.length>0,m=u.gsplatShadowCasters.length>0;if(!f&&!m)a&&a.removeLayerData(u);else{a??(a=this.getCameraData(r));const _=a.getLayerData(this.device,this,u,r);_.updateConfiguration(this.device,this,u,r),_.gsplatManager&&_.gsplatManager.reconcile(u.gsplatPlacements),_.gsplatManagerShadow&&_.gsplatManagerShadow.reconcile(u.gsplatShadowCasters)}}}if(a)for(const h of a.layersMap.values())h.gsplatManager&&(t+=h.gsplatManager.update()),h.gsplatManagerShadow&&(t+=h.gsplatManagerShadow.update())}this.renderer._gsplatCount=t,this.scene.gsplat.frameEnd();for(let i=0;i<e.layerList.length;i++)e.layerList[i].gsplatPlacementsDirty=!1}constructor(e,t,s,i){this.camerasMap=new Map,this.device=e,this.renderer=t,this.scene=s,this.eventHandler=i}}class hI extends ke{set customAabb(e){this._customAabb=e,this._instance?.meshInstance?.setCustomAabb(this._customAabb),this._placement&&this._customAabb&&(this._placement.aabb=this._customAabb)}get customAabb(){return this._customAabb}set instance(e){if(!this.unified&&(this.destroyInstance(),this._instance=e,this._instance)){const t=this._instance.meshInstance;t.node||(t.node=this.entity),t.castShadow=this._castShadows,t.setCustomAabb(this._customAabb),this.enabled&&this.entity.enabled&&this.addToLayers()}}get instance(){return this._instance}set material(e){this.unified||(this._instance?this._instance.material=e:this._materialTmp=e)}get material(){return this.unified?null:this._instance?.material??this._materialTmp??null}set highQualitySH(e){e!==this._highQualitySH&&(this._highQualitySH=e,this._instance?.setHighQualitySH(e))}get highQualitySH(){return this._highQualitySH}set castShadows(e){if(this._castShadows!==e){const t=this.layers,s=this.system.app.scene;if(this._placement)if(e)for(let r=0;r<t.length;r++)s.layers.getLayerById(t[r])?.addGSplatShadowCaster(this._placement);else for(let r=0;r<t.length;r++)s.layers.getLayerById(t[r])?.removeGSplatShadowCaster(this._placement);const i=this.instance?.meshInstance;if(i){if(this._castShadows&&!e)for(let r=0;r<t.length;r++)s.layers.getLayerById(this.layers[r])?.removeShadowCasters([i]);if(i.castShadow=e,!this._castShadows&&e)for(let r=0;r<t.length;r++)s.layers.getLayerById(t[r])?.addShadowCasters([i])}this._castShadows=e}}get castShadows(){return this._castShadows}set lodDistances(e){this._lodDistances=Array.isArray(e)?e.slice():null,this._placement&&(this._placement.lodDistances=this._lodDistances)}get lodDistances(){return this._lodDistances?this._lodDistances.slice():null}set splatBudget(e){this._splatBudget=e,this._placement&&(this._placement.splatBudget=this._splatBudget)}get splatBudget(){return this._splatBudget}set unified(e){this._unified!==e&&(this._unified=e,this._onGSplatAssetAdded())}get unified(){return this._unified}set layers(e){this.removeFromLayers(),this._layers.length=0;for(let t=0;t<e.length;t++)this._layers[t]=e[t];!this.enabled||!this.entity.enabled||this.addToLayers()}get layers(){return this._layers}set asset(e){const t=e instanceof Ee?e.id:e;this._assetReference.id!==t&&(this._assetReference.asset&&this._assetReference.asset.resource&&this._onGSplatAssetRemove(),this._assetReference.id=t,this._assetReference.asset&&this._onGSplatAssetAdded())}get asset(){return this._assetReference.id}destroyInstance(){this._placement&&(this.removeFromLayers(),this._placement=null),this._instance&&(this.removeFromLayers(),this._instance?.destroy(),this._instance=null)}addToLayers(){if(this._placement){const t=this.system.app.scene.layers;for(let s=0;s<this._layers.length;s++){const i=t.getLayerById(this._layers[s]);i&&(i.addGSplatPlacement(this._placement),this._castShadows&&i.addGSplatShadowCaster(this._placement))}return}const e=this.instance?.meshInstance;if(e){const t=this.system.app.scene.layers;for(let s=0;s<this._layers.length;s++)t.getLayerById(this._layers[s])?.addMeshInstances([e])}}removeFromLayers(){if(this._placement){const t=this.system.app.scene.layers;for(let s=0;s<this._layers.length;s++){const i=t.getLayerById(this._layers[s]);i&&(i.removeGSplatPlacement(this._placement),i.removeGSplatShadowCaster(this._placement))}return}const e=this.instance?.meshInstance;if(e){const t=this.system.app.scene.layers;for(let s=0;s<this._layers.length;s++)t.getLayerById(this._layers[s])?.removeMeshInstances([e])}}onRemoveChild(){this.removeFromLayers()}onInsertChild(){this.enabled&&this.entity.enabled&&(this._instance||this._placement)&&this.addToLayers()}onRemove(){this.destroyInstance(),this.asset=null,this._assetReference.id=null,this.entity.off("remove",this.onRemoveChild,this),this.entity.off("insert",this.onInsertChild,this)}onLayersChanged(e,t){this.addToLayers(),e.off("add",this.onLayerAdded,this),e.off("remove",this.onLayerRemoved,this),t.on("add",this.onLayerAdded,this),t.on("remove",this.onLayerRemoved,this)}onLayerAdded(e){this.layers.indexOf(e.id)<0||this.unified||this._instance&&e.addMeshInstances(this._instance.meshInstance)}onLayerRemoved(e){this.layers.indexOf(e.id)<0||this.unified||this._instance&&e.removeMeshInstances(this._instance.meshInstance)}onEnable(){const e=this.system.app.scene,t=e.layers;this._evtLayersChanged=e.on("set:layers",this.onLayersChanged,this),t&&(this._evtLayerAdded=t.on("add",this.onLayerAdded,this),this._evtLayerRemoved=t.on("remove",this.onLayerRemoved,this)),this._instance||this._placement?this.addToLayers():this.asset&&this._onGSplatAssetAdded()}onDisable(){const t=this.system.app.scene.layers;this._evtLayersChanged?.off(),this._evtLayersChanged=null,t&&(this._evtLayerAdded?.off(),this._evtLayerAdded=null,this._evtLayerRemoved?.off(),this._evtLayerRemoved=null),this.removeFromLayers()}hide(){this._instance&&(this._instance.meshInstance.visible=!1)}show(){this._instance&&(this._instance.meshInstance.visible=!0)}_onGSplatAssetAdded(){this._assetReference.asset&&(this._assetReference.asset.resource?this._onGSplatAssetLoad():this.enabled&&this.entity.enabled&&this.system.app.assets.load(this._assetReference.asset))}_onGSplatAssetLoad(){this.destroyInstance();const e=this._assetReference.asset;this.unified?(this._placement=null,e&&(this._placement=new CT(e.resource,this.entity),this._placement.lodDistances=this._lodDistances,this._placement.splatBudget=this._splatBudget,this.enabled&&this.entity.enabled&&this.addToLayers())):e&&(this.instance=new _L(e.resource,{material:this._materialTmp,highQualitySH:this._highQualitySH,scene:this.system.app.scene}),this._materialTmp=null),e&&(this.customAabb=e.resource.aabb.clone())}_onGSplatAssetUnload(){this.destroyInstance()}_onGSplatAssetRemove(){this._onGSplatAssetUnload()}constructor(e,t){super(e,t),this._layers=[sn],this._instance=null,this._placement=null,this._materialTmp=null,this._highQualitySH=!0,this._lodDistances=[5,10,15,20,25,30,35,40,45,50,55,60],this._splatBudget=0,this._customAabb=null,this._evtLayersChanged=null,this._evtLayerAdded=null,this._evtLayerRemoved=null,this._castShadows=!1,this._unified=!1,this._assetReference=new _f("asset",this,e.app.assets,{add:this._onGSplatAssetAdded,load:this._onGSplatAssetLoad,remove:this._onGSplatAssetRemove,unload:this._onGSplatAssetUnload},this),t.on("remove",this.onRemoveChild,this),t.on("removehierarchy",this.onRemoveChild,this),t.on("insert",this.onInsertChild,this),t.on("inserthierarchy",this.onInsertChild,this)}}class D7{constructor(){this.enabled=!0}}var P7=`
uniform mat4 matrix_model;
uniform mat4 matrix_view;
#ifndef GSPLAT_CENTER_NOPROJ
	uniform vec4 camera_params;
	uniform mat4 matrix_projection;
#endif
bool initCenter(vec3 modelCenter, inout SplatCenter center) {
	mat4 modelView = matrix_view * matrix_model;
	vec4 centerView = modelView * vec4(modelCenter, 1.0);
	#ifndef GSPLAT_CENTER_NOPROJ
		if (camera_params.w != 1.0 && centerView.z > 0.0) {
			return false;
		}
		vec4 centerProj = matrix_projection * centerView;
		#if WEBGPU
			centerProj.z = clamp(centerProj.z, 0, abs(centerProj.w));
		#else
			centerProj.z = clamp(centerProj.z, -abs(centerProj.w), abs(centerProj.w));
		#endif
		center.proj = centerProj;
		center.projMat00 = matrix_projection[0][0];
	#endif
	center.view = centerView.xyz / centerView.w;
	center.modelView = modelView;
	return true;
}
`,R7=`
uniform mediump sampler2D splatColor;
vec4 readColor(in SplatSource source) {
	return texelFetch(splatColor, source.uv, 0);
}
`,M7=`
#include "gsplatHelpersVS"
#include "gsplatCustomizeVS"
#include "gsplatModifyVS"
#include "gsplatStructsVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatSourceFormatVS"
#include "gsplatSourceVS"
#include "gsplatCenterVS"
#include "gsplatCornerVS"
#include "gsplatOutputVS"
void clipCorner(inout SplatCorner corner, float alpha) {
	float clip = min(1.0, sqrt(-log(1.0 / (255.0 * alpha))) / 2.0);
	corner.offset *= clip;
	corner.uv *= clip;
}
`,L7=`
#include "gsplatPackingPS"
uniform highp usampler2D packedTexture;
uniform highp sampler2D chunkTexture;
vec4 chunkDataA;
vec4 chunkDataB;
vec4 chunkDataC;
vec4 chunkDataD;
vec4 chunkDataE;
uvec4 packedData;
vec3 unpack111011(uint bits) {
	return vec3(
		float(bits >> 21u) / 2047.0,
		float((bits >> 11u) & 0x3ffu) / 1023.0,
		float(bits & 0x7ffu) / 2047.0
	);
}
const float norm = sqrt(2.0);
vec4 unpackRotation(uint bits) {
	float a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;
	float b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;
	float c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;
	float m = sqrt(1.0 - (a * a + b * b + c * c));
	uint mode = bits >> 30u;
	if (mode == 0u) return vec4(m, a, b, c);
	if (mode == 1u) return vec4(a, m, b, c);
	if (mode == 2u) return vec4(a, b, m, c);
	return vec4(a, b, c, m);
}
vec3 readCenter(SplatSource source) {
	uint w = uint(textureSize(chunkTexture, 0).x) / 5u;
	uint chunkId = source.id / 256u;
	ivec2 chunkUV = ivec2((chunkId % w) * 5u, chunkId / w);
	chunkDataA = texelFetch(chunkTexture, chunkUV, 0);
	chunkDataB = texelFetch(chunkTexture, chunkUV + ivec2(1, 0), 0);
	chunkDataC = texelFetch(chunkTexture, chunkUV + ivec2(2, 0), 0);
	chunkDataD = texelFetch(chunkTexture, chunkUV + ivec2(3, 0), 0);
	chunkDataE = texelFetch(chunkTexture, chunkUV + ivec2(4, 0), 0);
	packedData = texelFetch(packedTexture, source.uv, 0);
	return mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));
}
vec4 readColor(in SplatSource source) {
	vec4 r = unpack8888(packedData.w);
	return vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);
}
vec4 getRotation() {
	return unpackRotation(packedData.y);
}
vec3 getScale() {
	return exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));
}
`,I7=`
#if SH_BANDS > 0
uniform highp usampler2D shTexture0;
uniform highp usampler2D shTexture1;
uniform highp usampler2D shTexture2;
vec4 unpack8888s(in uint bits) {
	return vec4((uvec4(bits) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu) * (8.0 / 255.0) - 4.0;
}
void readSHData(in SplatSource source, out vec3 sh[15], out float scale) {
	uvec4 shData0 = texelFetch(shTexture0, source.uv, 0);
	uvec4 shData1 = texelFetch(shTexture1, source.uv, 0);
	uvec4 shData2 = texelFetch(shTexture2, source.uv, 0);
	vec4 r0 = unpack8888s(shData0.x);
	vec4 r1 = unpack8888s(shData0.y);
	vec4 r2 = unpack8888s(shData0.z);
	vec4 r3 = unpack8888s(shData0.w);
	vec4 g0 = unpack8888s(shData1.x);
	vec4 g1 = unpack8888s(shData1.y);
	vec4 g2 = unpack8888s(shData1.z);
	vec4 g3 = unpack8888s(shData1.w);
	vec4 b0 = unpack8888s(shData2.x);
	vec4 b1 = unpack8888s(shData2.y);
	vec4 b2 = unpack8888s(shData2.z);
	vec4 b3 = unpack8888s(shData2.w);
	sh[0] =  vec3(r0.x, g0.x, b0.x);
	sh[1] =  vec3(r0.y, g0.y, b0.y);
	sh[2] =  vec3(r0.z, g0.z, b0.z);
	sh[3] =  vec3(r0.w, g0.w, b0.w);
	sh[4] =  vec3(r1.x, g1.x, b1.x);
	sh[5] =  vec3(r1.y, g1.y, b1.y);
	sh[6] =  vec3(r1.z, g1.z, b1.z);
	sh[7] =  vec3(r1.w, g1.w, b1.w);
	sh[8] =  vec3(r2.x, g2.x, b2.x);
	sh[9] =  vec3(r2.y, g2.y, b2.y);
	sh[10] = vec3(r2.z, g2.z, b2.z);
	sh[11] = vec3(r2.w, g2.w, b2.w);
	sh[12] = vec3(r3.x, g3.x, b3.x);
	sh[13] = vec3(r3.y, g3.y, b3.y);
	sh[14] = vec3(r3.z, g3.z, b3.z);
	scale = 1.0;
}
#endif
`,O7=`
void modifyCenter(inout vec3 center) {
}
void modifyCovariance(vec3 originalCenter, vec3 modifiedCenter, inout vec3 covA, inout vec3 covB) {
}
void modifyColor(vec3 center, inout vec4 color) {
}
`,N7=`
	#if SH_BANDS == 1
		#define SH_COEFFS 3
	#elif SH_BANDS == 2
		#define SH_COEFFS 8
	#elif SH_BANDS == 3
		#define SH_COEFFS 15
	#else
		#define SH_COEFFS 0
	#endif
	#if SH_BANDS > 0
	const float SH_C1 = 0.4886025119029199f;
	#if SH_BANDS > 1
		const float SH_C2_0 = 1.0925484305920792f;
		const float SH_C2_1 = -1.0925484305920792f;
		const float SH_C2_2 = 0.31539156525252005f;
		const float SH_C2_3 = -1.0925484305920792f;
		const float SH_C2_4 = 0.5462742152960396f;
	#endif
	#if SH_BANDS > 2
		const float SH_C3_0 = -0.5900435899266435f;
		const float SH_C3_1 = 2.890611442640554f;
		const float SH_C3_2 = -0.4570457994644658f;
		const float SH_C3_3 = 0.3731763325901154f;
		const float SH_C3_4 = -0.4570457994644658f;
		const float SH_C3_5 = 1.445305721320277f;
		const float SH_C3_6 = -0.5900435899266435f;
	#endif
	vec3 evalSH(in vec3 sh[SH_COEFFS], in vec3 dir) {
		float x = dir.x;
		float y = dir.y;
		float z = dir.z;
		vec3 result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);
		#if SH_BANDS > 1
			float xx = x * x;
			float yy = y * y;
			float zz = z * z;
			float xy = x * y;
			float yz = y * z;
			float xz = x * z;
			result +=
				sh[3] * (SH_C2_0 * xy) +
				sh[4] * (SH_C2_1 * yz) +
				sh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +
				sh[6] * (SH_C2_3 * xz) +
				sh[7] * (SH_C2_4 * (xx - yy));
		#endif
		#if SH_BANDS > 2
			result +=
				sh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +
				sh[9]  * (SH_C3_1 * xy * z) +
				sh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +
				sh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +
				sh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +
				sh[13] * (SH_C3_5 * z * (xx - yy)) +
				sh[14] * (SH_C3_6 * x * (xx - 3.0 * yy));
		#endif
		return result;
	}
	#endif
`,F7=`
float gsplatExtractSize(vec3 covA, vec3 covB) {
	float tr = covA.x + covB.x + covB.z;
	return sqrt(max(tr, 0.0) / 3.0);
}
void gsplatApplyUniformScale(inout vec3 covA, inout vec3 covB, float scale) {
	float s2 = scale * scale;
	covA *= s2;
	covB *= s2;
}
void gsplatMakeRound(inout vec3 covA, inout vec3 covB, float size) {
	float s2 = size * size;
	covA = vec3(s2, 0.0, 0.0);
	covB = vec3(s2, 0.0, s2);
}
void gsplatMakeSpherical(inout vec3 scale, float size) {
	scale = vec3(size);
}
float gsplatGetSizeFromScale(vec3 scale) {
	return sqrt((scale.x * scale.x + scale.y * scale.y + scale.z * scale.z) / 3.0);
}
`,B7=`
void modifySplatCenter(inout vec3 center) {
}
void modifySplatRotationScale(vec3 originalCenter, vec3 modifiedCenter, inout vec4 rotation, inout vec3 scale) {
}
void modifySplatColor(vec3 center, inout vec4 color) {
}
`,U7=`
mat3 quatToMat3(vec4 R) {
	vec4 R2 = R + R;
	float X = R2.x * R.w;
	vec4 Y  = R2.y * R;
	vec4 Z  = R2.z * R;
	float W = R2.w * R.w;
	return mat3(
		1.0 - Z.z - W,
			  Y.z + X,
			  Y.w - Z.x,
			  Y.z - X,
		1.0 - Y.y - W,
			  Z.w + Y.x,
			  Y.w + Z.x,
			  Z.w - Y.x,
		1.0 - Y.y - Z.z
	);
}
vec4 quatMul(vec4 a, vec4 b) {
	return vec4(
		a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
		a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
		a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
		a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
	);
}
`,z7=`
uniform highp sampler2D packedSh0;
uniform float sh0_mins;
uniform float sh0_maxs;
const float SH_C0 = 0.28209479177387814;
vec4 readColor(in SplatSource source) {
	vec3 clr = mix(vec3(sh0_mins), vec3(sh0_maxs), unpack111110(pack8888(texelFetch(packedSh0, source.uv, 0))));
	float alpha = float(packedSample.z & 0xffu) / 255.0;
	return vec4(vec3(0.5) + clr.xyz * SH_C0, alpha);
}
`,k7=`
#include "gsplatPackingPS"
uniform highp usampler2D packedTexture;
uniform vec3 means_mins;
uniform vec3 means_maxs;
uniform float scales_mins;
uniform float scales_maxs;
uvec4 packedSample;
vec3 readCenter(SplatSource source) {
	packedSample = texelFetch(packedTexture, source.uv, 0);
	vec3 l = unpack8888(packedSample.x).xyz;
	vec3 u = unpack8888(packedSample.y).xyz;
	vec3 n = (l + u * 256.0) / 257.0;
	vec3 v = mix(means_mins, means_maxs, n);
	return sign(v) * (exp(abs(v)) - 1.0);
}
const float norm = sqrt(2.0);
vec4 getRotation() {
	vec3 qdata = unpack8888(packedSample.z).xyz;
	uint qmode = packedSample.w & 0x3u;
	vec3 abc = (qdata - 0.5) * norm;
	float d = sqrt(max(0.0, 1.0 - dot(abc, abc)));
	return (qmode == 0u) ? vec4(d, abc) :
		   ((qmode == 1u) ? vec4(abc.x, d, abc.yz) :
		   ((qmode == 2u) ? vec4(abc.xy, d, abc.z) : vec4(abc, d)));
}
vec3 getScale() {
	vec3 sdata = unpack101010(packedSample.w >> 2u);
	return exp(mix(vec3(scales_mins), vec3(scales_maxs), sdata));
}
`,V7=`
uniform highp sampler2D packedShN;
uniform float shN_mins;
uniform float shN_maxs;
void readSHData(in SplatSource source, out vec3 sh[SH_COEFFS], out float scale) {
	ivec2 t = ivec2(packedSample.xy & 255u);
	int n = t.x + t.y * 256;
	int u = (n % 64) * SH_COEFFS;
	int v = n / 64;
	for (int i = 0; i < SH_COEFFS; i++) {
		sh[i] = mix(vec3(shN_mins), vec3(shN_maxs), unpack111110(pack8888(texelFetch(packedShN, ivec2(u + i, v), 0))));
	}
	scale = 1.0;
}
`,G7=`
#if defined(GSPLAT_WORKBUFFER_DATA)
	#include "gsplatWorkBufferVS"
#elif GSPLAT_COMPRESSED_DATA == true
	#include "gsplatCompressedDataVS"
	#if SH_COEFFS > 0
		#include "gsplatCompressedSHVS"
	#endif
#elif GSPLAT_SOGS_DATA == true
	#include "gsplatSogsDataVS"
	#include "gsplatSogsColorVS"
	#if SH_COEFFS > 0
		#include "gsplatSogsSHVS"
	#endif
#else
	#include "gsplatDataVS"
	#include "gsplatColorVS"
	#if SH_COEFFS > 0
		#include "gsplatSHVS"
	#endif
#endif
`,H7=`
struct SplatSource {
	uint order;
	uint id;
	ivec2 uv;
	vec2 cornerUV;
};
struct SplatCenter {
	vec3 view;
	vec4 proj;
	mat4 modelView;
	float projMat00;
	vec3 modelCenterOriginal;
	vec3 modelCenterModified;
};
struct SplatCorner {
	vec2 offset;
	vec2 uv;
	#if GSPLAT_AA
		float aaFactor;
	#endif
	vec2 v;
	float dlen;
};
`,W7=`
uniform vec4 viewport_size;
void computeCovariance(vec4 rotation, vec3 scale, out vec3 covA, out vec3 covB) {
	mat3 rot = quatToMat3(rotation);
	mat3 M = transpose(mat3(
		scale.x * rot[0],
		scale.y * rot[1],
		scale.z * rot[2]
	));
	covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));
	covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));
}
bool initCornerCov(SplatSource source, SplatCenter center, out SplatCorner corner, vec3 covA, vec3 covB) {
	mat3 Vrk = mat3(
		covA.x, covA.y, covA.z, 
		covA.y, covB.x, covB.y,
		covA.z, covB.y, covB.z
	);
	float focal = viewport_size.x * center.projMat00;
	vec3 v = camera_params.w == 1.0 ? vec3(0.0, 0.0, 1.0) : center.view.xyz;
	float J1 = focal / v.z;
	vec2 J2 = -J1 / v.z * v.xy;
	mat3 J = mat3(
		J1, 0.0, J2.x, 
		0.0, J1, J2.y, 
		0.0, 0.0, 0.0
	);
	mat3 W = transpose(mat3(center.modelView));
	mat3 T = W * J;
	mat3 cov = transpose(T) * Vrk * T;
	#if GSPLAT_AA
		float detOrig = cov[0][0] * cov[1][1] - cov[0][1] * cov[0][1];
		float detBlur = (cov[0][0] + 0.3) * (cov[1][1] + 0.3) - cov[0][1] * cov[0][1];
		corner.aaFactor = sqrt(max(detOrig / detBlur, 0.0));
	#endif
	float diagonal1 = cov[0][0] + 0.3;
	float offDiagonal = cov[0][1];
	float diagonal2 = cov[1][1] + 0.3;
	float mid = 0.5 * (diagonal1 + diagonal2);
	float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));
	float lambda1 = mid + radius;
	float lambda2 = max(mid - radius, 0.1);
	float vmin = min(1024.0, min(viewport_size.x, viewport_size.y));
	float l1 = 2.0 * min(sqrt(2.0 * lambda1), vmin);
	float l2 = 2.0 * min(sqrt(2.0 * lambda2), vmin);
	if (l1 < 2.0 && l2 < 2.0) {
		return false;
	}
	vec2 c = center.proj.ww * viewport_size.zw;
	if (any(greaterThan(abs(center.proj.xy) - vec2(max(l1, l2)) * c, center.proj.ww))) {
		return false;
	}
	vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));
	vec2 v1 = l1 * diagonalVector;
	vec2 v2 = l2 * vec2(diagonalVector.y, -diagonalVector.x);
	corner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) * c;
	corner.uv = source.cornerUV;
	return true;
}
bool initCorner(SplatSource source, SplatCenter center, out SplatCorner corner) {
	vec4 rotation = getRotation().yzwx;
	vec3 scale = getScale();
	modifySplatRotationScale(center.modelCenterOriginal, center.modelCenterModified, rotation, scale);
	vec3 covA, covB;
	computeCovariance(rotation.wxyz, scale, covA, covB);
	modifyCovariance(center.modelCenterOriginal, center.modelCenterModified, covA, covB);
	return initCornerCov(source, center, corner, covA, covB);
}
`,X7=`
uniform highp usampler2D transformA;
uniform highp sampler2D transformB;
uint tAw;
vec4 tBcached;
vec3 readCenter(SplatSource source) {
	uvec4 tA = texelFetch(transformA, source.uv, 0);
	tAw = tA.w;
	tBcached = texelFetch(transformB, source.uv, 0);
	return uintBitsToFloat(tA.xyz);
}
vec4 unpackRotation(vec3 packed) {
	return vec4(packed.xyz, sqrt(max(0.0, 1.0 - dot(packed, packed))));
}
vec4 getRotation() {
	return unpackRotation(vec3(unpackHalf2x16(tAw), tBcached.w)).wxyz;
}
vec3 getScale() {
	return tBcached.xyz;
}
`,q7=`
#include "tonemappingPS"
#include "decodePS"
#include "gammaPS"
vec3 prepareOutputFromGamma(vec3 gammaColor) {
	#if TONEMAP == NONE
		#if GAMMA == NONE
			return decodeGamma(gammaColor);
		#else
			return gammaColor;
		#endif
	#else
		return gammaCorrectOutput(toneMap(decodeGamma(gammaColor)));
	#endif
}
`,Y7=`
#ifndef DITHER_NONE
	#include "bayerPS"
	#include "opacityDitherPS"
	varying float id;
#endif
#if defined(SHADOW_PASS) || defined(PICK_PASS) || defined(PREPASS_PASS)
	uniform float alphaClip;
#endif
#ifdef PREPASS_PASS
	varying float vLinearDepth;
	#include "floatAsUintPS"
#endif
varying mediump vec2 gaussianUV;
varying mediump vec4 gaussianColor;
#ifdef PICK_PASS
	#include "pickPS"
#endif
const float EXP4 = exp(-4.0);
const float INV_EXP4 = 1.0 / (1.0 - EXP4);
float normExp(float x) {
	return (exp(x * -4.0) - EXP4) * INV_EXP4;
}
void main(void) {
	mediump float A = dot(gaussianUV, gaussianUV);
	if (A > 1.0) {
		discard;
	}
	mediump float alpha = normExp(A) * gaussianColor.a;
	#if defined(SHADOW_PASS) || defined(PICK_PASS) || defined(PREPASS_PASS)
		if (alpha < alphaClip) {
			discard;
		}
	#endif
	#ifdef PICK_PASS
		pcFragColor0 = getPickOutput();
		#ifdef DEPTH_PICK_PASS
			pcFragColor1 = getPickDepth();
		#endif
	#elif SHADOW_PASS
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	#elif PREPASS_PASS
		gl_FragColor = float2vec4(vLinearDepth);
	#else
		if (alpha < 1.0 / 255.0) {
			discard;
		}
		#ifndef DITHER_NONE
			opacityDither(alpha, id * 0.013);
		#endif
		gl_FragColor = vec4(gaussianColor.xyz * alpha, alpha);
	#endif
}
`,j7=`
#if SH_BANDS > 0
vec3 unpack111011s(uint bits) {
	return vec3((uvec3(bits) >> uvec3(21u, 11u, 0u)) & uvec3(0x7ffu, 0x3ffu, 0x7ffu)) / vec3(2047.0, 1023.0, 2047.0) * 2.0 - 1.0;
}
void fetchScale(in uvec4 t, out float scale, out vec3 a, out vec3 b, out vec3 c) {
	scale = uintBitsToFloat(t.x);
	a = unpack111011s(t.y);
	b = unpack111011s(t.z);
	c = unpack111011s(t.w);
}
void fetch(in uvec4 t, out vec3 a, out vec3 b, out vec3 c, out vec3 d) {
	a = unpack111011s(t.x);
	b = unpack111011s(t.y);
	c = unpack111011s(t.z);
	d = unpack111011s(t.w);
}
void fetch(in uint t, out vec3 a) {
	a = unpack111011s(t);
}
#if SH_BANDS == 1
	uniform highp usampler2D splatSH_1to3;
	void readSHData(in SplatSource source, out vec3 sh[3], out float scale) {
		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);
	}
#elif SH_BANDS == 2
	uniform highp usampler2D splatSH_1to3;
	uniform highp usampler2D splatSH_4to7;
	uniform highp usampler2D splatSH_8to11;
	void readSHData(in SplatSource source, out vec3 sh[8], out float scale) {
		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);
		fetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);
		fetch(texelFetch(splatSH_8to11, source.uv, 0).x, sh[7]);
	}
#else
	uniform highp usampler2D splatSH_1to3;
	uniform highp usampler2D splatSH_4to7;
	uniform highp usampler2D splatSH_8to11;
	uniform highp usampler2D splatSH_12to15;
	void readSHData(in SplatSource source, out vec3 sh[15], out float scale) {
		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);
		fetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);
		fetch(texelFetch(splatSH_8to11, source.uv, 0), sh[7], sh[8], sh[9], sh[10]);
		fetch(texelFetch(splatSH_12to15, source.uv, 0), sh[11], sh[12], sh[13], sh[14]);
	}
#endif
#endif
`,$7=`
attribute vec3 vertex_position;
attribute uint vertex_id_attrib;
uniform uint numSplats;
uniform uint splatTextureSize;
uniform highp usampler2D splatOrder;
bool initSource(out SplatSource source) {
	source.order = vertex_id_attrib + uint(vertex_position.z);
	if (source.order >= numSplats) {
		return false;
	}
	ivec2 orderUV = ivec2(source.order % splatTextureSize, source.order / splatTextureSize);
	source.id = texelFetch(splatOrder, orderUV, 0).r;
	source.uv = ivec2(source.id % splatTextureSize, source.id / splatTextureSize);
	source.cornerUV = vertex_position.xy;
	return true;
}
`,K7=`
#include "gsplatCommonVS"
varying mediump vec2 gaussianUV;
varying mediump vec4 gaussianColor;
#ifndef DITHER_NONE
	varying float id;
#endif
mediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);
#ifdef PREPASS_PASS
	varying float vLinearDepth;
#endif
#ifdef GSPLAT_OVERDRAW
	uniform sampler2D colorRamp;
	uniform float colorRampIntensity;
#endif
void main(void) {
	SplatSource source;
	if (!initSource(source)) {
		gl_Position = discardVec;
		return;
	}
	vec3 modelCenter = readCenter(source);
	SplatCenter center;
	center.modelCenterOriginal = modelCenter;
	
	modifyCenter(modelCenter);
	modifySplatCenter(modelCenter);
	center.modelCenterModified = modelCenter;
	if (!initCenter(modelCenter, center)) {
		gl_Position = discardVec;
		return;
	}
	SplatCorner corner;
	if (!initCorner(source, center, corner)) {
		gl_Position = discardVec;
		return;
	}
	vec4 clr = readColor(source);
	#if GSPLAT_AA
		clr.a *= corner.aaFactor;
	#endif
	#if SH_BANDS > 0
		vec3 dir = normalize(center.view * mat3(center.modelView));
		vec3 sh[SH_COEFFS];
		float scale;
		readSHData(source, sh, scale);
		clr.xyz += evalSH(sh, dir) * scale;
	#endif
	modifyColor(modelCenter, clr);
	modifySplatColor(modelCenter, clr);
	clipCorner(corner, clr.w);
	gl_Position = center.proj + vec4(corner.offset, 0, 0);
	gaussianUV = corner.uv;
	#ifdef GSPLAT_OVERDRAW
		float t = clamp(modelCenter.y / 20.0, 0.0, 1.0);
		vec3 rampColor = textureLod(colorRamp, vec2(t, 0.5), 0.0).rgb;
		clr.a *= (1.0 / 32.0) * colorRampIntensity;
		gaussianColor = vec4(rampColor, clr.a);
	#else
		gaussianColor = vec4(prepareOutputFromGamma(max(clr.xyz, 0.0)), clr.w);
	#endif
	#ifndef DITHER_NONE
		id = float(source.id);
	#endif
	#ifdef PREPASS_PASS
		vLinearDepth = -center.view.z;
	#endif
}
`,Z7=`
uniform highp usampler2D splatTexture0;
uniform highp usampler2D splatTexture1;
#ifdef GSPLAT_COLOR_UINT
	uniform highp usampler2D splatColor;
#else
	uniform mediump sampler2D splatColor;
#endif
uvec4 cachedSplatTexture0Data;
uvec2 cachedSplatTexture1Data;
vec3 readCenter(SplatSource source) {
	cachedSplatTexture0Data = texelFetch(splatTexture0, source.uv, 0);
	cachedSplatTexture1Data = texelFetch(splatTexture1, source.uv, 0).xy;
	return vec3(uintBitsToFloat(cachedSplatTexture0Data.r), uintBitsToFloat(cachedSplatTexture0Data.g), uintBitsToFloat(cachedSplatTexture0Data.b));
}
vec4 getRotation() {
	vec2 rotXY = unpackHalf2x16(cachedSplatTexture0Data.a);
	vec2 rotZscaleX = unpackHalf2x16(cachedSplatTexture1Data.x);
	vec3 rotXYZ = vec3(rotXY, rotZscaleX.x);
	return vec4(rotXYZ, sqrt(max(0.0, 1.0 - dot(rotXYZ, rotXYZ)))).wxyz;
}
vec3 getScale() {
	vec2 rotZscaleX = unpackHalf2x16(cachedSplatTexture1Data.x);
	vec2 scaleYZ = unpackHalf2x16(cachedSplatTexture1Data.y);
	return vec3(rotZscaleX.y, scaleYZ);
}
vec4 readColor(in SplatSource source) {
	#ifdef GSPLAT_COLOR_UINT
		uvec4 packed = texelFetch(splatColor, source.uv, 0);
		uint packed_rg = packed.r | (packed.g << 16u);
		uint packed_ba = packed.b | (packed.a << 16u);
		return vec4(unpackHalf2x16(packed_rg), unpackHalf2x16(packed_ba));
	#else
		return texelFetch(splatColor, source.uv, 0);
	#endif
}
`;const Q7={gsplatCenterVS:P7,gsplatCornerVS:W7,gsplatColorVS:R7,gsplatCommonVS:M7,gsplatCompressedDataVS:L7,gsplatCompressedSHVS:I7,gsplatCustomizeVS:O7,gsplatEvalSHVS:N7,gsplatHelpersVS:F7,gsplatModifyVS:B7,gsplatQuatToMat3VS:U7,gsplatSogsColorVS:z7,gsplatSogsDataVS:k7,gsplatSogsSHVS:V7,gsplatSourceFormatVS:G7,gsplatStructsVS:H7,gsplatDataVS:X7,gsplatOutputVS:q7,gsplatPS:Y7,gsplatSHVS:j7,gsplatSourceVS:$7,gsplatVS:K7,gsplatWorkBufferVS:Z7,gsplatPackingPS:P_};var J7=`
uniform matrix_model: mat4x4f;
uniform matrix_view: mat4x4f;
#ifndef GSPLAT_CENTER_NOPROJ
	uniform camera_params: vec4f;
	uniform matrix_projection: mat4x4f;
#endif
fn initCenter(modelCenter: vec3f, center: ptr<function, SplatCenter>) -> bool {
	let modelView: mat4x4f = uniform.matrix_view * uniform.matrix_model;
	let centerView: vec4f = modelView * vec4f(modelCenter, 1.0);
	#ifndef GSPLAT_CENTER_NOPROJ
		if (uniform.camera_params.w != 1.0 && centerView.z > 0.0) {
			return false;
		}
		var centerProj: vec4f = uniform.matrix_projection * centerView;
		centerProj.z = clamp(centerProj.z, 0.0, abs(centerProj.w));
		center.proj = centerProj;
		center.projMat00 = uniform.matrix_projection[0][0];
	#endif
	center.view = centerView.xyz / centerView.w;
	center.modelView = modelView;
	return true;
}
`,eK=`
var splatColor: texture_2d<uff>;
fn readColor(source: ptr<function, SplatSource>) -> vec4f {
	return textureLoad(splatColor, source.uv, 0);
}
`,tK=`
#include "gsplatHelpersVS"
#include "gsplatCustomizeVS"
#include "gsplatModifyVS"
#include "gsplatStructsVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatSourceFormatVS"
#include "gsplatSourceVS"
#include "gsplatCenterVS"
#include "gsplatCornerVS"
#include "gsplatOutputVS"
fn clipCorner(corner: ptr<function, SplatCorner>, alpha: f32) {
	let clip: f32 = min(1.0, sqrt(-log(1.0 / (255.0 * alpha))) / 2.0);
	corner.offset = corner.offset * clip;
	corner.uv = corner.uv * clip;
}
`,sK=`
#include "gsplatPackingPS"
var packedTexture: texture_2d<u32>;
var chunkTexture: texture_2d<uff>;
var<private> chunkDataA: vec4f;
var<private> chunkDataB: vec4f;
var<private> chunkDataC: vec4f;
var<private> chunkDataD: vec4f;
var<private> chunkDataE: vec4f;
var<private> packedData: vec4u;
fn unpack111011(bits: u32) -> vec3f {
	return (vec3f((vec3<u32>(bits) >> vec3<u32>(21u, 11u, 0u)) & vec3<u32>(0x7ffu, 0x3ffu, 0x7ffu))) / vec3f(2047.0, 1023.0, 2047.0);
}
const norm_const: f32 = sqrt(2.0);
fn unpackRotation(bits: u32) -> vec4f {
	let a = (f32((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm_const;
	let b = (f32((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm_const;
	let c = (f32(bits & 0x3ffu) / 1023.0 - 0.5) * norm_const;
	let m = sqrt(1.0 - (a * a + b * b + c * c));
	let mode = bits >> 30u;
	if (mode == 0u) { return vec4f(m, a, b, c); }
	if (mode == 1u) { return vec4f(a, m, b, c); }
	if (mode == 2u) { return vec4f(a, b, m, c); }
	return vec4f(a, b, c, m);
}
fn readCenter(source: ptr<function, SplatSource>) -> vec3f {
	let tex_size_u = textureDimensions(chunkTexture, 0);
	let w: u32 = tex_size_u.x / 5u;
	let chunkId: u32 = source.id / 256u;
	let chunkUV: vec2<i32> = vec2<i32>(i32((chunkId % w) * 5u), i32(chunkId / w));
	chunkDataA = textureLoad(chunkTexture, chunkUV + vec2<i32>(0, 0), 0);
	chunkDataB = textureLoad(chunkTexture, chunkUV + vec2<i32>(1, 0), 0);
	chunkDataC = textureLoad(chunkTexture, chunkUV + vec2<i32>(2, 0), 0);
	chunkDataD = textureLoad(chunkTexture, chunkUV + vec2<i32>(3, 0), 0);
	chunkDataE = textureLoad(chunkTexture, chunkUV + vec2<i32>(4, 0), 0);
	packedData = textureLoad(packedTexture, source.uv, 0);
	return mix(chunkDataA.xyz, vec3f(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));
}
fn readColor(source: ptr<function, SplatSource>) -> vec4f {
	let r = unpack8888(packedData.w);
	return vec4f(mix(chunkDataD.xyz, vec3f(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);
}
fn getRotation() -> vec4f {
	return unpackRotation(packedData.y);
}
fn getScale() -> vec3f {
	return exp(mix(vec3f(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));
}
`,iK=`
#if SH_BANDS > 0
var shTexture0: texture_2d<u32>;
var shTexture1: texture_2d<u32>;
var shTexture2: texture_2d<u32>;
fn unpack8888s(bits: u32) -> vec4f {
	let unpacked_u = (vec4<u32>(bits) >> vec4<u32>(0u, 8u, 16u, 24u)) & vec4<u32>(0xffu);
	return vec4f(unpacked_u) * (8.0 / 255.0) - 4.0;
}
fn readSHData(source: ptr<function, SplatSource>, sh: ptr<function, array<vec3f, 15>>, scale: ptr<function, f32>) {
	let shData0: vec4<u32> = textureLoad(shTexture0, source.uv, 0);
	let shData1: vec4<u32> = textureLoad(shTexture1, source.uv, 0);
	let shData2: vec4<u32> = textureLoad(shTexture2, source.uv, 0);
	let r0 = unpack8888s(shData0.x);
	let r1 = unpack8888s(shData0.y);
	let r2 = unpack8888s(shData0.z);
	let r3 = unpack8888s(shData0.w);
	let g0 = unpack8888s(shData1.x);
	let g1 = unpack8888s(shData1.y);
	let g2 = unpack8888s(shData1.z);
	let g3 = unpack8888s(shData1.w);
	let b0 = unpack8888s(shData2.x);
	let b1 = unpack8888s(shData2.y);
	let b2 = unpack8888s(shData2.z);
	let b3 = unpack8888s(shData2.w);
	sh[0] =  vec3f(r0.x, g0.x, b0.x);
	sh[1] =  vec3f(r0.y, g0.y, b0.y);
	sh[2] =  vec3f(r0.z, g0.z, b0.z);
	sh[3] =  vec3f(r0.w, g0.w, b0.w);
	sh[4] =  vec3f(r1.x, g1.x, b1.x);
	sh[5] =  vec3f(r1.y, g1.y, b1.y);
	sh[6] =  vec3f(r1.z, g1.z, b1.z);
	sh[7] =  vec3f(r1.w, g1.w, b1.w);
	sh[8] =  vec3f(r2.x, g2.x, b2.x);
	sh[9] =  vec3f(r2.y, g2.y, b2.y);
	sh[10] = vec3f(r2.z, g2.z, b2.z);
	sh[11] = vec3f(r2.w, g2.w, b2.w);
	sh[12] = vec3f(r3.x, g3.x, b3.x);
	sh[13] = vec3f(r3.y, g3.y, b3.y);
	sh[14] = vec3f(r3.z, g3.z, b3.z);
	*scale = 1.0;
}
#endif
`,rK=`
fn modifyCenter(center: ptr<function, vec3f>) {
}
fn modifyCovariance(originalCenter: vec3f, modifiedCenter: vec3f, covA: ptr<function, vec3f>, covB: ptr<function, vec3f>) {
}
fn modifyColor(center: vec3f, color: ptr<function, vec4f>) {
}
`,aK=`
	#if SH_BANDS == 1
		const SH_COEFFS: i32 = 3;
	#elif SH_BANDS == 2
		const SH_COEFFS: i32 = 8;
	#elif SH_BANDS == 3
		const SH_COEFFS: i32 = 15;
	#else
		const SH_COEFFS: i32 = 0;
	#endif
	#if SH_BANDS > 0
	const SH_C1: f32 = 0.4886025119029199;
	#if SH_BANDS > 1
		const SH_C2_0: f32 = 1.0925484305920792;
		const SH_C2_1: f32 = -1.0925484305920792;
		const SH_C2_2: f32 = 0.31539156525252005;
		const SH_C2_3: f32 = -1.0925484305920792;
		const SH_C2_4: f32 = 0.5462742152960396;
	#endif
	#if SH_BANDS > 2
		const SH_C3_0: f32 = -0.5900435899266435;
		const SH_C3_1: f32 = 2.890611442640554;
		const SH_C3_2: f32 = -0.4570457994644658;
		const SH_C3_3: f32 = 0.3731763325901154;
		const SH_C3_4: f32 = -0.4570457994644658;
		const SH_C3_5: f32 = 1.445305721320277;
		const SH_C3_6: f32 = -0.5900435899266435;
	#endif
	fn evalSH(sh: ptr<function, array<vec3f, SH_COEFFS>>, dir: vec3f) -> vec3f {
		let x = dir.x;
		let y = dir.y;
		let z = dir.z;
		var result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);
		#if SH_BANDS > 1
			let xx = x * x;
			let yy = y * y;
			let zz = z * z;
			let xy = x * y;
			let yz = y * z;
			let xz = x * z;
			result = result + (
				sh[3] * (SH_C2_0 * xy) +
				sh[4] * (SH_C2_1 * yz) +
				sh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +
				sh[6] * (SH_C2_3 * xz) +
				sh[7] * (SH_C2_4 * (xx - yy))
			);
		#endif
		#if SH_BANDS > 2
			result = result + (
				sh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +
				sh[9]  * (SH_C3_1 * xy * z) +
				sh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +
				sh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +
				sh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +
				sh[13] * (SH_C3_5 * z * (xx - yy)) +
				sh[14] * (SH_C3_6 * x * (xx - 3.0 * yy))
			);
		#endif
		return result;
	}
	#endif
`,nK=`
fn gsplatExtractSize(covA: vec3f, covB: vec3f) -> f32 {
	let tr = covA.x + covB.x + covB.z;
	return sqrt(max(tr, 0.0) / 3.0);
}
fn gsplatApplyUniformScale(covA: ptr<function, vec3f>, covB: ptr<function, vec3f>, scale: f32) {
	let s2 = scale * scale;
	*covA = *covA * s2;
	*covB = *covB * s2;
}
fn gsplatMakeRound(covA: ptr<function, vec3f>, covB: ptr<function, vec3f>, size: f32) {
	let s2 = size * size;
	*covA = vec3f(s2, 0.0, 0.0);
	*covB = vec3f(s2, 0.0, s2);
}
fn gsplatMakeSpherical(scale: ptr<function, vec3f>, size: f32) {
	*scale = vec3f(size);
}
fn gsplatGetSizeFromScale(scale: vec3f) -> f32 {
	return sqrt((scale.x * scale.x + scale.y * scale.y + scale.z * scale.z) / 3.0);
}
`,oK=`
fn modifySplatCenter(center: ptr<function, vec3f>) {
}
fn modifySplatRotationScale(originalCenter: vec3f, modifiedCenter: vec3f, rotation: ptr<function, vec4f>, scale: ptr<function, vec3f>) {
}
fn modifySplatColor(center: vec3f, color: ptr<function, vec4f>) {
}
`,lK=`
fn quatToMat3(R: vec4<f32>) -> mat3x3<f32> {
	let R2: vec4<f32> = R + R;
	let X: f32	   = R2.x * R.w;
	let Y: vec4<f32> = R2.y * R;
	let Z: vec4<f32> = R2.z * R;
	let W: f32	   = R2.w * R.w;
	return mat3x3<f32>(
		1.0 - Z.z - W,  Y.z + X,	  Y.w - Z.x,
		Y.z - X,		1.0 - Y.y - W, Z.w + Y.x,
		Y.w + Z.x,	  Z.w - Y.x,	 1.0 - Y.y - Z.z
	);
}
fn quatMul(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {
	return vec4<f32>(
		a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
		a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
		a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w,
		a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z
	);
}
`,cK=`
var packedSh0: texture_2d<f32>;
uniform sh0_mins: f32;
uniform sh0_maxs: f32;
const SH_C0: f32 = 0.28209479177387814;
fn readColor(source: ptr<function, SplatSource>) -> vec4f {
	let clr = mix(vec3f(uniform.sh0_mins), vec3f(uniform.sh0_maxs), unpack111110(pack8888(textureLoad(packedSh0, source.uv, 0))));
	let alpha = f32(packedSample.z & 0xffu) / 255.0;
	return vec4f(vec3f(0.5) + clr.xyz * SH_C0, alpha);
}
`,hK=`
#include "gsplatPackingPS"
var packedTexture: texture_2d<u32>;
uniform means_mins: vec3f;
uniform means_maxs: vec3f;
uniform scales_mins: f32;
uniform scales_maxs: f32;
var<private> packedSample: vec4<u32>;
fn readCenter(source: ptr<function, SplatSource>) -> vec3f {
	packedSample = textureLoad(packedTexture, source.uv, 0);
	let l = unpack8888(packedSample.x).xyz;
	let u = unpack8888(packedSample.y).xyz;
	let n = (l + u * 256.0) / 257.0;
	let v = mix(uniform.means_mins, uniform.means_maxs, n);
	return sign(v) * (exp(abs(v)) - 1.0);
}
const norm: f32 = sqrt(2.0);
fn getRotation() -> vec4f {
	let qdata = unpack8888(packedSample.z).xyz;
	let qmode = packedSample.w & 0x3u;
	let abc = (qdata - 0.5) * norm;
	let d = sqrt(max(0.0, 1.0 - dot(abc, abc)));
	var quat: vec4f;
	if (qmode == 0u) {
		quat = vec4f(d, abc);
	} else if (qmode == 1u) {
		quat = vec4f(abc.x, d, abc.y, abc.z);
	} else if (qmode == 2u) {
		quat = vec4f(abc.x, abc.y, d, abc.z);
	} else {
		quat = vec4f(abc.x, abc.y, abc.z, d);
	}
	return quat;
}
fn getScale() -> vec3f {
	let sdata = unpack101010(packedSample.w >> 2u);
	return exp(mix(vec3f(uniform.scales_mins), vec3f(uniform.scales_maxs), sdata));
}
`,uK=`
var packedShN: texture_2d<f32>;
uniform shN_mins: f32;
uniform shN_maxs: f32;
fn readSHData(source: ptr<function, SplatSource>, sh: ptr<function, array<vec3f, SH_COEFFS>>, scale: ptr<function, f32>) {
	let t = vec2i(packedSample.xy & vec2u(255u));
	let n = t.x + t.y * 256;
	let u = (n % 64) * SH_COEFFS;
	let v = n / 64;
	for (var i: i32 = 0; i < SH_COEFFS; i = i + 1) {
		sh[i] = mix(vec3f(uniform.shN_mins), vec3f(uniform.shN_maxs), unpack111110(pack8888(textureLoad(packedShN, vec2i(u + i, v), 0))));
	}
	*scale = 1.0;
}
`,dK=`
#if defined(GSPLAT_WORKBUFFER_DATA)
	#include "gsplatWorkBufferVS"
#elif GSPLAT_COMPRESSED_DATA == true
	#include "gsplatCompressedDataVS"
	#if SH_BANDS > 0
		#include "gsplatCompressedSHVS"
	#endif
#elif GSPLAT_SOGS_DATA
	#include "gsplatSogsDataVS"
	#include "gsplatSogsColorVS"
	#if SH_BANDS > 0
		#include "gsplatSogsSHVS"
	#endif
#else
	#include "gsplatDataVS"
	#include "gsplatColorVS"
	#if SH_BANDS > 0
		#include "gsplatSHVS"
	#endif
#endif
`,fK=`
struct SplatSource {
	order: u32,
	id: u32,
	uv: vec2<i32>,
	cornerUV: vec2f,
}
struct SplatCenter {
	view: vec3f,
	proj: vec4f,
	modelView: mat4x4f,
	projMat00: f32,
	modelCenterOriginal: vec3f,
	modelCenterModified: vec3f,
}
struct SplatCorner {
	offset: vec2f,
	uv: vec2f,
	#if GSPLAT_AA
		aaFactor: f32,
	#endif
}
`,mK=`
uniform viewport_size: vec4f;
fn computeCovariance(rotation: vec4f, scale: vec3f, covA_ptr: ptr<function, vec3f>, covB_ptr: ptr<function, vec3f>) {
	let rot = quatToMat3(rotation);
	let M = transpose(mat3x3f(
		scale.x * rot[0],
		scale.y * rot[1],
		scale.z * rot[2]
	));
	*covA_ptr = vec3f(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));
	*covB_ptr = vec3f(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));
}
fn initCornerCov(source: ptr<function, SplatSource>, center: ptr<function, SplatCenter>, corner: ptr<function, SplatCorner>, covA: vec3f, covB: vec3f) -> bool {
	let Vrk = mat3x3f(
		vec3f(covA.x, covA.y, covA.z),
		vec3f(covA.y, covB.x, covB.y),
		vec3f(covA.z, covB.y, covB.z)
	);
	let focal = uniform.viewport_size.x * center.projMat00;
	let v = select(center.view.xyz, vec3f(0.0, 0.0, 1.0), uniform.camera_params.w == 1.0);
	let J1 = focal / v.z;
	let J2 = -J1 / v.z * v.xy;
	let J = mat3x3f(
		vec3f(J1, 0.0, J2.x),
		vec3f(0.0, J1, J2.y),
		vec3f(0.0, 0.0, 0.0)
	);
	let W = transpose(mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));
	let T = W * J;
	let cov = transpose(T) * Vrk * T;
	#if GSPLAT_AA
		let detOrig = cov[0][0] * cov[1][1] - cov[0][1] * cov[1][0];
		let detBlur = (cov[0][0] + 0.3) * (cov[1][1] + 0.3) - cov[0][1] * cov[1][0];
		corner.aaFactor = sqrt(detOrig / detBlur);
	#endif
	let diagonal1 = cov[0][0] + 0.3;
	let offDiagonal = cov[0][1];
	let diagonal2 = cov[1][1] + 0.3;
	let mid = 0.5 * (diagonal1 + diagonal2);
	let radius = length(vec2f((diagonal1 - diagonal2) / 2.0, offDiagonal));
	let lambda1 = mid + radius;
	let lambda2 = max(mid - radius, 0.1);
	let vmin = min(1024.0, min(uniform.viewport_size.x, uniform.viewport_size.y));
	let l1 = 2.0 * min(sqrt(2.0 * lambda1), vmin);
	let l2 = 2.0 * min(sqrt(2.0 * lambda2), vmin);
	if (l1 < 2.0 && l2 < 2.0) {
		return false;
	}
	let c = center.proj.ww * uniform.viewport_size.zw;
	if (any((abs(center.proj.xy) - vec2f(max(l1, l2)) * c) > center.proj.ww)) {
		return false;
	}
	let diagonalVector = normalize(vec2f(offDiagonal, lambda1 - diagonal1));
	let v1 = l1 * diagonalVector;
	let v2 = l2 * vec2f(diagonalVector.y, -diagonalVector.x);
	corner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) * c;
	corner.uv = source.cornerUV;
	return true;
}
fn initCorner(source: ptr<function, SplatSource>, center: ptr<function, SplatCenter>, corner: ptr<function, SplatCorner>) -> bool {
	var rotation: vec4f = getRotation().yzwx;
	var scale: vec3f = getScale();
	modifySplatRotationScale(center.modelCenterOriginal, center.modelCenterModified, &rotation, &scale);
	var covA: vec3f;
	var covB: vec3f;
	computeCovariance(rotation.wxyz, scale, &covA, &covB);
	modifyCovariance(center.modelCenterOriginal, center.modelCenterModified, &covA, &covB);
	return initCornerCov(source, center, corner, covA, covB);
}
`,pK=`
var transformA: texture_2d<u32>;
var transformB: texture_2d<uff>;
var<private> tAw: u32;
var<private> tBcached: vec4f;
fn readCenter(source: ptr<function, SplatSource>) -> vec3f {
	let tA: vec4<u32> = textureLoad(transformA, source.uv, 0);
	tAw = tA.w;
	tBcached = textureLoad(transformB, source.uv, 0);
	return bitcast<vec3f>(tA.xyz);
}
fn unpackRotation(packed: vec3f) -> vec4f {
	return vec4f(packed.xyz, sqrt(max(0.0, 1.0 - dot(packed, packed))));
}
fn getRotation() -> vec4f {
	return unpackRotation(vec3f(unpack2x16float(tAw), tBcached.w)).wxyz;
}
fn getScale() -> vec3f {
	return tBcached.xyz;
}
`,_K=`
#include "tonemappingPS"
#include "decodePS"
#include "gammaPS"
fn prepareOutputFromGamma(gammaColor: vec3f) -> vec3f {
	#if TONEMAP == NONE
		#if GAMMA == NONE
			return decodeGamma3(gammaColor);
		#else 
			return gammaColor;
		#endif
	#else
		return gammaCorrectOutput(toneMap(decodeGamma3(gammaColor)));
	#endif
}
`,gK=`
#ifndef DITHER_NONE
	#include "bayerPS"
	#include "opacityDitherPS"
	varying id: f32;
#endif
#if defined(SHADOW_PASS) || defined(PICK_PASS) || defined(PREPASS_PASS)
	uniform alphaClip: f32;
#endif
#ifdef PREPASS_PASS
	varying vLinearDepth: f32;
	#include "floatAsUintPS"
#endif
const EXP4	  = exp(-4.0);
const INV_EXP4  = 1.0 / (1.0 - EXP4);
fn normExp(x: f32) -> f32 {
	return (exp(x * -4.0) - EXP4) * INV_EXP4;
}
varying gaussianUV: vec2f;
varying gaussianColor: vec4f;
#ifdef PICK_PASS
	#include "pickPS"
#endif
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	var output: FragmentOutput;
	let A: f32 = dot(gaussianUV, gaussianUV);
	if (A > 1.0) {
		discard;
		return output;
	}
	var alpha = normExp(A) * gaussianColor.a;
	#if defined(SHADOW_PASS) || defined(PICK_PASS) || defined(PREPASS_PASS)
		if (alpha < uniform.alphaClip) {
			discard;
			return output;
		}
	#endif
	#ifdef PICK_PASS
		output.color = getPickOutput();
		#ifdef DEPTH_PICK_PASS
			output.color1 = getPickDepth();
		#endif
	#elif SHADOW_PASS
		output.color = vec4f(0.0, 0.0, 0.0, 1.0);
	#elif PREPASS_PASS
		output.color = float2vec4(vLinearDepth);
	#else
		if (alpha < (1.0 / 255.0)) {
			discard;
			return output;
		}
		#ifndef DITHER_NONE
			opacityDither(&alpha, id * 0.013);
		#endif
		output.color = vec4f(input.gaussianColor.xyz * alpha, alpha);
	#endif
	return output;
}`,vK=`
#if SH_BANDS > 0
fn unpack111011s(bits: u32) -> vec3f {
	return (vec3f((vec3<u32>(bits) >> vec3<u32>(21u, 11u, 0u)) & vec3<u32>(0x7ffu, 0x3ffu, 0x7ffu)) / vec3f(2047.0, 1023.0, 2047.0)) * 2.0 - 1.0;
}
struct ScaleAndSH {
	scale: f32,
	a: vec3f,
	b: vec3f,
	c: vec3f
};
fn fetchScale(t_in: vec4<u32>) -> ScaleAndSH {
	var result: ScaleAndSH;
	result.scale = bitcast<f32>(t_in.x);
	result.a = unpack111011s(t_in.y);
	result.b = unpack111011s(t_in.z);
	result.c = unpack111011s(t_in.w);
	return result;
}
struct SH {
	a: vec3f,
	b: vec3f,
	c: vec3f,
	d: vec3f
};
fn fetch4(t_in: vec4<u32>) -> SH {
	var result: SH;
	result.a = unpack111011s(t_in.x);
	result.b = unpack111011s(t_in.y);
	result.c = unpack111011s(t_in.z);
	result.d = unpack111011s(t_in.w);
	return result;
}
fn fetch1(t_in: u32) -> vec3f {
	return unpack111011s(t_in);
}
#if SH_BANDS == 1
	var splatSH_1to3: texture_2d<u32>;
	fn readSHData(source: ptr<function, SplatSource>, sh: ptr<function, array<vec3f, 3>>, scale: ptr<function, f32>) {
		let result = fetchScale(textureLoad(splatSH_1to3, source.uv, 0));
		*scale = result.scale;
		sh[0] = result.a;
		sh[1] = result.b;
		sh[2] = result.c;
	}
#elif SH_BANDS == 2
	var splatSH_1to3: texture_2d<u32>;
	var splatSH_4to7: texture_2d<u32>;
	var splatSH_8to11: texture_2d<u32>;
	fn readSHData(source: ptr<function, SplatSource>, sh: ptr<function, array<vec3f, 8>>, scale: ptr<function, f32>) {
		let first: ScaleAndSH = fetchScale(textureLoad(splatSH_1to3, source.uv, 0));
		*scale = first.scale;
		sh[0] = first.a;
		sh[1] = first.b;
		sh[2] = first.c;
		let second: SH = fetch4(textureLoad(splatSH_4to7, source.uv, 0));
		sh[3] = second.a;
		sh[4] = second.b;
		sh[5] = second.c;
		sh[6] = second.d;
		sh[7] = fetch1(textureLoad(splatSH_8to11, source.uv, 0).x);
	}
#else
	var splatSH_1to3: texture_2d<u32>;
	var splatSH_4to7: texture_2d<u32>;
	var splatSH_8to11: texture_2d<u32>;
	var splatSH_12to15: texture_2d<u32>;
	fn readSHData(source: ptr<function, SplatSource>, sh: ptr<function, array<vec3f, 15>>, scale: ptr<function, f32>) {
		let first: ScaleAndSH = fetchScale(textureLoad(splatSH_1to3, source.uv, 0));
		*scale = first.scale;
		sh[0] = first.a;
		sh[1] = first.b;
		sh[2] = first.c;
		let second: SH = fetch4(textureLoad(splatSH_4to7, source.uv, 0));
		sh[3] = second.a;
		sh[4] = second.b;
		sh[5] = second.c;
		sh[6] = second.d;
		let third: SH = fetch4(textureLoad(splatSH_8to11, source.uv, 0));
		sh[7] = third.a;
		sh[8] = third.b;
		sh[9] = third.c;
		sh[10] = third.d;
		let fourth: SH = fetch4(textureLoad(splatSH_12to15, source.uv, 0));
		sh[11] = fourth.a;
		sh[12] = fourth.b;
		sh[13] = fourth.c;
		sh[14] = fourth.d;
	}
#endif
#endif
`,SK=`
attribute vertex_position: vec3f;
attribute vertex_id_attrib: u32;
uniform numSplats: u32;
uniform splatTextureSize: u32;
#ifdef STORAGE_ORDER
	var<storage, read> splatOrder: array<u32>;
#else
	var splatOrder: texture_2d<u32>;
#endif
fn initSource(source: ptr<function, SplatSource>) -> bool {
	source.order = vertex_id_attrib + u32(vertex_position.z);
	if (source.order >= uniform.numSplats) {
		return false;
	}
	#ifdef STORAGE_ORDER
		source.id = splatOrder[source.order];
	#else
		let uv = vec2u(source.order % uniform.splatTextureSize, source.order / uniform.splatTextureSize);
		source.id = textureLoad(splatOrder, vec2i(uv), 0).r;
	#endif
	source.uv = vec2i(vec2u(source.id % uniform.splatTextureSize, source.id / uniform.splatTextureSize));
	source.cornerUV = vertex_position.xy;
	return true;
}
`,yK=`
#include "gsplatCommonVS"
varying gaussianUV: vec2f;
varying gaussianColor: vec4f;
#ifndef DITHER_NONE
	varying id: f32;
#endif
const discardVec: vec4f = vec4f(0.0, 0.0, 2.0, 1.0);
#ifdef PREPASS_PASS
	varying vLinearDepth: f32;
#endif
#ifdef GSPLAT_OVERDRAW
	uniform colorRampIntensity: f32;
	var colorRamp: texture_2d<f32>;
	var colorRampSampler: sampler;
#endif
@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
	var output: VertexOutput;
	var source: SplatSource;
	if (!initSource(&source)) {
		output.position = discardVec;
		return output;
	}
	var modelCenter: vec3f = readCenter(&source);
	var center: SplatCenter;
	center.modelCenterOriginal = modelCenter;
	
	modifyCenter(&modelCenter);
	modifySplatCenter(&modelCenter);
	center.modelCenterModified = modelCenter;
	if (!initCenter(modelCenter, &center)) {
		output.position = discardVec;
		return output;
	}
	var corner: SplatCorner;
	if (!initCorner(&source, &center, &corner)) {
		output.position = discardVec;
		return output;
	}
	var clr: vec4f = readColor(&source);
	#if GSPLAT_AA
		clr.a = clr.a * corner.aaFactor;
	#endif
	#if SH_BANDS > 0
		let modelView3x3 = mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz);
		let dir = normalize(center.view * modelView3x3);
		var sh: array<vec3f, SH_COEFFS>;
		var scale: f32;
		readSHData(&source, &sh, &scale);
		clr = vec4f(clr.xyz + evalSH(&sh, dir) * scale, clr.a);
	#endif
	modifyColor(modelCenter, &clr);
	modifySplatColor(modelCenter, &clr);
	clipCorner(&corner, clr.w);
	output.position = center.proj + vec4f(corner.offset, 0.0, 0.0);
	output.gaussianUV = corner.uv;
	#ifdef GSPLAT_OVERDRAW
		let t: f32 = clamp(originalCenter.y / 20.0, 0.0, 1.0);
		let rampColor: vec3f = textureSampleLevel(colorRamp, colorRampSampler, vec2f(t, 0.5), 0.0).rgb;
		clr.a = clr.a * (1.0 / 32.0) * uniform.colorRampIntensity;
		output.gaussianColor = vec4f(rampColor, clr.a);
	#else
		output.gaussianColor = vec4f(prepareOutputFromGamma(max(clr.xyz, vec3f(0.0))), clr.w);
	#endif
	#ifndef DITHER_NONE
		output.id = f32(source.id);
	#endif
	#ifdef PREPASS_PASS
		output.vLinearDepth = -center.view.z;
	#endif
	return output;
}
`,xK=`
var splatTexture0: texture_2d<u32>;
var splatTexture1: texture_2d<u32>;
var splatColor: texture_2d<uff>;
var<private> cachedSplatTexture0Data: vec4u;
var<private> cachedSplatTexture1Data: vec2u;
fn readCenter(source: ptr<function, SplatSource>) -> vec3f {
	cachedSplatTexture0Data = textureLoad(splatTexture0, source.uv, 0);
	cachedSplatTexture1Data = textureLoad(splatTexture1, source.uv, 0).xy;
	return vec3f(bitcast<f32>(cachedSplatTexture0Data.r), bitcast<f32>(cachedSplatTexture0Data.g), bitcast<f32>(cachedSplatTexture0Data.b));
}
fn getRotation() -> vec4f {
	let rotXY = unpack2x16float(cachedSplatTexture0Data.a);
	let rotZscaleX = unpack2x16float(cachedSplatTexture1Data.x);
	let rotXYZ = vec3f(rotXY, rotZscaleX.x);
	return vec4f(rotXYZ, sqrt(max(0.0, 1.0 - dot(rotXYZ, rotXYZ)))).wxyz;
}
fn getScale() -> vec3f {
	let rotZscaleX = unpack2x16float(cachedSplatTexture1Data.x);
	let scaleYZ = unpack2x16float(cachedSplatTexture1Data.y);
	return vec3f(rotZscaleX.y, scaleYZ);
}
fn readColor(source: ptr<function, SplatSource>) -> vec4f {
	return textureLoad(splatColor, source.uv, 0);
}   
`;const TK={gsplatCenterVS:J7,gsplatCornerVS:mK,gsplatColorVS:eK,gsplatCommonVS:tK,gsplatCompressedDataVS:sK,gsplatCompressedSHVS:iK,gsplatCustomizeVS:rK,gsplatEvalSHVS:aK,gsplatHelpersVS:nK,gsplatModifyVS:oK,gsplatSourceFormatVS:dK,gsplatStructsVS:fK,gsplatQuatToMat3VS:lK,gsplatSogsColorVS:cK,gsplatSogsDataVS:hK,gsplatSogsSHVS:uK,gsplatDataVS:pK,gsplatOutputVS:_K,gsplatPS:gK,gsplatSHVS:vK,gsplatSourceVS:SK,gsplatVS:yK,gsplatWorkBufferVS:xK,gsplatPackingPS:R_},DT=["enabled"],Ad=["unified","lodDistances","castShadows","material","highQualitySH","asset","layers"];class cb extends Ht{initializeComponentData(e,t,s){t.layers&&t.layers.length&&(t.layers=t.layers.slice(0));for(let i=0;i<Ad.length;i++)t.hasOwnProperty(Ad[i])&&(e[Ad[i]]=t[Ad[i]]);t.aabbCenter&&t.aabbHalfExtents&&(e.customAabb=new Ge(new D(t.aabbCenter),new D(t.aabbHalfExtents))),super.initializeComponentData(e,t,DT)}cloneComponent(e,t){const s=e.gsplat,i={};Ad.forEach(a=>{if(a==="material"){if(!s.unified){const o=s[a];o&&(i[a]=o.clone())}}else i[a]=s[a]}),i.enabled=s.enabled;const r=this.addComponent(t,i);return s.customAabb&&(r.customAabb=s.customAabb.clone()),r}onRemove(e,t){t.onRemove()}getMaterial(e,t){const s=this.app.renderer.gsplatDirector;if(!s)return null;const i=s.camerasMap.get(e);return i?i.layersMap.get(t)?.gsplatManager?.material??null:null}getGSplatMaterial(e,t){return this.getMaterial(e,t)}constructor(e){super(e),this.id="gsplat",this.ComponentType=hI,this.DataType=D7,this.schema=DT,e.renderer.gsplatDirector=new C7(e.graphicsDevice,e.renderer,e.scene,this),Ue.get(e.graphicsDevice,ot).add(Q7),Ue.get(e.graphicsDevice,Je).add(TK),this.on("beforeremove",this.onRemove,this)}}cb.EVENT_MATERIALCREATED="material:created";cb.EVENT_FRAMEREADY="frame:ready";ke._buildAccessors(hI.prototype,DT);class hb extends Pe{set meshes(e){this.decRefMeshes(),this._meshes=e,this.incRefMeshes(),this.fire("set:meshes",e)}get meshes(){return this._meshes}destroy(){this.meshes=null}decRefMeshes(){this._meshes?.forEach((e,t)=>{e&&(e.decRefCount(),e.refCount<1&&(e.destroy(),this._meshes[t]=null))})}incRefMeshes(){this._meshes?.forEach(e=>{e?.incRefCount()})}constructor(...e){super(...e),this._meshes=null}}hb.EVENT_SETMESHES="set:meshes";function F_(c){const e=this;if(!e.resource)return;const t=c.resource,s=t.renders&&t.renders[e.data.renderIndex];s&&(e.resource.meshes=s.resource.meshes)}function PR(c){const e=this;e.registry.off(`load:${c.id}`,F_,e),e.registry.on(`load:${c.id}`,F_,e),e.registry.off(`remove:${c.id}`,RR,e),e.registry.once(`remove:${c.id}`,RR,e),c.resource?F_.call(e,c):e.registry.load(c)}function RR(c){const e=this;e.registry.off(`load:${c.id}`,F_,e),e.resource&&e.resource.destroy()}class EK extends Rt{open(e,t){return new hb}patch(e,t){if(!e.data.containerAsset)return;const s=t.get(e.data.containerAsset);if(!s){t.once(`add:${e.data.containerAsset}`,PR,e);return}PR.call(e,s)}constructor(e){super(e,"render"),this._registry=e.assets}}class uI{get paths(){return this._paths}get input(){return this._input}get output(){return this._output}get interpolation(){return this._interpolation}constructor(e,t,s,i){this._paths=e,this._input=t,this._output=s,this._interpolation=i}}class bg{get components(){return this._components}get data(){return this._data}constructor(e,t){this._components=e,this._data=t}}function bK(c,e){let t;const r=(S,x)=>{switch(x){case t.DT_INT8:return new Int8Array(S.buffer,S.byteOffset,S.byteLength);case t.DT_INT16:return new Int16Array(S.buffer,S.byteOffset,S.byteLength/2);case t.DT_INT32:return new Int32Array(S.buffer,S.byteOffset,S.byteLength/4);case t.DT_UINT8:return new Uint8Array(S.buffer,S.byteOffset,S.byteLength);case t.DT_UINT16:return new Uint16Array(S.buffer,S.byteOffset,S.byteLength/2);case t.DT_UINT32:return new Uint32Array(S.buffer,S.byteOffset,S.byteLength/4);case t.DT_FLOAT32:return new Float32Array(S.buffer,S.byteOffset,S.byteLength/4)}return null},a=S=>{switch(S){case t.DT_INT8:return 1;case t.DT_INT16:return 2;case t.DT_INT32:return 4;case t.DT_UINT8:return 1;case t.DT_UINT16:return 2;case t.DT_UINT32:return 4;case t.DT_FLOAT32:return 4}return 1},o=S=>{switch(S){case t.DT_INT8:return 0;case t.DT_UINT8:return 1;case t.DT_INT16:return 2;case t.DT_UINT16:return 3;case t.DT_INT32:return 4;case t.DT_UINT32:return 5;case t.DT_FLOAT32:return 6;default:return 6}},h=S=>S.num_components()*a(S.data_type()),u={0:0,1:1,5:2,2:3,7:4,8:5,4:6,3:7},f=(S,x)=>{const T=(ee,j,ae)=>{ee[0]=j[0]-ae[0],ee[1]=j[1]-ae[1],ee[2]=j[2]-ae[2]},E=(ee,j,ae)=>{ee[0]=j[1]*ae[2]-ae[1]*j[2],ee[1]=j[2]*ae[0]-ae[2]*j[0],ee[2]=j[0]*ae[1]-ae[0]*j[1]},b=(ee,j)=>{const ae=ee[j+0],k=ee[j+1],O=ee[j+2],z=1/Math.sqrt(ae*ae+k*k+O*O);ee[j+0]*=z,ee[j+1]*=z,ee[j+2]*=z},C=(ee,j,ae)=>{for(let k=0;k<3;++k)ee[k]=j[ae+k]},w=x.length/3,P=S.length/3,I=new Float32Array(S.length),M=[0,0,0],R=[0,0,0],L=[0,0,0],B=[0,0,0],G=[0,0,0],H=[0,0,0];for(let ee=0;ee<w;++ee){const j=x[ee*3+0]*3,ae=x[ee*3+1]*3,k=x[ee*3+2]*3;C(M,S,j),C(R,S,ae),C(L,S,k),T(B,R,M),T(G,L,M),E(H,B,G),b(H,0);for(let O=0;O<3;++O)I[j+O]+=H[O],I[ae+O]+=H[O],I[k+O]+=H[O]}for(let ee=0;ee<P;++ee)b(I,ee*3);return new Uint8Array(I.buffer)},m=S=>{const x={},T=new t.DecoderBuffer;T.Init(S,S.length);const E=new t.Decoder;if(E.GetEncodedGeometryType(T)!==t.TRIANGULAR_MESH)return x.error="Failed to decode draco mesh: not a mesh",x;const b=new t.Mesh,C=E.DecodeBufferToMesh(T,b);if(!C||!C.ok()||t.getPointer(b)===0)return x.error="Failed to decode draco asset",x;const w=b.num_faces()*3,P=b.num_points()<=65535,I=w*(P?2:4),M=t._malloc(I);P?(E.GetTrianglesUInt16Array(b,I,M),x.indices=new Uint16Array(t.HEAPU16.buffer,M,w).slice().buffer):(E.GetTrianglesUInt32Array(b,I,M),x.indices=new Uint32Array(t.HEAPU32.buffer,M,w).slice().buffer),t._free(M);const R=[];for(let j=0;j<b.num_attributes();++j)R.push(E.GetAttribute(b,j));R.sort((j,ae)=>(u[j.attribute_type()]??u.length)-(u[ae.attribute_type()]??u.length));let L=0;const B=R.map(j=>{const ae=L;return L+=Math.ceil(h(j)/4)*4,ae}),G=R.some(j=>j.attribute_type()===1);let H=B[1]??0;if(!G){H=B[0]+Math.ceil(h(R[0])/4)*4;for(let j=1;j<B.length;++j)B[j]+=12;L+=12}x.attributes=R.map((j,ae)=>({id:j.unique_id(),dataType:o(j.data_type()),numComponents:j.num_components(),offset:B[ae]})),G||x.attributes.splice(1,0,{id:-1,dataType:6,numComponents:3,offset:H}),x.stride=L,x.vertices=new ArrayBuffer(b.num_points()*L);const ee=new Uint8Array(x.vertices);for(let j=0;j<b.num_attributes();++j){const ae=R[j],k=h(ae),O=b.num_points()*k,z=t._malloc(O);E.GetAttributeDataArrayForAllPoints(b,ae,ae.data_type(),O,z);const X=new Uint8Array(t.HEAPU8.buffer,z,O);for(let Y=0;Y<b.num_points();++Y)for(let F=0;F<k;++F)ee[Y*L+B[j]+F]=X[Y*k+F];if(!G&&ae.attribute_type()===0){const Y=f(r(X,ae.data_type()),P?new Uint16Array(x.indices):new Uint32Array(x.indices));for(let F=0;F<b.num_points();++F)for(let U=0;U<12;++U)ee[F*L+H+U]=Y[F*12+U]}t._free(z)}return t.destroy(b),t.destroy(E),t.destroy(T),x},_=S=>{const x=m(new Uint8Array(S.buffer));self.postMessage({jobId:S.jobId,error:x.error,indices:x.indices,vertices:x.vertices,attributes:x.attributes,stride:x.stride},[x.indices,x.vertices].filter(T=>T!=null))},g=[];self.onmessage=S=>{const x=S.data;switch(x.type){case"init":self.DracoDecoderModule({instantiateWasm:(T,E)=>(WebAssembly.instantiate(x.module,T).then(b=>E(b)).catch(b=>console.error(`instantiate failed + ${b}`)),{})}).then(T=>{t=T,g.forEach(E=>_(E))});break;case"decodeMesh":t?_(x):g.push(x);break}}}const MR=3;class AK{init(e){for(e.forEach(t=>{t.addEventListener("message",s=>{const i=s.data,r=this.jobCallbacks.get(i.jobId);if(r&&r(i.error,{indices:i.indices,vertices:i.vertices,attributes:i.attributes,stride:i.stride}),this.jobCallbacks.delete(i.jobId),this.jobQueue.length>0){const a=this.jobQueue.shift();this.run(t,a)}else{const a=this.workers[2].indexOf(t);if(a!==-1)this.workers[2].splice(a,1),this.workers[1].push(t);else{const o=this.workers[1].indexOf(t);o!==-1&&(this.workers[1].splice(o,1),this.workers[0].push(t))}}})}),this.workers[0]=e;this.jobQueue.length&&(this.workers[0].length||this.workers[1].length);){const t=this.jobQueue.shift();if(this.workers[0].length>0){const s=this.workers[0].shift();this.workers[1].push(s),this.run(s,t)}else{const s=this.workers[1].shift();this.workers[2].push(s),this.run(s,t)}}}enqueueJob(e,t){const s={jobId:this.jobId++,buffer:e};if(this.jobCallbacks.set(s.jobId,t),this.workers[0].length>0){const i=this.workers[0].shift();this.workers[1].push(i),this.run(i,s)}else if(this.workers[1].length>0){const i=this.workers[1].shift();this.workers[2].push(i),this.run(i,s)}else this.jobQueue.push(s)}constructor(){this.workers=[[],[],[]],this.jobId=0,this.jobQueue=[],this.jobCallbacks=new Map,this.run=(e,t)=>{e.postMessage({type:"decodeMesh",jobId:t.jobId,buffer:t.buffer},[t.buffer])}}}const wK=c=>new Promise((e,t)=>{const s={cache:!0,responseType:"text",retry:MR>0,maxRetries:MR};Pt.get(c,s,(i,r)=>{i?t(i):e(r)})}),CK=c=>{const e=()=>fetch(c).then(s=>s.arrayBuffer()).then(s=>WebAssembly.compile(s)),t=()=>WebAssembly.compileStreaming(fetch(c)).catch(s=>e());return WebAssembly.compileStreaming?t():e()},LR=1;let B_,PT;const dI=c=>{if(B_)return!0;if(!c)if(PT)c=PT;else{const e=FM.getConfig("DracoDecoderModule");e?c={jsUrl:e.glueUrl,wasmUrl:e.wasmUrl,numWorkers:e.numWorkers}:c={jsUrl:"draco.wasm.js",wasmUrl:"draco.wasm.wasm",numWorkers:LR}}return!c.jsUrl||!c.wasmUrl?!1:(B_=new AK,Promise.all([wK(c.jsUrl),CK(c.wasmUrl)]).then(([e,t])=>{const s=["/* draco */",e,"/* worker */",`(
${bK.toString()}
)()

`].join(`
`),i=new Blob([s],{type:"application/javascript"}),r=URL.createObjectURL(i),a=Math.max(1,Math.min(16,c.numWorkers||LR)),o=[];for(let h=0;h<a;++h){const u=new Worker(r);u.postMessage({type:"init",module:t}),o.push(u)}B_.init(o)}),!0)},DK=c=>{c?.lazyInit?PT=c:dI(c)},PK=(c,e)=>dI()?(B_.enqueueJob(c,e),!0):!1;class RK{destroy(){this.renders&&this.renders.forEach(e=>{e.meshes=null})}}const fI=c=>/^data:[^\n\r,\u2028\u2029]*,.*$/i.test(c),MK=c=>c.substring(c.indexOf(":")+1,c.indexOf(";")),Ag=c=>{switch(c){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return 3}},ub=c=>{switch(c){case 5120:return co;case 5121:return Va;case 5122:return ho;case 5123:return Nl;case 5124:return Wh;case 5125:return Xh;case 5126:return ct;default:return 0}},LK=c=>{switch(c){case 5120:return 1;case 5121:return 1;case 5122:return 2;case 5123:return 2;case 5124:return 4;case 5125:return 4;case 5126:return 4;default:return 0}},IK=c=>{switch(c){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:return null}},RT={POSITION:He,NORMAL:si,TANGENT:Xr,COLOR_0:Rs,JOINTS_0:yi,WEIGHTS_0:kr,TEXCOORD_0:Zi,TEXCOORD_1:Il,TEXCOORD_2:Of,TEXCOORD_3:Nf,TEXCOORD_4:Ff,TEXCOORD_5:Bf,TEXCOORD_6:Uf,TEXCOORD_7:zf},IR={[He]:0,[si]:1,[Xr]:2,[Rs]:3,[yi]:4,[kr]:5,[Zi]:6,[Il]:7,[Of]:8,[Nf]:9,[Ff]:10,[Bf]:11,[Uf]:12,[zf]:13},OK=c=>{switch(c){case co:return e=>Math.max(e/127,-1);case Va:return e=>e/255;case ho:return e=>Math.max(e/32767,-1);case Nl:return e=>e/65535;default:return e=>e}},MT=(c,e,t)=>{const s=OK(t),i=e.length;for(let r=0;r<i;++r)c[r]=s(e[r]);return c},ml=(c,e,t=!1)=>{const s=Ag(c.type),i=IK(c.componentType);if(!i)return null;let r;if(c.sparse){const a=c.sparse,o={count:a.count,type:"SCALAR"},h=ml(Object.assign(o,a.indices),e,!0),u={count:a.count,type:c.type,componentType:c.componentType},f=ml(Object.assign(u,a.values),e,!0);if(c.hasOwnProperty("bufferView")){const m={bufferView:c.bufferView,byteOffset:c.byteOffset,componentType:c.componentType,count:c.count,type:c.type};r=ml(m,e,!0).slice()}else r=new i(c.count*s);for(let m=0;m<a.count;++m){const _=h[m];for(let g=0;g<s;++g)r[_*s+g]=f[m*s+g]}}else if(c.hasOwnProperty("bufferView")){const a=e[c.bufferView];if(t&&a.hasOwnProperty("byteStride")){const o=s*i.BYTES_PER_ELEMENT,h=new ArrayBuffer(c.count*o),u=new Uint8Array(h);let f=0;for(let m=0;m<c.count;++m){let _=(c.byteOffset||0)+m*a.byteStride;for(let g=0;g<o;++g)u[f++]=a[_++]}r=new i(h)}else r=new i(a.buffer,a.byteOffset+(c.byteOffset||0),c.count*s)}else r=new i(c.count*s);return r},Th=(c,e)=>{const t=ml(c,e,!0);if(t instanceof Float32Array||!c.normalized)return t;const s=new Float32Array(t.length);return MT(s,t,ub(c.componentType)),s},LT=c=>{let e=c.min,t=c.max;if(!e||!t)return null;if(c.normalized){const s=ub(c.componentType);e=MT([],e,s),t=MT([],t,s)}return new Ge(new D((t[0]+e[0])*.5,(t[1]+e[1])*.5,(t[2]+e[2])*.5),new D((t[0]-e[0])*.5,(t[1]-e[1])*.5,(t[2]-e[2])*.5))},mI=c=>{if(!c.hasOwnProperty("mode"))return ka;switch(c.mode){case 0:return cv;case 1:return hv;case 2:return HM;case 3:return fE;case 4:return ka;case 5:return zr;case 6:return cl;default:return ka}},NK=c=>{const e=new Uint16Array(c);for(let t=0;t<c;t++)e[t]=t;return e},FK=(c,e)=>{const t=c[He];if(!t||t.components!==3)return;let s;if(t.size!==t.stride){const o=t.stride/Bd[t.type],h=new gh[t.type](t.buffer,t.offset,t.count*o);s=new gh[t.type](t.count*3);for(let u=0;u<t.count;++u)s[u*3+0]=h[u*o+0],s[u*3+1]=h[u*o+1],s[u*3+2]=h[u*o+2]}else s=new gh[t.type](t.buffer,t.offset,t.count*3);const i=t.count;e||(e=NK(i));const r=rL(s,e),a=new Float32Array(r.length);a.set(r),c[si]={buffer:a.buffer,size:12,offset:0,stride:12,count:i,components:3,type:ct}},BK=c=>{const e=s=>{const i=[];for(let r=0;r<s._levels.length;++r){let a=[];if(s.cubemap)for(let o=0;o<6;++o)a.push(s._levels[r][o]);else a=s._levels[r];i.push(a)}return i},t=new De(c.device,c);return t._levels=e(c),t},UK=c=>{const e=new Ee(`${c.name}_clone`,c.type,c.file,c.data,c.options);return e.loaded=!0,e.resource=BK(c.resource),c.registry.add(e),e},zK=(c,e)=>{const t=e[He];if(!t)return null;const s=t.count,i=[];for(const E in e)if(e.hasOwnProperty(E)){const b={semantic:E,components:e[E].components,type:e[E].type,normalize:!!e[E].normalize};Ti.isElementValid(c,b)||b.components++,i.push(b)}i.sort((E,b)=>IR[E.semantic]-IR[b.semantic]);let r,a,o,h,u,f;const m=new Ti(c,i);let _=!0;for(r=0;r<m.elements.length;++r)if(u=m.elements[r],h=e[u.name],f=h.offset-t.offset,h.buffer!==t.buffer||h.stride!==u.stride||h.size!==u.size||f!==u.offset){_=!1;break}const g=new Yr(c,m,s),S=g.lock(),x=new Uint32Array(S);let T;if(_)T=new Uint32Array(t.buffer,t.offset,s*g.format.size/4),x.set(T);else{let E,b;for(r=0;r<g.format.elements.length;++r){u=g.format.elements[r],E=u.stride/4,h=e[u.name],b=h.stride/4,T=new Uint32Array(h.buffer,h.offset,(h.count-1)*b+(h.size+3)/4);let C=0,w=u.offset/4;const P=Math.floor((h.size+3)/4);for(a=0;a<s;++a){for(o=0;o<P;++o)x[w+o]=T[C+o];C+=b,w+=E}}}return g.unlock(),g},kK=(c,e,t,s,i,r)=>{const a={},o=[];for(const f in e)e.hasOwnProperty(f)&&RT.hasOwnProperty(f)&&(a[f]=e[f],o.push(`${f}:${e[f]}`));o.sort();const h=o.join();let u=r[h];if(!u){const f={};for(const m in a){const _=s[e[m]],g=ml(_,i),S=i[_.bufferView],x=RT[m],T=Ag(_.type)*LK(_.componentType),E=S&&S.hasOwnProperty("byteStride")?S.byteStride:T;f[x]={buffer:g.buffer,size:T,offset:g.byteOffset,stride:E,count:_.count,components:Ag(_.type),type:ub(_.componentType),normalize:_.normalized}}f.hasOwnProperty(si)||FK(f,t),u=zK(c,f),r[h]=u}return u},VK=(c,e,t,s,i,r)=>{let a,o,h;const u=e.joints,f=u.length,m=[];if(e.hasOwnProperty("inverseBindMatrices")){const x=e.inverseBindMatrices,T=ml(t[x],s,!0),E=[];for(a=0;a<f;a++){for(o=0;o<16;o++)E[o]=T[a*16+o];h=new fe,h.set(E),m.push(h)}}else for(a=0;a<f;a++)h=new fe,m.push(h);const _=[];for(a=0;a<f;a++)_[a]=i[u[a]].name;const g=_.join("#");let S=r.get(g);return S||(S=new lL(c,m,_),r.set(g,S)),S},GK=(c,e,t,s,i,r,a)=>{const o=new Ct(c);if(o.aabb=LT(t[e.attributes.POSITION]),a.push(new Promise((h,u)=>{const f=e.extensions.KHR_draco_mesh_compression;PK(s[f.bufferView].slice().buffer,(m,_)=>{if(m)console.log(m),u(m);else{const g={};for(const[P,I]of Object.entries(f.attributes))g[I]=RT[P];g[-1]=si;const S=[];for(const P of _.attributes){const I=g[P.id];if(I!==void 0){let M=!1;if(P.id!==-1){for(const[R,L]of Object.entries(f.attributes))if(L===P.id&&e.attributes[R]!==void 0){M=t[e.attributes[R]].normalized??(I===Rs&&(P.dataType===Va||P.dataType===Nl));break}}S.push({semantic:I,components:P.numComponents,type:P.dataType,normalize:M,offset:P.offset,stride:_.stride})}}const x=new Ti(c,S),T=_.vertices.byteLength/_.stride,E=T<=65535?Ka:eo,b=_.indices.byteLength/(T<=65535?2:4),C=new Yr(c,x,T,{data:_.vertices}),w=new bl(c,E,b,Hi,_.indices);o.vertexBuffer=C,o.indexBuffer[0]=w,o.primitive[0].type=mI(e),o.primitive[0].base=0,o.primitive[0].count=w?b:T,o.primitive[0].indexed=!!w,h()}})})),e?.extensions?.KHR_materials_variants){const h=e.extensions.KHR_materials_variants,u={};h.mappings.forEach(f=>{f.variants.forEach(m=>{u[m]=f.material})}),i[o.id]=u}return r[o.id]=e.material,o},HK=(c,e,t,s,i,r,a,o,h)=>{const u=[];return e.primitives.forEach(f=>{if(f.extensions?.KHR_draco_mesh_compression)u.push(GK(c,f,t,s,r,a,h));else{let m=f.hasOwnProperty("indices")?ml(t[f.indices],s,!0):null;const _=kK(c,f.attributes,m,t,s,i),g=mI(f),S=new Ct(c);if(S.vertexBuffer=_,S.primitive[0].type=g,S.primitive[0].base=0,S.primitive[0].indexed=m!==null,m!==null){let T;m instanceof Uint8Array?T=Vx:m instanceof Uint16Array?T=Ka:T=eo,T===Vx&&c.isWebGPU&&(T=Ka,m=new Uint16Array(m));const E=new bl(c,T,m.length,Hi,m);S.indexBuffer[0]=E,S.primitive[0].count=m.length}else S.primitive[0].count=_.numVertices;if(f.hasOwnProperty("extensions")&&f.extensions.hasOwnProperty("KHR_materials_variants")){const T=f.extensions.KHR_materials_variants,E={};T.mappings.forEach(b=>{b.variants.forEach(C=>{E[C]=b.material})}),r[S.id]=E}a[S.id]=f.material;let x=t[f.attributes.POSITION];if(S.aabb=LT(x),f.hasOwnProperty("targets")){const T=[];f.targets.forEach((E,b)=>{const C={};E.hasOwnProperty("POSITION")&&(x=t[E.POSITION],C.deltaPositions=Th(x,s),C.aabb=LT(x)),E.hasOwnProperty("NORMAL")&&(x=t[E.NORMAL],C.deltaNormals=Th(x,s)),e.hasOwnProperty("extras")&&e.extras.hasOwnProperty("targetNames")?C.name=e.extras.targetNames[b]:C.name=b.toString(10),e.hasOwnProperty("weights")&&(C.defaultWeight=e.weights[b]),C.preserveData=o.morphPreserveData,T.push(new Lv(C))}),S.morph=new sL(T,c,{preferHighPrecision:o.morphPreferHighPrecision})}u.push(S)}}),u},ds=(c,e,t)=>{let s;const i=c.texCoord;if(i)for(s=0;s<t.length;++s)e[`${t[s]}MapUv`]=i;const r=[0,0],a=[1,1],o=c.extensions?.KHR_texture_transform;if(o){const h=o.offset||r,u=o.scale||a,f=o.rotation?-o.rotation*J.RAD_TO_DEG:0,m=new ne(u[0],u[1]),_=new ne(h[0],1-u[1]-h[1]);for(s=0;s<t.length;++s)e[`${t[s]}MapTiling`]=m,e[`${t[s]}MapOffset`]=_,e[`${t[s]}MapRotation`]=f}},WK=(c,e,t)=>{let s;if(c.hasOwnProperty("diffuseFactor")){const[i,r,a,o]=c.diffuseFactor;e.diffuse.set(i,r,a).gamma(),e.opacity=o}else e.diffuse.set(1,1,1),e.opacity=1;if(c.hasOwnProperty("diffuseTexture")){const i=c.diffuseTexture;s=t[i.index],e.diffuseMap=s,e.diffuseMapChannel="rgb",e.opacityMap=s,e.opacityMapChannel="a",ds(i,e,["diffuse","opacity"])}if(e.useMetalness=!1,c.hasOwnProperty("specularFactor")){const[i,r,a]=c.specularFactor;e.specular.set(i,r,a).gamma()}else e.specular.set(1,1,1);if(c.hasOwnProperty("glossinessFactor")?e.gloss=c.glossinessFactor:e.gloss=1,c.hasOwnProperty("specularGlossinessTexture")){const i=c.specularGlossinessTexture;e.specularMap=e.glossMap=t[i.index],e.specularMapChannel="rgb",e.glossMapChannel="a",ds(i,e,["gloss","metalness"])}},XK=(c,e,t)=>{if(c.hasOwnProperty("clearcoatFactor")?e.clearCoat=c.clearcoatFactor*.25:e.clearCoat=0,c.hasOwnProperty("clearcoatTexture")){const s=c.clearcoatTexture;e.clearCoatMap=t[s.index],e.clearCoatMapChannel="r",ds(s,e,["clearCoat"])}if(c.hasOwnProperty("clearcoatRoughnessFactor")?e.clearCoatGloss=c.clearcoatRoughnessFactor:e.clearCoatGloss=0,c.hasOwnProperty("clearcoatRoughnessTexture")){const s=c.clearcoatRoughnessTexture;e.clearCoatGlossMap=t[s.index],e.clearCoatGlossMapChannel="g",ds(s,e,["clearCoatGloss"])}if(c.hasOwnProperty("clearcoatNormalTexture")){const s=c.clearcoatNormalTexture;e.clearCoatNormalMap=t[s.index],ds(s,e,["clearCoatNormal"]),s.hasOwnProperty("scale")?e.clearCoatBumpiness=s.scale:e.clearCoatBumpiness=1}e.clearCoatGlossInvert=!0},qK=(c,e,t)=>{e.useLighting=!1,e.emissive.copy(e.diffuse),e.emissiveMap=e.diffuseMap,e.emissiveMapUv=e.diffuseMapUv,e.emissiveMapTiling.copy(e.diffuseMapTiling),e.emissiveMapOffset.copy(e.diffuseMapOffset),e.emissiveMapRotation=e.diffuseMapRotation,e.emissiveMapChannel=e.diffuseMapChannel,e.emissiveVertexColor=e.diffuseVertexColor,e.emissiveVertexColorChannel=e.diffuseVertexColorChannel,e.useLighting=!1,e.useSkybox=!1,e.diffuse.set(1,1,1),e.diffuseMap=null,e.diffuseVertexColor=!1},YK=(c,e,t)=>{if(e.useMetalnessSpecularColor=!0,c.hasOwnProperty("specularColorTexture")&&(e.specularMap=t[c.specularColorTexture.index],e.specularMapChannel="rgb",ds(c.specularColorTexture,e,["specular"])),c.hasOwnProperty("specularColorFactor")){const[s,i,r]=c.specularColorFactor;e.specular.set(s,i,r).gamma()}else e.specular.set(1,1,1);c.hasOwnProperty("specularFactor")?e.specularityFactor=c.specularFactor:e.specularityFactor=1,c.hasOwnProperty("specularTexture")&&(e.specularityFactorMapChannel="a",e.specularityFactorMap=t[c.specularTexture.index],ds(c.specularTexture,e,["specularityFactor"]))},jK=(c,e,t)=>{c.hasOwnProperty("ior")&&(e.refractionIndex=1/c.ior)},$K=(c,e,t)=>{c.hasOwnProperty("dispersion")&&(e.dispersion=c.dispersion)},KK=(c,e,t)=>{e.blendType=jr,e.useDynamicRefraction=!0,c.hasOwnProperty("transmissionFactor")&&(e.refraction=c.transmissionFactor),c.hasOwnProperty("transmissionTexture")&&(e.refractionMapChannel="r",e.refractionMap=t[c.transmissionTexture.index],ds(c.transmissionTexture,e,["refraction"]))},ZK=(c,e,t)=>{if(e.useSheen=!0,c.hasOwnProperty("sheenColorFactor")){const[s,i,r]=c.sheenColorFactor;e.sheen.set(s,i,r).gamma()}else e.sheen.set(1,1,1);c.hasOwnProperty("sheenColorTexture")&&(e.sheenMap=t[c.sheenColorTexture.index],ds(c.sheenColorTexture,e,["sheen"])),e.sheenGloss=c.hasOwnProperty("sheenRoughnessFactor")?c.sheenRoughnessFactor:0,c.hasOwnProperty("sheenRoughnessTexture")&&(e.sheenGlossMap=t[c.sheenRoughnessTexture.index],e.sheenGlossMapChannel="a",ds(c.sheenRoughnessTexture,e,["sheenGloss"])),e.sheenGlossInvert=!0},QK=(c,e,t)=>{if(e.blendType=jr,e.useDynamicRefraction=!0,c.hasOwnProperty("thicknessFactor")&&(e.thickness=c.thicknessFactor),c.hasOwnProperty("thicknessTexture")&&(e.thicknessMap=t[c.thicknessTexture.index],e.thicknessMapChannel="g",ds(c.thicknessTexture,e,["thickness"])),c.hasOwnProperty("attenuationDistance")&&(e.attenuationDistance=c.attenuationDistance),c.hasOwnProperty("attenuationColor")){const[s,i,r]=c.attenuationColor;e.attenuation.set(s,i,r).gamma()}},JK=(c,e,t)=>{c.hasOwnProperty("emissiveStrength")&&(e.emissiveIntensity=c.emissiveStrength)},eZ=(c,e,t)=>{e.useIridescence=!0,c.hasOwnProperty("iridescenceFactor")&&(e.iridescence=c.iridescenceFactor),c.hasOwnProperty("iridescenceTexture")&&(e.iridescenceMapChannel="r",e.iridescenceMap=t[c.iridescenceTexture.index],ds(c.iridescenceTexture,e,["iridescence"])),c.hasOwnProperty("iridescenceIor")&&(e.iridescenceRefractionIndex=c.iridescenceIor),c.hasOwnProperty("iridescenceThicknessMinimum")&&(e.iridescenceThicknessMin=c.iridescenceThicknessMinimum),c.hasOwnProperty("iridescenceThicknessMaximum")&&(e.iridescenceThicknessMax=c.iridescenceThicknessMaximum),c.hasOwnProperty("iridescenceThicknessTexture")&&(e.iridescenceThicknessMapChannel="g",e.iridescenceThicknessMap=t[c.iridescenceThicknessTexture.index],ds(c.iridescenceThicknessTexture,e,["iridescenceThickness"]))},tZ=(c,e,t)=>{if(e.enableGGXSpecular=!0,c.hasOwnProperty("anisotropyStrength")?e.anisotropyIntensity=c.anisotropyStrength:e.anisotropyIntensity=0,c.hasOwnProperty("anisotropyTexture")){const s=c.anisotropyTexture;e.anisotropyMap=t[s.index],ds(s,e,["anisotropy"])}c.hasOwnProperty("anisotropyRotation")?e.anisotropyRotation=c.anisotropyRotation*J.RAD_TO_DEG:e.anisotropyRotation=0},pI=(c,e)=>{const t=new vr;c.hasOwnProperty("name")&&(t.name=c.name),t.occludeSpecular=Pv,t.diffuseVertexColor=!0,t.specularTint=!0,t.specularVertexColor=!0,t.specular.set(1,1,1),t.gloss=1,t.glossInvert=!0,t.useMetalness=!0;let s;if(c.hasOwnProperty("pbrMetallicRoughness")){const r=c.pbrMetallicRoughness;if(r.hasOwnProperty("baseColorFactor")){const[a,o,h,u]=r.baseColorFactor;t.diffuse.set(a,o,h).gamma(),t.opacity=u}if(r.hasOwnProperty("baseColorTexture")){const a=r.baseColorTexture;s=e[a.index],t.diffuseMap=s,t.diffuseMapChannel="rgb",t.opacityMap=s,t.opacityMapChannel="a",ds(a,t,["diffuse","opacity"])}if(r.hasOwnProperty("metallicFactor")&&(t.metalness=r.metallicFactor),r.hasOwnProperty("roughnessFactor")&&(t.gloss=r.roughnessFactor),r.hasOwnProperty("metallicRoughnessTexture")){const a=r.metallicRoughnessTexture;t.metalnessMap=t.glossMap=e[a.index],t.metalnessMapChannel="b",t.glossMapChannel="g",ds(a,t,["gloss","metalness"])}}if(c.hasOwnProperty("normalTexture")){const r=c.normalTexture;t.normalMap=e[r.index],ds(r,t,["normal"]),r.hasOwnProperty("scale")&&(t.bumpiness=r.scale)}if(c.hasOwnProperty("occlusionTexture")){const r=c.occlusionTexture;t.aoMap=e[r.index],t.aoMapChannel="r",ds(r,t,["ao"])}if(c.hasOwnProperty("emissiveFactor")){const[r,a,o]=c.emissiveFactor;t.emissive.set(r,a,o).gamma()}if(c.hasOwnProperty("emissiveTexture")){const r=c.emissiveTexture;t.emissiveMap=e[r.index],ds(r,t,["emissive"])}if(c.hasOwnProperty("alphaMode"))switch(c.alphaMode){case"MASK":t.blendType=qi,c.hasOwnProperty("alphaCutoff")?t.alphaTest=c.alphaCutoff:t.alphaTest=.5;break;case"BLEND":t.blendType=jr,t.depthWrite=!1;break;default:case"OPAQUE":t.blendType=qi;break}else t.blendType=qi;c.hasOwnProperty("doubleSided")?(t.twoSidedLighting=c.doubleSided,t.cull=c.doubleSided?Ft:_l):(t.twoSidedLighting=!1,t.cull=_l);const i={KHR_materials_clearcoat:XK,KHR_materials_emissive_strength:JK,KHR_materials_ior:jK,KHR_materials_dispersion:$K,KHR_materials_iridescence:eZ,KHR_materials_pbrSpecularGlossiness:WK,KHR_materials_sheen:ZK,KHR_materials_specular:YK,KHR_materials_transmission:KK,KHR_materials_unlit:qK,KHR_materials_volume:QK,KHR_materials_anisotropy:tZ};if(c.hasOwnProperty("extensions"))for(const r in c.extensions){const a=i[r];a!==void 0&&a(c.extensions[r],t,e)}return t.update(),t},sZ=(c,e,t,s,i,r,a)=>{const o=R=>new bg(Ag(R.type),Th(R,s)),h={STEP:bL,LINEAR:nT,CUBICSPLINE:oT},u={},f={},m={};let _=1,g;for(g=0;g<c.samplers.length;++g){const R=c.samplers[g];u.hasOwnProperty(R.input)||(u[R.input]=o(t[R.input])),f.hasOwnProperty(R.output)||(f[R.output]=o(t[R.output]));const L=R.hasOwnProperty("interpolation")&&h.hasOwnProperty(R.interpolation)?h[R.interpolation]:nT,B={paths:[],input:R.input,output:R.output,interpolation:L};m[g]=B}const S=[],x={translation:"localPosition",rotation:"localRotation",scale:"localScale"},T=R=>{const L=[];for(;R;)L.unshift(R.name),R=R.parent;return L},E=(R,L,B)=>{const G=f[R.output];if(!G)return;let H;if(r&&r[L.mesh]){const z=r[L.mesh];z.hasOwnProperty("extras")&&z.extras.hasOwnProperty("targetNames")&&(H=z.extras.targetNames)}const ee=G.data,j=ee.length/u[R.input].data.length,ae=ee.length/j,k=ae*4,O=new ArrayBuffer(k*j);for(let z=0;z<j;z++){const X=new Float32Array(O,k*z,ae);for(let K=0;K<ae;K++)X[K]=ee[K*j+z];const Y=new bg(1,X),F=H?.[z]?`name.${H[z]}`:z;f[-_]=Y;const U={paths:[{entityPath:B,component:"graph",propertyPath:[`weight.${F}`]}],input:R.input,output:-_,interpolation:R.interpolation};_++,m[`morphCurve-${g}-${z}`]=U}};for(g=0;g<c.channels.length;++g){const R=c.channels[g],L=R.target,B=m[R.sampler],G=i[L.node],H=a[L.node],ee=T(G);L.path.startsWith("weights")?(E(B,H,ee),m[R.sampler].morphCurve=!0):B.paths.push({entityPath:ee,component:"graph",propertyPath:[x[L.path]]})}const b=[],C=[],w=[];for(const R in u)b.push(u[R]),u[R]=b.length-1;for(const R in f)C.push(f[R]),f[R]=C.length-1;for(const R in m){const L=m[R];L.morphCurve||(w.push(new uI(L.paths,u[L.input],f[L.output],L.interpolation)),L.paths.length>0&&L.paths[0].propertyPath[0]==="localRotation"&&L.interpolation!==oT&&S.push(w[w.length-1].output))}S.sort();let P=null,I;for(g=0;g<S.length;++g){const R=S[g];if(g===0||R!==P){if(I=C[R],I.components===4){const L=I.data,B=L.length-4;for(let G=0;G<B;G+=4)L[G+0]*L[G+4]+L[G+1]*L[G+5]+L[G+2]*L[G+6]+L[G+3]*L[G+7]<0&&(L[G+4]*=-1,L[G+5]*=-1,L[G+6]*=-1,L[G+7]*=-1)}P=R}}let M=0;for(g=0;g<b.length;g++)I=b[g]._data,M=Math.max(M,I.length===0?0:I[I.length-1]);return new Qa(c.hasOwnProperty("name")?c.name:`animation_${e}`,M,b,C,w)},wd=new fe,Cd=new D,OR=new pe,iZ=(c,e,t)=>{const s=new Dt;if(c.hasOwnProperty("name")&&c.name.length>0?s.name=c.name:s.name=`node_${e}`,c.hasOwnProperty("matrix")&&(wd.data.set(c.matrix),wd.getTranslation(Cd),s.setLocalPosition(Cd),OR.setFromMat4(wd),s.setLocalRotation(OR),wd.getScale(Cd),Cd.x*=wd.scaleSign,s.setLocalScale(Cd)),c.hasOwnProperty("rotation")){const i=c.rotation;s.setLocalRotation(i[0],i[1],i[2],i[3])}if(c.hasOwnProperty("translation")){const i=c.translation;s.setLocalPosition(i[0],i[1],i[2])}if(c.hasOwnProperty("scale")){const i=c.scale;s.setLocalScale(i[0],i[1],i[2])}return c.hasOwnProperty("extensions")&&c.extensions.EXT_mesh_gpu_instancing&&t.set(c,{ext:c.extensions.EXT_mesh_gpu_instancing}),s},rZ=(c,e)=>{const t=c.type==="orthographic",s=t?c.orthographic:c.perspective,i={enabled:!1,projection:t?Dv:dr,nearClip:s.znear,aspectRatioMode:$E};s.zfar&&(i.farClip=s.zfar),t?(i.orthoHeight=s.ymag,s.xmag&&s.ymag&&(i.aspectRatioMode=Zx,i.aspectRatio=s.xmag/s.ymag)):(i.fov=s.yfov*J.RAD_TO_DEG,s.aspectRatio&&(i.aspectRatioMode=Zx,i.aspectRatio=s.aspectRatio));const r=new Nt(c.name);return r.addComponent("camera",i),r},aZ=(c,e)=>{const t={enabled:!1,type:c.type==="point"?"omni":c.type,color:c.hasOwnProperty("color")?new ue(c.color):ue.WHITE,range:c.hasOwnProperty("range")?c.range:9999,falloffMode:b2,intensity:c.hasOwnProperty("intensity")?J.clamp(c.intensity,0,2):1};if(c.hasOwnProperty("spot")&&(t.innerConeAngle=c.spot.hasOwnProperty("innerConeAngle")?c.spot.innerConeAngle*J.RAD_TO_DEG:0,t.outerConeAngle=c.spot.hasOwnProperty("outerConeAngle")?c.spot.outerConeAngle*J.RAD_TO_DEG:45),c.hasOwnProperty("intensity")){const i=c.spot?.outerConeAngle??Math.PI/4,r=c.spot?.innerConeAngle??0;t.luminance=c.intensity*ff.getLightUnitConversion(Jx[t.type],i,r)}const s=new Nt(e.name);return s.rotateLocal(90,0,0),s.addComponent("light",t),s},nZ=(c,e,t,s)=>{if(!e.hasOwnProperty("skins")||e.skins.length===0)return[];const i=new Map;return e.skins.map(r=>VK(c,r,e.accessors,s,t,i))},oZ=(c,e,t,s)=>{const i={},r={},a={},o=[];return{meshes:!s.skipMeshes&&e?.meshes?.length&&e?.accessors?.length&&e?.bufferViews?.length?e.meshes.map(f=>HK(c,f,e.accessors,t,i,r,a,s,o)):[],meshVariants:r,meshDefaultMaterials:a,promises:o}},lZ=(c,e,t)=>{if(!c.hasOwnProperty("materials")||c.materials.length===0)return[];const s=t?.material?.preprocess,i=t?.material?.process??pI,r=t?.material?.postprocess;return c.materials.map(a=>{s&&s(a);const o=i(a,e);return r&&r(a,o),o})},cZ=c=>{if(!c.hasOwnProperty("extensions")||!c.extensions.hasOwnProperty("KHR_materials_variants"))return null;const e=c.extensions.KHR_materials_variants.variants,t={};for(let s=0;s<e.length;s++)t[e[s].name]=s;return t},hZ=(c,e,t,s)=>{if(!c.hasOwnProperty("animations")||c.animations.length===0)return[];const i=s?.animation?.preprocess,r=s?.animation?.postprocess;return c.animations.map((a,o)=>{i&&i(a);const h=sZ(a,o,c.accessors,t,e,c.meshes,c.nodes);return r&&r(a,h),h})},uZ=(c,e,t,s)=>{const i=e.accessors;t.forEach((r,a)=>{const o=r.ext.attributes;let h;if(o.hasOwnProperty("TRANSLATION")){const _=i[o.TRANSLATION];h=Th(_,s)}let u;if(o.hasOwnProperty("ROTATION")){const _=i[o.ROTATION];u=Th(_,s)}let f;if(o.hasOwnProperty("SCALE")){const _=i[o.SCALE];f=Th(_,s)}const m=(h?h.length/3:0)||(u?u.length/4:0)||(f?f.length/3:0);if(m){const _=new Float32Array(m*16),g=new D,S=new pe,x=new D(1,1,1),T=new fe;let E=0;for(let b=0;b<m;b++){const C=b*3;if(h&&g.set(h[C],h[C+1],h[C+2]),u){const w=b*4;S.set(u[w],u[w+1],u[w+2],u[w+3])}f&&x.set(f[C],f[C+1],f[C+2]),T.setTRS(g,S,x);for(let w=0;w<16;w++)_[E++]=T.data[w]}r.matrices=_}})},dZ=(c,e,t)=>{if(!c.hasOwnProperty("nodes")||c.nodes.length===0)return[];const s=e?.node?.preprocess,i=e?.node?.process??iZ,r=e?.node?.postprocess,a=c.nodes.map((o,h)=>{s&&s(o);const u=i(o,h,t);return r&&r(o,u),u});for(let o=0;o<c.nodes.length;++o){const h=c.nodes[o];if(h.hasOwnProperty("children")){const u=a[o],f={};for(let m=0;m<h.children.length;++m){const _=a[h.children[m]];_.parent||(f.hasOwnProperty(_.name)?_.name+=f[_.name]++:f[_.name]=1,u.addChild(_))}}}return a},fZ=(c,e)=>{const t=[],s=c.scenes.length;if(s===1&&c.scenes[0].nodes?.length===1){const i=c.scenes[0].nodes[0];t.push(e[i])}else for(let i=0;i<s;i++){const r=c.scenes[i];if(r.nodes){const a=new Dt(r.name);for(let o=0;o<r.nodes.length;o++){const h=e[r.nodes[o]];a.addChild(h)}t.push(a)}}return t},mZ=(c,e,t)=>{let s=null;if(c.hasOwnProperty("nodes")&&c.hasOwnProperty("cameras")&&c.cameras.length>0){const i=t?.camera?.preprocess,r=t?.camera?.process??rZ,a=t?.camera?.postprocess;c.nodes.forEach((o,h)=>{if(o.hasOwnProperty("camera")){const u=c.cameras[o.camera];if(u){i&&i(u);const f=r(u,e[h]);a&&a(u,f),f&&(s||(s=new Map),s.set(o,f))}}})}return s},pZ=(c,e,t)=>{let s=null;if(c.hasOwnProperty("nodes")&&c.hasOwnProperty("extensions")&&c.extensions.hasOwnProperty("KHR_lights_punctual")&&c.extensions.KHR_lights_punctual.hasOwnProperty("lights")){const i=c.extensions.KHR_lights_punctual.lights;if(i.length){const r=t?.light?.preprocess,a=t?.light?.process??aZ,o=t?.light?.postprocess;c.nodes.forEach((h,u)=>{if(h.hasOwnProperty("extensions")&&h.extensions.hasOwnProperty("KHR_lights_punctual")&&h.extensions.KHR_lights_punctual.hasOwnProperty("light")){const f=h.extensions.KHR_lights_punctual.light,m=i[f];if(m){r&&r(m);const _=a(m,e[u]);o&&o(m,_),_&&(s||(s=new Map),s.set(h,_))}}})}}return s},_Z=(c,e,t)=>{c.nodes.forEach(s=>{s.hasOwnProperty("mesh")&&s.hasOwnProperty("skin")&&e[s.mesh].meshes.forEach(r=>{r.skin=t[s.skin]})})},gZ=async(c,e,t,s,i)=>{const r=i?.global?.preprocess,a=i?.global?.postprocess;r&&r(e),e.asset&&e.asset.generator;const o=new Map,h=dZ(e,i,o),u=fZ(e,h),f=pZ(e,h,i),m=mZ(e,h,i),_=cZ(e),g=await Promise.all(t),{meshes:S,meshVariants:x,meshDefaultMaterials:T,promises:E}=oZ(c,e,g,i),b=hZ(e,h,g,i);uZ(c,e,o,g);const C=await Promise.all(s),w=C.map(L=>L.resource),P=lZ(e,w,i),I=nZ(c,e,h,g),M=[];for(let L=0;L<S.length;L++)M[L]=new hb,M[L].meshes=S[L];_Z(e,M,I);const R=new RK;return R.gltf=e,R.nodes=h,R.scenes=u,R.animations=b,R.textures=C,R.materials=P,R.variants=_,R.meshVariants=x,R.meshDefaultMaterials=T,R.renders=M,R.skins=I,R.lights=f,R.cameras=m,R.nodeInstancingMap=o,a&&a(e,R),await Promise.all(E),R},vZ=(c,e)=>{const t=(i,r)=>{switch(i){case 9728:return ze;case 9729:return $t;case 9984:return Ef;case 9985:return Af;case 9986:return bf;case 9987:return Jn;default:return r}},s=(i,r)=>{switch(i){case 33071:return Te;case 33648:return Lg;case 10497:return as;default:return r}};c&&(e=e??{},c.minFilter=t(e.minFilter,Jn),c.magFilter=t(e.magFilter,$t),c.addressU=s(e.wrapS,as),c.addressV=s(e.wrapT,as))};let SZ=0;const ah=c=>c.extensions?.KHR_texture_basisu?.source??c.extensions?.EXT_texture_webp?.source??c.source,yZ=(c,e,t,s,i)=>{if(!c.images||c.images.length===0)return[];const r=i?.image?.preprocess,a=i?.image?.processAsync,o=i?.image?.postprocess,h={"image/png":"png","image/jpeg":"jpg","image/basis":"basis","image/ktx":"ktx","image/ktx2":"ktx2","image/vnd-ms.dds":"dds"},u=_=>{const g=new Set;return _.hasOwnProperty("materials")&&_.materials.forEach(S=>{if(S.hasOwnProperty("pbrMetallicRoughness")){const x=S.pbrMetallicRoughness;if(x.hasOwnProperty("baseColorTexture")){const T=_.textures[x.baseColorTexture.index];g.add(ah(T))}}if(S.hasOwnProperty("emissiveTexture")){const x=_.textures[S.emissiveTexture.index];g.add(ah(x))}if(S.hasOwnProperty("extensions")){const x=S.extensions.KHR_materials_sheen;if(x&&x.hasOwnProperty("sheenColorTexture")){const b=_.textures[x.sheenColorTexture.index];g.add(ah(b))}const T=S.extensions.KHR_materials_pbrSpecularGlossiness;if(T&&T.hasOwnProperty("specularGlossinessTexture")){const b=_.textures[T.specularGlossinessTexture.index];g.add(ah(b))}const E=S.extensions.KHR_materials_specular;if(E&&E.hasOwnProperty("specularColorTexture")){const b=_.textures[E.specularColorTexture.index];g.add(ah(b))}}}),g},f=(_,g,S,x,T,E)=>new Promise((b,C)=>{const w=P=>{const I=`${_.name||"gltf-texture"}-${SZ++}`,M={url:g||I};if(P&&(M.contents=P.slice(0).buffer),x){const B=h[x];B&&(M.filename=`${M.url}.${B}`)}const R={srgb:E},L=new Ee(I,"texture",M,R,T);L.on("load",B=>b(B)),L.on("error",B=>C(B)),s.add(L),s.load(L)};S?S.then(P=>w(P)):w(null)}),m=u(c);return c.images.map((_,g)=>{r&&r(_);let S;return a?S=new Promise((x,T)=>{a(_,(E,b)=>{E?T(E):x(b)})}):S=new Promise(x=>{x(null)}),S=S.then(x=>{const T=m.has(g);return x||(_.hasOwnProperty("uri")?fI(_.uri)?f(_,_.uri,null,MK(_.uri),null,T):f(_,Nh.test(_.uri)?_.uri:Re.join(t,_.uri),null,null,{crossOrigin:"anonymous"},T):_.hasOwnProperty("bufferView")&&_.hasOwnProperty("mimeType")?f(_,null,e[_.bufferView],_.mimeType,null,T):Promise.reject(new Error(`Invalid image found in gltf (neither uri or bufferView found). index=${g}`)))}),o&&(S=S.then(x=>(o(_,x),x))),S})},xZ=(c,e,t)=>{if(!c?.images?.length||!c?.textures?.length)return[];const s=t?.texture?.preprocess,i=t?.texture?.processAsync,r=t?.texture?.postprocess,a=new Set;return c.textures.map(o=>{s&&s(o);let h;return i?h=new Promise((u,f)=>{i(o,c.images,(m,_)=>{m?f(m):u(_)})}):h=new Promise(u=>{u(null)}),h=h.then(u=>{u=u??ah(o);const f=a.has(u);return a.add(u),e[u].then(m=>{const _=f?UK(m):m;return vZ(_.resource,(c.samplers??[])[o.sampler]),_})}),r&&(h=h.then(u=>(r(o,u),u))),h})},TZ=(c,e,t,s)=>{if(!c.buffers||c.buffers.length===0)return[];const i=s?.buffer?.preprocess,r=s?.buffer?.processAsync,a=s?.buffer?.postprocess;return c.buffers.map((o,h)=>{i&&i(o);let u;return r?u=new Promise((f,m)=>{r(o,(_,g)=>{_?m(_):f(g)})}):u=new Promise(f=>{f(null)}),u=u.then(f=>{if(f)return f;if(o.hasOwnProperty("uri")){if(fI(o.uri)){const m=atob(o.uri.split(",")[1]),_=new Uint8Array(m.length);for(let g=0;g<m.length;g++)_[g]=m.charCodeAt(g);return _}return new Promise((m,_)=>{Pt.get(Nh.test(o.uri)?o.uri:Re.join(t,o.uri),{cache:!0,responseType:"arraybuffer",retry:!1},(g,S)=>{g?_(g):m(new Uint8Array(S))})})}return e}),a&&(u=u.then(f=>(a(c.buffers[h],f),f))),u})},EZ=(c,e)=>{const s=JSON.parse((i=>{if(typeof TextDecoder<"u")return new TextDecoder().decode(i);let r="";for(let a=0;a<i.length;a++)r+=String.fromCharCode(i[a]);return decodeURIComponent(escape(r))})(c));if(s.asset&&s.asset.version&&parseFloat(s.asset.version)<2){e(`Invalid gltf version. Expected version 2.0 or above but found version '${s.asset.version}'.`);return}e(null,s)},bZ=(c,e)=>{const t=c instanceof ArrayBuffer?new DataView(c):new DataView(c.buffer,c.byteOffset,c.byteLength),s=t.getUint32(0,!0),i=t.getUint32(4,!0),r=t.getUint32(8,!0);if(s!==1179937895){e(`Invalid magic number found in glb header. Expected 0x46546C67, found 0x${s.toString(16)}`);return}if(i!==2){e(`Invalid version number found in glb header. Expected 2, found ${i}`);return}if(r<=0||r>t.byteLength){e(`Invalid length found in glb header. Found ${r}`);return}const a=[];let o=12;for(;o<r;){const h=t.getUint32(o,!0);o+h+8>t.byteLength&&e(`Invalid chunk length found in glb. Found ${h}`);const u=t.getUint32(o+4,!0),f=new Uint8Array(t.buffer,t.byteOffset+o+8,h);a.push({length:h,type:u,data:f}),o+=h+8}if(a.length!==1&&a.length!==2){e("Invalid number of chunks found in glb file.");return}if(a[0].type!==1313821514){e(`Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${a[0].type.toString(16)}`);return}if(a.length>1&&a[1].type!==5130562){e(`Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${a[1].type.toString(16)}`);return}e(null,{gltfChunk:a[0].data,binaryChunk:a.length===2?a[1].data:null})},AZ=(c,e,t)=>{const s=()=>{const i=new Uint8Array(e);return i[0]===103&&i[1]===108&&i[2]===84&&i[3]===70};c&&c.toLowerCase().endsWith(".glb")||s()?bZ(e,t):t(null,{gltfChunk:e,binaryChunk:null})},wZ=(c,e,t)=>{const s=[],i=t?.bufferView?.preprocess,r=t?.bufferView?.processAsync,a=t?.bufferView?.postprocess;if(!c.bufferViews?.length)return s;for(let o=0;o<c.bufferViews.length;++o){const h=c.bufferViews[o];i&&i(h);let u;r?u=new Promise((f,m)=>{r(h,e,(_,g)=>{_?m(_):f(g)})}):u=new Promise(f=>{f(null)}),u=u.then(f=>f||e[h.buffer].then(m=>new Uint8Array(m.buffer,m.byteOffset+(h.byteOffset||0),h.byteLength))),h.hasOwnProperty("byteStride")&&(u=u.then(f=>(f.byteStride=h.byteStride,f))),a&&(u=u.then(f=>(a(h,f),f))),s.push(u)}return s};class wg{static parse(e,t,s,i,r,a,o){AZ(e,s,(h,u)=>{if(h){o(h);return}EZ(u.gltfChunk,(f,m)=>{if(f){o(f);return}const _=TZ(m,u.binaryChunk,t,a),g=wZ(m,_,a),S=yZ(m,g,t,r,a),x=xZ(m,S,a);gZ(i,m,g,x,a).then(T=>o(null,T)).catch(T=>o(T))})})}static createDefaultMaterial(){return pI({name:"defaultGlbMaterial"},[])}}class CZ extends Rt{load(e,t,s){typeof e=="string"&&(e={load:e,original:e});const i={retry:this.maxRetries>0,maxRetries:this.maxRetries};(e.load.startsWith("blob:")||e.load.startsWith("data:"))&&(Re.getExtension(e.original).toLowerCase()===".glb"?i.responseType=Oe.ResponseType.ARRAY_BUFFER:i.responseType=Oe.ResponseType.JSON),Pt.get(e.load,i,(r,a)=>{r?t(`Error loading animation resource: ${e.original} [${r}]`):Re.getExtension(e.original).toLowerCase()===".glb"?wg.parse("filename.glb","",a,this.device,this.assets,s?.options??{},(o,h)=>{if(o)t(o);else{const u=h.animations;if(s?.data?.events)for(let f=0;f<u.length;f++)u[f].events=new DL(Object.values(s.data.events));h.destroy(),t(null,u)}}):t(null,this[`_parseAnimationV${a.animation.version}`](a))})}open(e,t,s){return t}_parseAnimationV3(e){const t=e.animation,s=new AP;s.name=t.name,s.duration=t.duration;for(let i=0;i<t.nodes.length;i++){const r=new bP,a=t.nodes[i];r._name=a.name;for(let o=0;o<a.keys.length;o++){const h=a.keys[o],u=h.time,f=h.pos,m=h.rot,_=h.scale,g=new D(f[0],f[1],f[2]),S=new pe().setFromEulerAngles(m[0],m[1],m[2]),x=new D(_[0],_[1],_[2]),T=new EP(u,g,S,x);r._keys.push(T)}s.addNode(r)}return s}_parseAnimationV4(e){const t=e.animation,s=new AP;s.name=t.name,s.duration=t.duration;for(let i=0;i<t.nodes.length;i++){const r=new bP,a=t.nodes[i];r._name=a.name;const o=a.defaults.p,h=a.defaults.r,u=a.defaults.s;for(let f=0;f<a.keys.length;f++){const m=a.keys[f],_=m.t,g=o||m.p,S=h||m.r,x=u||m.s,T=new D(g[0],g[1],g[2]),E=new pe().setFromEulerAngles(S[0],S[1],S[2]),b=new D(x[0],x[1],x[2]),C=new EP(_,T,E,b);r._keys.push(C)}s.addNode(r)}return s}constructor(e){super(e,"animation"),this.device=e.graphicsDevice,this.assets=e.assets}}class DZ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e});const s={retry:this.maxRetries>0,maxRetries:this.maxRetries};e.load.startsWith("blob:")&&(s.responseType=Oe.ResponseType.JSON),Pt.get(e.load,s,(i,r)=>{i?t(`Error loading animation clip resource: ${e.original} [${i}]`):t(null,r)})}open(e,t){const s=t.name,i=t.duration,r=t.inputs.map(h=>new bg(1,h)),a=t.outputs.map(h=>new bg(h.components,h.data)),o=t.curves.map(h=>new uI([h.path],h.inputIndex,h.outputIndex,h.interpolation));return new Qa(s,i,r,a,o)}constructor(e){super(e,"animclip")}}class PZ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e});const s={retry:this.maxRetries>0,maxRetries:this.maxRetries};e.load.startsWith("blob:")&&(s.responseType=Oe.ResponseType.JSON),Pt.get(e.load,s,(i,r)=>{i?t(`Error loading animation state graph resource: ${e.original} [${i}]`):t(null,r)})}open(e,t){return new I_(t)}constructor(e){super(e,"animstategraph")}}const hx=(function(){if(typeof window>"u")return!1;const c=window.navigator.userAgent,e=c.indexOf("MSIE ");if(e>0)return parseInt(c.substring(e+5,c.indexOf(".",e)),10);if(c.indexOf("Trident/")>0){const s=c.indexOf("rv:");return parseInt(c.substring(s+3,c.indexOf(".",s)),10)}return!1})(),RZ=[".ogg",".mp3",".wav",".mp4a",".m4a",".mp4",".aac",".opus"];class MZ extends Rt{_isSupported(e){const t=Re.getExtension(e);return RZ.indexOf(t)>-1}load(e,t){typeof e=="string"&&(e={load:e,original:e});const s=function(r){t(null,new Ok(r))},i=function(r){let a=`Error loading audio url: ${e.original}`;r&&(a+=`: ${r.message||r}`),console.warn(a),t(a)};if(this._createSound){if(!this._isSupported(e.original)){i(`Audio format for ${e.original} not supported`);return}this._createSound(e.load,s,i)}else i(null)}_createSound(e,t,s){if(Wf()){const i=this.manager;if(!i.context){s("Audio manager has no audio context");return}const r={retry:this.maxRetries>0,maxRetries:this.maxRetries};(e.startsWith("blob:")||e.startsWith("data:"))&&(r.responseType=Oe.ResponseType.ARRAY_BUFFER),Pt.get(e,r,(a,o)=>{if(a){s(a);return}i.context.decodeAudioData(o,t,s)})}else{let i=null;try{i=new Audio}catch{s("No support for Audio element");return}hx&&document.body.appendChild(i);const r=function(){i.removeEventListener("canplaythrough",r),hx&&document.body.removeChild(i),t(i)};i.onerror=function(){i.onerror=null,hx&&document.body.removeChild(i),s()},i.addEventListener("canplaythrough",r),i.src=e}}constructor(e){super(e,"audio"),this.manager=e.soundManager}}class LZ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{responseType:Oe.ResponseType.ARRAY_BUFFER,retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t(`Error loading binary resource: ${e.original} [${s}]`):t(null,i)})}openBinary(e){return e.buffer}constructor(e){super(e,"binary")}}class Wn{get model(){if(!this._model){const e=Wn.createModel(this.data,this._defaultMaterial),t=Wn.createAsset(this._assetName,"model",e,0);this._assets.add(t),this._model=t}return this._model}static createAsset(e,t,s,i){const r=new Ee(`${e}/${t}/${i}`,t,{url:""});return r.resource=s,r.loaded=!0,r}instantiateModelEntity(e){const t=new Nt(void 0,this._assets._loader._app);return t.addComponent("model",Object.assign({type:"asset",asset:this.model},e)),t}instantiateRenderEntity(e){const t=this._defaultMaterial,s=[],i=function(o,h,u,f,m,_,g,S){const x=m[u.id],T=x===void 0?t:f[x],E=new lt(u,T);u.morph&&(E.morphInstance=new Pl(u.morph)),g.hasOwnProperty("skin")&&s.push({meshInstance:E,rootBone:o,entity:h});const b=S.get(g);if(b){const C=b.matrices,w=Ti.getDefaultInstancingFormat(u.device),P=new Yr(u.device,w,C.length/16,{data:C});E.setInstancing(P),E.instancingData._destroyVertexBuffer=!0}return E},r=(o,h,u)=>{const f=new Nt(void 0,this._assets._loader._app);h._cloneInternal(f),o||(o=f);let m=null,_=null;for(let S=0;S<u.nodes.length;S++)if(u.nodes[S]===h){const T=u.gltf.nodes[S];if(T.hasOwnProperty("mesh")){const E=u.renders[T.mesh].meshes;_=this.renders[T.mesh];for(let b=0;b<E.length;b++){const C=E[b];if(C){const w=i(o,f,C,u.materials,u.meshDefaultMaterials,u.skins,T,u.nodeInstancingMap);m||(m=[]),m.push(w)}}}if(u.lights){const E=u.lights.get(T);E&&f.addChild(E.clone())}if(u.cameras){const E=u.cameras.get(T);E&&E.camera.system.cloneComponent(E,f)}}m&&(f.addComponent("render",Object.assign({type:"asset",meshInstances:m},e)),f.render.assignAsset(_));const g=h.children;for(let S=0;S<g.length;S++){const x=r(o,g[S],u);f.addChild(x)}return f},a=[];for(const o of this.data.scenes)a.push(r(null,o,this.data));return s.forEach(o=>{o.meshInstance.skinInstance=ki.createCachedSkinInstance(o.meshInstance.mesh.skin,o.rootBone,o.entity),o.meshInstance.node.render.rootBone=o.rootBone}),Wn.createSceneHierarchy(a,Nt)}getMaterialVariants(){return this.data.variants?Object.keys(this.data.variants):[]}applyMaterialVariant(e,t){const s=t?this.data.variants[t]:null;if(s===void 0)return;const i=e.findComponents("render");for(let r=0;r<i.length;r++){const a=i[r];this._applyMaterialVariant(s,a.meshInstances)}}applyMaterialVariantInstances(e,t){const s=t?this.data.variants[t]:null;s!==void 0&&this._applyMaterialVariant(s,e)}_applyMaterialVariant(e,t){t.forEach(s=>{if(e===null)s.material=this._defaultMaterial;else{const i=this.data.meshVariants[s.mesh.id];i&&(s.material=this.data.materials[i[e]])}})}static createSceneHierarchy(e,t){let s=null;if(e.length===1)s=e[0];else{s=new t("SceneGroup");for(const i of e)s.addChild(i)}return s}static createModel(e,t){const s=function(a,o,h,u,f,m,_){const g=e.meshDefaultMaterials[o.id],S=g===void 0?t:f[g],x=new lt(o,S,m);if(o.morph){const T=new Pl(o.morph);x.morphInstance=T,a.morphInstances.push(T)}if(_.hasOwnProperty("skin")){const T=_.skin,E=h[T];o.skin=E;const b=u[T];x.skinInstance=b,a.skinInstances.push(b)}a.meshInstances.push(x)},i=new rn,r=[];for(const a of e.skins){const o=new Yf(a);o.bones=a.bones,r.push(o)}i.graph=Wn.createSceneHierarchy(e.scenes,Dt);for(let a=0;a<e.nodes.length;a++){const o=e.nodes[a];if(o.root===i.graph){const h=e.gltf.nodes[a];if(h.hasOwnProperty("mesh")){const u=e.renders[h.mesh].meshes;for(let f=0;f<u.length;f++){const m=u[f];m&&s(i,m,e.skins,r,e.materials,o,h)}}}}return i}destroy(){const e=this._assets,t=function(i){e.remove(i),i.unload()},s=function(i){i.forEach(r=>{t(r)})};this.animations&&(s(this.animations),this.animations=null),this.textures&&(s(this.textures),this.textures=null),this.materials&&(s(this.materials),this.materials=null),this.renders&&(s(this.renders),this.renders=null),this._model&&(t(this._model),this._model=null),this.data=null,this.assets=null}constructor(e,t,s,i){const r=function(u,f,m){const _=Wn.createAsset(t.name,u,f,m);return s.add(_),_},a=[];for(let u=0;u<e.renders.length;++u)a.push(r("render",e.renders[u],u));const o=[];for(let u=0;u<e.materials.length;++u)o.push(r("material",e.materials[u],u));const h=[];for(let u=0;u<e.animations.length;++u)h.push(r("animation",e.animations[u],u));this.data=e,this._model=null,this._assetName=t.name,this._assets=s,this._defaultMaterial=i,this.renders=a,this.materials=o,this.textures=e.textures,this.animations=h}}class IZ{_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}load(e,t,s){Ee.fetchArrayBuffer(e.load,(i,r)=>{i?t(i):wg.parse(this._getUrlWithoutParams(e.original),Re.extractPath(e.load),r,this._device,s.registry,s.options,(a,o)=>{a?t(a):t(null,new Wn(o,s,this._assets,this._defaultMaterial))})},s,this.maxRetries)}open(e,t,s){return t}patch(e,t){}constructor(e,t,s){this._device=e,this._assets=t,this._defaultMaterial=wg.createDefaultMaterial(),this.maxRetries=s}}class OZ extends Rt{set maxRetries(e){this.glbContainerParser.maxRetries=e;for(const t in this.parsers)this.parsers.hasOwnProperty(t)&&(this.parsers[t].maxRetries=e)}get maxRetries(){return this.glbContainerParser.maxRetries}_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}_getParser(e){const t=e?Re.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".",""):null;return this.parsers[t]||this.glbContainerParser}load(e,t,s){typeof e=="string"&&(e={load:e,original:e}),this._getParser(e.original).load(e,t,s)}open(e,t,s){return this._getParser(e).open(e,t,s)}constructor(e){super(e,"container"),this.glbContainerParser=new IZ(e.graphicsDevice,e.assets,0),this.parsers={}}}class NZ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t(`Error loading css resource: ${e.original} [${s}]`):t(null,i)})}openBinary(e){return this.decoder??(this.decoder=new TextDecoder("utf-8")),this.decoder.decode(e)}constructor(e){super(e,"css"),this.decoder=null}}class FZ extends Rt{load(e,t,s){this.loadAssets(s,t)}open(e,t,s){return s?s.resource:null}patch(e,t){this.loadAssets(e,(s,i)=>{s&&(t.fire("error",e),t.fire(`error:${e.id}`,s,e),e.fire("error",e))})}getAssetIds(e){const t=[];if(t[0]=e.file,(e.loadFaces||!e.file)&&e.data&&e.data.textures)for(let s=0;s<6;++s)t[s+1]=e.data.textures[s];else t[1]=t[2]=t[3]=t[4]=t[5]=t[6]=null;return t}compareAssetIds(e,t){return e&&t?parseInt(e,10)===e||typeof e=="string"?e===t:e.url===t.url:e!==null==(t!==null)}update(e,t,s){const i=e.data||{},r=e._handlerState.assets,a=e._resources;let o,h,u;const f=[null,null,null,null,null,null,null],m=function(){return i.hasOwnProperty("type")?i.type:i.hasOwnProperty("rgbm")?i.rgbm?Sl:qr:null};if(!e.loaded||s[0]!==r[0]){if(s[0])if(o=s[0].resource,o.cubemap)for(u=0;u<6;++u)f[u+1]=new De(this._device,{name:`${e.name}_prelitCubemap${o.width>>u}`,cubemap:!0,type:m()||o.type,width:o.width>>u,height:o.height>>u,format:o.format,levels:[o._levels[u]],addressU:Te,addressV:Te,mipmaps:u===0});else f[1]=o}else f[1]=a[1]||null,f[2]=a[2]||null,f[3]=a[3]||null,f[4]=a[4]||null,f[5]=a[5]||null,f[6]=a[6]||null;const _=s.slice(1);if(!e.loaded||!this.cmpArrays(_,r.slice(1))){if(_.indexOf(null)===-1){const g=_.map(E=>E.resource),S=[];for(h=0;h<g[0]._levels.length;++h)S.push(g.map(E=>E._levels[h]));const x=g[0].format,T=new De(this._device,{name:`${e.name}_faces`,cubemap:!0,type:m()||g[0].type,width:g[0].width,height:g[0].height,format:x===Ja?Ze:x,mipmaps:i.mipmaps??!0,levels:S,minFilter:i.hasOwnProperty("minFilter")?i.minFilter:g[0].minFilter,magFilter:i.hasOwnProperty("magFilter")?i.magFilter:g[0].magFilter,anisotropy:i.hasOwnProperty("anisotropy")?i.anisotropy:1,addressU:Te,addressV:Te});f[0]=T}}else f[0]=a[0]||null;if(!this.cmpArrays(f,a))for(e.resources=f,e._handlerState.assetIds=t,e._handlerState.assets=s,u=0;u<a.length;++u)a[u]!==null&&f.indexOf(a[u])===-1&&a[u].destroy();for(u=0;u<r.length;++u)r[u]!==null&&s.indexOf(r[u])===-1&&r[u].unload()}cmpArrays(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;++s)if(e[s]!==t[s])return!1;return!0}resolveId(e){const t=parseInt(e,10);return t===e||t.toString()===e?t:e}loadAssets(e,t){e.hasOwnProperty("_handlerState")||(e._handlerState={assetIds:[null,null,null,null,null,null,null],assets:[null,null,null,null,null,null,null]});const s=this,i=s.getAssetIds(e),r=[null,null,null,null,null,null,null],a=e._handlerState.assetIds,o=e._handlerState.assets,h=s._registry;let u=7;const f=function(S,x){r[S]=x,u--,u===0&&(s.update(e,i,r),t(null,e.resources))},m=function(S,x,T){t(x)},_=function(S,x){x.loaded?f(S,x):(h.once(`load:${x.id}`,f.bind(s,S)),h.once(`error:${x.id}`,m.bind(s,S)),x.loading||h.load(x))};let g;for(let S=0;S<7;++S){const x=this.resolveId(i[S]);if(!x)f(S,null);else if(s.compareAssetIds(x,a[S]))_(S,o[S]);else if(parseInt(x,10)===x)g=h.get(x),g?_(S,g):setTimeout(((T,E)=>{const b=h.get(E);b?_(T,b):m(T,`failed to find dependent cubemap asset=${E}`)}).bind(null,S,x));else{const T=typeof x=="string"?{url:x,filename:x}:x,E=T.url.search(".dds")===-1?{type:"rgbp",addressu:"clamp",addressv:"clamp",mipmaps:!1}:null;g=new Ee(`${e.name}_part_${S}`,"texture",T,E),h.add(g),_(S,g)}}}constructor(e){super(e,"cubemap"),this._device=e.graphicsDevice,this._registry=e.assets,this._loader=e.loader}}class BZ extends Rt{load(e,t){t(null,null)}constructor(e){super(e,"folder")}}class NR{set data(e){if(this._data=e,!!e&&(this._data.intensity!==void 0&&(this.intensity=this._data.intensity),this._data.info||(this._data.info={}),(!this._data.version||this._data.version<2)&&(this._data.info.maps=[{width:this._data.info.width,height:this._data.info.height}],this._data.chars)))for(const t in this._data.chars)this._data.chars[t].map=0}get data(){return this._data}constructor(e,t){this.type=t&&t.type||Tg,this.em=1,this.textures=e,this.intensity=0,this._data=null,this.data=t}}function ux(c){return c.version<3&&(c.version<2&&(c.info.maps=c.info.maps||[{width:c.info.width,height:c.info.height}]),c.chars=Object.keys(c.chars||{}).reduce((e,t)=>{const s=c.chars[t],i=s.letter!==void 0?s.letter:T_.fromCodePoint(t);return c.version<2&&(s.map=s.map||0),e[i]=s,e},{}),c.version=3),c}class UZ extends Rt{load(e,t,s){typeof e=="string"&&(e={load:e,original:e});const i=this;Re.getExtension(e.original)===".json"?Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(r,a)=>{if(r)t(`Error loading font resource: ${e.original} [${r}]`);else{const o=ux(a);i._loadTextures(e.load.replace(".json",".png"),o,(h,u)=>{h?t(h):t(null,{data:o,textures:u})})}}):(s&&s.data&&(s.data=ux(s.data)),this._loadTextures(e.load,s&&s.data,t))}_loadTextures(e,t,s){const i=t.info.maps.length;let r=0,a=null;const o=new Array(i),h=this._loader,u=function(f){const m=function(_,g){if(!a){if(_){a=_,s(_);return}g.upload(),o[f]=g,r++,r===i&&s(null,o)}};f===0?h.load(e,"texture",m):h.load(e.replace(".png",`${f}.png`),"texture",m)};for(let f=0;f<i;f++)u(f)}open(e,t,s){let i;return t.textures?i=new NR(t.textures,t.data):i=new NR(t,null),i}patch(e,t){const s=e.resource;!s.data&&e.data?s.data=e.data:!e.data&&s.data&&(e.data=s.data),e.data&&(e.data=ux(e.data))}constructor(e){super(e,"font"),this._loader=e.loader,this.maxRetries=0}}const dx=.28209479177387814;class zZ{constructor(e,t,s,i,r,a){const o=(w,P)=>{const I=(1<<P)-1;return(w&I)/I},h=(w,P)=>{w.x=o(P>>>21,11),w.y=o(P>>>11,10),w.z=o(P,11)},u=(w,P)=>{w.x=o(P>>>24,8),w.y=o(P>>>16,8),w.z=o(P>>>8,8),w.w=o(P,8)},f=(w,P)=>{const I=Math.SQRT2,M=(o(P>>>20,10)-.5)*I,R=(o(P>>>10,10)-.5)*I,L=(o(P,10)-.5)*I,B=Math.sqrt(1-(M*M+R*R+L*L));switch(P>>>30){case 0:w.set(M,R,L,B);break;case 1:w.set(B,R,L,M);break;case 2:w.set(R,B,L,M);break;case 3:w.set(R,L,B,M);break}},m=(w,P,I)=>w*(1-I)+P*I,{chunkData:_,chunkSize:g,vertexData:S,shData0:x,shData1:T,shData2:E,shBands:b}=e,C=[3,8,15][b-1];this.read=w=>{const P=Math.floor(w/256)*g;if(t&&(h(t,S[w*4+0]),t.x=m(_[P+0],_[P+3],t.x),t.y=m(_[P+1],_[P+4],t.y),t.z=m(_[P+2],_[P+5],t.z)),s&&f(s,S[w*4+1]),i&&(h(i,S[w*4+2]),i.x=m(_[P+6],_[P+9],i.x),i.y=m(_[P+7],_[P+10],i.y),i.z=m(_[P+8],_[P+11],i.z)),r&&(u(r,S[w*4+3]),g>12&&(r.x=m(_[P+12],_[P+15],r.x),r.y=m(_[P+13],_[P+16],r.y),r.z=m(_[P+14],_[P+17],r.z))),a&&b>0){const I=[x,T,E];for(let M=0;M<3;++M)for(let R=0;R<15;++R)a[M*15+R]=R<C?I[M][w*16+R]*(8/255)-4:0}}}}class kZ{createIter(e,t,s,i,r){return new zZ(this,e,t,s,i,r)}calcAabb(e){const{chunkData:t,numChunks:s,chunkSize:i}=this;let r=Math.exp(Math.max(t[9],t[10],t[11])),a=t[0]-r,o=t[1]-r,h=t[2]-r,u=t[3]+r,f=t[4]+r,m=t[5]+r;for(let _=1;_<s;++_){const g=_*i;r=Math.exp(Math.max(t[g+9],t[g+10],t[g+11])),a=Math.min(a,t[g+0]-r),o=Math.min(o,t[g+1]-r),h=Math.min(h,t[g+2]-r),u=Math.max(u,t[g+3]+r),f=Math.max(f,t[g+4]+r),m=Math.max(m,t[g+5]+r)}return e.center.set((a+u)*.5,(o+f)*.5,(h+m)*.5),e.halfExtents.set((u-a)*.5,(f-o)*.5,(m-h)*.5),!0}getCenters(){const{vertexData:e,chunkData:t,numChunks:s,chunkSize:i}=this,r=new Float32Array(this.numSplats*3);let a,o,h,u,f,m;for(let _=0;_<s;++_){const g=_*i;a=t[g+0],o=t[g+1],h=t[g+2],u=t[g+3],f=t[g+4],m=t[g+5];const S=Math.min(this.numSplats,(_+1)*256);for(let x=_*256;x<S;++x){const T=e[x*4],E=(T>>>21)/2047,b=(T>>>11&1023)/1023,C=(T&2047)/2047;r[x*3+0]=(1-E)*a+E*u,r[x*3+1]=(1-b)*o+b*f,r[x*3+2]=(1-C)*h+C*m}}return r}getChunks(e){const{chunkData:t,numChunks:s,chunkSize:i}=this;let r,a,o,h,u,f;for(let m=0;m<s;++m){const _=m*i;r=t[_+0],a=t[_+1],o=t[_+2],h=t[_+3],u=t[_+4],f=t[_+5],e[m*6+0]=r,e[m*6+1]=a,e[m*6+2]=o,e[m*6+3]=h,e[m*6+4]=u,e[m*6+5]=f}}calcFocalPoint(e){const{chunkData:t,numChunks:s,chunkSize:i}=this;e.x=0,e.y=0,e.z=0;for(let r=0;r<s;++r){const a=r*i;e.x+=t[a+0]+t[a+3],e.y+=t[a+1]+t[a+4],e.z+=t[a+2]+t[a+5]}e.mulScalar(.5/s)}get isCompressed(){return!0}get numChunks(){return Math.ceil(this.numSplats/256)}get chunkSize(){return this.chunkData.length/this.numChunks}decompress(){const e=["x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity","scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3"],{shBands:t}=this;if(t>0){const f=[];for(let _=0;_<45;++_)f.push(`f_rest_${_}`);const m=Math.max(...["f_dc_0","f_dc_1","f_dc_2"].map(_=>e.indexOf(_)));e.splice(m+1,0,...f)}const s={};e.forEach(f=>{s[f]=new Float32Array(this.numSplats)});const i=new D,r=new pe,a=new D,o=new me,h=t>0?new Float32Array(45):null,u=this.createIter(i,r,a,o,h);for(let f=0;f<this.numSplats;++f)if(u.read(f),s.x[f]=i.x,s.y[f]=i.y,s.z[f]=i.z,s.rot_1[f]=r.x,s.rot_2[f]=r.y,s.rot_3[f]=r.z,s.rot_0[f]=r.w,s.scale_0[f]=a.x,s.scale_1[f]=a.y,s.scale_2[f]=a.z,s.f_dc_0[f]=(o.x-.5)/dx,s.f_dc_1[f]=(o.y-.5)/dx,s.f_dc_2[f]=(o.z-.5)/dx,s.opacity[f]=o.w<=0?-40:o.w>=1?40:-Math.log(1/o.w-1),h)for(let m=0;m<45;++m)s[`f_rest_${m}`][f]=h[m];return new Ml([{name:"vertex",count:this.numSplats,properties:e.map(f=>({name:f,type:"float",byteSize:4,storage:s[f]}))}],this.comments)}}const VZ=(c,e,t,s,i)=>{for(let r=0;r<i;++r)for(let a=0;a<s;++a)c[r*e+a]=t[r*s+a]};class GZ extends Js{destroy(){this.packedTexture?.destroy(),this.chunkTexture?.destroy(),this.shTexture0?.destroy(),this.shTexture1?.destroy(),this.shTexture2?.destroy(),super.destroy()}configureMaterialDefines(e){e.set("GSPLAT_COMPRESSED_DATA",!0),e.set("SH_BANDS",this.shTexture0?3:0)}configureMaterial(e){this.configureMaterialDefines(e.defines),e.setParameter("packedTexture",this.packedTexture),e.setParameter("chunkTexture",this.chunkTexture),this.shTexture0&&(e.setParameter("shTexture0",this.shTexture0),e.setParameter("shTexture1",this.shTexture1),e.setParameter("shTexture2",this.shTexture2))}evalTextureSize(e){const t=Math.ceil(Math.sqrt(e)),s=Math.ceil(e/t);return new ne(t,s)}constructor(e,t){super(e,t);const{chunkData:s,chunkSize:i,numChunks:r,numSplats:a,vertexData:o,shBands:h}=t;this.chunks=new Float32Array(r*6),t.getChunks(this.chunks),this.packedTexture=this.createTexture("packedData",Ps,this.evalTextureSize(a),o);const u=this.evalTextureSize(r);u.x*=5,this.chunkTexture=this.createTexture("chunkData",fs,u);const f=this.chunkTexture.lock();if(VZ(f,20,s,i,r),i===12)for(let m=0;m<r;++m)f[m*20+15]=1,f[m*20+16]=1,f[m*20+17]=1;if(this.chunkTexture.unlock(),h>0){const m=this.evalTextureSize(a);this.shTexture0=this.createTexture("shTexture0",Ps,m,new Uint32Array(t.shData0.buffer)),this.shTexture1=this.createTexture("shTexture1",Ps,m,new Uint32Array(t.shData1.buffer)),this.shTexture2=this.createTexture("shTexture2",Ps,m,new Uint32Array(t.shData2.buffer))}else this.shTexture0=null,this.shTexture1=null,this.shTexture2=null}}const FR=new Uint8Array([112,108,121,10]),BR=new Uint8Array([10,101,110,100,95,104,101,97,100,101,114,10]),IT=new Map([["char",Int8Array],["uchar",Uint8Array],["short",Int16Array],["ushort",Uint16Array],["int",Int32Array],["uint",Uint32Array],["float",Float32Array],["double",Float64Array]]);class HZ{async read(){const{value:e,done:t}=await this.reader.read();if(t)throw new Error("Stream finished before end of header");this.push(e),this.progressFunc?.(e.byteLength)}push(e){if(!this.data)this.data=e,this.view=new DataView(this.data.buffer),this.tail=e.length;else{const t=this.tail-this.head,s=t+e.length;if(this.data.length>=s)this.head>0?(this.data.copyWithin(0,this.head,this.tail),this.data.set(e,t),this.head=0,this.tail=s):(this.data.set(e,this.tail),this.tail+=e.length);else{const i=new Uint8Array(s);this.head>0||this.tail<this.data.length?i.set(this.data.subarray(this.head,this.tail),0):i.set(this.data,0),i.set(e,t),this.data=i,this.view=new DataView(this.data.buffer),this.head=0,this.tail=s}}}compact(){this.head>0&&(this.data.copyWithin(0,this.head,this.tail),this.tail-=this.head,this.head=0)}get remaining(){return this.tail-this.head}getInt8(){const e=this.view.getInt8(this.head);return this.head++,e}getUint8(){const e=this.view.getUint8(this.head);return this.head++,e}getInt16(){const e=this.view.getInt16(this.head,!0);return this.head+=2,e}getUint16(){const e=this.view.getUint16(this.head,!0);return this.head+=2,e}getInt32(){const e=this.view.getInt32(this.head,!0);return this.head+=4,e}getUint32(){const e=this.view.getUint32(this.head,!0);return this.head+=4,e}getFloat32(){const e=this.view.getFloat32(this.head,!0);return this.head+=4,e}getFloat64(){const e=this.view.getFloat64(this.head,!0);return this.head+=8,e}constructor(e,t){this.head=0,this.tail=0,this.reader=e,this.progressFunc=t}}const WZ=c=>{const e=[],t=[];let s;for(let i=1;i<c.length;++i){const r=c[i].split(" ");switch(r[0]){case"comment":t.push(r.slice(1).join(" "));break;case"format":s=r[1];break;case"element":e.push({name:r[1],count:parseInt(r[2],10),properties:[]});break;case"property":{if(!IT.has(r[1]))throw new Error(`Unrecognized property data type '${r[1]}' in ply header`);e[e.length-1].properties.push({type:r[1],name:r[2],storage:null,byteSize:IT.get(r[1]).BYTES_PER_ELEMENT});break}default:throw new Error(`Unrecognized header value '${r[0]}' in ply header`)}}return{elements:e,format:s,comments:t}},XZ=c=>{const e=["min_x","min_y","min_z","max_x","max_y","max_z","min_scale_x","min_scale_y","min_scale_z","max_scale_x","max_scale_y","max_scale_z","min_r","min_g","min_b","max_r","max_g","max_b"],t=["packed_position","packed_rotation","packed_scale","packed_color"],s=new Array(45).fill("").map((a,o)=>`f_rest_${o}`),i=()=>c[0].name==="chunk"&&c[0].properties.every((a,o)=>a.name===e[o]&&a.type==="float")&&c[1].name==="vertex"&&c[1].properties.every((a,o)=>a.name===t[o]&&a.type==="uint"),r=()=>c[2].name==="sh"&&[9,24,45].indexOf(c[2].properties.length)!==-1&&c[2].properties.every((a,o)=>a.name===s[o]&&a.type==="uchar");return c.length===2&&i()||c.length===3&&i()&&r()},qZ=c=>c.length===1&&c[0].name==="vertex"&&c[0].properties.every(e=>e.type==="float"),YZ=async(c,e,t)=>{const s=new kZ;s.comments=t;const i=e[0].count,r=e[0].properties.length,a=e[1].count,h=(f=>{const m=Math.ceil(Math.sqrt(f)),_=Math.ceil(f/m);return m*_})(a);s.numSplats=a,s.chunkData=new Float32Array(i*r),s.vertexData=new Uint32Array(h*4);const u=async(f,m)=>{const _=new Uint8Array(f);let g=0;for(;g<m;){for(;c.remaining===0;)await c.read();const S=Math.min(m-g,c.remaining),x=c.data;for(let T=0;T<S;++T)_[g++]=x[c.head++]}};if(await u(s.chunkData.buffer,i*r*4),await u(s.vertexData.buffer,a*4*4),e.length===3){const f=h*16,m=new Uint8Array(f),_=new Uint8Array(f),g=new Uint8Array(f),S=1024,x=e[2].properties.length/3,T=new Uint8Array(S*x*3);for(let E=0;E<s.numSplats;E+=S){const b=Math.min(S,s.numSplats-E);await u(T.buffer,b*x*3);for(let C=0;C<b;++C)for(let w=0;w<15;++w){const P=(E+C)*16+w;w<x?(m[P]=T[(C*3+0)*x+w],_[P]=T[(C*3+1)*x+w],g[P]=T[(C*3+2)*x+w]):(m[P]=127,_[P]=127,g[P]=127)}}s.shData0=m,s.shData1=_,s.shData2=g,s.shBands={3:1,8:2,15:3}[x]}else s.shBands=0;return s},jZ=async(c,e,t)=>{const s=e[0],i=s.properties,r=i.length,a=i.map(m=>m.storage),o=i.reduce((m,_)=>m+_.byteSize,0);let h=0,u;const f=()=>{const m=c.data.buffer;u?.buffer!==m&&(u=new Float32Array(m,0,m.byteLength/4))};for(f();h<s.count;){for(;c.remaining<o;)await c.read(),f();const m=Math.min(s.count-h,Math.floor(c.remaining/o));for(let _=0;_<r;++_){const g=a[_];for(let S=0;S<m;++S)g[S+h]=u[S*r+_]}h+=m,c.head+=m*o}return new Ml(e,t)},$Z=async(c,e,t)=>{for(let s=0;s<e.length;++s){const i=e[s],r=i.properties.reduce((h,u)=>h+u.byteSize,0),a=i.properties.map(h=>{if(h.storage)switch(h.type){case"char":return(u,f)=>{h.storage[f]=u.getInt8()};case"uchar":return(u,f)=>{h.storage[f]=u.getUint8()};case"short":return(u,f)=>{h.storage[f]=u.getInt16()};case"ushort":return(u,f)=>{h.storage[f]=u.getUint16()};case"int":return(u,f)=>{h.storage[f]=u.getInt32()};case"uint":return(u,f)=>{h.storage[f]=u.getUint32()};case"float":return(u,f)=>{h.storage[f]=u.getFloat32()};case"double":return(u,f)=>{h.storage[f]=u.getFloat64()};default:throw new Error(`Unsupported property data type '${h.type}' in ply header`)}else return u=>{u.head+=h.byteSize}});let o=0;for(;o<i.count;){for(;c.remaining<r;)await c.read();const h=Math.min(i.count-o,Math.floor(c.remaining/r));for(let u=0;u<h;++u){for(let f=0;f<i.properties.length;++f)a[f](c,o);o++}}}return new Ml(e,t)},KZ=async(c,e=null,t=null)=>{const s=(_,g)=>{const S=_.length-g.length;let x,T;for(x=0;x<=S;++x){for(T=0;T<g.length&&_[x+T]===g[T];++T);if(T===g.length)return x}return-1},i=(_,g)=>{if(_.length<g.length)return!1;for(let S=0;S<g.length;++S)if(_[S]!==g[S])return!1;return!0},r=new HZ(c,t);let a;for(;;){if(await r.read(),r.tail>=FR.length&&!i(r.data,FR))throw new Error("Invalid ply header");if(a=s(r.data,BR),a!==-1)break}const o=new TextDecoder("ascii").decode(r.data.subarray(0,a)).split(`
`),{elements:h,format:u,comments:f}=WZ(o);if(u!=="binary_little_endian")throw new Error("Unsupported ply format");return r.head=a+BR.length,r.compact(),await(async()=>XZ(h)?await YZ(r,h,f):(h.forEach(_=>{_.properties.forEach(g=>{const S=IT.get(g.type);if(S){const x=!e||e(g.name)?new S(_.count):null;g.storage=x}})}),qZ(h)?await jZ(r,h,f):await $Z(r,h,f)))()},ZZ=c=>!0;class QZ{async load(e,t,s){try{const i=await(s.file?.contents??fetch(e.load));if(!i||!i.body)t("Error loading resource",null);else{const r=parseInt(i.headers.get("content-length")??"0",10);let a=0;const o=await KZ(i.body.getReader(),s.data.elementFilter??ZZ,u=>{a+=u,s&&s.fire("progress",a,r)});s.fire("load:data",o),o.isCompressed||(s.data.reorder??!0)&&o.reorderData();const h=o.isCompressed&&!s.data.decompress?new GZ(this.app.graphicsDevice,o):new ib(this.app.graphicsDevice,o.isCompressed?o.decompress():o);t(null,h)}}catch(i){t(i,null)}}open(e,t){return t}constructor(e,t){this.app=e,this.maxRetries=t}}const JZ=(c,e)=>{const t=new Map,s=()=>{let i=0,r=0;t.forEach(a=>{i+=a.loaded,r+=a.total}),c.fire("progress",i,r)};e.forEach(i=>{const r=(o,h)=>{t.set(i,{loaded:o,total:h}),s()},a=()=>{i.off("progress",r),i.off("load",a),i.off("error",a)};i.on("progress",r),i.on("load",a),i.on("error",a)})},eQ=c=>{const e={version:1,count:c.means.shape[0],means:{mins:c.means.mins,maxs:c.means.maxs,files:c.means.files},scales:{mins:c.scales.mins,maxs:c.scales.maxs,files:c.scales.files},quats:{files:c.quats.files},sh0:{mins:c.sh0.mins,maxs:c.sh0.maxs,files:c.sh0.files}};return c.shN&&(e.shN={mins:c.shN.mins,maxs:c.shN.maxs,files:c.shN.files}),e};class tQ{_shouldAbort(e,t){return!!(t||!this.app.assets.get(e.id)||!this.app?.graphicsDevice||this.app.graphicsDevice._destroyed)}async loadTextures(e,t,s,i){i.version!==2&&(i=eQ(i));const{assets:r}=this.app,a=["means","quats","scales","sh0","shN"],o={},h=[];a.forEach(x=>{const T=i[x]?.files??[];o[x]=T.map(E=>{const b=new Ee(E,"texture",{url:s.options?.mapUrl?.(E)??new URL(E,new URL(e.load,window.location.href).toString()).toString(),filename:E},{mipmaps:!1},{crossOrigin:"anonymous"}),C=new Promise((w,P)=>{b.on("load",()=>w(null)),b.on("error",I=>P(I))});return r.add(b),h.push(C),b})});const u=a.map(x=>o[x]).flat();let f=!1;if(s.once("unload",()=>{f=!0,u.forEach(x=>{r.remove(x),x.unload()})}),JZ(s,u),u.forEach(x=>r.load(x)),await Promise.allSettled(h),this._shouldAbort(s,f)){u.forEach(x=>{r.remove(x),x.unload()}),t(null,null);return}const m=new mf;m.url=e.original,m.meta=i,m.numSplats=i.count,m.means_l=o.means[0].resource,m.means_u=o.means[1].resource,m.quats=o.quats[0].resource,m.scales=o.scales[0].resource,m.sh0=o.sh0[0].resource,m.sh_centroids=o.shN?.[0]?.resource,m.sh_labels=o.shN?.[1]?.resource,m.shBands=mf.calcBands(m.sh_centroids?.width);const _=s.data?.decompress,g=s.options?.minimalMemory??!1;if(m.minimalMemory=g,!_){if(this._shouldAbort(s,f)){m.destroy(),t(null,null);return}await m.prepareGpuData()}if(this._shouldAbort(s,f)){m.destroy(),t(null,null);return}const S=_?new ib(this.app.graphicsDevice,await m.decompress()):new gL(this.app.graphicsDevice,m);if(this._shouldAbort(s,f)){S.destroy(),t(null,null);return}t(null,S)}load(e,t,s){if(s.data?.means)this.loadTextures(e,t,s,s.data);else{typeof e=="string"&&(e={load:e,original:e});const i={retry:this.maxRetries>0,maxRetries:this.maxRetries,responseType:Oe.ResponseType.JSON};Pt.get(e.load,i,(r,a)=>{if(this._shouldAbort(s,!1)){t(null,null);return}r?t(`Error loading gsplat meta: ${e.original} [${r}]`):this.loadTextures(e,t,s,a)})}}constructor(e,t){this.app=e,this.maxRetries=t}}const sQ=c=>{const e=new DataView(c),t=f=>e.getUint16(f,!0),s=f=>e.getUint32(f,!0),i=f=>({magic:s(f),numFiles:t(f+8),cdSizeBytes:s(f+12),cdOffsetBytes:s(f+16)}),r=f=>{const m=t(f+28),_=t(f+30),g=t(f+32);return{magic:s(f),compressionMethod:t(f+10),compressedSizeBytes:s(f+20),uncompressedSizeBytes:s(f+24),lfhOffsetBytes:s(f+42),filename:new TextDecoder().decode(new Uint8Array(c,f+46,m)),recordSizeBytes:46+m+_+g}},a=f=>{const m=t(f+26),_=t(f+28);return{magic:s(f),offsetBytes:f+30+m+_}},o=i(e.byteLength-22);if(o.magic!==101010256)throw new Error("Invalid zip file: EOCDR not found");if(o.cdOffsetBytes===4294967295||o.cdSizeBytes===4294967295)throw new Error("Invalid zip file: Zip64 not supported");const h=[];let u=o.cdOffsetBytes;for(let f=0;f<o.numFiles;f++){const m=r(u);if(m.magic!==33639248)throw new Error("Invalid zip file: CDR not found");const _=a(m.lfhOffsetBytes);if(_.magic!==67324752)throw new Error("Invalid zip file: LFH not found");h.push({filename:m.filename,compression:{0:"none",8:"deflate"}[m.compressionMethod]??"unknown",data:new Uint8Array(c,_.offsetBytes,m.compressedSizeBytes)}),u+=m.recordSizeBytes}return h},iQ=async c=>{const e=new DecompressionStream("deflate-raw"),t=new Blob([c]).stream().pipeThrough(e),s=await new Response(t).arrayBuffer();return new Uint8Array(s)},rQ=async(c,e)=>{const t=await(e.file?.contents??fetch(c.load));if(!t)throw new Error("Error loading resource");if(t instanceof Response){if(!t.ok)throw new Error(`Error loading resource: ${t.status} ${t.statusText}`);const s=parseInt(t.headers.get("content-length")??"0",10);if(!t.body||!t.body.getReader){const o=await t.arrayBuffer();return e.fire("progress",o.byteLength,s),o}const i=t.body.getReader(),r=[];let a=0;try{for(;;){const{done:o,value:h}=await i.read();if(o)break;r.push(h),a+=h.byteLength,e.fire("progress",a,s)}}finally{i.releaseLock()}return new Blob(r).arrayBuffer()}return t};class aQ{async load(e,t,s){try{const i=await rQ(e,s),r=sQ(i);for(const T of r)T.compression==="deflate"&&(T.data=await iQ(T.data));const a=r.find(T=>T.filename==="meta.json");if(!a){t("Error: meta.json not found");return}let o;try{o=JSON.parse(new TextDecoder().decode(a.data))}catch(T){t(`Error parsing meta.json: ${T}`);return}const h=["means","scales","quats","sh0","shN"].map(T=>o[T]?.files??[]).flat(),u={},f=[];for(const T of h){const E=r.find(w=>w.filename===T);let b;if(E)b=new Ee(T,"texture",{url:`${e.load}/${T}`,filename:T,contents:E.data},{mipmaps:!1},{crossOrigin:"anonymous"});else{const w=new URL(T,new URL(T,window.location.href).toString()).toString();b=new Ee(T,"texture",{url:w,filename:T},{mipmaps:!1},{crossOrigin:"anonymous"})}const C=new Promise((w,P)=>{b.on("load",()=>w(null)),b.on("error",I=>P(I))});this.app.assets.add(b),u[T]=b,f.push(C)}Object.values(u).forEach(T=>this.app.assets.load(T)),await Promise.allSettled(f);const{assets:m}=this.app;s.once("unload",()=>{Object.values(u).forEach(T=>{m.remove(T),T.unload()})});const _=s.data?.decompress,g=s.options?.minimalMemory??!1,S=new mf;S.url=e.original,S.minimalMemory=g,S.meta=o,S.numSplats=o.count,S.means_l=u[o.means.files[0]].resource,S.means_u=u[o.means.files[1]].resource,S.quats=u[o.quats.files[0]].resource,S.scales=u[o.scales.files[0]].resource,S.sh0=u[o.sh0.files[0]].resource,S.sh_centroids=u[o.shN?.files[0]]?.resource,S.sh_labels=u[o.shN?.files[1]]?.resource,S.shBands=mf.calcBands(S.sh_centroids?.width),_||await S.prepareGpuData();const x=_?new ib(this.app.graphicsDevice,await S.decompress()):new gL(this.app.graphicsDevice,S);t(null,x)}catch(i){t(i)}}constructor(e,t=3){this.app=e,this.maxRetries=t}}class nQ{load(e){}unload(e){}getResource(e){}destroy(){}}class oQ extends nQ{destroy(){this._destroyed=!0;for(const e of this._urlToAsset.values())e.fire("unload",e),e.off("load"),e.off("error"),this._registry.remove(e),e.unload();this._urlToAsset.clear(),this._loadQueue.length=0,this._currentlyLoading.clear(),this._retryCount.clear()}_canLoad(){return!!this._registry.loader?.getHandler("gsplat")}load(e){this._urlToAsset.get(e)?.loaded||this._currentlyLoading.has(e)||this._loadQueue.includes(e)||(this._currentlyLoading.size<this.maxConcurrentLoads?this._startLoading(e):this._loadQueue.push(e))}_startLoading(e){this._currentlyLoading.add(e);let t=this._urlToAsset.get(e);t||(t=new Ee(e,"gsplat",{url:e},{},{minimalMemory:!0}),this._registry.add(t),this._urlToAsset.set(e,t)),t.once("load",()=>this._onAssetLoadSuccess(e,t)),t.once("error",s=>this._onAssetLoadError(e,t,s)),!t.loaded&&!t.loading&&this._registry.load(t)}_onAssetLoadSuccess(e,t){this._destroyed||!this._urlToAsset.has(e)||(this._currentlyLoading.delete(e),this._retryCount.delete(e),this._processQueue())}_onAssetLoadError(e,t,s){if(this._destroyed||!this._canLoad()||!this._urlToAsset.has(e))return;const i=this._retryCount.get(e)||0;i<this.maxRetries?(this._retryCount.set(e,i+1),t.loaded=!1,t.loading=!1,this._registry.load(t)):(this._currentlyLoading.delete(e),this._retryCount.delete(e),this._processQueue())}_processQueue(){if(!(this._destroyed||!this._canLoad()))for(;this._currentlyLoading.size<this.maxConcurrentLoads&&this._loadQueue.length>0;){const e=this._loadQueue.shift();e&&this._startLoading(e)}}unload(e){this._currentlyLoading.delete(e);const t=this._loadQueue.indexOf(e);t!==-1&&this._loadQueue.splice(t,1),this._retryCount.delete(e);const s=this._urlToAsset.get(e);s&&(s.fire("unload",s),s.off("load"),s.off("error"),this._registry.remove(s),s.unload(),this._urlToAsset.delete(e)),this._processQueue()}getResource(e){return this._urlToAsset.get(e)?.resource}constructor(e){super(),this._urlToAsset=new Map,this.maxConcurrentLoads=2,this.maxRetries=2,this._currentlyLoading=new Set,this._loadQueue=[],this._retryCount=new Map,this._destroyed=!1,this._registry=e}}class lQ{load(e,t,s){typeof e=="string"&&(e={load:e,original:e});const i={retry:this.maxRetries>0,maxRetries:this.maxRetries,responseType:Oe.ResponseType.JSON};Pt.get(e.load,i,(r,a)=>{if(r)t(`Error loading gsplat octree: ${e.original} [${r}]`);else{const o=new oQ(this.app.assets),h=new oI(s.file.url,a,o);t(null,h)}})}constructor(e,t){this.app=e,this.maxRetries=t}}class cQ extends Rt{_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}_getParser(e){const t=Re.getBasename(this._getUrlWithoutParams(e)).toLowerCase();if(t==="lod-meta.json")return this.parsers.octree;const s=Re.getExtension(t).replace(".","");return this.parsers[s]||this.parsers.ply}load(e,t,s){typeof e=="string"&&(e={load:e,original:e}),this._getParser(e.original).load(e,t,s)}open(e,t,s){return t}constructor(e){super(e,"gsplat"),this.parsers={ply:new QZ(e,3),sog:new aQ(e),json:new tQ(e,3),octree:new lQ(e,3)}}}class OT{static setCompressedPRS(e,t,s){const i=s.singleVecs;let r,a;const o=t.___1;o||(r=s.tripleVecs,a=t.___2);let h=o?o[0]:r[a];e.setLocalPosition(i[h],i[h+1],i[h+2]),h=o?o[1]:r[a+1],e.setLocalEulerAngles(i[h],i[h+1],i[h+2]),h=o?o[2]:r[a+2],e.setLocalScale(i[h],i[h+1],i[h+2])}static oneCharToKey(e,t){const s=e.charCodeAt(0)-t.fieldFirstCode;return t.fieldArray[s]}static multCharToKey(e,t){let s=0;for(let i=0;i<e.length;i++)s=s*t.fieldCodeBase+e.charCodeAt(i)-t.fieldFirstCode;return t.fieldArray[s]}}class Cg{run(){const e=Object.prototype.toString.call(this._node);return e==="[object Object]"?this._handleMap():e==="[object Array]"?this._handleArray():this._result=this._node,this._result}_handleMap(){this._result={},Object.keys(this._node).forEach(this._handleKey,this)}_handleKey(e){let t=e;const s=e.length;s===1?t=OT.oneCharToKey(e,this._data):s===2&&(t=OT.multCharToKey(e,this._data)),this._result[t]=new Cg(this._node[e],this._data).run()}_handleArray(){this._result=[],this._node.forEach(this._handleArElt,this)}_handleArElt(e){const t=new Cg(e,this._data).run();this._result.push(t)}constructor(e,t){this._node=e,this._data=t}}class db{parse(e){const t={};let s=null;const i=e.compressedFormat;i&&!e.entDecompressed&&(e.entDecompressed=!0,e.entities=new Cg(e.entities,i).run());for(const r in e.entities){const a=e.entities[r],o=this._createEntity(a,i);t[r]=o,a.parent===null&&(s=o)}for(const r in e.entities){const a=t[r],o=e.entities[r].children,h=o.length;for(let u=0;u<h;u++){const f=t[o[u]];f&&a.addChild(f)}}return this._openComponentData(s,e.entities),s}_createEntity(e,t){const s=new Nt(e.name,this._app);if(s.setGuid(e.resource_id),this._setPosRotScale(s,e,t),s._enabled=e.enabled??!0,this._isTemplate?s._template=!0:s._enabledInHierarchy=s._enabled,s.template=e.template,e.tags)for(let i=0;i<e.tags.length;i++)s.tags.add(e.tags[i]);return s}_setPosRotScale(e,t,s){if(s)OT.setCompressedPRS(e,t,s);else{const i=t.position,r=t.rotation,a=t.scale;e.setLocalPosition(i[0],i[1],i[2]),e.setLocalEulerAngles(r[0],r[1],r[2]),e.setLocalScale(a[0],a[1],a[2])}}_openComponentData(e,t){const s=this._app.systems.list;let i=s.length;const r=t[e.getGuid()];for(let o=0;o<i;o++){const h=s[o],u=r.components[h.id];u&&h.addComponent(e,u)}i=r.children.length;const a=e._children;for(let o=0;o<i;o++)a[o]&&(a[o]=this._openComponentData(a[o],t));return e}constructor(e,t){this._app=e,this._isTemplate=t}}class _I{static load(e,t,s){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{retry:t>0,maxRetries:t},(i,r)=>{if(!i)s(i,r);else{let a=`Error while loading scene JSON ${e.original}`;i.message?(a+=`: ${i.message}`,i.stack&&(a+=`
${i.stack}`)):a+=`: ${i}`,s(a)}})}}class hQ extends Rt{load(e,t){_I.load(e,this.maxRetries,t)}open(e,t){this._app.systems.script.preloading=!0;const i=new db(this._app,!1).parse(t);return this._app.systems.script.preloading=!1,i}constructor(e){super(e,"hierarchy")}}class uQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t(`Error loading html resource: ${e.original} [${s}]`):t(null,i)})}openBinary(e){return this.decoder??(this.decoder=new TextDecoder("utf-8")),this.decoder.decode(e)}constructor(e){super(e,"html"),this.decoder=null}}class dQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e});const s={retry:this.maxRetries>0,maxRetries:this.maxRetries};e.load.startsWith("blob:")&&(s.responseType=Oe.ResponseType.JSON),Pt.get(e.load,s,(i,r)=>{i?t(`Error loading JSON resource: ${e.original} [${i}]`):t(null,r)})}openBinary(e){return this.decoder??(this.decoder=new TextDecoder("utf-8")),JSON.parse(this.decoder.decode(e))}constructor(e){super(e,"json"),this.decoder=null}}class fQ{setInvalid(e,t){this.valid=!1,this.removeInvalid&&delete t[e]}validate(e){const t=Oh,s=HG,i=e.mappingFormat==="path";for(const r in e){const a=t[r];if(!a){s[r]?delete e[r]:this.valid=!1;continue}if(a.startsWith("enum")){const o=a.split(":")[1];this.enumValidators[o]&&(this.enumValidators[o](e[r])||this.setInvalid(r,e))}else if(a==="number")typeof e[r]!="number"&&this.setInvalid(r,e);else if(a==="boolean")typeof e[r]!="boolean"&&this.setInvalid(r,e);else if(a==="string")typeof e[r]!="string"&&this.setInvalid(r,e);else if(a==="vec2")e[r]instanceof Array&&e[r].length===2||this.setInvalid(r,e);else if(a==="rgb")e[r]instanceof Array&&e[r].length===3||this.setInvalid(r,e);else if(a==="texture")i?typeof e[r]=="string"||e[r]===null||e[r]instanceof De||this.setInvalid(r,e):typeof e[r]=="number"||e[r]===null||e[r]instanceof De||this.setInvalid(r,e);else if(a==="boundingbox")e[r].center&&e[r].center instanceof Array&&e[r].center.length===3||this.setInvalid(r,e),e[r].halfExtents&&e[r].halfExtents instanceof Array&&e[r].halfExtents.length===3||this.setInvalid(r,e);else if(a==="cubemap")typeof e[r]=="number"||e[r]===null||e[r]===void 0||e[r]instanceof De&&e[r].cubemap||this.setInvalid(r,e);else if(a==="chunks"){const o=Object.keys(e[r]);for(let h=0;h<o.length;h++)typeof e[r][o[h]]!="string"&&this.setInvalid(o[h],e[r])}else console.error(`Unknown material type: ${a}`)}return e.validated=!0,this.valid}_createEnumValidator(e){return function(t){return e.indexOf(t)>=0}}constructor(){this.removeInvalid=!0,this.valid=!0,this.enumValidators={occludeSpecular:this._createEnumValidator([L2,Pv,I2]),cull:this._createEnumValidator([Ft,_l,Fd,AB]),blendType:this._createEnumValidator([DE,rf,jr,qi,ro,PE,RE,ME,LE,IE,OE]),depthFunc:this._createEnumValidator([wB,X_,q_,kx,CB,DB,PB,$a])}}}class mQ{parse(e){const t=this.migrate(e),s=this._validate(t),i=new vr;return this.initialize(i,s),i}initialize(e,t){if(t.validated||(t=this._validate(t)),t.chunks&&t.chunks&&Object.keys(t.chunks).length>0){const s=e.shaderChunks.glsl;Object.entries(t.chunks).forEach(([i,r])=>s.set(i,r))}for(const s in t){const i=Oh[s],r=t[s];if(i==="vec2")e[s]=new ne(r[0],r[1]);else if(i==="rgb")e[s]=new ue(r[0],r[1],r[2]);else if(i==="texture")r instanceof De?e[s]=r:e[s]instanceof De&&typeof r=="number"&&r>0||(e[s]=null);else if(i==="cubemap")r instanceof De?e[s]=r:e[s]instanceof De&&typeof r=="number"&&r>0||(e[s]=null),s==="cubeMap"&&!r&&(e.prefilteredCubemaps=null);else if(i==="boundingbox"){const a=new D(r.center[0],r.center[1],r.center[2]),o=new D(r.halfExtents[0],r.halfExtents[1],r.halfExtents[2]);e[s]=new Ge(a,o)}else e[s]=t[s]}e.update()}migrate(e){e.shader&&delete e.shader,e.mapping_format&&(e.mappingFormat=e.mapping_format,delete e.mapping_format);let t;const s=[["bumpMapFactor","bumpiness"],["aoUvSet","aoMapUv"],["aoMapVertexColor","aoVertexColor"],["diffuseMapVertexColor","diffuseVertexColor"],["emissiveMapVertexColor","emissiveVertexColor"],["specularMapVertexColor","specularVertexColor"],["metalnessMapVertexColor","metalnessVertexColor"],["opacityMapVertexColor","opacityVertexColor"],["glossMapVertexColor","glossVertexColor"],["lightMapVertexColor","lightVertexColor"],["specularMapTint","specularTint"],["metalnessMapTint","metalnessTint"],["clearCoatGlossiness","clearCoatGloss"]];for(t=0;t<s.length;t++){const r=s[t][0],a=s[t][1];e[r]!==void 0&&(e[a]===void 0&&(e[a]=e[r]),delete e[r])}const i=["fresnelFactor","shadowSampleType"];for(t=0;t<i.length;t++){const r=i[t];e.hasOwnProperty(r)&&delete e[r]}return e}_validate(e){return e.validated||(this._validator||(this._validator=new fQ),this._validator.validate(e)),e}constructor(){this._validator=null}}const pQ={aoMap:"white",aoDetailMap:"white",diffuseMap:"gray",diffuseDetailMap:"gray",specularMap:"gray",specularityFactorMap:"white",metalnessMap:"black",glossMap:"gray",sheenMap:"black",sheenGlossMap:"gray",clearCoatMap:"black",clearCoatGlossMap:"gray",clearCoatNormalMap:"normal",refractionMap:"white",emissiveMap:"gray",normalMap:"normal",normalDetailMap:"normal",heightMap:"gray",opacityMap:"gray",sphereMap:"gray",lightMap:"white",thicknessMap:"black",iridescenceMap:"black",iridescenceThicknessMap:"black",envAtlas:"black",anisotropyMap:"black"};class _Q extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t&&t(`Error loading material: ${e.original} [${s}]`):t&&(i._engine=!0,t(null,i))})}open(e,t){const s=this._parser.parse(t);return t._engine&&(s._data=t,delete t._engine),s}patch(e,t){e.resource._data&&(e._data=e.resource._data,delete e.resource._data),e.data.name=e.name,e.resource.name=e.name,this._bindAndAssignAssets(e,t),e.off("unload",this._onAssetUnload,this),e.on("unload",this._onAssetUnload,this)}_onAssetUnload(e){delete e.data.parameters,delete e.data.chunks,delete e.data.name}_assignTexture(e,t,s){t.resource[e]=s}_getPlaceholderTexture(e){const t=pQ[e];return dl(this._device,t)}_assignPlaceholderTexture(e,t){t.resource[e]=this._getPlaceholderTexture(e)}_onTextureLoad(e,t,s){this._assignTexture(e,t,s.resource),t.resource.update()}_onTextureAdd(e,t,s){this._assets.load(s)}_onTextureRemoveOrUnload(e,t,s){const i=t.resource;i&&t.resource[e]===s.resource&&(this._assignPlaceholderTexture(e,t),i.update())}_assignCubemap(e,t,s){if(t.resource[e]=s[0],e==="cubeMap"){const i=s.slice(1);i.every(r=>r)?t.resource.prefilteredCubemaps=i:i[0]&&(t.resource.envAtlas=i[0])}}_onCubemapLoad(e,t,s){this._assignCubemap(e,t,s.resources),this._parser.initialize(t.resource,t.data)}_onCubemapAdd(e,t,s){this._assets.load(s)}_onCubemapRemoveOrUnload(e,t,s){const i=t.resource;t.data.prefilteredCubeMap128===s.resources[1]&&(this._assignCubemap(e,t,[null,null,null,null,null,null,null]),i.update())}_bindAndAssignAssets(e,t){const s=this._parser.migrate(e.data),i=e.resource,r=s.mappingFormat==="path",a=Iv;let o,h,u;for(o=0;o<a.length;o++){h=a[o],u=i._assetReferences[h];const m=s[h],_=i[h],g=_===this._getPlaceholderTexture(h),S=s.validated;m&&(!_||!S||g)?(u||(u=new _f(h,e,t,{load:this._onTextureLoad,add:this._onTextureAdd,remove:this._onTextureRemoveOrUnload,unload:this._onTextureRemoveOrUnload},this),i._assetReferences[h]=u),r?u.url=e.getAbsoluteUrl(m):u.id=m,u.asset&&(u.asset.resource?this._assignTexture(h,e,u.asset.resource):this._assignPlaceholderTexture(h,e),t.load(u.asset))):u&&(r?u.url=null:u.id=null)}const f=eb;for(o=0;o<f.length;o++)h=f[o],u=i._assetReferences[h],s[h]&&!e.data.prefilteredCubeMap128&&(u||(u=new _f(h,e,t,{load:this._onCubemapLoad,add:this._onCubemapAdd,remove:this._onCubemapRemoveOrUnload,unload:this._onCubemapRemoveOrUnload},this),i._assetReferences[h]=u),r?u.url=s[h]:u.id=s[h],u.asset&&(u.asset.loaded&&this._assignCubemap(h,e,u.asset.resources),t.load(u.asset)));this._parser.initialize(i,s)}constructor(e){super(e,"material"),this._assets=e.assets,this._device=e.graphicsDevice,this._parser=new mQ}}class gQ{parse(e,t,s){wg.parse("filename.glb","",e,this._device,this._assets,s?.options??{},(i,r)=>{if(i)t(i);else{const a=Wn.createModel(r,this._defaultMaterial);r.destroy(),t(null,a)}})}constructor(e){this._device=e.device,this._defaultMaterial=e.defaultMaterial,this._assets=e.assets}}const vQ={points:cv,lines:hv,lineloop:HM,linestrip:fE,triangles:ka,trianglestrip:zr,trianglefan:cl},SQ={int8:co,uint8:Va,int16:ho,uint16:Nl,int32:Wh,uint32:Xh,float32:ct};class yQ{parse(e,t){const s=e.model;if(!s){t(null,null);return}if(s.version<=1){t("JsonModelParser#parse: Trying to parse unsupported model format.");return}const i=this._parseNodes(e),r=this._parseSkins(e,i),a=this._parseVertexBuffers(e),o=this._parseIndexBuffers(e,a),h=this._parseMorphs(e,i,a),u=this._parseMeshes(e,r.skins,h.morphs,a,o.buffer,o.data),f=this._parseMeshInstances(e,i,u,r.skins,r.instances,h.morphs,h.instances),m=new rn;m.graph=i[0],m.meshInstances=f,m.skinInstances=r.instances,m.morphInstances=h.instances,m.getGraph().syncHierarchy(),t(null,m)}_parseNodes(e){const t=e.model,s=[];let i;for(i=0;i<t.nodes.length;i++){const r=t.nodes[i],a=new Dt(r.name);a.setLocalPosition(r.position[0],r.position[1],r.position[2]),a.setLocalEulerAngles(r.rotation[0],r.rotation[1],r.rotation[2]),a.setLocalScale(r.scale[0],r.scale[1],r.scale[2]),a.scaleCompensation=!!r.scaleCompensation,s.push(a)}for(i=1;i<t.parents.length;i++)s[t.parents[i]].addChild(s[i]);return s}_parseSkins(e,t){const s=e.model,i=[],r=[];let a,o;for(a=0;a<s.skins.length;a++){const h=s.skins[a],u=[];for(o=0;o<h.inverseBindMatrices.length;o++){const g=h.inverseBindMatrices[o];u[o]=new fe().set(g)}const f=new lL(this._device,u,h.boneNames);i.push(f);const m=new Yf(f),_=[];for(o=0;o<f.boneNames.length;o++){const g=f.boneNames[o],S=t[0].findByName(g);_.push(S)}m.bones=_,r.push(m)}return{skins:i,instances:r}}_getMorphVertexCount(e,t,s){for(let i=0;i<e.meshes.length;i++){const r=e.meshes[i];if(r.morph===t)return s[r.vertices].numVertices}}_parseMorphs(e,t,s){const i=e.model,r=[],a=[];let o,h,u,f,m,_;if(i.morphs){const g=function(S,x,T){const E=new Float32Array(T*3);for(let b=0;b<x.length;b++){const C=x[b]*3;E[C]=S[b*3],E[C+1]=S[b*3+1],E[C+2]=S[b*3+2]}return E};for(o=0;o<i.morphs.length;o++){for(f=i.morphs[o].targets,_=[],u=this._getMorphVertexCount(i,o,s),h=0;h<f.length;h++){const T=f[h].aabb,E=T.min,b=T.max,C=new Ge(new D((b[0]+E[0])*.5,(b[1]+E[1])*.5,(b[2]+E[2])*.5),new D((b[0]-E[0])*.5,(b[1]-E[1])*.5,(b[2]-E[2])*.5)),w=f[h].indices;let P=f[h].deltaPositions,I=f[h].deltaNormals;w&&(P=g(P,w,u),I=g(I,w,u)),m=new Lv({deltaPositions:P,deltaNormals:I,name:f[h].name,aabb:C}),_.push(m)}const S=new sL(_,this._device);r.push(S);const x=new Pl(S);a.push(x)}}return{morphs:r,instances:a}}_parseVertexBuffers(e){const t=e.model,s=[],i={position:He,normal:si,tangent:Xr,blendWeight:kr,blendIndices:yi,color:Rs,texCoord0:Zi,texCoord1:Il,texCoord2:Of,texCoord3:Nf,texCoord4:Ff,texCoord5:Bf,texCoord6:Uf,texCoord7:zf};for(let r=0;r<t.vertices.length;r++){const a=t.vertices[r],o=[];for(const _ in a){const g=a[_];o.push({semantic:i[_],components:g.components,type:SQ[g.type],normalize:i[_]===Rs})}const h=new Ti(this._device,o),u=a.position.data.length/a.position.components,f=new Yr(this._device,h,u),m=new zd(f);for(let _=0;_<u;_++){for(const g in a){const S=a[g];switch(S.components){case 1:m.element[i[g]].set(S.data[_]);break;case 2:m.element[i[g]].set(S.data[_*2],1-S.data[_*2+1]);break;case 3:m.element[i[g]].set(S.data[_*3],S.data[_*3+1],S.data[_*3+2]);break;case 4:m.element[i[g]].set(S.data[_*4],S.data[_*4+1],S.data[_*4+2],S.data[_*4+3]);break}}m.next()}m.end(),s.push(f)}return s}_parseIndexBuffers(e,t){const s=e.model;let i=null,r=null,a,o=0;for(a=0;a<s.meshes.length;a++){const u=s.meshes[a];u.indices!==void 0&&(o+=u.indices.length)}let h=0;for(a=0;a<t.length;a++)h=Math.max(h,t[a].numVertices);return o>0&&(h>65535?(i=new bl(this._device,eo,o),r=new Uint32Array(i.lock())):(i=new bl(this._device,Ka,o),r=new Uint16Array(i.lock()))),{buffer:i,data:r}}_parseMeshes(e,t,s,i,r,a){const o=e.model,h=[];let u=0;for(let f=0;f<o.meshes.length;f++){const m=o.meshes[f],_=m.aabb,g=_.min,S=_.max,x=new Ge(new D((S[0]+g[0])*.5,(S[1]+g[1])*.5,(S[2]+g[2])*.5),new D((S[0]-g[0])*.5,(S[1]-g[1])*.5,(S[2]-g[2])*.5)),T=m.indices!==void 0,E=new Ct(this._device);E.vertexBuffer=i[m.vertices],E.indexBuffer[0]=T?r:null,E.primitive[0].type=vQ[m.type],E.primitive[0].base=T?m.base+u:m.base,E.primitive[0].count=m.count,E.primitive[0].indexed=T,E.skin=m.skin!==void 0?t[m.skin]:null,E.morph=m.morph!==void 0?s[m.morph]:null,E.aabb=x,T&&(a.set(m.indices,u),u+=m.indices.length),h.push(E)}return r!==null&&r.unlock(),h}_parseMeshInstances(e,t,s,i,r,a,o){const h=e.model,u=[];let f;for(f=0;f<h.meshInstances.length;f++){const m=h.meshInstances[f],_=t[m.node],g=s[m.mesh],S=new lt(g,this._defaultMaterial,_);if(g.skin){const x=i.indexOf(g.skin);S.skinInstance=r[x]}if(g.morph){const x=a.indexOf(g.morph);S.morphInstance=o[x]}u.push(S)}return u}constructor(e){this._device=e.device,this._defaultMaterial=e.defaultMaterial}}class xQ extends Rt{load(e,t,s){typeof e=="string"&&(e={load:e,original:e});const i={retry:this.maxRetries>0,maxRetries:this.maxRetries};(e.load.startsWith("blob:")||e.load.startsWith("data:"))&&(Re.getExtension(e.original).toLowerCase()===".glb"?i.responseType=Oe.ResponseType.ARRAY_BUFFER:i.responseType=Oe.ResponseType.JSON),Pt.get(e.load,i,(r,a)=>{if(t)if(r)t(`Error loading model: ${e.original} [${r}]`);else{for(let o=0;o<this._parsers.length;o++){const h=this._parsers[o];if(h.decider(e.original,a)){h.parser.parse(a,(u,f)=>{u?t(u):t(null,f)},s);return}}t("No parsers found")}})}open(e,t){return t}patch(e,t){if(!e.resource)return;const s=e.data,i=this;e.resource.meshInstances.forEach((r,a)=>{if(s.mapping){const o=function(m){m.resource?r.material=m.resource:(m.once("load",o),t.load(m)),m.once("remove",_=>{r.material===_.resource&&(r.material=i.defaultMaterial)})};if(!s.mapping[a]){r.material=i.defaultMaterial;return}const h=s.mapping[a].material,u=s.mapping[a].path;let f;if(h!==void 0)h?(f=t.get(h),f?o(f):t.once(`add:${h}`,o)):r.material=i.defaultMaterial;else if(u){const m=e.getAbsoluteUrl(s.mapping[a].path);f=t.getByUrl(m),f?o(f):t.once(`add:url:${m}`,o)}}})}addParser(e,t){this._parsers.push({parser:e,decider:t})}constructor(e){super(e,"model"),this._parsers=[],this.device=e.graphicsDevice,this.assets=e.assets,this.defaultMaterial=jf(this.device),this.addParser(new yQ(this),(t,s)=>Re.getExtension(t)===".json"),this.addParser(new gQ(this),(t,s)=>Re.getExtension(t)===".glb")}}class TQ extends Rt{load(e,t){_I.load(e,this.maxRetries,t)}open(e,t){this._app.systems.script.preloading=!0;const i=new db(this._app,!1).parse(t),r=this._app.scene;return r.root=i,this._app.applySceneSettings(t.settings),this._app.systems.script.preloading=!1,r}constructor(e){super(e,"scene")}}class jn{static push(e){jn._types.push(e)}}jn._types=[];const EQ=new Set(["system","entity","create","destroy","swap","move","data","scripts","_scripts","_scriptsIndex","_scriptsData","enabled","_oldState","onEnable","onDisable","onPostStateChange","_onSetEnabled","_checkState","_onBeforeRemove","_onInitializeAttributes","_onInitialize","_onPostInitialize","_onUpdate","_onPostUpdate","_callbacks","_callbackActive","has","get","on","off","fire","once","hasEvent","worker"]),bQ={};go.reservedNames.forEach((c,e,t)=>{bQ[c]=1});function AQ(c,e,t){if(typeof c!="function")throw new Error(`script class: '${c}' must be a constructor function (i.e. class).`);if(!(c.prototype instanceof zs))throw new Error(`script class: '${Hd.__getScriptName(c)}' does not extend pc.Script.`);if(e=e||c.__name||Hd.__getScriptName(c),EQ.has(e))throw new Error(`script name: '${e}' is reserved, please change script name`);c.__name=e,Yn.getApplication().scripts.add(c),jn.push(c)}const wQ=c=>c[0].toLowerCase()+c.substring(1);class CQ extends Rt{clearCache(){for(const e in this._cache){const t=this._cache[e],s=t.parentNode;s&&s.removeChild(t)}this._cache={}}load(e,t){typeof e=="string"&&(e={load:e,original:e});const s=this;this._app;const i=(e.load,(o,h,u)=>{if(o)t(o);else{const f={};for(let _=0;_<jn._types.length;_++)f[jn._types[_].name]=jn._types[_];jn._types.length=0,t(null,f,u);const m=h.split("&hash=")[0];delete s._loader._cache[xh.makeKey(m,"script")]}}),[r]=e.load.split("?");r.endsWith(".mjs")?this._loadModule(r,i):this._loadScript(e.load,i)}open(e,t){return t}patch(e,t){}_loadScript(e,t){const s=document.head,i=document.createElement("script");this._cache[e]=i,i.async=!1,i.addEventListener("error",a=>{t(`Script: ${a.target.src} failed to load`)},!1);let r=!1;i.onload=i.onreadystatechange=function(){!r&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")&&(r=!0,t(null,e,i))},i.src=e,s.appendChild(i)}_loadModule(e,t){const i=Ve.browser&&window.location.origin!=="null"?window.location.origin+window.location.pathname:import.meta.url,r=new URL(e,i);import(r.toString()).then(a=>{const o=r.pathname.split("/").pop(),h=this._app.assets.find(o,"script")?.data?.scripts;for(const u in a){const f=a[u];if(f.prototype instanceof zs){const _=wQ(f.name);f.scriptName;const g=f.scriptName??_;AQ(f,g),h&&this._app.scripts.addSchema(g,h[g])}}t(null,e,null)}).catch(a=>{t(a)})}constructor(e){super(e,"script"),this._scripts={},this._cache={}}}class DQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t(`Error loading shader resource: ${e.original} [${s}]`):t(null,i)})}openBinary(e){return this.decoder??(this.decoder=new TextDecoder("utf-8")),this.decoder.decode(e)}constructor(e){super(e,"shader"),this.decoder=null}}function fx(c){const e=this;e.resource&&(e.resource.atlas=c.resource)}function mx(c){this.registry.load(c)}class PQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Re.getExtension(e.original)===".json"&&Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t(s):t(null,i)})}open(e,t){const s=new PG(this._device);return e&&(s.__data=t),s}patch(e,t){const s=e.resource;if(s.__data&&(e.data.pixelsPerUnit=s.__data.pixelsPerUnit,e.data.renderMode=s.__data.renderMode,e.data.frameKeys=s.__data.frameKeys,s.__data.textureAtlasAsset)){const i=t.getByUrl(s.__data.textureAtlasAsset);i?e.data.textureAtlasAsset=i.id:console.warn(`Could not find textureatlas with url: ${s.__data.textureAtlasAsset}`)}s.startUpdate(),s.renderMode=e.data.renderMode,s.pixelsPerUnit=e.data.pixelsPerUnit,s.frameKeys=e.data.frameKeys,this._updateAtlas(e),s.endUpdate(),e.off("change",this._onAssetChange,this),e.on("change",this._onAssetChange,this)}_updateAtlas(e){const t=e.resource;if(!e.data.textureAtlasAsset){t.atlas=null;return}this._assets.off(`load:${e.data.textureAtlasAsset}`,fx,e),this._assets.on(`load:${e.data.textureAtlasAsset}`,fx,e);const s=this._assets.get(e.data.textureAtlasAsset);s&&s.resource?t.atlas=s.resource:s?this._assets.load(s):(this._assets.off(`add:${e.data.textureAtlasAsset}`,mx,e),this._assets.on(`add:${e.data.textureAtlasAsset}`,mx,e))}_onAssetChange(e,t,s,i){t==="data"&&s&&s.textureAtlasAsset&&i&&s.textureAtlasAsset!==i.textureAtlasAsset&&(this._assets.off(`load:${i.textureAtlasAsset}`,fx,e),this._assets.off(`add:${i.textureAtlasAsset}`,mx,e))}constructor(e){super(e,"sprite"),this._assets=e.assets,this._device=e.graphicsDevice}}class UR{instantiate(){return this._templateRoot||this._parseTemplate(),this._templateRoot.clone()}_parseTemplate(){const e=new db(this._app,!0);this._templateRoot=e.parse(this._data)}set data(e){this._data=e,this._templateRoot=null}get data(){return this._data}constructor(e,t){this._templateRoot=null,this._app=e,this._data=t}}class RQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e});const s={retry:this.maxRetries>0,maxRetries:this.maxRetries};Pt.get(e.load,s,(i,r)=>{i?t(`Error requesting template: ${e.original}`):t(i,r)})}open(e,t){return new UR(this._app,t)}openBinary(e){return this.decoder??(this.decoder=new TextDecoder("utf-8")),new UR(this._app,JSON.parse(this.decoder.decode(e)))}patch(e,t){if(!e||!e.resource||!e.data||!e.data.entities)return;const s=e.resource;s.data=e.data}constructor(e){super(e,"template"),this.decoder=null}}class MQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e}),Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(s,i)=>{s?t(`Error loading text resource: ${e.original} [${s}]`):t(null,i)})}openBinary(e){return this.decoder??(this.decoder=new TextDecoder("utf-8")),this.decoder.decode(e)}constructor(e){super(e,"text"),this.decoder=null}}const f_={repeat:as,clamp:Te,mirror:Lg},m_={nearest:ze,linear:$t,nearest_mip_nearest:Ef,linear_mip_nearest:Af,nearest_mip_linear:bf,linear_mip_linear:Jn},LQ=/^data\.frames\.(\d+)$/;class IQ extends Rt{load(e,t){typeof e=="string"&&(e={load:e,original:e});const s=this,i=this._loader.getHandler("texture");Re.getExtension(e.original)===".json"?Pt.get(e.load,{retry:this.maxRetries>0,maxRetries:this.maxRetries},(r,a)=>{if(r)t(r);else{const o=e.original.replace(".json",".png");s._loader.load(o,"texture",(h,u)=>{h?t(h):t(null,{data:a,texture:u})})}}):i.load(e,t)}open(e,t,s){const i=new RG;if(t.texture&&t.data)i.texture=t.texture,i.__data=t.data;else{const a=this._loader.getHandler("texture").open(e,t,s);if(!a)return null;i.texture=a}return i}patch(e,t){if(!e.resource)return;e.resource.__data&&(e.resource.__data.minfilter!==void 0&&(e.data.minfilter=e.resource.__data.minfilter),e.resource.__data.magfilter!==void 0&&(e.data.magfilter=e.resource.__data.magfilter),e.resource.__data.addressu!==void 0&&(e.data.addressu=e.resource.__data.addressu),e.resource.__data.addressv!==void 0&&(e.data.addressv=e.resource.__data.addressv),e.resource.__data.mipmaps!==void 0&&(e.data.mipmaps=e.resource.__data.mipmaps),e.resource.__data.anisotropy!==void 0&&(e.data.anisotropy=e.resource.__data.anisotropy),e.resource.__data.rgbm!==void 0&&(e.data.rgbm=!!e.resource.__data.rgbm),e.data.frames=e.resource.__data.frames,delete e.resource.__data);const s=e.resource.texture;if(s&&(s.name=e.name,e.data.hasOwnProperty("minfilter")&&s.minFilter!==m_[e.data.minfilter]&&(s.minFilter=m_[e.data.minfilter]),e.data.hasOwnProperty("magfilter")&&s.magFilter!==m_[e.data.magfilter]&&(s.magFilter=m_[e.data.magfilter]),e.data.hasOwnProperty("addressu")&&s.addressU!==f_[e.data.addressu]&&(s.addressU=f_[e.data.addressu]),e.data.hasOwnProperty("addressv")&&s.addressV!==f_[e.data.addressv]&&(s.addressV=f_[e.data.addressv]),e.data.hasOwnProperty("mipmaps")&&s.mipmaps!==e.data.mipmaps&&(s.mipmaps=e.data.mipmaps),e.data.hasOwnProperty("anisotropy")&&s.anisotropy!==e.data.anisotropy&&(s.anisotropy=e.data.anisotropy),e.data.hasOwnProperty("rgbm"))){const r=e.data.rgbm?Sl:qr;s.type!==r&&(s.type=r)}e.resource.texture=s;const i={};for(const r in e.data.frames){const a=e.data.frames[r];i[r]={rect:new me(a.rect),pivot:new ne(a.pivot),border:new me(a.border)}}e.resource.frames=i,e.off("change",this._onAssetChange,this),e.on("change",this._onAssetChange,this)}_onAssetChange(e,t,s){let i;if(t==="data"||t==="data.frames"){const r={};for(const a in s.frames)i=s.frames[a],r[a]={rect:new me(i.rect),pivot:new ne(i.pivot),border:new me(i.border)};e.resource.frames=r}else{const r=t.match(LQ);if(r){const a=r[1];s?(e.resource.frames[a]?(i=e.resource.frames[a],i.rect.set(s.rect[0],s.rect[1],s.rect[2],s.rect[3]),i.pivot.set(s.pivot[0],s.pivot[1]),i.border.set(s.border[0],s.border[1],s.border[2],s.border[3])):e.resource.frames[a]={rect:new me(s.rect),pivot:new ne(s.pivot),border:new me(s.border)},e.resource.fire("set:frame",a,e.resource.frames[a])):e.resource.frames[a]&&(delete e.resource.frames[a],e.resource.fire("remove:frame",a))}}}constructor(e){super(e,"textureatlas"),this._loader=e.loader}}function OQ(){const c={cTFETC1:0,cTFETC2:1,cTFBC1:2,cTFBC3:3,cTFPVRTC1_4_RGB:8,cTFPVRTC1_4_RGBA:9,cTFASTC_4x4:10,cTFATC_RGB:11,cTFATC_RGBA_INTERPOLATED_ALPHA:12,cTFRGBA32:13,cTFRGB565:14,cTFRGBA4444:16},e={astc:c.cTFASTC_4x4,dxt:c.cTFBC1,etc1:c.cTFETC1,etc2:c.cTFETC1,pvr:c.cTFPVRTC1_4_RGB,atc:c.cTFATC_RGB,none:c.cTFRGB565},t={astc:c.cTFASTC_4x4,dxt:c.cTFBC3,etc1:c.cTFRGBA4444,etc2:c.cTFETC2,pvr:c.cTFPVRTC1_4_RGBA,atc:c.cTFATC_RGBA_INTERPOLATED_ALPHA,none:c.cTFRGBA4444},s={ETC1:21,ETC2_RGB:22,ETC2_RGBA:23,DXT1:8,DXT5:10,PVRTC_4BPP_RGB_1:26,PVRTC_4BPP_RGBA_1:27,ASTC_4x4:28,ATC_RGB:29,ATC_RGBA:30,R8_G8_B8_A8:7,R5_G6_B5:3,R4_G4_B4_A4:5},i=(w,P)=>{switch(w){case c.cTFETC1:return P.formats.etc2?s.ETC2_RGB:s.ETC1;case c.cTFETC2:return s.ETC2_RGBA;case c.cTFBC1:return s.DXT1;case c.cTFBC3:return s.DXT5;case c.cTFPVRTC1_4_RGB:return s.PVRTC_4BPP_RGB_1;case c.cTFPVRTC1_4_RGBA:return s.PVRTC_4BPP_RGBA_1;case c.cTFASTC_4x4:return s.ASTC_4x4;case c.cTFATC_RGB:return s.ATC_RGB;case c.cTFATC_RGBA_INTERPOLATED_ALPHA:return s.ATC_RGBA;case c.cTFRGBA32:return s.R8_G8_B8_A8;case c.cTFRGB565:return s.R5_G6_B5;case c.cTFRGBA4444:return s.R4_G4_B4_A4}},r=w=>{const P=function(I,M){const R=I*.00784313725490196-1,L=M*(2/255)-1,B=Math.sqrt(1-Math.min(1,R*R+L*L));return Math.max(0,Math.min(255,Math.floor((B+1)*.5*255)))};for(let I=0;I<w.length;I+=4){const M=w[I+3],R=w[I+1];w[I+0]=M,w[I+2]=P(M,R),w[I+3]=255}return w},a=w=>{const P=new Uint16Array(w.length/4);for(let I=0;I<w.length;I+=4){const M=w[I+0],R=w[I+1],L=w[I+2];P[I/4]=(M&248)<<8|(R&252)<<3|L>>3}return P},o=(w,P)=>(w&w-1)===0&&(P&P-1)===0,h=()=>typeof performance<"u"?performance.now():0;let u,f,m;const _=(w,P,I)=>{if(I){if(w.formats.astc)return"astc"}else if(P){if(w.formats.etc2)return"etc2"}else{if(w.formats.etc2)return"etc2";if(w.formats.etc1)return"etc1"}return(R=>{for(let L=0;L<R.length;++L){const B=R[L];if(w.formats[B])return B}return"none"})(P?m:f)},g=(w,P,I)=>{switch(I){case c.cTFETC1:case c.cTFETC2:return!0;case c.cTFBC1:case c.cTFBC3:return(w&3)===0&&(P&3)===0;case c.cTFPVRTC1_4_RGB:case c.cTFPVRTC1_4_RGBA:return o(w,P);case c.cTFASTC_4x4:return!0;case c.cTFATC_RGB:case c.cTFATC_RGBA_INTERPOLATED_ALPHA:return!0}return!1},S=(w,P,I)=>{if(!u.KTX2File)throw new Error("Basis transcoder module does not include support for KTX2.");const M=h(),R=new u.KTX2File(new Uint8Array(P)),L=R.getWidth(),B=R.getHeight(),G=R.getLevels(),H=!!R.getHasAlpha(),ee=R.isUASTC&&R.isUASTC();if(!L||!B||!G)throw R.close(),R.delete(),new Error(`Invalid image dimensions url=${w} width=${L} height=${B} levels=${G}`);const j=_(I.deviceDetails,H,ee),ae=!!I.isGGGR&&j==="pvr";let k;if(ae?k=c.cTFRGBA32:(k=H?t[j]:e[j],g(L,B,k)||(k=H?c.cTFRGBA32:c.cTFRGB565)),!R.startTranscoding())throw R.close(),R.delete(),new Error(`Failed to start transcoding url=${w}`);let O;const z=[];for(let X=0;X<G;++X){const Y=R.getImageTranscodedSizeInBytes(X,0,0,k),F=new Uint8Array(Y);if(!R.transcodeImage(F,X,0,0,k,0,-1,-1))throw R.close(),R.delete(),new Error(`Failed to transcode image url=${w}`);const U=k===c.cTFRGB565||k===c.cTFRGBA4444;z.push(U?new Uint16Array(F.buffer):F)}if(R.close(),R.delete(),ae)for(k=c.cTFRGB565,O=0;O<z.length;++O)z[O]=a(r(z[O]));return{format:i(k,I.deviceDetails),width:L,height:B,levels:z,cubemap:!1,transcodeTime:h()-M,url:w,unswizzledGGGR:ae}},x=(w,P,I)=>{const M=h(),R=new u.BasisFile(new Uint8Array(P)),L=R.getImageWidth(0,0),B=R.getImageHeight(0,0),G=R.getNumImages(),H=R.getNumLevels(0),ee=!!R.getHasAlpha(),j=R.isUASTC&&R.isUASTC();if(!L||!B||!G||!H)throw R.close(),R.delete(),new Error(`Invalid image dimensions url=${w} width=${L} height=${B} images=${G} levels=${H}`);const ae=_(I.deviceDetails,ee,j),k=!!I.isGGGR&&ae==="pvr";let O;if(k?O=c.cTFRGBA32:(O=ee?t[ae]:e[ae],g(L,B,O)||(O=ee?c.cTFRGBA32:c.cTFRGB565)),!R.startTranscoding())throw R.close(),R.delete(),new Error(`Failed to start transcoding url=${w}`);let z;const X=[];for(let Y=0;Y<H;++Y){const F=R.getImageTranscodedSizeInBytes(0,Y,O),U=new Uint8Array(F);if(!R.transcodeImage(U,0,Y,O,0,0))if(Y===H-1&&F===X[Y-1].buffer.byteLength)U.set(new Uint8Array(X[Y-1].buffer)),console.warn(`Failed to transcode last mipmap level, using previous level instead url=${w}`);else throw R.close(),R.delete(),new Error(`Failed to transcode image url=${w}`);const K=O===c.cTFRGB565||O===c.cTFRGBA4444;X.push(K?new Uint16Array(U.buffer):U)}if(R.close(),R.delete(),k)for(O=c.cTFRGB565,z=0;z<X.length;++z)X[z]=a(r(X[z]));return{format:i(O,I.deviceDetails),width:L,height:B,levels:X,cubemap:!1,transcodeTime:h()-M,url:w,unswizzledGGGR:k}},T=(w,P,I)=>I.isKTX2?S(w,P,I):x(w,P,I),E=(w,P,I)=>{try{const M=T(w,P,I);M.levels=M.levels.map(R=>R.buffer),self.postMessage({url:w,data:M},M.levels)}catch(M){self.postMessage({url:w,err:M},null)}},b=(w,P)=>{const I=(M,R)=>(WebAssembly.instantiate(w.module,M).then(L=>{R(L)}).catch(L=>{console.error(`instantiate failed + ${L}`)}),{});self.BASIS(w.module?{instantiateWasm:I}:null).then(M=>{M.initializeBasis(),u=M,f=w.rgbPriority,m=w.rgbaPriority,P(null)})},C=[];self.onmessage=w=>{const P=w.data;switch(P.type){case"init":b(P.config,()=>{for(let I=0;I<C.length;++I)E(C[I].url,C[I].data,C[I].options);C.length=0});break;case"transcode":u?E(P.url,P.data,P.options):C.push(P);break}}}const NQ=c=>({astc:!!c.extCompressedTextureASTC,atc:!!c.extCompressedTextureATC,dxt:!!c.extCompressedTextureS3TC,etc1:!!c.extCompressedTextureETC1,etc2:!!c.extCompressedTextureETC,pvr:!!c.extCompressedTexturePVRTC}),FQ=(c,e)=>{const t=a=>{const o=["/* basis */",a,"",`(${OQ.toString()})()

`].join(`
`);return new Blob([o],{type:"application/javascript"})},s=()=>{try{if(typeof WebAssembly=="object"&&typeof WebAssembly.instantiate=="function"){const a=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(a instanceof WebAssembly.Module)return new WebAssembly.Instance(a)instanceof WebAssembly.Instance}}catch{}return!1},i=(a,o)=>{e(null,{workerUrl:URL.createObjectURL(t(a)),module:o,rgbPriority:c.rgbPriority,rgbaPriority:c.rgbaPriority})},r={cache:!0,responseType:"text",retry:c.maxRetries>0,maxRetries:c.maxRetries};if(c.glueUrl&&c.wasmUrl&&s()){let a=null,o=null;Pt.get(c.glueUrl,r,(f,m)=>{f?e(f):o?i(m,o):a=m});const h=fetch(c.wasmUrl),u=()=>{h.then(f=>f.arrayBuffer()).then(f=>WebAssembly.compile(f)).then(f=>{a?i(a,f):o=f}).catch(f=>{e(f,null)})};WebAssembly.compileStreaming?WebAssembly.compileStreaming(h).then(f=>{a?i(a,f):o=f}).catch(f=>{u()}):u()}else Pt.get(c.fallbackUrl,r,(a,o)=>{a?e(a,null):i(o,null)})};class BQ{enqueueJob(e,t,s,i){if(this.callbacks.hasOwnProperty(e))this.callbacks[e].push(s);else{this.callbacks[e]=[s];const r={url:e,data:t,options:i};this.clients.length>0?this.clients.shift().run(r):this.queue.push(r)}}enqueueClient(e){this.queue.length>0?e.run(this.queue.shift()):this.clients.push(e)}handleResponse(e,t,s){const i=this.callbacks[e];if(t)for(let r=0;r<i.length;++r)i[r](t);else{s.format===wf||s.format===Cf?s.levels=s.levels.map(r=>new Uint16Array(r)):s.levels=s.levels.map(r=>new Uint8Array(r));for(let r=0;r<i.length;++r)i[r](null,s)}delete this.callbacks[e]}constructor(){this.callbacks={},this.queue=[],this.clients=[]}}class UQ{run(e){const t=[];e.data instanceof ArrayBuffer&&t.push(e.data),this.worker.postMessage({type:"transcode",url:e.url,format:e.format,data:e.data,options:e.options},t),this.eager&&this.queue.enqueueClient(this)}constructor(e,t,s){this.queue=e,this.worker=new Worker(t.workerUrl),this.worker.addEventListener("message",i=>{const r=i.data;this.queue.handleResponse(r.url,r.err,r.data),this.eager||this.queue.enqueueClient(this)}),this.worker.postMessage({type:"init",config:t}),this.eager=s}}const zQ=1,kQ=["etc2","etc1","astc","dxt","pvr","atc"],VQ=["astc","dxt","etc2","pvr","atc"],GQ=5,NT=new BQ;let zR=null,FT=!1;function HQ(c){if(!FT){if(!c)c=zR||{};else if(c.lazyInit){zR=c;return}if(!c.glueUrl||!c.wasmUrl||!c.fallbackUrl){const e=FM.getConfig("BASIS");e&&(c={glueUrl:e.glueUrl,wasmUrl:e.wasmUrl,fallbackUrl:e.fallbackUrl,numWorkers:e.numWorkers})}if(c.glueUrl||c.wasmUrl||c.fallbackUrl){FT=!0;const e=Math.max(1,Math.min(16,c.numWorkers||zQ)),t=c.numWorkers===1||(c.hasOwnProperty("eagerWorkers")?c.eagerWorkers:!0);c.rgbPriority=c.rgbPriority||kQ,c.rgbaPriority=c.rgbaPriority||VQ,c.maxRetries=c.hasOwnProperty("maxRetries")?c.maxRetries:GQ,FQ(c,(s,i)=>{if(s)console.error(`failed to initialize basis worker: ${s}`);else for(let r=0;r<e;++r)NT.enqueueClient(new UQ(NT,i,t))})}}}let px=null;function gI(c,e,t,s,i){return HQ(),px||(px={formats:NQ(c)}),NT.enqueueJob(e,t,s,{deviceDetails:px,isGGGR:!!i?.isGGGR,isKTX2:!!i?.isKTX2}),FT}class tu{load(e,t,s){throw new Error("not implemented")}open(e,t,s){throw new Error("not implemented")}}class WQ extends tu{load(e,t,s){const i=this.device,r=a=>{gI(i,e.load,a,t,{isGGGR:(s?.file?.variants?.basis?.opt&8)!==0})||t(`Basis module not found. Asset [${s.name}](${s.getFileUrl()}) basis texture variant will not be loaded.`)};Ee.fetchArrayBuffer(e.load,(a,o)=>{a?t(a):r(o)},s,this.maxRetries)}open(e,t,s,i={}){const r=i.srgb?lv(t.format):t.format,a=new De(s,{name:e,addressU:t.cubemap?Te:as,addressV:t.cubemap?Te:as,width:t.width,height:t.height,format:r,cubemap:t.cubemap,levels:t.levels,...i});return a.upload(),a}constructor(e,t){super(),this.device=t,this.maxRetries=0}}class XQ extends tu{load(e,t,s){const i=!!s?.file?.contents;if(i){if(this.device.supportsImageBitmap){this._loadImageBitmapFromBlob(new Blob([s.file.contents]),t);return}e={load:URL.createObjectURL(new Blob([s.file.contents])),original:e.original}}const r=(o,h)=>{i&&URL.revokeObjectURL(e.load),t(o,h)};let a;s&&s.options&&s.options.hasOwnProperty("crossOrigin")?a=s.options.crossOrigin:Nh.test(e.load)&&(a=this.crossOrigin),this.device.supportsImageBitmap?this._loadImageBitmap(e.load,e.original,a,r,s):this._loadImage(e.load,e.original,a,r,s)}open(e,t,s,i={}){const r=new De(s,{name:e,width:t.width,height:t.height,format:i.srgb?Us:Ze,...i});return r.setSource(t),r}_loadImage(e,t,s,i,r){const a=new Image;s&&(a.crossOrigin=s);let o=0;const h=this.maxRetries;let u;const f=1024*1024;r?.fire("progress",0,f),a.onload=function(){r?.fire("progress",f,f),i(null,a)},a.onerror=function(){if(!u)if(h>0&&++o<=h){const m=Math.pow(2,o)*100;console.log(`Error loading Texture from: '${t}' - Retrying in ${m}ms...`);const g=e.indexOf("?")>=0?"&":"?";u=setTimeout(()=>{a.src=`${e+g}retry=${Date.now()}`,u=null},m)}else i(`Error loading Texture from: '${t}'`)},a.src=e}_loadImageBitmap(e,t,s,i,r){const a={cache:!0,responseType:"blob",retry:this.maxRetries>0,maxRetries:this.maxRetries,progress:r};Pt.get(e,a,(o,h)=>{o?i(o):this._loadImageBitmapFromBlob(h,i)})}_loadImageBitmapFromBlob(e,t){createImageBitmap(e,{premultiplyAlpha:"none",colorSpaceConversion:"none"}).then(s=>t(null,s)).catch(s=>t(s))}constructor(e,t){super(),this.crossOrigin=e.prefix?"anonymous":null,this.maxRetries=0,this.device=t}}const _x=[1481919403,3140563232,169478669],qQ={33776:Df,33778:Ng,33779:kh,36196:Rf,37492:Ug,37496:zg,35840:Mf,35841:Vh,35842:Lf,35843:Gh,32849:Ja,32856:Ze,35905:Bg,35907:Us,35898:vl,34843:Pf,34842:kt};function YQ(c,e,t,s){return c===vl?new Uint32Array(e,t,s/4):new Uint8Array(e,t,s)}class jQ extends tu{load(e,t,s){Ee.fetchArrayBuffer(e.load,t,s,this.maxRetries)}open(e,t,s,i={}){const r=this.parse(t);if(!r)return null;const a=i.srgb?lv(r.format):r.format,o=new De(s,{name:e,addressU:r.cubemap?Te:as,addressV:r.cubemap?Te:as,width:r.width,height:r.height,format:a,cubemap:r.cubemap,levels:r.levels,...i});return o.upload(),o}parse(e){const t=new Uint32Array(e);if(_x[0]!==t[0]||_x[1]!==t[1]||_x[2]!==t[2])return null;const s={endianness:t[3],glType:t[4],glTypeSize:t[5],glFormat:t[6],glInternalFormat:t[7],glBaseInternalFormat:t[8],pixelWidth:t[9],pixelHeight:t[10],pixelDepth:t[11],numberOfArrayElements:t[12],numberOfFaces:t[13],numberOfMipmapLevels:t[14],bytesOfKeyValueData:t[15]};if(s.pixelDepth>1||s.numberOfArrayElements!==0)return null;const i=qQ[s.glInternalFormat];if(i===void 0)return null;let r=16+s.bytesOfKeyValueData/4;const a=s.numberOfFaces>1,o=[];for(let h=0;h<(s.numberOfMipmapLevels||1);h++){const u=t[r++];a&&o.push([]);const f=a?o[h]:o;for(let m=0;m<(a?6:1);++m)f.push(YQ(i,e,r*4,u)),r+=u+3>>2}return{format:i,width:s.pixelWidth,height:s.pixelHeight,levels:o,cubemap:a}}constructor(e){super(),this.maxRetries=0}}const $Q={KHR_DF_MODEL_UASTC:166};class KQ extends tu{load(e,t,s){Ee.fetchArrayBuffer(e.load,(i,r)=>{i?t(i,r):this.parse(r,e,t,s)},s,this.maxRetries)}open(e,t,s,i={}){const r=i.srgb?lv(t.format):t.format,a=new De(s,{name:e,addressU:t.cubemap?Te:as,addressV:t.cubemap?Te:as,width:t.width,height:t.height,format:r,cubemap:t.cubemap,levels:t.levels,...i});return a.upload(),a}parse(e,t,s,i){const r=new BM(e),a=[r.readU32be(),r.readU32be(),r.readU32be()];if(a[0]!==2873840728||a[1]!==540160187||a[2]!==218765834)return null;const o={vkFormat:r.readU32(),typeSize:r.readU32(),pixelWidth:r.readU32(),pixelHeight:r.readU32(),pixelDepth:r.readU32(),layerCount:r.readU32(),faceCount:r.readU32(),levelCount:r.readU32(),supercompressionScheme:r.readU32()},h={dfdByteOffset:r.readU32(),dfdByteLength:r.readU32(),kvdByteOffset:r.readU32(),kvdByteLength:r.readU32(),sgdByteOffset:r.readU64(),sgdByteLength:r.readU64()},u=[];for(let _=0;_<Math.max(1,o.levelCount);++_)u.push({byteOffset:r.readU64(),byteLength:r.readU64(),uncompressedByteLength:r.readU64()});if(r.readU32()!==h.kvdByteOffset-h.dfdByteOffset)return null;r.skip(8);const m=r.readU8();r.skip(h.dfdByteLength-9),r.skip(h.kvdByteLength),o.supercompressionScheme===1||m===$Q.KHR_DF_MODEL_UASTC?gI(this.device,t.load,e,s,{isGGGR:(i?.file?.variants?.basis?.opt&8)!==0,isKTX2:!0})||s(`Basis module not found. Asset [${i.name}](${i.getFileUrl()}) basis texture variant will not be loaded.`):s("unsupported KTX2 pixel format")}constructor(e,t){super(),this.maxRetries=0,this.device=t}}class ZQ extends tu{load(e,t,s){Ee.fetchArrayBuffer(e.load,t,s,this.maxRetries)}open(e,t,s,i={}){const r=new Uint32Array(t,0,32),a=r[4],o=r[3],h=Math.max(r[7],1),u=r[20]===4,f=r[21],m=r[22],_=r[28]===65024,g=827611204,S=894720068,x=113,T=116,E=826496069,b=825438800,C=825504336,w=825439312,P=825504848;let I=!1,M=!1,R=!1,L=!1,B=null,G=1,H;if(u?f===g?(B=Df,I=!0):f===S?(B=kh,I=!0):f===x?(B=kt,G=2):f===T?(B=fs,G=4):f===E?(B=Rf,I=!0,M=!0):f===b||f===C?(B=f===b?Vh:Gh,I=!0,R=!0):(f===w||f===P)&&(B=f===w?Mf:Lf,I=!0,L=!0):m===32&&(B=Ze),!B)return H=new De(s,{width:4,height:4,format:Ja,name:"dds-legacy-empty"}),H;H=new De(s,{name:e,addressU:_?Te:as,addressV:_?Te:as,width:a,height:o,format:B,cubemap:_,mipmaps:h>1,...i});let ee=128;const j=_?6:1;let ae;const k=4,O=4,z=f===g?8:16;let X,Y,F;for(let U=0;U<j;U++){let K=a,se=o;for(let le=0;le<h;le++){I?M?ae=Math.floor((K+3)/4)*Math.floor((se+3)/4)*8:R?ae=Math.max(K,16)*Math.max(se,8)/4:L?ae=Math.max(K,8)*Math.max(se,8)/2:(X=Math.floor((K+k-1)/k),Y=Math.floor((se+O-1)/O),F=X*Y,ae=F*z):ae=K*se*4;const re=B===fs?new Float32Array(t,ee,ae):B===kt?new Uint16Array(t,ee,ae):new Uint8Array(t,ee,ae);_?(H._levels[le]||(H._levels[le]=[]),H._levels[le][U]=re):H._levels[le]=re,ee+=ae*G,K=Math.max(K*.5,1),se=Math.max(se*.5,1)}}return H.upload(),H}constructor(e){super(),this.maxRetries=0}}class QQ extends tu{load(e,t,s){Ee.fetchArrayBuffer(e.load,t,s,this.maxRetries),s.data&&!s.data.type&&(s.data.type=sg)}open(e,t,s,i={}){const r=this.parse(t);if(!r)return null;const a=new De(s,{name:e,addressU:as,addressV:Te,minFilter:ze,magFilter:ze,width:r.width,height:r.height,levels:r.levels,format:Ze,type:sg,mipmaps:!1,...i});return a.upload(),a}parse(e){const t=new BM(e);if(!t.readLine().startsWith("#?RADIANCE"))return null;const i={};for(;;){const u=t.readLine();if(u.length===0)break;{const f=u.split("=");f.length===2&&(i[f[0]]=f[1])}}if(!i.hasOwnProperty("FORMAT"))return null;const r=t.readLine().split(" ");if(r.length!==4)return null;const a=parseInt(r[1],10),o=parseInt(r[3],10),h=this._readPixels(t,o,a,r[0]==="-Y");return h?{width:o,height:a,levels:[h]}:null}_readPixels(e,t,s,i){if(t<8||t>32767)return this._readPixelsFlat(e,t,s);const r=[0,0,0,0];if(e.readArray(r),r[0]!==2||r[1]!==2||(r[2]&128)!==0)return e.skip(-4),this._readPixelsFlat(e,t,s);const a=new ArrayBuffer(t*s*4),o=new Uint8Array(a);let h=i?0:t*4*(s-1),u,f,m,_,g,S;for(f=0;f<s;++f){if(f&&e.readArray(r),(r[2]<<8)+r[3]!==t)return null;for(_=0;_<4;++_)for(u=0;u<t;)if(g=e.readU8(),g>128){if(g-=128,u+g>t)return null;for(S=e.readU8(),m=0;m<g;++m)o[h+_+4*u++]=S}else{if(g===0||u+g>t)return null;for(m=0;m<g;++m)o[h+_+4*u++]=e.readU8()}h+=t*4*(i?1:-1)}return o}_readPixelsFlat(e,t,s){return e.remainingBytes===t*s*4?new Uint8Array(e.arraybuffer,e.offset):null}constructor(e){super(),this.maxRetries=0}}const kR={repeat:as,clamp:Te,mirror:Lg},VR={nearest:ze,linear:$t,nearest_mip_nearest:Ef,linear_mip_nearest:Af,nearest_mip_linear:bf,linear_mip_linear:Jn},JQ={default:qr,rgbm:Sl,rgbe:sg,rgbp:bh,swizzleGGGR:yE},eJ=function(c){const e=Wi.calcMipLevelsCount(c._width,c._height),t=function(i){return i instanceof HTMLCanvasElement||i instanceof HTMLImageElement||i instanceof HTMLVideoElement};if(!(c._format===Ze||c._format===fs)||c._volume||c._compressed||c._levels.length===1||c._levels.length===e||t(c._cubemap?c._levels[0][0]:c._levels[0]))return;const s=function(i,r,a){const o=Math.max(1,i>>1),h=Math.max(1,r>>1),u=new a.constructor(o*h*4),f=Math.floor(i/o),m=Math.floor(r/h),_=f*m;for(let g=0;g<h;++g)for(let S=0;S<o;++S)for(let x=0;x<4;++x){let T=0;for(let E=0;E<m;++E)for(let b=0;b<f;++b)T+=a[(S*f+b+(g*m+E)*i)*4+x];u[(S+g*o)*4+x]=T/_}return u};for(let i=c._levels.length;i<e;++i){const r=Math.max(1,c._width>>i-1),a=Math.max(1,c._height>>i-1);if(c._cubemap){const o=[];for(let h=0;h<6;++h)o.push(s(r,a,c._levels[i-1][h]));c._levels.push(o)}else c._levels.push(s(r,a,c._levels[i-1]))}c._levelsUpdated=c._cubemap?[[!0,!0,!0,!0,!0,!0]]:[!0]};class tJ extends Rt{set crossOrigin(e){this.imgParser.crossOrigin=e}get crossOrigin(){return this.imgParser.crossOrigin}set maxRetries(e){this.imgParser.maxRetries=e;for(const t in this.parsers)this.parsers.hasOwnProperty(t)&&(this.parsers[t].maxRetries=e)}get maxRetries(){return this.imgParser.maxRetries}_getUrlWithoutParams(e){return e.indexOf("?")>=0?e.split("?")[0]:e}_getParser(e){const t=Re.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".","");return this.parsers[t]||this.imgParser}_getTextureOptions(e){const t={};if(e){e.name?.length>0&&(t.name=e.name);const s=e.data;s.hasOwnProperty("minfilter")&&(t.minFilter=VR[s.minfilter]),s.hasOwnProperty("magfilter")&&(t.magFilter=VR[s.magfilter]),s.hasOwnProperty("addressu")&&(t.addressU=kR[s.addressu]),s.hasOwnProperty("addressv")&&(t.addressV=kR[s.addressv]),s.hasOwnProperty("mipmaps")&&(t.mipmaps=s.mipmaps),s.hasOwnProperty("anisotropy")&&(t.anisotropy=s.anisotropy),s.hasOwnProperty("flipY")&&(t.flipY=!!s.flipY),s.hasOwnProperty("srgb")&&(t.srgb=!!s.srgb),t.type=qr,s.hasOwnProperty("type")?t.type=JQ[s.type]:s.hasOwnProperty("rgbm")&&s.rgbm?t.type=Sl:e.file&&(e.file.opt&8)!==0&&(t.type=yE)}return t}load(e,t,s){typeof e=="string"&&(e={load:e,original:e}),this._getParser(e.original).load(e,t,s)}open(e,t,s){if(!e)return;const i=this._getTextureOptions(s);let r=this._getParser(e).open(e,t,this._device,i);return r===null?r=new De(this._device,{width:4,height:4,format:Ja}):(eJ(r),t.unswizzledGGGR&&(s.file.variants.basis.opt&=-9)),r}patch(e,t){const s=e.resource;if(!s)return;const i=this._getTextureOptions(e);for(const r of Object.keys(i))s[r]=i[r]}constructor(e){super(e,"texture");const t=e.assets,s=e.graphicsDevice;this._device=s,this._assets=t,this.imgParser=new XQ(t,s),this.parsers={dds:new ZQ(t),ktx:new jQ(t),ktx2:new KQ(t,s),basis:new WQ(t,s),hdr:new QQ(t)}}}const sJ="inline",iJ="immersive-vr",Wd="immersive-ar",GR="viewer",rJ="left",aJ="cpu-optimized",vI="gpu-optimized",SI="luminance-alpha",yI="unsigned-short",xI="float32";class nJ{get supported(){return this._supported}get available(){return this._supported&&this._manager.active&&this._manager._session.domOverlayState!==null}get state(){return!this._supported||!this._manager.active||!this._manager._session.domOverlayState?null:this._manager._session.domOverlayState.type}set root(e){!this._supported||this._manager.active||(this._root=e)}get root(){return this._root}constructor(e){this._supported=Ve.browser&&!!window.XRDOMOverlayState,this._root=null,this._manager=e}}const p_=[],HR=[];class fb extends Pe{remove(){if(!this._xrHitTestSource)return;const e=this.manager.hitTest.sources,t=e.indexOf(this);t!==-1&&e.splice(t,1),this.onStop()}onStop(){this._xrHitTestSource.cancel(),this._xrHitTestSource=null,this.fire("remove"),this.manager.hitTest.fire("remove",this)}update(e){if(this._transient){const t=e.getHitTestResultsForTransientInput(this._xrHitTestSource);for(let s=0;s<t.length;s++){const i=t[s];if(!i.results.length)continue;let r;i.inputSource&&(r=this.manager.input._getByInputSource(i.inputSource)),this.updateHitResults(i.results,r)}}else{const t=e.getHitTestResults(this._xrHitTestSource);if(!t.length)return;this.updateHitResults(t)}}updateHitResults(e,t){if(this._inputSource&&this._inputSource!==t)return;const s=p_.pop()??new D;t?s.copy(t.getOrigin()):s.copy(this.manager.camera.getPosition());let i=1/0,r=null;const a=p_.pop()??new D,o=HR.pop()??new pe;for(let h=0;h<e.length;h++){const u=e[h].getPose(this.manager._referenceSpace),f=s.distance(u.transform.position);f>=i||(i=f,r=e[h],a.copy(u.transform.position),o.copy(u.transform.orientation))}this.fire("result",a,o,t||this._inputSource,r),this.manager.hitTest.fire("result",this,a,o,t||this._inputSource,r),p_.push(s),p_.push(a),HR.push(o)}constructor(e,t,s,i=null){super(),this.manager=e,this._xrHitTestSource=t,this._transient=s,this._inputSource=i}}fb.EVENT_REMOVE="remove";fb.EVENT_RESULT="result";class zl extends Pe{_onSessionStart(){if(this.manager.session.enabledFeatures){const e=this.manager.session.enabledFeatures.indexOf("hit-test")!==-1;if(!e)return;this._available=e,this.fire("available")}else this._checkingAvailability||(this._checkingAvailability=!0,this.manager.session.requestReferenceSpace(GR).then(e=>{this.manager.session.requestHitTestSource({space:e}).then(t=>{t.cancel(),this.manager.active&&(this._available=!0,this.fire("available"))}).catch(()=>{})}).catch(()=>{}))}_onSessionEnd(){if(this._available){this._available=!1;for(let e=0;e<this.sources.length;e++)this.sources[e].onStop();this.sources=[],this.fire("unavailable")}}start(e={}){if(!this._supported){e.callback?.(new Error("XR HitTest is not supported"),null);return}if(!this._available){e.callback?.(new Error("XR HitTest is not available"),null);return}!e.profile&&!e.spaceType&&(e.spaceType=GR);let t;const s=e.offsetRay;if(s){const r=new DOMPoint(s.origin.x,s.origin.y,s.origin.z,1),a=new DOMPoint(s.direction.x,s.direction.y,s.direction.z,0);t=new XRRay(r,a)}const i=e.callback;e.spaceType?this.manager.session.requestReferenceSpace(e.spaceType).then(r=>{if(!this.manager.session){const a=new Error("XR Session is not started (2)");i&&i(a),this.fire("error",a);return}this.manager.session.requestHitTestSource({space:r,entityTypes:e.entityTypes||void 0,offsetRay:t}).then(a=>{this._onHitTestSource(a,!1,e.inputSource,i)}).catch(a=>{i&&i(a),this.fire("error",a)})}).catch(r=>{i&&i(r),this.fire("error",r)}):this.manager.session.requestHitTestSourceForTransientInput({profile:e.profile,entityTypes:e.entityTypes||void 0,offsetRay:t}).then(r=>{this._onHitTestSource(r,!0,e.inputSource,i)}).catch(r=>{i&&i(r),this.fire("error",r)})}_onHitTestSource(e,t,s,i){if(!this.manager.session){e.cancel();const a=new Error("XR Session is not started (3)");i&&i(a),this.fire("error",a);return}const r=new fb(this.manager,e,t,s??null);this.sources.push(r),i&&i(null,r),this.fire("add",r)}update(e){if(this._available)for(let t=0;t<this.sources.length;t++)this.sources[t].update(e)}get supported(){return this._supported}get available(){return this._available}constructor(e){super(),this._supported=Ve.browser&&!!(window.XRSession&&window.XRSession.prototype.requestHitTestSource),this._available=!1,this._checkingAvailability=!1,this.sources=[],this.manager=e,this._supported&&(this.manager.on("start",this._onSessionStart,this),this.manager.on("end",this._onSessionEnd,this))}}zl.EVENT_AVAILABLE="available";zl.EVENT_UNAVAILABLE="unavailable";zl.EVENT_ADD="add";zl.EVENT_REMOVE="remove";zl.EVENT_RESULT="result";zl.EVENT_ERROR="error";class mb extends Pe{get image(){return this._image}set width(e){this._width=e}get width(){return this._width}get trackable(){return this._trackable}get tracking(){return this._tracking}get emulated(){return this._emulated}prepare(){return this._bitmap?{image:this._bitmap,widthInMeters:this._width}:createImageBitmap(this._image).then(e=>(this._bitmap=e,{image:this._bitmap,widthInMeters:this._width}))}destroy(){this._image=null,this._pose=null,this._bitmap&&(this._bitmap.close(),this._bitmap=null)}getPosition(){return this._pose&&this._position.copy(this._pose.transform.position),this._position}getRotation(){return this._pose&&this._rotation.copy(this._pose.transform.orientation),this._rotation}constructor(e,t){super(),this._bitmap=null,this._measuredWidth=0,this._trackable=!1,this._tracking=!1,this._emulated=!1,this._pose=null,this._position=new D,this._rotation=new pe,this._image=e,this._width=t}}mb.EVENT_TRACKED="tracked";mb.EVENT_UNTRACKED="untracked";class TI extends Pe{add(e,t){if(!this._supported||this._manager.active)return null;const s=new mb(e,t);return this._images.push(s),s}remove(e){if(this._manager.active)return;const t=this._images.indexOf(e);t!==-1&&(e.destroy(),this._images.splice(t,1))}_onSessionStart(){this._manager.session.getTrackedImageScores().then(e=>{this._available=!0;for(let t=0;t<e.length;t++)this._images[t]._trackable=e[t]==="trackable"}).catch(e=>{this._available=!1,this.fire("error",e)})}_onSessionEnd(){this._available=!1;for(let e=0;e<this._images.length;e++){const t=this._images[e];t._pose=null,t._measuredWidth=0,t._tracking&&(t._tracking=!1,t.fire("untracked"))}}prepareImages(e){this._images.length?Promise.all(this._images.map(t=>t.prepare())).then(t=>{e(null,t)}).catch(t=>{e(t,null)}):e(null,null)}update(e){if(!this._available)return;const t=e.getImageTrackingResults(),s={};for(let i=0;i<t.length;i++){s[t[i].index]=t[i];const r=this._images[t[i].index];r._emulated=t[i].trackingState==="emulated",r._measuredWidth=t[i].measuredWidthInMeters,r._pose=e.getPose(t[i].imageSpace,this._manager._referenceSpace)}for(let i=0;i<this._images.length;i++)this._images[i]._tracking&&!s[i]?(this._images[i]._tracking=!1,this._images[i].fire("untracked")):!this._images[i]._tracking&&s[i]&&(this._images[i]._tracking=!0,this._images[i].fire("tracked"))}get supported(){return this._supported}get available(){return this._available}get images(){return this._images}constructor(e){super(),this._supported=Ve.browser&&!!window.XRImageTrackingResult,this._available=!1,this._images=[],this._manager=e,this._supported&&(this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this))}}TI.EVENT_ERROR="error";class oJ{get index(){return this._index}get hand(){return this._hand}get joints(){return this._joints}get tip(){return this._tip}constructor(e,t){this._joints=[],this._tip=null,this._index=e,this._hand=t,this._hand._fingers.push(this)}}const WR=Ve.browser&&window.XRHand?["thumb-tip","index-finger-tip","middle-finger-tip","ring-finger-tip","pinky-finger-tip"]:[],EI={};for(let c=0;c<WR.length;c++)EI[WR[c]]=!0;class XR{update(e){this._dirtyLocal=!0,this._radius=e.radius,this._localPosition.copy(e.transform.position),this._localRotation.copy(e.transform.orientation)}_updateTransforms(){this._dirtyLocal&&(this._dirtyLocal=!1,this._localTransform.setTRS(this._localPosition,this._localRotation,D.ONE));const t=this._hand._manager.camera.parent;t?this._worldTransform.mul2(t.getWorldTransform(),this._localTransform):this._worldTransform.copy(this._localTransform)}getPosition(){return this._updateTransforms(),this._worldTransform.getTranslation(this._position),this._position}getRotation(){return this._updateTransforms(),this._rotation.setFromMat4(this._worldTransform),this._rotation}get id(){return this._id}get index(){return this._index}get hand(){return this._hand}get finger(){return this._finger}get wrist(){return this._wrist}get tip(){return this._tip}get radius(){return this._radius||.005}constructor(e,t,s,i=null){this._radius=null,this._localTransform=new fe,this._worldTransform=new fe,this._localPosition=new D,this._localRotation=new pe,this._position=new D,this._rotation=new pe,this._dirtyLocal=!0,this._index=e,this._id=t,this._hand=s,this._finger=i,this._wrist=t==="wrist",this._tip=this._finger&&!!EI[t]}}let U_=[];const Jo=new D,__=new D,qR=new D;Ve.browser&&window.XRHand&&(U_=[["thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip"],["index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip"],["middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip"],["ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip"],["pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"]]);class pb extends Pe{update(e){const t=this._inputSource._xrInputSource;for(let f=0;f<this._joints.length;f++){const m=this._joints[f],_=t.hand.get(m._id);if(_){let g;if(e.session.visibilityState!=="hidden"&&(g=e.getJointPose(_,this._manager._referenceSpace)),g)m.update(g),m.wrist&&!this._tracking&&(this._tracking=!0,this.fire("tracking"));else if(m.wrist){this._tracking&&(this._tracking=!1,this.fire("trackinglost"));break}}}const s=this._jointsById["thumb-metacarpal"],i=this._jointsById["thumb-tip"],r=this._jointsById["index-finger-phalanx-proximal"],a=this._jointsById["index-finger-tip"],o=this._jointsById["ring-finger-phalanx-proximal"],h=this._jointsById["pinky-finger-phalanx-proximal"];if(s&&i&&r&&a&&o&&h){this._inputSource._dirtyRay=!0,this._inputSource._rayLocal.origin.lerp(i._localPosition,a._localPosition,.5);let f=s,m=h;if(this._inputSource.handedness===rJ){const _=f;f=m,m=_}Jo.sub2(f._localPosition,this._wrist._localPosition),__.sub2(m._localPosition,this._wrist._localPosition),qR.cross(Jo,__).normalize(),Jo.lerp(r._localPosition,o._localPosition,.5),Jo.sub(this._wrist._localPosition).normalize(),this._inputSource._rayLocal.direction.lerp(qR,Jo,.5).normalize()}this._fingerIsClosed(1)&&this._fingerIsClosed(2)&&this._fingerIsClosed(3)&&this._fingerIsClosed(4)?this._inputSource._squeezing||(this._inputSource._squeezing=!0,this._inputSource.fire("squeezestart"),this._manager.input.fire("squeezestart",this._inputSource)):this._inputSource._squeezing&&(this._inputSource._squeezing=!1,this._inputSource.fire("squeeze"),this._manager.input.fire("squeeze",this._inputSource),this._inputSource.fire("squeezeend"),this._manager.input.fire("squeezeend",this._inputSource))}_fingerIsClosed(e){const t=this._fingers[e];return Jo.sub2(t.joints[0]._localPosition,t.joints[1]._localPosition).normalize(),__.sub2(t.joints[2]._localPosition,t.joints[3]._localPosition).normalize(),Jo.dot(__)<-.8}getJointById(e){return this._jointsById[e]||null}get fingers(){return this._fingers}get joints(){return this._joints}get tips(){return this._tips}get wrist(){return this._wrist}get tracking(){return this._tracking}constructor(e){super(),this._tracking=!1,this._fingers=[],this._joints=[],this._jointsById={},this._tips=[],this._wrist=null;const t=e._xrInputSource.hand;if(this._manager=e._manager,this._inputSource=e,t.get("wrist")){const s=new XR(0,"wrist",this,null);this._wrist=s,this._joints.push(s),this._jointsById.wrist=s}for(let s=0;s<U_.length;s++){const i=new oJ(s,this);for(let r=0;r<U_[s].length;r++){const a=U_[s][r];if(!t.get(a))continue;const o=new XR(r,a,this,i);this._joints.push(o),this._jointsById[a]=o,o.tip&&(this._tips.push(o),i._tip=o),i._joints.push(o)}}}}pb.EVENT_TRACKING="tracking";pb.EVENT_TRACKINGLOST="trackinglost";const YR=new D,jR=new pe;let lJ=0;class yr extends Pe{get id(){return this._id}get inputSource(){return this._xrInputSource}get targetRayMode(){return this._xrInputSource.targetRayMode}get handedness(){return this._xrInputSource.handedness}get profiles(){return this._xrInputSource.profiles}get grip(){return this._grip}get hand(){return this._hand}get gamepad(){return this._xrInputSource.gamepad||null}get selecting(){return this._selecting}get squeezing(){return this._squeezing}set elementInput(e){this._elementInput!==e&&(this._elementInput=e,this._elementInput||(this._elementEntity=null))}get elementInput(){return this._elementInput}get elementEntity(){return this._elementEntity}get hitTestSources(){return this._hitTestSources}update(e){if(this._hand)this._hand.update(e);else{const t=this._xrInputSource.gripSpace;if(t){const i=e.getPose(t,this._manager._referenceSpace);if(i){this._grip||(this._grip=!0,this._localTransform=new fe,this._worldTransform=new fe,this._localPositionLast=new D,this._localPosition=new D,this._localRotation=new pe,this._linearVelocity=new D);const r=vs(),a=(r-this._velocitiesTimestamp)/1e3;this._velocitiesTimestamp=r,this._dirtyLocal=!0,this._localPositionLast.copy(this._localPosition),this._localPosition.copy(i.transform.position),this._localRotation.copy(i.transform.orientation),this._velocitiesAvailable=!0,this._manager.input.velocitiesSupported&&i.linearVelocity?this._linearVelocity.copy(i.linearVelocity):a>0&&(YR.sub2(this._localPosition,this._localPositionLast).divScalar(a),this._linearVelocity.lerp(this._linearVelocity,YR,.15))}else this._velocitiesAvailable=!1}const s=e.getPose(this._xrInputSource.targetRaySpace,this._manager._referenceSpace);s&&(this._dirtyRay=!0,this._rayLocal.origin.copy(s.transform.position),this._rayLocal.direction.set(0,0,-1),jR.copy(s.transform.orientation),jR.transformVector(this._rayLocal.direction,this._rayLocal.direction))}}_updateTransforms(){this._dirtyLocal&&(this._dirtyLocal=!1,this._localTransform.setTRS(this._localPosition,this._localRotation,D.ONE));const e=this._manager.camera.parent;e?this._worldTransform.mul2(e.getWorldTransform(),this._localTransform):this._worldTransform.copy(this._localTransform)}_updateRayTransforms(){const e=this._dirtyRay;this._dirtyRay=!1;const t=this._manager.camera.parent;if(t){const s=t.getWorldTransform();s.getTranslation(this._position),this._rotation.setFromMat4(s),this._rotation.transformVector(this._rayLocal.origin,this._ray.origin),this._ray.origin.add(this._position),this._rotation.transformVector(this._rayLocal.direction,this._ray.direction)}else e&&(this._ray.origin.copy(this._rayLocal.origin),this._ray.direction.copy(this._rayLocal.direction))}getPosition(){return this._grip?(this._updateTransforms(),this._worldTransform.getTranslation(this._position),this._position):null}getLocalPosition(){return this._localPosition}getRotation(){return this._grip?(this._updateTransforms(),this._rotation.setFromMat4(this._worldTransform),this._rotation):null}getLocalRotation(){return this._localRotation}getLinearVelocity(){return this._velocitiesAvailable?this._linearVelocity:null}getOrigin(){return this._updateRayTransforms(),this._ray.origin}getDirection(){return this._updateRayTransforms(),this._ray.direction}hitTestStart(e={}){e.inputSource=this,e.profile=this._xrInputSource.profiles[0];const t=e.callback;e.callback=(s,i)=>{i&&this.onHitTestSourceAdd(i),t&&t(s,i)},this._manager.hitTest.start(e)}onHitTestSourceAdd(e){this._hitTestSources.push(e),this.fire("hittest:add",e),e.on("result",(t,s,i,r)=>{i===this&&this.fire("hittest:result",e,t,s,r)}),e.once("remove",()=>{this.onHitTestSourceRemove(e),this.fire("hittest:remove",e)})}onHitTestSourceRemove(e){const t=this._hitTestSources.indexOf(e);t!==-1&&this._hitTestSources.splice(t,1)}constructor(e,t){super(),this._ray=new Ux,this._rayLocal=new Ux,this._grip=!1,this._hand=null,this._velocitiesAvailable=!1,this._velocitiesTimestamp=vs(),this._localTransform=null,this._worldTransform=null,this._position=new D,this._rotation=new pe,this._localPosition=null,this._localPositionLast=null,this._localRotation=null,this._linearVelocity=null,this._dirtyLocal=!0,this._dirtyRay=!1,this._selecting=!1,this._squeezing=!1,this._elementInput=!0,this._elementEntity=null,this._hitTestSources=[],this._id=++lJ,this._manager=e,this._xrInputSource=t,t.hand&&(this._hand=new pb(this))}}yr.EVENT_REMOVE="remove";yr.EVENT_SELECT="select";yr.EVENT_SELECTSTART="selectstart";yr.EVENT_SELECTEND="selectend";yr.EVENT_SQUEEZE="squeeze";yr.EVENT_SQUEEZESTART="squeezestart";yr.EVENT_SQUEEZEEND="squeezeend";yr.EVENT_HITTESTADD="hittest:add";yr.EVENT_HITTESTREMOVE="hittest:remove";yr.EVENT_HITTESTRESULT="hittest:result";class on extends Pe{_onSessionStart(){const e=this.manager.session;e.addEventListener("inputsourceschange",this._onInputSourcesChangeEvt),e.addEventListener("select",s=>{const i=this._getByInputSource(s.inputSource);i.update(s.frame),i.fire("select",s),this.fire("select",i,s)}),e.addEventListener("selectstart",s=>{const i=this._getByInputSource(s.inputSource);i.update(s.frame),i._selecting=!0,i.fire("selectstart",s),this.fire("selectstart",i,s)}),e.addEventListener("selectend",s=>{const i=this._getByInputSource(s.inputSource);i.update(s.frame),i._selecting=!1,i.fire("selectend",s),this.fire("selectend",i,s)}),e.addEventListener("squeeze",s=>{const i=this._getByInputSource(s.inputSource);i.update(s.frame),i.fire("squeeze",s),this.fire("squeeze",i,s)}),e.addEventListener("squeezestart",s=>{const i=this._getByInputSource(s.inputSource);i.update(s.frame),i._squeezing=!0,i.fire("squeezestart",s),this.fire("squeezestart",i,s)}),e.addEventListener("squeezeend",s=>{const i=this._getByInputSource(s.inputSource);i.update(s.frame),i._squeezing=!1,i.fire("squeezeend",s),this.fire("squeezeend",i,s)});const t=e.inputSources;for(let s=0;s<t.length;s++)this._addInputSource(t[s])}_onSessionEnd(){let e=this._inputSources.length;for(;e--;){const s=this._inputSources[e];this._inputSources.splice(e,1),s.fire("remove"),this.fire("remove",s)}this.manager.session.removeEventListener("inputsourceschange",this._onInputSourcesChangeEvt)}_onInputSourcesChange(e){for(let t=0;t<e.removed.length;t++)this._removeInputSource(e.removed[t]);for(let t=0;t<e.added.length;t++)this._addInputSource(e.added[t])}_getByInputSource(e){for(let t=0;t<this._inputSources.length;t++)if(this._inputSources[t].inputSource===e)return this._inputSources[t];return null}_addInputSource(e){if(this._getByInputSource(e))return;const t=new yr(this.manager,e);this._inputSources.push(t),this.fire("add",t)}_removeInputSource(e){for(let t=0;t<this._inputSources.length;t++){if(this._inputSources[t].inputSource!==e)continue;const s=this._inputSources[t];this._inputSources.splice(t,1);let i=s.hitTestSources.length;for(;i--;)s.hitTestSources[i].remove();s.fire("remove"),this.fire("remove",s);return}}update(e){for(let t=0;t<this._inputSources.length;t++)this._inputSources[t].update(e)}get inputSources(){return this._inputSources}constructor(e){super(),this._inputSources=[],this.velocitiesSupported=!1,this.manager=e,this.velocitiesSupported=!!(Ve.browser&&window.XRPose?.prototype?.hasOwnProperty("linearVelocity")),this._onInputSourcesChangeEvt=t=>{this._onInputSourcesChange(t)},this.manager.on("start",this._onSessionStart,this),this.manager.on("end",this._onSessionEnd,this)}}on.EVENT_ADD="add";on.EVENT_REMOVE="remove";on.EVENT_SELECT="select";on.EVENT_SELECTSTART="selectstart";on.EVENT_SELECTEND="selectend";on.EVENT_SQUEEZE="squeeze";on.EVENT_SQUEEZESTART="squeezestart";on.EVENT_SQUEEZEEND="squeezeend";const eh=new D,$R=new D,gx=new fe,KR=new fe;class _b extends Pe{_onSessionStart(){this._manager.session.requestLightProbe&&(this._supported=!0)}_onSessionEnd(){this._supported=!1,this._available=!1,this._lightProbeRequested=!1,this._lightProbe=null}start(){let e;if(this._manager.session||(e=new Error("XR session is not running")),!e&&this._manager.type!==Wd&&(e=new Error("XR session type is not AR")),!e&&!this._supported&&(e=new Error("light-estimation is not supported")),(!e&&this._lightProbe||this._lightProbeRequested)&&(e=new Error("light estimation is already requested")),e){this.fire("error",e);return}this._lightProbeRequested=!0,this._manager.session.requestLightProbe().then(t=>{const s=this._lightProbeRequested;this._lightProbeRequested=!1,this._manager.active?s&&(this._lightProbe=t):this.fire("error",new Error("XR session is not active"))}).catch(t=>{this._lightProbeRequested=!1,this.fire("error",t)})}end(){this._lightProbeRequested=!1,this._lightProbe=null,this._available=!1}update(e){if(!this._lightProbe)return;const t=e.getLightEstimate(this._lightProbe);if(!t)return;this._available||(this._available=!0,this.fire("available"));const s=t.primaryLightIntensity;this._intensity=Math.max(1,Math.max(s.x,Math.max(s.y,s.z))),eh.copy(s).mulScalar(1/this._intensity),this._color.set(eh.x,eh.y,eh.z),eh.set(0,0,0),$R.copy(t.primaryLightDirection),gx.setLookAt($R,eh,D.UP),KR.setFromAxisAngle(D.RIGHT,90),gx.mul(KR),this._rotation.setFromMat4(gx),this._sphericalHarmonics.set(t.sphericalHarmonicsCoefficients)}get supported(){return this._supported}get available(){return this._available}get intensity(){return this._available?this._intensity:null}get color(){return this._available?this._color:null}get rotation(){return this._available?this._rotation:null}get sphericalHarmonics(){return this._available?this._sphericalHarmonics:null}constructor(e){super(),this._supported=!1,this._available=!1,this._lightProbeRequested=!1,this._lightProbe=null,this._intensity=0,this._rotation=new pe,this._color=new ue,this._sphericalHarmonics=new Float32Array(27),this._manager=e,this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this)}}_b.EVENT_AVAILABLE="available";_b.EVENT_ERROR="error";let cJ=0;class gb extends Pe{destroy(){this._xrPlane&&(this._xrPlane=null,this.fire("remove"))}update(e){const t=this._planeDetection._manager,s=e.getPose(this._xrPlane.planeSpace,t._referenceSpace);s&&(this._position.copy(s.transform.position),this._rotation.copy(s.transform.orientation)),this._lastChangedTime!==this._xrPlane.lastChangedTime&&(this._lastChangedTime=this._xrPlane.lastChangedTime,this.fire("change"))}getPosition(){return this._position}getRotation(){return this._rotation}get id(){return this._id}get orientation(){return this._orientation}get points(){return this._xrPlane.polygon}get label(){return this._xrPlane.semanticLabel||""}constructor(e,t){super(),this._position=new D,this._rotation=new pe,this._id=++cJ,this._planeDetection=e,this._xrPlane=t,this._lastChangedTime=t.lastChangedTime,this._orientation=t.orientation}}gb.EVENT_REMOVE="remove";gb.EVENT_CHANGE="change";class tm extends Pe{_onSessionStart(){this._manager.session.enabledFeatures&&this._manager.session.enabledFeatures.indexOf("plane-detection")!==-1&&(this._available=!0,this.fire("available"))}_onSessionEnd(){for(let e=0;e<this._planes.length;e++)this._planes[e].destroy(),this.fire("remove",this._planes[e]);this._planesIndex.clear(),this._planes.length=0,this._available&&(this._available=!1,this.fire("unavailable"))}update(e){if(!this._available)if(!this._manager.session.enabledFeatures&&e.detectedPlanes.size)this._available=!0,this.fire("available");else return;const t=e.detectedPlanes;for(const[s,i]of this._planesIndex)t.has(s)||(this._planesIndex.delete(s),this._planes.splice(this._planes.indexOf(i),1),i.destroy(),this.fire("remove",i));for(const s of t){let i=this._planesIndex.get(s);i?i.update(e):(i=new gb(this,s),this._planesIndex.set(s,i),this._planes.push(i),i.update(e),this.fire("add",i))}}get supported(){return this._supported}get available(){return this._available}get planes(){return this._planes}constructor(e){super(),this._supported=Ve.browser&&!!window.XRPlane,this._available=!1,this._planesIndex=new Map,this._planes=[],this._manager=e,this._supported&&(this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this))}}tm.EVENT_AVAILABLE="available";tm.EVENT_UNAVAILABLE="unavailable";tm.EVENT_ADD="add";tm.EVENT_REMOVE="remove";class sm extends Pe{destroy(){if(!this._xrAnchor)return;const e=this._xrAnchor;this._xrAnchor.delete(),this._xrAnchor=null,this.fire("destroy",e,this)}update(e){if(!this._xrAnchor)return;const t=e.getPose(this._xrAnchor.anchorSpace,this._anchors.manager._referenceSpace);if(t){if(this._position.equals(t.transform.position)&&this._rotation.equals(t.transform.orientation))return;this._position.copy(t.transform.position),this._rotation.copy(t.transform.orientation),this.fire("change")}}getPosition(){return this._position}getRotation(){return this._rotation}persist(e){if(!this._anchors.persistence){e?.(new Error("Persistent Anchors are not supported"),null);return}if(this._uuid){e?.(null,this._uuid);return}if(this._uuidRequests){e&&this._uuidRequests.push(e);return}this._uuidRequests=[],this._xrAnchor.requestPersistentHandle().then(t=>{this._uuid=t,this._anchors._indexByUuid.set(this._uuid,this),e?.(null,t);for(const s of this._uuidRequests)s(null,t);this._uuidRequests=null,this.fire("persist",t)}).catch(t=>{e?.(t,null);for(const s of this._uuidRequests)s(t,null);this._uuidRequests=null})}forget(e){if(!this._uuid){e?.(new Error("Anchor is not persistent"));return}this._anchors.forget(this._uuid,t=>{this._uuid=null,e?.(t),this.fire("forget")})}get uuid(){return this._uuid}get persistent(){return!!this._uuid}constructor(e,t,s=null){super(),this._position=new D,this._rotation=new pe,this._uuid=null,this._uuidRequests=null,this._anchors=e,this._xrAnchor=t,this._uuid=s}}sm.EVENT_DESTROY="destroy";sm.EVENT_CHANGE="change";sm.EVENT_PERSIST="persist";sm.EVENT_FORGET="forget";class su extends Pe{_onSessionStart(){const e=this.manager.session.enabledFeatures?.indexOf("anchors")>=0;e&&(this._available=e,this.fire("available"))}_onSessionEnd(){if(!this._available)return;this._available=!1;for(let t=0;t<this._creationQueue.length;t++)this._creationQueue[t].callback&&this._creationQueue[t].callback(new Error("session ended"),null);this._creationQueue.length=0,this._index.clear(),this._indexByUuid.clear();let e=this._list.length;for(;e--;)this._list[e].destroy();this._list.length=0,this.fire("unavailable")}_createAnchor(e,t=null){const s=new sm(this,e,t);return this._index.set(e,s),t&&this._indexByUuid.set(t,s),this._list.push(s),s.once("destroy",this._onAnchorDestroy,this),s}_onAnchorDestroy(e,t){this._index.delete(e),t.uuid&&this._indexByUuid.delete(t.uuid);const s=this._list.indexOf(t);s!==-1&&this._list.splice(s,1),this.fire("destroy",t)}create(e,t,s){if(!this._available){s?.(new Error("Anchors API is not available"),null);return}if(window.XRHitTestResult&&e instanceof XRHitTestResult){const i=e;if(s=t,!this._supported){s?.(new Error("Anchors API is not supported"),null);return}if(!i.createAnchor){s?.(new Error("Creating Anchor from Hit Test is not supported"),null);return}i.createAnchor().then(r=>{const a=this._createAnchor(r);s?.(null,a),this.fire("add",a)}).catch(r=>{s?.(r,null),this.fire("error",r)})}else this._creationQueue.push({transform:new XRRigidTransform(e,t),callback:s})}restore(e,t){if(!this._available){t?.(new Error("Anchors API is not available"),null);return}if(!this._persistence){t?.(new Error("Anchor Persistence is not supported"),null);return}if(!this.manager.active){t?.(new Error("WebXR session is not active"),null);return}this.manager.session.restorePersistentAnchor(e).then(s=>{const i=this._createAnchor(s,e);t?.(null,i),this.fire("add",i)}).catch(s=>{t?.(s,null),this.fire("error",s)})}forget(e,t){if(!this._available){t?.(new Error("Anchors API is not available"));return}if(!this._persistence){t?.(new Error("Anchor Persistence is not supported"));return}if(!this.manager.active){t?.(new Error("WebXR session is not active"));return}this.manager.session.deletePersistentAnchor(e).then(()=>{t?.(null)}).catch(s=>{t?.(s),this.fire("error",s)})}update(e){if(!this._available){!this.manager.session.enabledFeatures&&!this._checkingAvailability&&(this._checkingAvailability=!0,e.createAnchor(new XRRigidTransform,this.manager._referenceSpace).then(t=>{t.delete(),this.manager.active&&(this._available=!0,this.fire("available"))}).catch(()=>{}));return}if(this._creationQueue.length){for(let t=0;t<this._creationQueue.length;t++){const s=this._creationQueue[t];e.createAnchor(s.transform,this.manager._referenceSpace).then(i=>{s.callback&&this._callbacksAnchors.set(i,s.callback)}).catch(i=>{s.callback&&s.callback(i,null),this.fire("error",i)})}this._creationQueue.length=0}for(const[t,s]of this._index)e.trackedAnchors.has(t)||(this._index.delete(t),s.destroy());for(let t=0;t<this._list.length;t++)this._list[t].update(e);for(const t of e.trackedAnchors){if(this._index.has(t))continue;try{const r=t.anchorSpace}catch{continue}const s=this._createAnchor(t);s.update(e);const i=this._callbacksAnchors.get(t);i&&(this._callbacksAnchors.delete(t),i(null,s)),this.fire("add",s)}}get supported(){return this._supported}get available(){return this._available}get persistence(){return this._persistence}get uuids(){return!this._available||!this._persistence||!this.manager.active?null:this.manager.session.persistentAnchors}get list(){return this._list}constructor(e){super(),this._supported=Ve.browser&&!!window.XRAnchor,this._available=!1,this._checkingAvailability=!1,this._persistence=Ve.browser&&!!window?.XRSession?.prototype.restorePersistentAnchor,this._creationQueue=[],this._index=new Map,this._indexByUuid=new Map,this._list=[],this._callbacksAnchors=new Map,this.manager=e,this._supported&&(this.manager.on("start",this._onSessionStart,this),this.manager.on("end",this._onSessionEnd,this))}}su.EVENT_AVAILABLE="available";su.EVENT_UNAVAILABLE="unavailable";su.EVENT_ERROR="error";su.EVENT_ADD="add";su.EVENT_DESTROY="destroy";class vb extends Pe{get xrMesh(){return this._xrMesh}get label(){return this._xrMesh.semanticLabel||""}get vertices(){return this._xrMesh.vertices}get indices(){return this._xrMesh.indices}destroy(){this._xrMesh&&(this._xrMesh=null,this.fire("remove"))}update(e){const t=this._meshDetection._manager,s=e.getPose(this._xrMesh.meshSpace,t._referenceSpace);s&&(this._position.copy(s.transform.position),this._rotation.copy(s.transform.orientation)),this._lastChanged!==this._xrMesh.lastChangedTime&&(this._lastChanged=this._xrMesh.lastChangedTime,this.fire("change"))}getPosition(){return this._position}getRotation(){return this._rotation}constructor(e,t){super(),this._lastChanged=0,this._position=new D,this._rotation=new pe,this._meshDetection=e,this._xrMesh=t,this._lastChanged=this._xrMesh.lastChangedTime}}vb.EVENT_REMOVE="remove";vb.EVENT_CHANGE="change";class im extends Pe{update(e){if(!this._available)if(!this._manager.session.enabledFeatures&&e.detectedMeshes.size)this._available=!0,this.fire("available");else return;for(const t of e.detectedMeshes){let s=this._index.get(t);s?s.update(e):(s=new vb(this,t),this._index.set(t,s),this._list.push(s),s.update(e),this.fire("add",s))}for(const t of this._index.values())e.detectedMeshes.has(t.xrMesh)||this._removeMesh(t)}_removeMesh(e){this._index.delete(e.xrMesh),this._list.splice(this._list.indexOf(e),1),e.destroy(),this.fire("remove",e)}_onSessionStart(){if(this._manager.session.enabledFeatures){const e=this._manager.session.enabledFeatures.indexOf("mesh-detection")!==-1;if(!e)return;this._available=e,this.fire("available")}}_onSessionEnd(){if(this._available){this._available=!1;for(const e of this._index.values())this._removeMesh(e);this.fire("unavailable")}}get supported(){return this._supported}get available(){return this._available}get meshes(){return this._list}constructor(e){super(),this._supported=Ve.browser&&!!window.XRMesh,this._available=!1,this._index=new Map,this._list=[],this._manager=e,this._supported&&(this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this))}}im.EVENT_AVAILABLE="available";im.EVENT_UNAVAILABLE="unavailable";im.EVENT_ADD="add";im.EVENT_REMOVE="remove";class bI extends Pe{get textureColor(){return this._textureColor}get textureDepth(){return this._textureDepth}get depthUvMatrix(){return this._depthMatrix}get depthValueToMeters(){return this._depthInfo?.rawValueToMeters||0}get eye(){return this._xrView.eye}get viewport(){return this._viewport}get projMat(){return this._projMat}get projViewOffMat(){return this._projViewOffMat}get viewOffMat(){return this._viewOffMat}get viewInvOffMat(){return this._viewInvOffMat}get viewMat3(){return this._viewMat3}get positionData(){return this._positionData}update(e,t){this._xrView=t,this._manager.views.availableColor&&(this._xrCamera=this._xrView.camera);const i=e.session.renderState.baseLayer.getViewport(this._xrView);this._viewport.x=i.x,this._viewport.y=i.y,this._viewport.z=i.width,this._viewport.w=i.height,this._projMat.set(this._xrView.projectionMatrix),this._viewMat.set(this._xrView.transform.inverse.matrix),this._viewInvMat.set(this._xrView.transform.matrix),this._updateTextureColor(),this._updateDepth(e)}_updateTextureColor(){if(!this._manager.views.availableColor||!this._xrCamera||!this._textureColor)return;const e=this._manager.webglBinding;if(!e)return;const t=e.getCameraImage(this._xrCamera);if(!t)return;const s=this._manager.app.graphicsDevice,i=s.gl;if(!this._frameBufferSource)this._frameBufferSource=i.createFramebuffer(),this._frameBuffer=i.createFramebuffer();else{const r=i.COLOR_ATTACHMENT0,a=this._xrCamera.width,o=this._xrCamera.height;s.setFramebuffer(this._frameBufferSource),i.framebufferTexture2D(i.FRAMEBUFFER,r,i.TEXTURE_2D,t,0),s.setFramebuffer(this._frameBuffer),i.framebufferTexture2D(i.FRAMEBUFFER,r,i.TEXTURE_2D,this._textureColor.impl._glTexture,0),i.bindFramebuffer(i.READ_FRAMEBUFFER,this._frameBufferSource),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,this._frameBuffer),i.blitFramebuffer(0,o,a,0,0,0,a,o,i.COLOR_BUFFER_BIT,i.NEAREST)}}_updateDepth(e){if(!this._manager.views.availableDepth||!this._textureDepth)return;const t=this._manager.views.depthGpuOptimized,s=t?this._manager.webglBinding:e;if(!s){this._depthInfo=null;return}const i=s.getDepthInformation(this._xrView);if(!i){this._depthInfo=null;return}let r=!this._depthInfo!=!i;this._depthInfo=i;const a=this._depthInfo?.width||4,o=this._depthInfo?.height||4;let h=!1;if((this._textureDepth.width!==a||this._textureDepth.height!==o)&&(this._textureDepth._width=a,this._textureDepth._height=o,r=!0,h=!0),r&&(this._depthInfo?this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix):this._depthMatrix.setIdentity()),this._depthInfo)if(t){if(this._depthInfo.texture){const u=this._manager.app.graphicsDevice.gl;switch(this._textureDepth.impl._glTexture=this._depthInfo.texture,this._depthInfo.textureType==="texture-array"?this._textureDepth.impl._glTarget=u.TEXTURE_2D_ARRAY:this._textureDepth.impl._glTarget=u.TEXTURE_2D,this._manager.views.depthPixelFormat){case Wr:this._textureDepth.impl._glInternalFormat=u.R32F,this._textureDepth.impl._glPixelType=u.FLOAT,this._textureDepth.impl._glFormat=u.RED;break;case Br:this._textureDepth.impl._glInternalFormat=u.DEPTH_COMPONENT16,this._textureDepth.impl._glPixelType=u.UNSIGNED_SHORT,this._textureDepth.impl._glFormat=u.DEPTH_COMPONENT;break}this._textureDepth.impl._glCreated=!0}}else this._textureDepth._levels[0]=new Uint8Array(this._depthInfo.data),this._textureDepth.upload();else this._textureDepth._levels[0]=this._emptyDepthBuffer,this._textureDepth.upload();h&&this.fire("depth:resize",a,o)}updateTransforms(e){e?(this._viewInvOffMat.mul2(e,this._viewInvMat),this.viewOffMat.copy(this._viewInvOffMat).invert()):(this._viewInvOffMat.copy(this._viewInvMat),this.viewOffMat.copy(this._viewMat)),this._viewMat3.setFromMat4(this._viewOffMat),this._projViewOffMat.mul2(this._projMat,this._viewOffMat),this._positionData[0]=this._viewInvOffMat.data[12],this._positionData[1]=this._viewInvOffMat.data[13],this._positionData[2]=this._viewInvOffMat.data[14]}_onDeviceLost(){this._frameBufferSource=null,this._frameBuffer=null,this._depthInfo=null}getDepth(e,t){return this._manager.views.depthGpuOptimized?null:this._depthInfo?.getDepthInMeters(e,t)??null}destroy(){if(this._depthInfo=null,this._textureColor&&(this._textureColor.destroy(),this._textureColor=null),this._textureDepth&&(this._textureDepth.destroy(),this._textureDepth=null),this._frameBufferSource){const e=this._manager.app.graphicsDevice.gl;e.deleteFramebuffer(this._frameBufferSource),this._frameBufferSource=null,e.deleteFramebuffer(this._frameBuffer),this._frameBuffer=null}}constructor(e,t,s){super(),this._positionData=new Float32Array(3),this._viewport=new me,this._projMat=new fe,this._projViewOffMat=new fe,this._viewMat=new fe,this._viewOffMat=new fe,this._viewMat3=new $i,this._viewInvMat=new fe,this._viewInvOffMat=new fe,this._xrCamera=null,this._textureColor=null,this._textureDepth=null,this._depthInfo=null,this._emptyDepthBuffer=new Uint8Array(32),this._depthMatrix=new fe,this._manager=e,this._xrView=t;const i=this._manager.app.graphicsDevice;if(this._manager.views.supportedColor&&(this._xrCamera=this._xrView.camera,this._manager.views.availableColor&&this._xrCamera&&(this._textureColor=new De(i,{format:Ja,mipmaps:!1,addressU:Te,addressV:Te,minFilter:$t,magFilter:$t,width:this._xrCamera.width,height:this._xrCamera.height,name:`XrView-${this._xrView.eye}-Color`}))),this._manager.views.supportedDepth&&this._manager.views.availableDepth){const r=this._manager.views.depthGpuOptimized?ze:$t;this._textureDepth=new De(i,{format:this._manager.views.depthPixelFormat,arrayLength:s===1?0:s,mipmaps:!1,addressU:Te,addressV:Te,minFilter:r,magFilter:r,width:4,height:4,name:`XrView-${this._xrView.eye}-Depth`});for(let a=0;a<this._textureDepth._levels.length;a++)this._textureDepth._levels[a]=this._emptyDepthBuffer;this._textureDepth.upload()}(this._textureColor||this._textureDepth)&&i.on("devicelost",this._onDeviceLost,this)}}bI.EVENT_DEPTHRESIZE="depth:resize";class Sb extends Pe{get list(){return this._list}get supportedColor(){return this._supportedColor}get supportedDepth(){return this._supportedDepth}get availableColor(){return this._availableColor}get availableDepth(){return this._availableDepth}get depthUsage(){return this._depthUsage}get depthGpuOptimized(){return this._depthUsage===vI}get depthFormat(){return this._depthFormat}get depthPixelFormat(){return this._depthFormats[this._depthFormat]??null}update(e,t){for(let s=0;s<t.length;s++)this._indexTmp.set(t[s].eye,t[s]);for(const[s,i]of this._indexTmp){let r=this._index.get(s);r?r.update(e,i):(r=new bI(this._manager,i,t.length),this._index.set(s,r),this._list.push(r),r.update(e,i),this.fire("add",r))}for(const[s,i]of this._index){if(this._indexTmp.has(s))continue;i.destroy(),this._index.delete(s);const r=this._list.indexOf(i);r!==-1&&this._list.splice(r,1),this.fire("remove",i)}this._indexTmp.clear()}get(e){return this._index.get(e)||null}_onSessionStart(){if(this._manager.type===Wd&&this._manager.session.enabledFeatures&&(this._availableColor=this._manager.session.enabledFeatures.indexOf("camera-access")!==-1,this._availableDepth=this._manager.session.enabledFeatures.indexOf("depth-sensing")!==-1,this._availableDepth)){const e=this._manager.session;this._depthUsage=e.depthUsage,this._depthFormat=e.depthDataFormat}}_onSessionEnd(){for(const e of this._index.values())e.destroy();this._index.clear(),this._availableColor=!1,this._availableDepth=!1,this._depthUsage="",this._depthFormat="",this._list.length=0}constructor(e){super(),this._index=new Map,this._indexTmp=new Map,this._list=[],this._supportedColor=Ve.browser&&!!window.XRCamera&&!!window.XRWebGLBinding,this._supportedDepth=Ve.browser&&!!window.XRDepthInformation,this._availableColor=!1,this._availableDepth=!1,this._depthUsage="",this._depthFormat="",this._depthFormats={[SI]:Ig,[yI]:Br,[xI]:Wr},this._manager=e,this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this)}}Sb.EVENT_ADD="add";Sb.EVENT_REMOVE="remove";class iu extends Pe{destroy(){}start(e,t,s,i){let r=i;if(typeof i=="object"&&(r=i.callback),!this._available[t]){r&&r(new Error("XR is not available"));return}if(this._session){r&&r(new Error("XR session is already started"));return}this._camera=e,this._camera.camera.xr=this,this._type=t,this._spaceType=s,this._framebufferScaleFactor=i?.framebufferScaleFactor??1,this._setClipPlanes(e.nearClip,e.farClip);const a={requiredFeatures:[s],optionalFeatures:[]},o=this.app.graphicsDevice;o?.isWebGPU&&a.requiredFeatures.push("webgpu");const h=o?.isWebGL2;if(t===Wd){if(a.optionalFeatures.push("light-estimation"),a.optionalFeatures.push("hit-test"),i&&(i.imageTracking&&this.imageTracking.supported&&a.optionalFeatures.push("image-tracking"),i.planeDetection&&a.optionalFeatures.push("plane-detection"),i.meshDetection&&a.optionalFeatures.push("mesh-detection")),this.domOverlay.supported&&this.domOverlay.root&&(a.optionalFeatures.push("dom-overlay"),a.domOverlay={root:this.domOverlay.root}),i&&i.anchors&&this.anchors.supported&&a.optionalFeatures.push("anchors"),i&&i.depthSensing&&this.views.supportedDepth){a.optionalFeatures.push("depth-sensing");const u=[],f=[];if(u.push(vI,aJ),f.push(xI,SI,yI),i.depthSensing.usagePreference){const m=u.indexOf(i.depthSensing.usagePreference);m!==-1&&u.splice(m,1),u.unshift(i.depthSensing.usagePreference)}if(i.depthSensing.dataFormatPreference){const m=f.indexOf(i.depthSensing.dataFormatPreference);m!==-1&&f.splice(m,1),f.unshift(i.depthSensing.dataFormatPreference)}a.depthSensing={usagePreference:u,dataFormatPreference:f}}h&&i&&i.cameraColor&&this.views.supportedColor&&a.optionalFeatures.push("camera-access")}a.optionalFeatures.push("hand-tracking"),i&&i.optionalFeatures&&(a.optionalFeatures=a.optionalFeatures.concat(i.optionalFeatures)),this.imageTracking.supported&&this.imageTracking.images.length?this.imageTracking.prepareImages((u,f)=>{if(u){r&&r(u),this.fire("error",u);return}f!==null&&(a.trackedImages=f),this._onStartOptionsReady(t,s,a,r)}):this._onStartOptionsReady(t,s,a,r)}_onStartOptionsReady(e,t,s,i){navigator.xr.requestSession(e,s).then(r=>{this._onSessionStart(r,t,i)}).catch(r=>{this._camera.camera.xr=null,this._camera=null,this._type=null,this._spaceType=null,i&&i(r),this.fire("error",r)})}end(e){if(!this._session){e&&e(new Error("XR Session is not initialized"));return}this.webglBinding=null,e&&this.once("end",e),this._session.end()}isAvailable(e){return this._available[e]}_deviceAvailabilityCheck(){for(const e in this._available)this._sessionSupportCheck(e)}initiateRoomCapture(e){if(!this._session){e(new Error("Session is not active"));return}if(!this._session.initiateRoomCapture){e(new Error("Session does not support manual room capture"));return}this._session.initiateRoomCapture().then(()=>{e&&e(null)}).catch(t=>{e&&e(t)})}updateTargetFrameRate(e,t){if(!this._session?.updateTargetFrameRate){t?.(new Error("unable to update frameRate"));return}this._session.updateTargetFrameRate(e).then(()=>{t?.()}).catch(s=>{t?.(s)})}_sessionSupportCheck(e){navigator.xr.isSessionSupported(e).then(t=>{this._available[e]!==t&&(this._available[e]=t,this.fire("available",e,t),this.fire(`available:${e}`,t))}).catch(t=>{this.fire("error",t)})}_onSessionStart(e,t,s){let i=!1;this._session=e;const r=()=>{this.fire("visibility:change",e.visibilityState)},a=()=>{this._setClipPlanes(this._camera.nearClip,this._camera.farClip)},o=()=>{this.fire("frameratechange",this._session?.frameRate)},h=()=>{this._camera&&(this._camera.off("set_nearClip",a),this._camera.off("set_farClip",a),this._camera.camera.xr=null,this._camera=null),e.removeEventListener("end",h),e.removeEventListener("visibilitychange",r),e.removeEventListener("frameratechange",o),i||this.fire("end"),this._session=null,this._referenceSpace=null,this._width=0,this._height=0,this._type=null,this._spaceType=null,this.app.systems&&this.app.requestAnimationFrame()};e.addEventListener("end",h),e.addEventListener("visibilitychange",r),this._camera.on("set_nearClip",a),this._camera.on("set_farClip",a),this._createBaseLayer(),this.session.supportedFrameRates?this._supportedFrameRates=Array.from(this.session.supportedFrameRates):this._supportedFrameRates=null,this._session.addEventListener("frameratechange",o),e.requestReferenceSpace(t).then(u=>{this._referenceSpace=u,this.app.requestAnimationFrame(),s&&s(null),this.fire("start")}).catch(u=>{i=!0,e.end(),s&&s(u),this.fire("error",u)})}_setClipPlanes(e,t){this._depthNear===e&&this._depthFar===t||(this._depthNear=e,this._depthFar=t,this._session&&this._session.updateRenderState({depthNear:this._depthNear,depthFar:this._depthFar}))}_createBaseLayer(){const e=this.app.graphicsDevice,t=e.maxPixelRatio/window.devicePixelRatio*this._framebufferScaleFactor;if(this._baseLayer=new XRWebGLLayer(this._session,e.gl,{alpha:!0,depth:!0,stencil:!0,framebufferScaleFactor:t,antialias:!1}),e?.isWebGL2&&window.XRWebGLBinding)try{this.webglBinding=new XRWebGLBinding(this._session,e.gl)}catch(s){this.fire("error",s)}this._session.updateRenderState({baseLayer:this._baseLayer,depthNear:this._depthNear,depthFar:this._depthFar})}_onDeviceLost(){this._session&&(this.webglBinding&&(this.webglBinding=null),this._baseLayer=null,this._session.updateRenderState({baseLayer:this._baseLayer,depthNear:this._depthNear,depthFar:this._depthFar}))}_onDeviceRestored(){this._session&&setTimeout(()=>{this.app.graphicsDevice.gl.makeXRCompatible().then(()=>{this._createBaseLayer()}).catch(e=>{this.fire("error",e)})},0)}update(e){if(!this._session)return!1;const t=e.session.renderState.baseLayer.framebufferWidth,s=e.session.renderState.baseLayer.framebufferHeight;(this._width!==t||this._height!==s)&&(this._width=t,this._height=s,this.app.graphicsDevice.setResolution(t,s));const i=e.getViewerPose(this._referenceSpace);if(!i)return!1;const r=this.views.list.length;this.views.update(e,i.views);const a=i.transform.position,o=i.transform.orientation;if(this._localPosition.set(a.x,a.y,a.z),this._localRotation.set(o.x,o.y,o.z,o.w),r===0&&this.views.list.length>0){const h=new fe,u=this.views.list[0];h.copy(u.projMat);const f=h.data,m=2*Math.atan(1/f[5])*180/Math.PI,_=f[5]/f[0],g=f[14]/(f[10]+1),S=f[14]/(f[10]-1);this._camera.camera.setXrProperties({aspectRatio:_,farClip:g,fov:m,horizontalFov:!1,nearClip:S})}return this._camera.camera._node.setLocalPosition(this._localPosition),this._camera.camera._node.setLocalRotation(this._localRotation),this.input.update(e),this._type===Wd&&(this.hitTest.supported&&this.hitTest.update(e),this.lightEstimation.supported&&this.lightEstimation.update(e),this.imageTracking.supported&&this.imageTracking.update(e),this.anchors.supported&&this.anchors.update(e),this.planeDetection.supported&&this.planeDetection.update(e),this.meshDetection.supported&&this.meshDetection.update(e)),this.fire("update",e),!0}get supported(){return this._supported}get active(){return!!this._session}get type(){return this._type}get spaceType(){return this._spaceType}get session(){return this._session}get frameRate(){return this._session?.frameRate??null}get supportedFrameRates(){return this._supportedFrameRates}get framebufferScaleFactor(){return this._framebufferScaleFactor}set fixedFoveation(e){(this._baseLayer?.fixedFoveation??null)!==null&&(this.app.graphicsDevice.samples>1,this._baseLayer.fixedFoveation=e)}get fixedFoveation(){return this._baseLayer?.fixedFoveation??null}get camera(){return this._camera?this._camera.entity:null}get visibilityState(){return this._session?this._session.visibilityState:null}constructor(e){super(),this._supported=Ve.browser&&!!navigator.xr,this._available={},this._type=null,this._spaceType=null,this._session=null,this._baseLayer=null,this.webglBinding=null,this._referenceSpace=null,this._camera=null,this._localPosition=new D,this._localRotation=new pe,this._depthNear=.1,this._depthFar=1e3,this._supportedFrameRates=null,this._width=0,this._height=0,this._framebufferScaleFactor=1,this.app=e,this._available[sJ]=!1,this._available[iJ]=!1,this._available[Wd]=!1,this.domOverlay=new nJ(this),this.hitTest=new zl(this),this.imageTracking=new TI(this),this.planeDetection=new tm(this),this.meshDetection=new im(this),this.input=new on(this),this.lightEstimation=new _b(this),this.anchors=new su(this),this.views=new Sb(this),this._supported&&(navigator.xr.addEventListener("devicechange",()=>{this._deviceAvailabilityCheck()}),this._deviceAvailabilityCheck(),this.app.graphicsDevice.on("devicelost",this._onDeviceLost,this),this.app.graphicsDevice.on("devicerestored",this._onDeviceRestored,this))}}iu.EVENT_AVAILABLE="available";iu.EVENT_START="start";iu.EVENT_END="end";iu.EVENT_UPDATE="update";iu.EVENT_ERROR="error";let AI=class extends Yn{createDevice(e,t){return t.graphicsDeviceOptions||(t.graphicsDeviceOptions={}),Ve.browser&&navigator.xr&&(t.graphicsDeviceOptions.xrCompatible=!0),t.graphicsDeviceOptions.alpha=t.graphicsDeviceOptions.alpha||!1,new g2(e,t.graphicsDeviceOptions)}addComponentSystems(e){e.componentSystems=[jL,DY,rj,tY,oY,vj,l9,H9,X9,a7,L9,cY,a9,g9,ej,fY,C9,P9,B9,mj,nj,z9,cb]}addResourceHandles(e){e.resourceHandlers=[EK,CZ,DZ,PZ,xQ,_Q,tJ,MQ,dQ,MZ,CQ,TQ,FZ,uQ,NZ,DQ,hQ,BZ,UZ,LZ,IQ,PQ,RQ,OZ,cQ]}constructor(e,t={}){super(e);const s=new Eq;s.graphicsDevice=t.graphicsDevice??this.createDevice(e,t),this.addComponentSystems(s),this.addResourceHandles(s),s.elementInput=t.elementInput,s.keyboard=t.keyboard,s.mouse=t.mouse,s.touch=t.touch,s.gamepads=t.gamepads,s.scriptPrefix=t.scriptPrefix,s.assetPrefix=t.assetPrefix,s.scriptsOrder=t.scriptsOrder,s.soundManager=new Ik,s.lightmapper=Fq,s.batchManager=LV,s.xr=iu,this.init(s)}};const g_=[],hJ=[[],[],[]];class uJ extends ii{destroy(){this.viewBindGroups.forEach(e=>{e.defaultUniformBuffer.destroy(),e.destroy()}),this.viewBindGroups.length=0}update(e,t,s,i,r){this.camera=e,this.scene=t,this.layers=s,this.mapping=i,this.depth=r,t.clusteredLightingEnabled&&(this.emptyWorldClusters=this.renderer.worldClustersAllocator.empty)}execute(){const e=this.device,{renderer:t,camera:s,scene:i,layers:r,mapping:a,renderTarget:o}=this,h=i.layers.layerList,u=i.layers.subLayerEnabled,f=i.layers.subLayerList;for(let m=0;m<h.length;m++){const _=h[m];if(!(r&&r.indexOf(_)<0)&&_.enabled&&u[m]&&_.camerasSet.has(s.camera)){const g=f[m];_._clearDepthBuffer&&t.clear(s.camera,!1,!0,!1);const S=_.meshInstances;for(let x=0;x<S.length;x++){const T=S[x];T.pick&&T.transparent===g&&(g_.push(T),a.set(T.id,T))}if(g_.length>0){const x=i.clusteredLightingEnabled;x&&this.emptyWorldClusters.activate(),t.setCameraUniforms(s.camera,o),e.supportsUniformBuffers&&(t.initViewBindGroupFormat(x),t.setupViewUniformBuffers(this.viewBindGroups,t.viewUniformFormat,t.viewBindGroupFormat,null));const T=this.depth?k2:qf;t.renderForward(s.camera,o,g_,hJ,T,E=>{e.setBlendState(this.blendState)}),g_.length=0}}}}constructor(e,t){super(e),this.viewBindGroups=[],this.blendState=ht.NOBLEND,this.renderer=t}}const vx=new Set,dJ=new me,wI=new Float32Array(1),fJ=new Int32Array(wI.buffer);class mJ{destroy(){this.releaseRenderTarget(),this.renderPass?.destroy()}getSelection(e,t,s=1,i=1){const r=this.device;if(r.isWebGPU)return[];t=this.renderTarget.height-(t+i);const a=this.sanitizeRect(e,t,s,i);r.setRenderTarget(this.renderTarget),r.updateBegin();const o=new Uint8Array(4*a.z*a.w);return r.readPixels(a.x,a.y,a.z,a.w,o),r.updateEnd(),this.decodePixels(o,this.mapping)}getSelectionAsync(e,t,s=1,i=1){return!this.renderTarget||!this.renderTarget.colorBuffer?Promise.resolve([]):this._readTexture(this.renderTarget.colorBuffer,e,t,s,i,this.renderTarget).then(r=>this.decodePixels(r,this.mapping))}_readTexture(e,t,s,i,r,a){this.device?.isWebGL2&&(s=a.height-(s+r));const o=this.sanitizeRect(t,s,i,r);return e.read(o.x,o.y,o.z,o.w,{immediate:!0,renderTarget:a})}async getWorldPointAsync(e,t){const s=this.renderPass.camera;if(!s)return null;const r=new fe().mul2(s.camera.projectionMatrix,s.camera.viewMatrix).invert(),a=await this.getPointDepthAsync(e,t);if(a===null)return null;const o=new me(e/this.width*2-1,(1-t/this.height)*2-1,a*2-1,1);return r.transformVec4(o,o),o.mulScalar(1/o.w),new D(o.x,o.y,o.z)}async getPointDepthAsync(e,t){if(!this.depthBuffer)return null;const s=await this._readTexture(this.depthBuffer,e,t,1,1,this.renderTargetDepth),i=s[0]<<24|s[1]<<16|s[2]<<8|s[3];return i===4294967295?null:(fJ[0]=i,wI[0])}sanitizeRect(e,t,s,i){const r=this.renderTarget.width,a=this.renderTarget.height;return e=J.clamp(Math.floor(e),0,r-1),t=J.clamp(Math.floor(t),0,a-1),s=Math.floor(Math.max(s,1)),s=Math.min(s,r-e),i=Math.floor(Math.max(i,1)),i=Math.min(i,a-t),dJ.set(e,t,s,i)}decodePixels(e,t){const s=[];if(this.deviceValid){const i=e.length;for(let r=0;r<i;r+=4){const a=e[r+0],o=e[r+1],h=e[r+2],f=(e[r+3]<<24|a<<16|o<<8|h)>>>0;f!==4294967295&&vx.add(t.get(f))}vx.forEach(r=>{r&&s.push(r)}),vx.clear()}return s}createTexture(e){return new De(this.device,{format:Ze,width:this.width,height:this.height,mipmaps:!1,minFilter:ze,magFilter:ze,addressU:Te,addressV:Te,name:e})}allocateRenderTarget(){this.colorBuffer=this.createTexture("pick");const e=[this.colorBuffer];this.depth&&(this.depthBuffer=this.createTexture("pick-depth"),e.push(this.depthBuffer),this.renderTargetDepth=new At({colorBuffer:this.depthBuffer,depth:!1})),this.renderTarget=new At({colorBuffers:e,depth:!0})}releaseRenderTarget(){this.renderTarget?.destroyTextureBuffers(),this.renderTarget?.destroy(),this.renderTarget=null,this.renderTargetDepth?.destroy(),this.renderTargetDepth=null,this.colorBuffer=null,this.depthBuffer=null}prepare(e,t,s){s instanceof il&&(s=[s]),this.renderTarget?.resize(this.width,this.height),this.renderTargetDepth?.resize(this.width,this.height),this.mapping.clear();const i=this.renderPass;i.init(this.renderTarget),i.setClearColor(ue.WHITE),i.depthStencilOps.clearDepth=!0,i.update(e,t,s,this.mapping,this.depth),i.render()}resize(e,t){this.width=Math.floor(e),this.height=Math.floor(t)}constructor(e,t,s,i=!1){this.renderTarget=null,this.colorBuffer=null,this.depthBuffer=null,this.renderTargetDepth=null,this.mapping=new Map,this.deviceValid=!0,this.device=e.graphicsDevice,this.renderPass=new uJ(this.device,e.renderer),this.depth=i,this.width=0,this.height=0,this.resize(t,s),this.allocateRenderTarget(),this.device.on("destroy",()=>{this.deviceValid=!1})}}const pJ=new D,_J=new pe;class ei{copy(e){return this.set(e.position,e.angles,e.distance)}clone(){return new ei(this.position.clone(),this.angles.clone(),this.distance)}equalsApprox(e,t=1e-6){return this.position.equalsApprox(e.position,t)&&this.angles.equalsApprox(e.angles,t)&&Math.abs(this.distance-e.distance)<t}lerp(e,t,s,i=s,r=s){return this.position.lerp(e.position,t.position,s),this.angles.x=J.lerpAngle(e.angles.x,t.angles.x,i)%360,this.angles.y=J.lerpAngle(e.angles.y,t.angles.y,i)%360,this.angles.z=J.lerpAngle(e.angles.z,t.angles.z,i)%360,this.distance=J.lerp(e.distance,t.distance,r),this}move(e){return this.position.add(e),this.position.x=J.clamp(this.position.x,this.xRange.x,this.xRange.y),this.position.y=J.clamp(this.position.y,this.yRange.x,this.yRange.y),this.position.z=J.clamp(this.position.z,this.zRange.x,this.zRange.y),this}rotate(e){return this.angles.add(e),this.angles.x%=360,this.angles.y%=360,this.angles.z%=360,this.angles.x=J.clamp(this.angles.x,this.pitchRange.x,this.pitchRange.y),this.angles.y=J.clamp(this.angles.y,this.yawRange.x,this.yawRange.y),this}set(e,t,s){return this.position.copy(e),this.angles.copy(t),this.distance=s,this}look(e,t){this.position.copy(e),this.distance=e.distance(t);const s=pJ.sub2(t,e).normalize(),i=Math.atan2(-s.y,Math.sqrt(s.x*s.x+s.z*s.z))*J.RAD_TO_DEG,r=Math.atan2(-s.x,-s.z)*J.RAD_TO_DEG;return this.angles.set(-i,r,0),this}getFocus(e){return _J.setFromEulerAngles(this.angles).transformVector(D.FORWARD,e).mulScalar(this.distance).add(this.position)}constructor(e=D.ZERO,t=D.ZERO,s=0){this.position=new D,this.angles=new D,this.distance=0,this.pitchRange=new ne(-1/0,1/0),this.yawRange=new ne(-1/0,1/0),this.xRange=new ne(-1/0,1/0),this.yRange=new ne(-1/0,1/0),this.zRange=new ne(-1/0,1/0),this.set(e,t,s)}}class gJ{add(e){for(let t=0;t<this._value.length;t++)this._value[t]+=e._value[t]||0;return this}append(e){for(let t=0;t<this._value.length;t++)this._value[t]+=e[t]||0;return this}copy(e){for(let t=0;t<this._value.length;t++)this._value[t]=e._value[t]||0;return this}length(){let e=0;for(const t of this._value)e+=t*t;return Math.sqrt(e)}read(){const e=this._value.slice();return this._value.fill(0),e}constructor(e){Array.isArray(e)?this._value=e.slice():this._value=new Array(+e).fill(0)}}class CI{read(){const e={};for(const t in this.deltas)e[t]=this.deltas[t].read();return e}constructor(e){this.deltas={};for(const t in e)this.deltas[t]=new gJ(e[t])}}class Nv extends CI{on(e,t){this._events.on(e,t)}off(e,t){this._events.off(e,t)}fire(e,...t){this._events.fire(e,...t)}attach(e){this._element&&this.detach(),this._element=e}detach(){this._element&&(this._element=null,this.read())}destroy(){this.detach(),this._events.off()}constructor(...e){super(...e),this._element=null,this._events=new Pe}}class vJ{update(e,t){e.read()}}class yb extends vJ{attach(e,t=!0){}detach(){}update(e,t){return super.update(e,t),this._pose}destroy(){this.detach()}constructor(...e){super(...e),this._pose=new ei}}const SJ=250,yJ=100,xb=()=>{const c=new Map;return{down:e=>{c.set(e.pointerId,[e.screenX,e.screenY])},move:e=>{if(!c.has(e.pointerId))return[0,0];const t=c.get(e.pointerId),s=e.screenX-t[0],i=e.screenY-t[1];return t[0]=e.screenX,t[1]=e.screenY,[s,i]},up:e=>{c.delete(e.pointerId)}}},el=new ne;class ZR{get value(){return this._value}down(e,t){return this._position.set(e,t),this._value.set(0,0),[e,t,e,t]}move(e,t){el.set(e-this._position.x,t-this._position.y),el.length()>this._range&&el.normalize().mulScalar(this._range),this._value.set(J.clamp(el.x/this._range,-1,1),J.clamp(el.y/this._range,-1,1));const{x:s,y:i}=this._position;return[s,i,s+el.x,i+el.y]}up(){return this._position.set(0,0),this._value.set(0,0),[-1,-1,-1,-1]}constructor({range:e}={}){this._range=70,this._position=new ne,this._value=new ne,this._range=e??this._range}}const Sx=(c,e)=>c.indexOf(e)===0,yx=(c,e)=>c.indexOf(e,c.length-e.length)!==-1;class xJ extends Nv{set layout(e){this._layout!==e&&(this._layout=e,this.read(),this._pointerData.clear())}get layout(){return this._layout}get leftJoystick(){return this._leftJoystick}get rightJoystick(){return this._rightJoystick}_onPointerDown(e){const{pointerType:t,pointerId:s,clientX:i,clientY:r}=e;if(this._movementState.down(e),t!=="touch")return;this._element?.setPointerCapture(s);const a=i<window.innerWidth*.5;this._pointerData.set(s,{x:i,y:r,left:a});const o=Date.now();(this._lastPointer.x-i)**2+(this._lastPointer.y-r)**2<yJ&&o-this._lastPointer.time<SJ&&this.deltas.doubleTap.append([1]),this._lastPointer.x=i,this._lastPointer.y=r,this._lastPointer.time=o,a&&Sx(this._layout,"joystick")&&this.fire("joystick:position:left",this._leftJoystick.down(i,r)),!a&&yx(this._layout,"joystick")&&this.fire("joystick:position:right",this._rightJoystick.down(i,r))}_onPointerMove(e){const{pointerType:t,pointerId:s,target:i,clientX:r,clientY:a}=e,[o,h]=this._movementState.move(e);if(t!=="touch"||i!==this._element)return;const u=this._pointerData.get(s);if(!u)return;const{left:f}=u;u.x=r,u.y=a,f?Sx(this._layout,"joystick")?this.fire("joystick:position:left",this._leftJoystick.move(r,a)):this.deltas.leftInput.append([o,h]):yx(this._layout,"joystick")?this.fire("joystick:position:right",this._rightJoystick.move(r,a)):this.deltas.rightInput.append([o,h])}_onPointerUp(e){const{pointerType:t,pointerId:s}=e;if(this._movementState.up(e),t!=="touch")return;this._element?.releasePointerCapture(s);const i=this._pointerData.get(s);if(!i)return;const{left:r}=i;this._pointerData.delete(s),r&&Sx(this._layout,"joystick")&&this.fire("joystick:position:left",this._leftJoystick.up()),!r&&yx(this._layout,"joystick")&&this.fire("joystick:position:right",this._rightJoystick.up())}attach(e){super.attach(e),this._element=e,this._element.addEventListener("pointerdown",this._onPointerDown),this._element.addEventListener("pointermove",this._onPointerMove),this._element.addEventListener("pointerup",this._onPointerUp),this._element.addEventListener("pointercancel",this._onPointerUp)}detach(){this._element&&(this._element.removeEventListener("pointerdown",this._onPointerDown),this._element.removeEventListener("pointermove",this._onPointerMove),this._element.removeEventListener("pointerup",this._onPointerUp),this._element.removeEventListener("pointercancel",this._onPointerUp),this._pointerData.clear(),super.detach())}read(){return this.deltas.leftInput.append([this._leftJoystick.value.x,this._leftJoystick.value.y]),this.deltas.rightInput.append([this._rightJoystick.value.x,this._rightJoystick.value.y]),super.read()}destroy(){this._leftJoystick.up(),this._rightJoystick.up(),super.destroy()}constructor(e){super({leftInput:[0,0],rightInput:[0,0],doubleTap:[0]}),this._movementState=xb(),this._layout="joystick-touch",this._pointerData=new Map,this._lastPointer={x:0,y:0,time:0},e&&(this.layout=e),this._leftJoystick=new ZR,this._rightJoystick=new ZR,this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this)}}const TJ=new ne;class EJ extends Nv{_onPointerDown(e){const{pointerId:t,pointerType:s}=e;this._movementState.down(e),s==="touch"&&(this._element?.setPointerCapture(t),this._pointerEvents.set(t,e),this.deltas.count.append([1]),this._pointerEvents.size>1&&(this._getMidPoint(this._pointerPos),this._pinchDist=this._getPinchDist()))}_onPointerMove(e){const{pointerType:t,target:s,pointerId:i}=e,[r,a]=this._movementState.move(e);if(t==="touch"&&s===this._element&&this._pointerEvents.size!==0)if(this._pointerEvents.set(i,e),this._pointerEvents.size>1){const o=this._getMidPoint(TJ);this.deltas.touch.append([o.x-this._pointerPos.x,o.y-this._pointerPos.y]),this._pointerPos.copy(o);const h=this._getPinchDist();this._pinchDist>0&&this.deltas.pinch.append([this._pinchDist-h]),this._pinchDist=h}else this.deltas.touch.append([r,a])}_onPointerUp(e){const{pointerType:t,pointerId:s}=e;this._movementState.up(e),t==="touch"&&(this._element?.releasePointerCapture(s),this._pointerEvents.delete(s),this.deltas.count.append([-1]),this._pointerEvents.size<2&&(this._pinchDist=-1),this._pointerPos.set(0,0))}_onContextMenu(e){e.preventDefault()}_getMidPoint(e){if(this._pointerEvents.size<2)return e.set(0,0);const[t,s]=this._pointerEvents.values(),i=t.clientX-s.clientX,r=t.clientY-s.clientY;return e.set(s.clientX+i*.5,s.clientY+r*.5)}_getPinchDist(){if(this._pointerEvents.size<2)return 0;const[e,t]=this._pointerEvents.values(),s=e.clientX-t.clientX,i=e.clientY-t.clientY;return Math.sqrt(s*s+i*i)}attach(e){super.attach(e),this._element=e,this._element.addEventListener("pointerdown",this._onPointerDown),this._element.addEventListener("pointermove",this._onPointerMove),this._element.addEventListener("pointerup",this._onPointerUp),this._element.addEventListener("pointercancel",this._onPointerUp),this._element.addEventListener("contextmenu",this._onContextMenu)}detach(){this._element&&(this._element.removeEventListener("pointerdown",this._onPointerDown),this._element.removeEventListener("pointermove",this._onPointerMove),this._element.removeEventListener("pointerup",this._onPointerUp),this._element.removeEventListener("pointercancel",this._onPointerUp),this._element.removeEventListener("contextmenu",this._onContextMenu),this._pointerEvents.clear(),super.detach())}constructor(){super({touch:[0,0],count:[0],pinch:[0]}),this._movementState=xb(),this._pointerEvents=new Map,this._pointerPos=new ne,this._pinchDist=-1,this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onContextMenu=this._onContextMenu.bind(this)}}const QR={passive:!1},DI={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,0:26,1:27,2:28,3:29,4:30,5:31,6:32,7:33,8:34,9:35,UP:36,DOWN:37,LEFT:38,RIGHT:39,SPACE:40,SHIFT:41,CTRL:42},z_=Object.keys(DI).length,xx=Array(z_).fill(0);class gf extends Nv{_onWheel(e){e.preventDefault(),this.deltas.wheel.append([e.deltaY])}_onPointerDown(e){this._movementState.down(e),e.pointerType==="mouse"&&(this._pointerLock?document.pointerLockElement!==this._element&&this._element?.requestPointerLock():this._element?.setPointerCapture(e.pointerId),this._clearButtons(),this._button[e.button]=1,this.deltas.button.append(this._button),this._pointerId===-1&&(this._pointerId=e.pointerId))}_onPointerMove(e){const[t,s]=this._pointerLock&&document.pointerLockElement===this._element?[e.movementX,e.movementY]:this._movementState.move(e);if(e.pointerType==="mouse"&&e.target===this._element){if(this._pointerLock){if(document.pointerLockElement!==this._element)return}else if(this._pointerId!==e.pointerId)return;this.deltas.mouse.append([t,s])}}_onPointerUp(e){this._movementState.up(e),e.pointerType==="mouse"&&(this._pointerLock||this._element?.releasePointerCapture(e.pointerId),this._clearButtons(),this.deltas.button.append(this._button),this._pointerId===e.pointerId&&(this._pointerId=-1))}_onContextMenu(e){e.preventDefault()}_onKeyDown(e){this._pointerLock&&document.pointerLockElement!==this._element||(e.stopPropagation(),this._setKey(e.code,1))}_onKeyUp(e){e.stopPropagation(),this._setKey(e.code,0)}_clearButtons(){for(let e=0;e<this._button.length;e++){if(this._button[e]===1){this._button[e]=-1;continue}this._button[e]=0}}_setKey(e,t){this._keyMap.has(e)&&(this._keyNow[this._keyMap.get(e)??0]=t)}attach(e){super.attach(e),this._element=e,this._element.addEventListener("wheel",this._onWheel,QR),this._element.addEventListener("pointerdown",this._onPointerDown),this._element.addEventListener("pointermove",this._onPointerMove),this._element.addEventListener("pointerup",this._onPointerUp),this._element.addEventListener("pointercancel",this._onPointerUp),this._element.addEventListener("pointerleave",this._onPointerUp),this._element.addEventListener("contextmenu",this._onContextMenu),window.addEventListener("keydown",this._onKeyDown,!1),window.addEventListener("keyup",this._onKeyUp,!1)}detach(){this._element&&(this._element.removeEventListener("wheel",this._onWheel,QR),this._element.removeEventListener("pointerdown",this._onPointerDown),this._element.removeEventListener("pointermove",this._onPointerMove),this._element.removeEventListener("pointerup",this._onPointerUp),this._element.removeEventListener("pointercancel",this._onPointerUp),this._element.removeEventListener("pointerleave",this._onPointerUp),this._element.removeEventListener("contextmenu",this._onContextMenu),window.removeEventListener("keydown",this._onKeyDown,!1),window.removeEventListener("keyup",this._onKeyUp,!1),this._keyNow.fill(0),this._keyPrev.fill(0),super.detach())}read(){for(let e=0;e<xx.length;e++)xx[e]=this._keyNow[e]-this._keyPrev[e],this._keyPrev[e]=this._keyNow[e];return this.deltas.key.append(xx),super.read()}constructor({pointerLock:e=!1}={}){super({key:Array(z_).fill(0),button:[0,0,0],mouse:[0,0],wheel:[0]}),this._movementState=xb(),this._pointerId=-1,this._keyMap=new Map,this._keyPrev=Array(z_).fill(0),this._keyNow=Array(z_).fill(0),this._button=Array(3).fill(0),this._pointerLock=e??!1;const{keyCode:t}=gf;for(let s=0;s<26;s++){const i=`Key${String.fromCharCode(65+s)}`;this._keyMap.set(i,t.A+s)}for(let s=0;s<10;s++){const i=`Digit${s}`;this._keyMap.set(i,t[0]+s)}this._keyMap.set("ArrowUp",t.UP),this._keyMap.set("ArrowDown",t.DOWN),this._keyMap.set("ArrowLeft",t.LEFT),this._keyMap.set("ArrowRight",t.RIGHT),this._keyMap.set("Space",t.SPACE),this._keyMap.set("ShiftLeft",t.SHIFT),this._keyMap.set("ShiftRight",t.SHIFT),this._keyMap.set("ControlLeft",t.CTRL),this._keyMap.set("ControlRight",t.CTRL),this._onWheel=this._onWheel.bind(this),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onContextMenu=this._onContextMenu.bind(this),this._onKeyDown=this._onKeyDown.bind(this),this._onKeyUp=this._onKeyUp.bind(this)}}gf.keyCode=DI;const PI={A:0,B:1,X:2,Y:3,LB:4,RB:5,LT:6,RT:7,SELECT:8,START:9,LEFT_STICK:10,RIGHT_STICK:11},Tx=Object.keys(PI).length;class RI extends Nv{read(){const e=navigator.getGamepads();for(let t=0;t<e.length;t++){const s=e[t];if(!s||s.mapping!=="standard"||s.axes.length<4||s.buttons.length<Tx)continue;const{buttons:i,axes:r}=s;for(let a=0;a<this._buttonPrev.length;a++){const o=+i[a].pressed;this.deltas.buttons[a]=o-this._buttonPrev[a],this._buttonPrev[a]=o}this.deltas.leftStick.append([r[0],r[1]]),this.deltas.rightStick.append([r[2],r[3]])}return super.read()}constructor(){super({buttons:Array(Tx).fill(0),leftStick:[0,0],rightStick:[0,0]}),this._buttonPrev=Array(Tx).fill(0)}}RI.buttonCode=PI;const Qn=(c,e)=>1-Math.pow(c,e*1e3),Dd=new D,bJ=new D,JR=new D,eM=new D,tM=new D,v_=new pe;class AJ extends yb{set pitchRange(e){this._targetPose.pitchRange.copy(e),this._pose.copy(this._targetPose.rotate(D.ZERO))}get pitchRange(){return this._targetPose.pitchRange}set yawRange(e){this._targetPose.yawRange.copy(e),this._pose.copy(this._targetPose.rotate(D.ZERO))}get yawRange(){return this._targetPose.yawRange}attach(e,t=!0){this._targetPose.copy(e),t||this._pose.copy(this._targetPose)}detach(){this._targetPose.copy(this._pose)}update(e,t){const{move:s,rotate:i}=e.read();return this._targetPose.rotate(bJ.set(-i[1],-i[0],0)),v_.setFromEulerAngles(this._pose.angles),v_.transformVector(D.FORWARD,JR),v_.transformVector(D.RIGHT,eM),v_.transformVector(D.UP,tM),Dd.set(0,0,0),Dd.add(JR.mulScalar(s[2])),Dd.add(eM.mulScalar(s[0])),Dd.add(tM.mulScalar(s[1])),this._targetPose.move(Dd),this._pose.lerp(this._pose,this._targetPose,Qn(this.moveDamping,t),Qn(this.rotateDamping,t))}destroy(){this.detach()}constructor(...e){super(...e),this._targetPose=new ei,this.rotateDamping=.98,this.moveDamping=.98}}const wJ=new D,tl=new D,CJ=new D,sM=new pe;class DJ extends yb{set pitchRange(e){this._targetRootPose.pitchRange.copy(e),this._rootPose.copy(this._targetRootPose.rotate(D.ZERO))}get pitchRange(){return this._targetRootPose.pitchRange}set yawRange(e){this._targetRootPose.yawRange.copy(e),this._rootPose.copy(this._targetRootPose.rotate(D.ZERO))}get yawRange(){return this._targetRootPose.yawRange}set zoomRange(e){this._targetChildPose.zRange.copy(e),this._childPose.copy(this._targetChildPose.move(D.ZERO))}get zoomRange(){return this._targetRootPose.zRange}attach(e,t=!0){this._targetRootPose.set(e.getFocus(wJ),e.angles,0),this._targetChildPose.position.set(0,0,e.distance),t||(this._rootPose.copy(this._targetRootPose),this._childPose.copy(this._targetChildPose))}detach(){this._targetRootPose.copy(this._rootPose),this._targetChildPose.copy(this._childPose)}update(e,t){const{move:s,rotate:i}=e.read();tl.set(s[0],s[1],0),sM.setFromEulerAngles(this._rootPose.angles).transformVector(tl,tl),this._targetRootPose.move(tl);const{z:r}=this._targetChildPose.position;return this._targetChildPose.move(tl.set(0,0,r*(1+s[2])-r)),this._targetRootPose.rotate(CJ.set(-i[1],-i[0],0)),this._rootPose.lerp(this._rootPose,this._targetRootPose,Qn(this.moveDamping,t),Qn(this.rotateDamping,t),1),this._childPose.lerp(this._childPose,this._targetChildPose,Qn(this.zoomDamping,t),1,1),sM.setFromEulerAngles(this._rootPose.angles).transformVector(this._childPose.position,tl).add(this._rootPose.position),this._pose.set(tl,this._rootPose.angles,this._childPose.position.z)}destroy(){this.detach()}constructor(...e){super(...e),this._targetRootPose=new ei,this._rootPose=new ei,this._targetChildPose=new ei,this._childPose=new ei,this.rotateDamping=.98,this.moveDamping=.98,this.zoomDamping=.98}}const iM=.001,PJ=new D,rM=new D,RJ=new pe;class MJ extends yb{attach(e,t=!0){this._targetRootPose.set(e.getFocus(PJ),e.angles,0),this._targetChildPose.position.set(0,0,e.distance),t||(this._rootPose.copy(this._targetRootPose),this._childPose.copy(this._targetChildPose))}detach(){this._targetRootPose.copy(this._rootPose),this._targetChildPose.copy(this._childPose)}complete(){return this._targetRootPose.equalsApprox(this._rootPose,iM)&&this._targetChildPose.equalsApprox(this._childPose,iM)}update(e,t){return e.read(),this._rootPose.lerp(this._rootPose,this._targetRootPose,Qn(this.focusDamping,t),Qn(this.focusDamping,t),1),this._childPose.lerp(this._childPose,this._targetChildPose,Qn(this.focusDamping,t),1,1),RJ.setFromEulerAngles(this._rootPose.angles).transformVector(this._childPose.position,rM).add(this._rootPose.position),this._pose.set(rM,this._rootPose.angles,this._childPose.position.length())}destroy(){this.detach()}constructor(...e){super(...e),this._targetRootPose=new ei,this._rootPose=new ei,this._targetChildPose=new ei,this._childPose=new ei,this.focusDamping=.98}}const Tb=q.createContext(void 0),Eb=()=>{const c=q.useContext(Tb);if(c===void 0)throw new Error("`useParent` must be used within an App or Entity via a ParentContext.Provider");return c},MI=q.createContext(null),ru=()=>{const c=q.useContext(MI);if(!c)throw new Error("`useApp` must be used within an Application component");return c},LI={aliceblue:"#F0F8FF",antiquewhite:"#FAEBD7",aqua:"#00FFFF",aquamarine:"#7FFFD4",azure:"#F0FFFF",beige:"#F5F5DC",bisque:"#FFE4C4",black:"#000000",blanchedalmond:"#FFEBCD",blue:"#0000FF",blueviolet:"#8A2BE2",brown:"#A52A2A",burlywood:"#DEB887",cadetblue:"#5F9EA0",chartreuse:"#7FFF00",chocolate:"#D2691E",coral:"#FF7F50",cornflowerblue:"#6495ED",cornsilk:"#FFF8DC",crimson:"#DC143C",cyan:"#00FFFF",darkblue:"#00008B",darkcyan:"#008B8B",darkgoldenrod:"#B8860B",darkgray:"#A9A9A9",darkgreen:"#006400",darkgrey:"#A9A9A9",darkkhaki:"#BDB76B",darkmagenta:"#8B008B",darkolivegreen:"#556B2F",darkorange:"#FF8C00",darkorchid:"#9932CC",darkred:"#8B0000",darksalmon:"#E9967A",darkseagreen:"#8FBC8F",darkslateblue:"#483D8B",darkslategray:"#2F4F4F",darkslategrey:"#2F4F4F",darkturquoise:"#00CED1",darkviolet:"#9400D3",deeppink:"#FF1493",deepskyblue:"#00BFFF",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1E90FF",firebrick:"#B22222",floralwhite:"#FFFAF0",forestgreen:"#228B22",fuchsia:"#FF00FF",gainsboro:"#DCDCDC",ghostwhite:"#F8F8FF",gold:"#FFD700",goldenrod:"#DAA520",gray:"#808080",green:"#008000",greenyellow:"#ADFF2F",grey:"#808080",honeydew:"#F0FFF0",hotpink:"#FF69B4",indianred:"#CD5C5C",indigo:"#4B0082",ivory:"#FFFFF0",khaki:"#F0E68C",lavender:"#E6E6FA",lavenderblush:"#FFF0F5",lawngreen:"#7CFC00",lemonchiffon:"#FFFACD",lightblue:"#ADD8E6",lightcoral:"#F08080",lightcyan:"#E0FFFF",lightgoldenrodyellow:"#FAFAD2",lightgray:"#D3D3D3",lightgreen:"#90EE90",lightgrey:"#D3D3D3",lightpink:"#FFB6C1",lightsalmon:"#FFA07A",lightseagreen:"#20B2AA",lightskyblue:"#87CEFA",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#B0C4DE",lightyellow:"#FFFFE0",lime:"#00FF00",limegreen:"#32CD32",linen:"#FAF0E6",magenta:"#FF00FF",maroon:"#800000",mediumaquamarine:"#66CDAA",mediumblue:"#0000CD",mediumorchid:"#BA55D3",mediumpurple:"#9370DB",mediumseagreen:"#3CB371",mediumslateblue:"#7B68EE",mediumspringgreen:"#00FA9A",mediumturquoise:"#48D1CC",mediumvioletred:"#C71585",midnightblue:"#191970",mintcream:"#F5FFFA",mistyrose:"#FFE4E1",moccasin:"#FFE4B5",navajowhite:"#FFDEAD",navy:"#000080",oldlace:"#FDF5E6",olive:"#808000",olivedrab:"#6B8E23",orange:"#FFA500",orangered:"#FF4500",orchid:"#DA70D6",palegoldenrod:"#EEE8AA",palegreen:"#98FB98",paleturquoise:"#AFEEEE",palevioletred:"#DB7093",papayawhip:"#FFEFD5",peachpuff:"#FFDAB9",peru:"#CD853F",pink:"#FFC0CB",plum:"#DDA0DD",powderblue:"#B0E0E6",purple:"#800080",rebeccapurple:"#663399",red:"#FF0000",rosybrown:"#BC8F8F",royalblue:"#4169E1",saddlebrown:"#8B4513",salmon:"#FA8072",sandybrown:"#F4A460",seagreen:"#2E8B57",seashell:"#FFF5EE",sienna:"#A0522D",silver:"#C0C0C0",skyblue:"#87CEEB",slateblue:"#6A5ACD",slategray:"#708090",slategrey:"#708090",snow:"#FFFAFA",springgreen:"#00FF7F",steelblue:"#4682B4",tan:"#D2B48C",teal:"#008080",thistle:"#D8BFD8",tomato:"#FF6347",turquoise:"#40E0D0",violet:"#EE82EE",wheat:"#F5DEB3",white:"#FFFFFF",whitesmoke:"#F5F5F5",yellow:"#FFFF00",yellowgreen:"#9ACD32"},LJ=new Set(Object.keys(LI)),IJ=c=>LJ.has(c)&&LI[c],aM=1e3,th=new Set,Xn=c=>{th.has(c)||(console.error(`[PlayCanvas React]:

${c}`),th.add(c),th.size>aM&&Array.from(th).slice(0,th.size-aM).forEach(t=>th.delete(t)))};function II(c,e,t,s,i){return c!==void 0&&e.validate(c)?c:e.default}function OI(c,e,t=!0){const{schema:s,name:i,apiName:r}=e,a={...c};return Object.keys(c).forEach(o=>{if(o!=="children"&&o in s){const h=s[o];h&&(a[o]=II(c[o],h))}}),a}function vf(c,e,t=!0){const{schema:s,name:i,apiName:r}=e,a={};for(const o in s){const h=s[o],u=c[o],f=u!==void 0?u:h?.default;a[o]=II(f,h)}return a}function NI(c,e,t){Object.entries(t).forEach(([s,i])=>{if(s in e){const r=e[s];if(r)if(r.apply)r.apply(c,t,s);else try{c[s]=i}catch(a){console.error(`Error applying prop ${s}: ${a}`)}}})}function OJ(c){const e={};Object.entries(c).filter(([i])=>!i.startsWith("_")&&typeof c[i]!="function").forEach(([i,r])=>{e[i]={value:r,isDefinedWithSetter:!1}});const s=Object.getPrototypeOf(c);if(s&&s!==Object.prototype){const i=Object.getOwnPropertyDescriptors(s);Object.entries(i).forEach(([r,a])=>{if(r.startsWith("_")||r==="constructor")return;const o=typeof a.get=="function",h=typeof a.set=="function";if(!(h&&!o))if(a.get){const u=console.warn;try{console.warn=()=>{};const f=a.get.call(c),m=f!==null&&typeof f=="object"?f.clone?f.clone():{...f}:f;e[r]={value:m,isDefinedWithSetter:h}}catch{e[r]={value:void 0,isDefinedWithSetter:h}}finally{console.warn=u}}else h&&(e[r]={value:void 0,isDefinedWithSetter:!0})})}return e}function rm(c,e,t,s){const{exclude:i=[],apiName:r=c}=s??{},a=e(),o={},h=OJ(a);return Object.entries(h).forEach(([m,_])=>{if(i.includes(String(m)))return;const{value:g,isDefinedWithSetter:S}=_;g instanceof ue?o[m]={validate:x=>Array.isArray(x)&&x.length===3||typeof x=="string",default:g.toString(!0),errorMsg:x=>`Invalid value for prop "${String(m)}": "${x}". Expected a hex like "#FF0000", CSS color name like "red", or an array "[1, 0, 0]").`,apply:(x,T,E)=>{if(typeof T[E]=="string"){const b=IJ(T[E])||T[E];x[E]=new ue().fromString(b)}else x[E]=x[E]=new ue().fromArray(T[E])}}:g instanceof ne?o[m]={validate:x=>Array.isArray(x)&&x.length===2,default:[g.x,g.y],errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected an array of 2 numbers.`,apply:S?(x,T,E)=>{x[E]=new ne().fromArray(T[E])}:(x,T,E)=>{x[E].set(...T[E])}}:g instanceof D?o[m]={validate:x=>Array.isArray(x)&&x.length===3,default:[g.x,g.y,g.z],errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected an array of 3 numbers.`,apply:S?(x,T,E)=>{x[E]=new D().fromArray(T[E])}:(x,T,E)=>{x[E].set(...T[E])}}:g instanceof me?o[m]={validate:x=>Array.isArray(x)&&x.length===4,default:[g.x,g.y,g.z,g.w],errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected an array of 4 numbers.`,apply:S?(x,T,E)=>{x[E]=new me().fromArray(T[E])}:(x,T,E)=>{x[E].set(...T[E])}}:g instanceof pe?o[m]={validate:x=>Array.isArray(x)&&(x.length===4||x.length===3),default:[g.x,g.y,g.z,g.w],errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected an array of 4 numbers.`,apply:S?(x,T,E)=>{x[E]=new pe().fromArray(T[E])}:(x,T,E)=>{x[E].set(...T[E])}}:g instanceof fe?o[m]={validate:x=>Array.isArray(x)&&x.length===16,default:Array.from(g.data),errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected an array of 16 numbers.`}:typeof g=="number"?o[m]={validate:x=>typeof x=="number",default:g,errorMsg:x=>`Invalid value for prop "${String(m)}": "${x}". Expected a number.`}:typeof g=="string"?o[m]={validate:x=>typeof x=="string",default:g,errorMsg:x=>`Invalid value for prop "${String(m)}": "${x}". Expected a string.`}:typeof g=="boolean"?o[m]={validate:x=>typeof x=="boolean",default:g,errorMsg:x=>`Invalid value for prop "${String(m)}": "${x}". Expected a boolean.`}:Array.isArray(g)?o[m]={validate:x=>Array.isArray(x),default:g,errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected an array.`,apply:(x,T,E)=>{const b=T[E];if(Array.isArray(b)){const C=x[E];C.length=0,C.push(...b)}}}:g instanceof Dl?o[m]={validate:x=>x instanceof Dl,default:g,errorMsg:x=>`Invalid value for prop "${String(m)}": "${JSON.stringify(x)}". Expected a Material.`}:g===null&&(o[m]={validate:()=>!0,default:g,errorMsg:()=>"",apply:(x,T,E)=>{x[E]=T[E]}})}),t&&t(a),{name:c,apiName:r,schema:o}}function FI(){const c={id:"pc-react-mock-canvas"};return new AI(c,{graphicsDevice:new v2(c)})}const NJ=FI(),Fv=()=>NJ;function BI(c,e,t){const s=q.useRef(null),i=Eb(),r=ru();q.useLayoutEffect(()=>{if(c)return i&&(s.current||(s.current=i.addComponent(c))),()=>{const a=s.current;s.current=null,!(!r||!r.root)&&a&&r.systems[c]&&i.c[c]&&i.removeComponent(c)}},[r,i,c]),q.useLayoutEffect(()=>{if(!c)return;const a=s.current;if(!a)return;const o=Object.fromEntries(Object.entries(e).filter(([h])=>h in a));NI(a,t,o)})}const FJ=(c,e,t)=>{const s=Eb(),i=ru(),r=BJ(c.name),a=q.useRef(null),o=q.useRef(null);q.useEffect(()=>{if(i){if(s.script||s.addComponent("script"),!a.current){const h=s.script,u=h.create(c,{properties:{...e},preloading:!1});t&&(typeof t=="function"?t(u):t.current=u),a.current=u,o.current=h}return()=>{const h=o.current,u=a.current;a.current=null,o.current=null,i&&i.root&&u&&h&&(h.destroy(r),t&&(typeof t=="function"?t(null):t.current=null))}}},[i,s,c]),q.useEffect(()=>{const h=a.current;if(!h)return;const u=Object.fromEntries(Object.entries(e).filter(([f])=>f in h));Object.assign(h,u)},[e])},BJ=c=>c[0].toLowerCase()+c.substring(1),UJ=({app:c,url:e,type:t,props:s={},onProgress:i})=>new Promise((r,a)=>{let o=e;try{o+=JSON.stringify(s,Object.keys(s).sort())}catch{const g=`Invalid props for "fetchAsset({ url: '${e}', type: '${t}' })". \`props\` must be serializable to JSON.`;throw Xn(g),new Error(g)}let h=c.assets.find(o,t);h||(h=new Ee(o,t,{url:e,...s.file??{}},s.data??{},s.options??{}),c.assets.add(h));const u=()=>{_(),i?.({progress:1}),r(h)},f=g=>{_(),a(g)},m=(g,S)=>{if(typeof g!="number"||typeof S!="number"){Xn("Invalid progress callback parameters");return}i?.({progress:g/S,totalReceived:g,totalRequired:S})},_=()=>{i&&h.off("progress",m),h.off("load",u),h.off("error",f)};i&&h.on("progress",m),h.resource?u():(h.once("load",u),h.once("error",f),h.loading||c.assets.load(h))}),nM="https://www.gstatic.com/draco/versioned/decoders/1.5.7/";DK({jsUrl:nM+"draco_wasm_wrapper.js",wasmUrl:nM+"draco_decoder.wasm",numWorkers:2,lazyInit:!0});const oM=["texture","gsplat","container","model","font"],UI=(c,e,t={})=>{const s=ru(),i=q.useRef(new Set),r=q.useCallback(f=>(i.current.add(f),()=>i.current.delete(f)),[]),[a,o]=q.useState({asset:null,loading:!0,error:null});let h=null;try{h=JSON.stringify({props:t},Object.keys({props:t}).sort())}catch{const f=`Invalid props for "useAsset('${c}')". \`props\` must be serializable to JSON.`;Xn(f),o({asset:null,loading:!1,error:f})}const u=q.useCallback(f=>{for(const m of i.current)m(f)},[]);return q.useEffect(()=>{if(h!==null){if(o({asset:null,loading:!0,error:null}),!c){Xn("Asset source URL is required"),o({asset:null,loading:!1,error:"Asset source URL is required"});return}if(!s){Xn("PlayCanvas application not found"),o({asset:null,loading:!1,error:"PlayCanvas application not found"});return}if(!oM.includes(e)){Xn(`Unsupported asset type: "${e}". Supported types are "${oM.join('", "')}"`),o({asset:null,loading:!1,error:`Unsupported asset type: ${e}`});return}UJ({app:s,url:c,type:e,props:t,onProgress:u}).then(f=>{o({asset:f,loading:!1,error:null})}).catch(f=>{Xn(`Failed to load asset: ${c}`),o({asset:null,loading:!1,error:f?.message||`Failed to load asset: ${c}`})})}},[s,c,e,h]),{...a,subscribe:r}},zJ=(c,e={})=>UI(c,"gsplat",e),kJ=(c,e={})=>UI(c,"texture",{...e,data:{type:bh,mipmaps:!1,...e.data??{}}}),VJ=q.createContext({isPhysicsEnabled:!1,isPhysicsLoaded:!1,physicsError:null});let Ex=0;const GJ=({children:c,enabled:e,app:t})=>{const[s,i]=q.useState(!1),[r,a]=q.useState(null);return q.useEffect(()=>{if(!e){i(!1),a(null);return}return(async()=>{try{if(!globalThis.Ammo){const h=await Xx(()=>import("./react_false-Bscn1dCY.js"),[]);globalThis.Ammo=h.default}t.systems.rigidbody?.dispatcher||t.systems.rigidbody?.onLibraryLoaded(),i(!0),a(null),Ex++}catch(h){const u=h instanceof Error?h:new Error("Failed to load physics library");a(u),i(!1)}})(),()=>{e&&(Ex--,Ex===0&&globalThis.Ammo&&delete globalThis.Ammo)}},[e,t]),ge.jsx(VJ.Provider,{value:{isPhysicsEnabled:e,isPhysicsLoaded:s,physicsError:r},children:c})},zI=q.createContext(null),HJ=()=>{const c=q.useContext(zI);if(c===null)throw new Error("usePointerEventsContext must be used within a PointerEventsContext.Provider");return c};class bx{nativeEvent;hasStoppedPropagation=!1;type;constructor(e){this.nativeEvent=e,this.type=e.type,Object.assign(this,e)}stopPropagation(){this.hasStoppedPropagation=!0,this.nativeEvent.stopPropagation()}stopImmediatePropagation(){this.hasStoppedPropagation=!0,this.nativeEvent.stopImmediatePropagation()}}class WJ{nativeEvent;hasStoppedPropagation=!1;type;constructor(e){this.nativeEvent=e,this.type=e.type,Object.assign(this,e)}stopPropagation(){this.hasStoppedPropagation=!0,this.nativeEvent.stopPropagation()}stopImmediatePropagation(){this.hasStoppedPropagation=!0,this.nativeEvent.stopImmediatePropagation()}}const Ax=(c,e,t=null)=>{for(;c;){if(c===t)return!1;if(c.fire(e.type,e),e.hasStoppedPropagation)return!0;c=c.parent}return!1},XJ=(c,e)=>{const t=new Set;let s=c;for(;s;)t.add(s),s=s.parent;for(s=e;s;){if(t.has(s))return s;s=s.parent}return null},lM=async(c,e,t,s)=>{const[i]=c.root.findComponents("camera").filter(f=>!f.renderTarget).sort((f,m)=>f.priority-m.priority);if(!i)return null;const r=c.graphicsDevice.canvas;if(!r||r.width===0||r.height===0)return null;const a=s.clientX-t.left,o=s.clientY-t.top;if(a<0||o<0||a>t.width||o>t.height)return null;const h=r.width/(t.width*c.graphicsDevice.maxPixelRatio),u=r.height/(t.height*c.graphicsDevice.maxPixelRatio);try{e.prepare(i,c.scene);const[f]=await e.getSelectionAsync(a*h,o*u);return f?f?.node:null}catch{return null}},qJ=(c,e,t)=>{const s=q.useRef(null),i=q.useRef(null),r=q.useRef(c?c.graphicsDevice.canvas.getBoundingClientRect():null),a=q.useMemo(()=>!c||!c.graphicsDevice?null:new mJ(c,c.graphicsDevice.width,c.graphicsDevice.height),[c]);q.useEffect(()=>{const f=new ResizeObserver(()=>{r.current=c?c.graphicsDevice.canvas.getBoundingClientRect():null,r.current&&a?.resize(r.current.width,r.current.height)});return c?.graphicsDevice?.canvas&&f.observe(c.graphicsDevice.canvas),()=>f.disconnect()},[c]);const o=q.useCallback(f=>{i.current=f},[a]),h=q.useCallback(async()=>{if(t.size===0){s.current=null;return}const f=i.current;if(!a||!c||!f||!r.current)return null;const m=await lM(c,a,r.current,f),_=s.current,g=XJ(_,m);if(_&&_!==m){const S=new bx(f);S.type="pointerout",Ax(_,S,g)}if(m&&m!==_){const S=new bx(f);S.type="pointerover",Ax(m,S,g)}return s.current=m,null},[a,t]),u=q.useCallback(async f=>{if(!a||!c||!r.current||t.size===0)return;const m=await lM(c,a,r.current,f);if(!m)return;const _=f instanceof PointerEvent?new bx(f):new WJ(f);Ax(m,_)},[a,t]);q.useLayoutEffect(()=>{if(!(!a||!e||!c))return e.addEventListener("pointerup",u),e.addEventListener("pointerdown",u),e.addEventListener("mouseup",u),e.addEventListener("click",u),e.addEventListener("pointermove",o),c.on("update",h),()=>{e.removeEventListener("pointerup",u),e.removeEventListener("pointerdown",u),e.removeEventListener("click",u),e.removeEventListener("pointermove",o),c.off("update",h)}},[c,e,u,o,h])},YJ={alpha:!0,depth:!0,stencil:!0,antialias:!0,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:"default",failIfMajorPerformanceCaveat:!1,desynchronized:!1,xrCompatible:!1};async function jJ(c,e={}){const t=e.deviceTypes??[];Ve.browser&&globalThis.navigator?.xr&&(e.xrCompatible??=!0);const s=t.map(i=>i===ng&&globalThis.navigator?.gpu?async()=>new Wz(c,e).initWebGpu(e.glslangUrl,e.twgslUrl):i===_h?async()=>new g2(c,e):i===og?async()=>new v2(c,e):async()=>{throw new Error(`Unsupported device type: ${i}`)});for(const i of s)try{const r=await i();if(r)return r}catch(r){console.log(r)}throw new Error("Failed to create a graphics device")}const $J=({children:c,className:e="pc-app",style:t={width:"100%",height:"100%"},...s})=>{const i=q.useRef(null);return ge.jsxs(ge.Fragment,{children:[ge.jsx(KJ,{className:e,style:t,ref:i}),ge.jsx(ZJ,{canvasRef:i,...s,children:c})]})},KJ=b1.memo(b1.forwardRef((c,e)=>{const{className:t,style:s}=c;return ge.jsx("canvas",{ref:e,className:t,style:s,"aria-label":"Interactive 3D Scene"})})),ZJ=c=>{const{children:e,...t}=c,s=vf(t,Dg),{canvasRef:i,fillMode:r=M_,resolutionMode:a=yh,usePhysics:o=!1,graphicsDeviceOptions:h,deviceTypes:u=[_h],...f}=s,m=u.join("-"),_=q.useMemo(()=>h?Object.entries(h).sort(([b],[C])=>b.localeCompare(C)).map(([b,C])=>`${b}:${String(C)}`).join("|"):"none",[h]),g=q.useMemo(()=>({...YJ,...h}),[h]),[S,x]=q.useState(null),T=q.useRef(null),E=q.useMemo(()=>new Set,[]);return qJ(T.current,i.current,E),q.useLayoutEffect(()=>{let b=!1;return(async()=>{const C=i.current;if(!C||T.current)return;const w=await jJ(C,{deviceTypes:u,...g});if(b){w.destroy?.();return}const P=new AI(C,{mouse:new Gf(C),touch:new Hf(C),graphicsDevice:w});P.start(),T.current=P,x(P)})(),()=>{b=!0,T.current&&(T.current.destroy(),T.current=null,x(null))}},[_,m]),q.useEffect(()=>{S&&(S.setCanvasFillMode(r),S.setCanvasResolution(a))},[S,r,a]),q.useLayoutEffect(()=>{S&&NI(S,Dg.schema,f)}),S?ge.jsx(GJ,{enabled:o,app:S,children:ge.jsx(MI.Provider,{value:T.current,children:ge.jsx(zI.Provider,{value:E,children:ge.jsx(Tb.Provider,{value:T.current?.root,children:e})})})}):null},QJ=["mouse","touch","keyboard","gamepads","scene","scripts","assets"],Dg=rm("Application",()=>FI(),c=>c.destroy(),{exclude:QJ});Dg.schema={...Dg.schema,deviceTypes:{validate:c=>Array.isArray(c)&&c.every(e=>typeof e=="string"&&[ng,_h,og].includes(e)),errorMsg:c=>`deviceTypes must be an array containing one or more of: '${ng}', '${_h}', '${og}'. Received: ['${c}']`,default:[_h]},className:{validate:c=>typeof c=="string",errorMsg:c=>`className must be a string. Received: ${c}`,default:"pc-app"},style:{validate:c=>typeof c=="object"&&c!==null,errorMsg:c=>`style must be an object. Received: ${c}`,default:{width:"100%",height:"100%"}},canvasRef:{validate:c=>c!==null&&typeof c=="object"&&"current"in c,errorMsg:c=>`canvasRef must be a React ref object. Received: ${c}`,default:null},usePhysics:{validate:c=>typeof c=="boolean",errorMsg:c=>`usePhysics must be a boolean. Received: ${c}`,default:!1},fillMode:{validate:c=>typeof c=="string"&&[M_,iT,gg].includes(c),errorMsg:()=>`"fillMode" must be one of: ${M_}, ${iT}, ${gg}`,default:M_},resolutionMode:{validate:c=>typeof c=="string"&&[yh,rT].includes(c),errorMsg:()=>`"resolutionMode" must be one of: ${yh}, ${rT}`,default:yh},graphicsDeviceOptions:{validate:c=>c===void 0||typeof c=="object"&&c!==null,errorMsg:c=>`graphicsDeviceOptions must be an object. Received: ${c}`,default:void 0}};const wx=q.forwardRef(function(e,t){const{children:s,...i}=e,r=vf(i,JJ),{name:a="Untitled",position:o=[0,0,0],scale:h=[1,1,1],rotation:u=[0,0,0],onPointerDown:f,onPointerUp:m,onPointerOver:_,onPointerOut:g,onClick:S}=r,x=Eb(),T=ru(),E=HJ(),b=!!(f||m||_||g||S),C=P=>{P.name=a,P.setLocalPosition(...o),P.setLocalScale(...h),P.setLocalEulerAngles(...u)},w=q.useMemo(()=>{const P=new Nt(void 0,T);return C(P),P},[T]);return q.useImperativeHandle(t,()=>w),q.useLayoutEffect(()=>(x.addChild(w),()=>{x.removeChild(w),w.destroy()}),[T,x,w]),q.useLayoutEffect(()=>(b&&E.add(w.getGuid()),f&&w.on("pointerdown",f),m&&w.on("pointerup",m),_&&w.on("pointerover",_),g&&w.on("pointerout",g),S&&w.on("click",S),()=>{b&&E.delete(w.getGuid()),f&&w.off("pointerdown",f),m&&w.off("pointerup",m),_&&w.off("pointerover",_),g&&w.off("pointerout",g),S&&w.off("click",S)}),[T,x,w,f,m,_,g,S]),q.useLayoutEffect(()=>{C(w)},[w,a,o,h,u]),ge.jsx(ge.Fragment,{children:ge.jsx(Tb.Provider,{value:w,children:s||null})})}),JJ={name:"Entity",apiName:"Entity",schema:{name:{validate:c=>!c||typeof c=="string",errorMsg:c=>`Invalid value for prop "name": "${c}". Expected a string or undefined.`,default:"Untitled"},position:{validate:c=>Array.isArray(c)&&c.length===3,errorMsg:c=>`Invalid value for prop "position": "${c}". Expected an array of 3 numbers.`,default:[0,0,0]},scale:{validate:c=>Array.isArray(c)&&c.length===3,errorMsg:c=>`Invalid value for prop "scale": "${c}". Expected an array of 3 numbers.`,default:[1,1,1]},rotation:{validate:c=>Array.isArray(c)&&c.length===3,errorMsg:c=>`Invalid value for prop "rotation": "${c}". Expected an array of 3 numbers.`,default:[0,0,0]},onPointerDown:{validate:c=>typeof c=="function",errorMsg:c=>`Invalid value for prop "onPointerDown": "${c}". Expected a function.`,default:void 0},onPointerUp:{validate:c=>typeof c=="function",errorMsg:c=>`Invalid value for prop "onPointerUp": "${c}". Expected a function.`,default:void 0},onPointerOver:{validate:c=>typeof c=="function",errorMsg:c=>`Invalid value for prop "onPointerOver": "${c}". Expected a function.`,default:void 0},onPointerOut:{validate:c=>typeof c=="function",errorMsg:c=>`Invalid value for prop "onPointerOut": "${c}". Expected a function.`,default:void 0},onClick:{validate:c=>typeof c=="function",errorMsg:c=>`Invalid value for prop "onClick": "${c}". Expected a function.`,default:void 0}}},eee=c=>{const e=OI(c,cM);return BI("camera",e,cM.schema),null},cM=rm("Camera",()=>new Nt("mock-camera",Fv()).addComponent("camera"),c=>c.system.destroy(),{apiName:"CameraComponent"}),Pd=new D,Aa=new D,Cx=new ei,Dx=new CI({move:[0,0,0],rotate:[0,0,0]}),hM=(c,e,t)=>{const s=Math.sqrt(c[0]*c[0]+c[1]*c[1]);if(s<e){c.fill(0);return}const i=(s-e)/(t-e);c[0]*=i/s,c[1]*=i/s},uM=(c,e,t,s,i=new D)=>{const{system:r,fov:a,aspectRatio:o,horizontalFov:h,projection:u,orthoHeight:f}=c,{width:m,height:_}=r.app.graphicsDevice.clientRect;i.set(-(e/m)*2,t/_*2,0);const g=Aa.set(0,0,0);if(u===dr){const S=s*Math.tan(.5*a*J.DEG_TO_RAD);h?g.set(S,S/o,0):g.set(S*o,S,0)}else g.set(f*o,f,0);return i.mul(g),i};class tee extends zs{static scriptName="cameraControls";_camera;_enableOrbit=!0;_enableFly=!0;_startZoomDist=0;_pitchRange=new ne(-360,360);_yawRange=new ne(-360,360);_zoomRange=new ne(.01,0);_desktopInput=new gf;_orbitMobileInput=new EJ;_flyMobileInput=new xJ;_gamepadInput=new RI;_flyController=new AJ;_orbitController=new DJ;_focusController=new MJ;_controller;_pose=new ei;_mode;_state={axis:new D,shift:0,ctrl:0,mouse:[0,0,0],touches:0};set enableFly(e){this._enableFly=e,!this._enableFly&&this._mode==="fly"&&this._setMode("orbit")}get enableFly(){return this._enableFly}set enableOrbit(e){this._enableOrbit=e,!this._enableOrbit&&this._mode==="orbit"&&this._setMode("fly")}get enableOrbit(){return this._enableOrbit}enablePan=!0;set focusDamping(e){this._focusController.focusDamping=e}get focusDamping(){return this._focusController.focusDamping}set focusPoint(e){const t=this._camera.entity.getPosition();this._startZoomDist=t.distance(e),this._controller.attach(this._pose.look(t,e),!1)}get focusPoint(){return this._pose.getFocus(Pd)}set moveDamping(e){this._flyController.moveDamping=e}get moveDamping(){return this._flyController.moveDamping}moveSpeed=10;moveFastSpeed=20;moveSlowSpeed=5;set rotateDamping(e){this._flyController.rotateDamping=e,this._orbitController.rotateDamping=e}get rotateDamping(){return this._orbitController.rotateDamping}rotateSpeed=.2;rotateJoystickSens=2;set zoomDamping(e){this._orbitController.zoomDamping=e}get zoomDamping(){return this._orbitController.zoomDamping}zoomPinchSens=5;set zoomRange(e){this._zoomRange.x=e.x,this._zoomRange.y=e.y<=e.x?1/0:e.y,this._orbitController.zoomRange=this._zoomRange}get zoomRange(){return this._zoomRange}zoomSpeed=.001;set pitchRange(e){this._pitchRange.x=J.clamp(e.x,-360,360),this._pitchRange.y=J.clamp(e.y,-360,360),this._flyController.pitchRange=this._pitchRange,this._orbitController.pitchRange=this._pitchRange}get pitchRange(){return this._pitchRange}set yawRange(e){this._yawRange.x=J.clamp(e.x,-360,360),this._yawRange.y=J.clamp(e.y,-360,360),this._flyController.yawRange=this._yawRange,this._orbitController.yawRange=this._yawRange}get yawRange(){return this._yawRange}joystickEventName="joystick";set mobileInputLayout(e){if(!/(?:joystick|touch)-(?:joystick|touch)/.test(e)){console.warn(`CameraControls: invalid mobile input layout: ${e}`);return}this._flyMobileInput.layout=e}get mobileInputLayout(){return this._flyMobileInput.layout}gamepadDeadZone=new ne(.3,.6);constructor({app:e,entity:t,...s}){if(super({app:e,entity:t,...s}),!this.entity.camera){console.error("CameraControls: camera component not found");return}this._camera=this.entity.camera,this._orbitController.zoomRange=new ne(.01,1/0),this._desktopInput.attach(this.app.graphicsDevice.canvas),this._orbitMobileInput.attach(this.app.graphicsDevice.canvas),this._flyMobileInput.attach(this.app.graphicsDevice.canvas),this._gamepadInput.attach(this.app.graphicsDevice.canvas),this._flyMobileInput.on("joystick:position:left",([i,r,a,o])=>{this._mode==="fly"&&this.app.fire(`${this.joystickEventName}:left`,i,r,a,o)}),this._flyMobileInput.on("joystick:position:right",([i,r,a,o])=>{this._mode==="fly"&&this.app.fire(`${this.joystickEventName}:right`,i,r,a,o)}),this._pose.look(this._camera.entity.getPosition(),D.ZERO),this._setMode("orbit"),this.on("state",()=>{this._desktopInput.read(),this._orbitMobileInput.read(),this._flyMobileInput.read(),this._gamepadInput.read()}),this.on("destroy",this._destroy,this)}_destroy(){this._desktopInput.destroy(),this._orbitMobileInput.destroy(),this._flyMobileInput.destroy(),this._gamepadInput.destroy(),this._flyController.destroy(),this._orbitController.destroy()}_setMode(e){switch(!0){case(this.enableFly&&!this.enableOrbit):{e="fly";break}case(!this.enableFly&&this.enableOrbit):{e="orbit";break}case(!this.enableFly&&!this.enableOrbit):{console.warn("CameraControls: both fly and orbit modes are disabled");return}}if(this._mode!==e){switch(this._mode=e,this._controller&&this._controller.detach(),this._mode){case"orbit":{this._controller=this._orbitController;break}case"fly":{this._controller=this._flyController;break}case"focus":{this._controller=this._focusController;break}}this._controller.attach(this._pose,!1)}}focus(e,t=!1){this._setMode("focus");const s=t?this._startZoomDist:this._camera.entity.getPosition().distance(e),i=Pd.copy(this._camera.entity.forward).mulScalar(-s).add(e);this._controller.attach(Cx.look(i,e))}look(e,t=!1){this._setMode("focus");const s=t?Pd.copy(this._camera.entity.getPosition()).sub(e).normalize().mulScalar(this._startZoomDist).add(e):this._camera.entity.getPosition();this._controller.attach(Cx.look(s,e))}reset(e,t){this._setMode("focus"),this._controller.attach(Cx.look(t,e))}update(e){const{keyCode:t}=gf,{key:s,button:i,mouse:r,wheel:a}=this._desktopInput.read(),{touch:o,pinch:h,count:u}=this._orbitMobileInput.read(),{leftInput:f,rightInput:m}=this._flyMobileInput.read(),{leftStick:_,rightStick:g}=this._gamepadInput.read();hM(_,this.gamepadDeadZone.x,this.gamepadDeadZone.y),hM(g,this.gamepadDeadZone.x,this.gamepadDeadZone.y),this._state.axis.add(Pd.set(s[t.D]-s[t.A]+(s[t.RIGHT]-s[t.LEFT]),s[t.E]-s[t.Q],s[t.W]-s[t.S]+(s[t.UP]-s[t.DOWN])));for(let F=0;F<this._state.mouse.length;F++)this._state.mouse[F]+=i[F];this._state.shift+=s[t.SHIFT],this._state.ctrl+=s[t.CTRL],this._state.touches+=u[0],i[0]===1||i[1]===1||i[2]===1||a[0]!==0?this._setMode("orbit"):this._state.axis.length()>0&&this._setMode("fly");const S=+(this._mode==="orbit"),x=+(this._mode==="fly"),T=+(this._state.touches>1),E=+(this._state.shift||this._state.mouse[1]||this._state.mouse[2]),b=+this._flyMobileInput.layout.endsWith("joystick"),C=(this._state.shift?this.moveFastSpeed:this._state.ctrl?this.moveSlowSpeed:this.moveSpeed)*e,w=this.zoomSpeed*60*e,P=w*this.zoomPinchSens,I=this.rotateSpeed*60*e,M=this.rotateSpeed*this.rotateJoystickSens*60*e,{deltas:R}=Dx,L=Pd.set(0,0,0),B=this._state.axis.clone().normalize();L.add(B.mulScalar(x*C));const G=uM(this._camera,r[0],r[1],this._pose.distance);L.add(G.mulScalar(S*E*+this.enablePan));const H=Aa.set(0,0,a[0]);L.add(H.mulScalar(S*w)),R.move.append([L.x,L.y,L.z]),L.set(0,0,0);const ee=Aa.set(r[0],r[1],0);L.add(ee.mulScalar((1-S*E)*I)),R.rotate.append([L.x,L.y,L.z]),L.set(0,0,0);const j=Aa.set(f[0],0,-f[1]);L.add(j.mulScalar(x*C));const ae=uM(this._camera,o[0],o[1],this._pose.distance);L.add(ae.mulScalar(S*T*+this.enablePan));const k=Aa.set(0,0,h[0]);L.add(k.mulScalar(S*T*P)),R.move.append([L.x,L.y,L.z]),L.set(0,0,0);const O=Aa.set(o[0],o[1],0);L.add(O.mulScalar(S*(1-T)*I));const z=Aa.set(m[0],m[1],0);L.add(z.mulScalar(x*(b?M:I))),R.rotate.append([L.x,L.y,L.z]),L.set(0,0,0);const X=Aa.set(_[0],0,-_[1]);L.add(X.mulScalar(x*C)),R.move.append([L.x,L.y,L.z]),L.set(0,0,0);const Y=Aa.set(g[0],g[1],0);if(L.add(Y.mulScalar(x*M)),R.rotate.append([L.x,L.y,L.z]),this.app.xr?.active){Dx.read();return}if(this._mode==="focus"){const F=R.move.length()+R.rotate.length()>0,U=this._focusController.complete();(F||U)&&this._setMode("orbit")}this._pose.copy(this._controller.update(Dx,e)),this._camera.entity.setPosition(this._pose.position),this._camera.entity.setEulerAngles(this._pose.angles)}}const see=c=>{const e=vf(c,Pg);return BI("gsplat",e,Pg.schema),null},Pg=rm("GSplat",()=>new Nt("mock-gsplat",Fv()).addComponent("gsplat"),c=>c.system.destroy(),{apiName:"GSplatComponent"});Pg.schema={...Pg.schema,asset:{validate:c=>c instanceof Ee,errorMsg:c=>`Invalid value for prop "asset": "${JSON.stringify(c)}". Expected an Asset.`,default:null},unified:{validate:c=>typeof c=="boolean",errorMsg:c=>`Invalid value for prop "unified": "${JSON.stringify(c)}". Expected a boolean.`,default:!1,apply:(c,e,t)=>{const s=e[t];if(c.unified!==s){if(!c.enabled){c.unified=s;return}c.enabled=!1,c.unified=s,c.enabled=!0}}},material:{validate:c=>c===null||c instanceof Za,errorMsg:c=>`Invalid value for prop "material": "${c}". Expected a ShaderMaterial or null.`,default:null,apply:(c,e,t)=>{const s=e[t];c.material!==s&&s&&(c.material=s)}},instance:{validate:c=>c===null||c instanceof _L,errorMsg:c=>`Invalid value for prop "instance": "${c}". Expected a GSplatInstance or null.`,default:null,apply:(c,e,t)=>{const s=e[t];c.instance!==s&&(c.instance=s)}}};function iee(c){return typeof c=="object"&&c!==null&&"equals"in c&&typeof c.equals=="function"}const ree=(c,e)=>{if(c===e)return!0;if(typeof c!="object"||c===null||typeof e!="object"||e===null)return!1;const t=Object.keys(c),s=Object.keys(e);if(t.length!==s.length)return!1;for(let i=0;i<t.length;i++){const r=t[i],a=c[r],o=e[r];if(iee(a))return a.equals(o);if(a!==o)return!1}return!0},aee=q.forwardRef(function(e,t){const s=OI(e,lee,!1),{script:i,...r}=s,a=q.useMemo(()=>r,[r]);return FJ(i,a,t),null}),nee=q.memo(aee,(c,e)=>c.script===e.script&&ree(c,e));class oee extends zs{static scriptName="null-script"}const lee={name:"Script",apiName:"ScriptComponent",schema:{script:{validate:c=>!!(c&&c instanceof Function&&c.prototype instanceof zs),errorMsg:c=>`Invalid value for prop "script": "${c}". Expected a subclass of Script.`,default:oee}}};function dM(c,e){var t=Object.keys(c);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(c);e&&(s=s.filter(function(i){return Object.getOwnPropertyDescriptor(c,i).enumerable})),t.push.apply(t,s)}return t}function fM(c){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?dM(Object(t),!0).forEach(function(s){cee(c,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(c,Object.getOwnPropertyDescriptors(t)):dM(Object(t)).forEach(function(s){Object.defineProperty(c,s,Object.getOwnPropertyDescriptor(t,s))})}return c}function cee(c,e,t){return e=hee(e),e in c?Object.defineProperty(c,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):c[e]=t,c}function hee(c){var e=uee(c,"string");return typeof e=="symbol"?e:String(e)}function uee(c,e){if(typeof c!="object"||c===null)return c;var t=c[Symbol.toPrimitive];if(t!==void 0){var s=t.call(c,e);if(typeof s!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(c)}const dee=kI({});function kI(c){return e.withOptions=t=>kI(fM(fM({},c),t)),e;function e(t,...s){const i=typeof t=="string"?[t]:t.raw,{alignValues:r=!1,escapeSpecialCharacters:a=Array.isArray(t),trimWhitespace:o=!0}=c;let h="";for(let m=0;m<i.length;m++){let _=i[m];if(a&&(_=_.replace(/\\\n[ \t]*/g,"").replace(/\\`/g,"`").replace(/\\\$/g,"$").replace(/\\\{/g,"{")),h+=_,m<s.length){const g=r?fee(s[m],h):s[m];h+=g}}const u=h.split(`
`);let f=null;for(const m of u){const _=m.match(/^(\s+)\S+/);if(_){const g=_[1].length;f?f=Math.min(f,g):f=g}}if(f!==null){const m=f;h=u.map(_=>_[0]===" "||_[0]==="	"?_.slice(m):_).join(`
`)}return o&&(h=h.trim()),a&&(h=h.replace(/\\n/g,`
`)),typeof Bun<"u"&&(h=h.replace(/\\u(?:\{([\da-fA-F]{1,6})\}|([\da-fA-F]{4}))/g,(m,_,g)=>{var S;const x=(S=_??g)!==null&&S!==void 0?S:"";return String.fromCodePoint(parseInt(x,16))})),h}}function fee(c,e){if(typeof c!="string"||!c.includes(`
`))return c;const s=e.slice(e.lastIndexOf(`
`)+1).match(/^(\s+)/);if(s){const i=s[1];return c.replace(/\n/g,`
${i}`)}return c}const Px=new Set;function mee(c){const e=ru(),{center:t,scale:s,rotation:i,depthWrite:r,type:a,showSkybox:o,...h}=c,u={center:t,scale:s,rotation:i,depthWrite:r,type:a,showSkybox:o},f=vf(h,UT),m=vf(u,BT),_=q.useRef(!1);return q.useEffect(()=>{const g=e.root.getGuid(),S=Px.has(g);return Px.add(g),_.current=S,S&&Xn(dee`Multiple \`<Environment/>\` components have been mounted.
                Only the first \`<Environment/>\` component will be used.`),()=>{Px.delete(g)}}),q.useEffect(()=>{if(_.current)return;const g=f.skybox;if(!g)return;const S=Array.isArray(g.resources)&&g.resources.length===6;let x=g.resource;return S||(x=JE.generateSkyboxCubemap(g.resource)),e.scene.skybox=x,()=>{e?.scene&&(e.scene.skybox=null)}},[_.current,f.skybox?.id]),q.useEffect(()=>{if(!_.current)return e.scene.envAtlas=f?.envAtlas?.resource??null,()=>{e?.scene&&(e.scene.envAtlas=null)}},[_.current,f.envAtlas?.id]),q.useEffect(()=>{if(_.current)return;e.scene.exposure=f.exposure??1,e.scene.envAtlas=f.envAtlas?.resource??null,m.rotation&&(e.scene.skyboxRotation=new pe().setFromEulerAngles(m.rotation[0],m.rotation[1],m.rotation[2])),m.scale&&e.scene.sky.node.setLocalScale(...m.scale),m.position&&e.scene.sky.node.setLocalPosition(...m.position),m.center&&e.scene.sky.center.set(...m.center),e.scene.sky.type=m.type??V2,e.scene.sky.depthWrite=m.depthWrite??!0,e.scene.skyboxMip=f.skyboxMip??0,e.scene.skyboxLuminance=f.skyboxLuminance??1,e.scene.skyboxIntensity=f.skyboxIntensity??1,e.scene.skyboxHighlightMultiplier=f.skyboxHighlightMultiplier??1;const g=e?.scene?.layers?.getLayerByName("Skybox");return g&&(g.enabled=m.showSkybox??!0),()=>{if(e.scene){e.scene.exposure=1,e.scene.skyboxRotation=new pe().setFromEulerAngles(0,0,0),e.scene.sky.node.setLocalScale(1,1,1),e.scene.sky.node.setLocalPosition(0,0,0),e.scene.sky.center.set(0,.05,0),e.scene.sky.type=kd,e.scene.sky.depthWrite=!1,e.scene.skyboxMip=0,e.scene.skyboxLuminance=0,e.scene.skyboxIntensity=1,e.scene.skyboxHighlightMultiplier=1;const S=e?.scene?.layers?.getLayerByName("Skybox");S&&(S.enabled=!0)}}},[_.current,f.exposure,m.type,m.depthWrite,m.showSkybox,f.skyboxMip,f.skyboxLuminance,f.skyboxIntensity,f.skyboxHighlightMultiplier,`scale-${m.scale?.join("-")}`,`rotation-${m.rotation?.join("-")}`,`center-${m.center?.join("-")}`]),null}const BT=rm("Sky",()=>new nL(Fv().scene),c=>c.resetSkyMesh()),UT=rm("Scene",()=>Fv().scene);BT.schema={...BT.schema,scale:{validate:c=>Array.isArray(c)&&c.length===3&&c.every(e=>typeof e=="number"),errorMsg:c=>`Expected an array of 3 numbers, got \`${typeof c}\``,default:[100,100,100]},rotation:{validate:c=>Array.isArray(c)&&c.length===3&&c.every(e=>typeof e=="number"),errorMsg:c=>`Expected an array of 3 numbers, got \`${typeof c}\``,default:[0,0,0]},position:{validate:c=>Array.isArray(c)&&c.length===3&&c.every(e=>typeof e=="number"),errorMsg:c=>`Expected an array of 3 numbers, got \`${typeof c}\``,default:[0,0,0]},center:{validate:c=>Array.isArray(c)&&c.length===3&&c.every(e=>typeof e=="number"),errorMsg:c=>`Expected an array of 3 numbers, got \`${typeof c}\``,default:[0,.05,0]},showSkybox:{validate:c=>typeof c=="boolean",errorMsg:c=>`Expected a boolean, got \`${typeof c}\``,default:!0}};UT.schema={...UT.schema,envAtlas:{validate:c=>c instanceof Ee&&c.type==="texture",errorMsg:c=>`Expected a \`Asset\` instance, got \`${typeof c}\``,default:null},skybox:{validate:c=>c instanceof Ee&&c.type==="texture",errorMsg:c=>`Expected a \`Asset\` instance, got \`${typeof c}\``,default:null}};function pee({onClick:c,label:e,splatSrc:t,bgColor:s}){const[i,r]=q.useState(!1),a=ru(),o=q.useRef(null),h=q.useRef(null),u="/my-3d-gallery_2/",{asset:f}=kJ(`${u}environment-map.png`),{asset:m}=zJ(t),_=q.memo(function({asset:S}){return ge.jsx(see,{asset:S})});return q.useEffect(()=>{document.body.style.cursor=i?"pointer":"default"},[i]),q.useEffect(()=>{e&&console.log("Viewer label:",e)},[e]),q.useEffect(()=>{o.current&&o.current.lookAt(0,0,0)},[]),q.useEffect(()=>{if(!o.current)return;const g=o.current.camera;g&&g.clearColor.fromString(s)},[s,a]),q.useEffect(()=>{const g=S=>S.preventDefault();return window.addEventListener("contextmenu",g),()=>window.removeEventListener("contextmenu",g)},[]),q.useEffect(()=>{if(!a)return;const g=a.graphicsDevice.canvas;let S=!1,x=0,T=0;const E=new D,b=new D,C=new D,w=R=>R.preventDefault(),P=R=>{R.button===2&&(S=!0,x=R.clientX,T=R.clientY,g.setPointerCapture?.(R.pointerId))},I=R=>{R.button===2&&(S=!1,g.releasePointerCapture?.(R.pointerId))},M=R=>{if(!S||!o.current||!h.current)return;const L=R.clientX-x,B=R.clientY-T;x=R.clientX,T=R.clientY;const G=.002;b.copy(o.current.right).mulScalar(L*G),C.copy(o.current.up).mulScalar(-B*G),E.copy(h.current.getPosition()).add(b).add(C),h.current.setPosition(E)};return g.addEventListener("contextmenu",w),g.addEventListener("pointerdown",P),g.addEventListener("pointerup",I),g.addEventListener("pointermove",M),()=>{g.removeEventListener("contextmenu",w),g.removeEventListener("pointerdown",P),g.removeEventListener("pointerup",I),g.removeEventListener("pointermove",M)}},[a]),ge.jsxs(ge.Fragment,{children:[ge.jsx(mee,{envAtlas:f,showSkybox:!1}),ge.jsxs(wx,{ref:o,name:"camera",position:[0,.5,2.5],children:[ge.jsx(eee,{clearColor:s}),ge.jsx(nee,{script:tee})]}),ge.jsx(wx,{ref:h,rotation:[180,0,0],position:[0,0,0],children:m?ge.jsx(_,{asset:m}):null}),ge.jsx(wx,{position:[0,0,0],onClick:c,onPointerOver:()=>r(!0),onPointerOut:()=>r(!1)})]})}function _ee({works:c,currentIndex:e,onSelect:t}){return ge.jsxs("aside",{className:"gallery-list",children:[ge.jsx("h2",{children:"3D Models"}),ge.jsx("ul",{children:c.map((s,i)=>ge.jsx("li",{children:ge.jsx("button",{className:i===e?"active":"",onClick:()=>t(i),children:s.title})},s.id))})]})}const mM="/my-3d-gallery_2/",Rx=[{id:"work-001",title:"001: ",description:"",tags:["sample"],splatSrc:`${mM}splats/work_001.compressed.ply`},{id:"work-002",title:"002: ",description:"",tags:["sample"],splatSrc:`${mM}splats/work_002.compressed.ply`}];function gee(){const[c,e]=q.useState(0),[t,s]=q.useState("#777777"),i=Rx[c],r=HT(),a=()=>{e(o=>(o+1)%Rx.length)};return ge.jsxs(ge.Fragment,{children:[ge.jsx("div",{className:"full-bleed",children:ge.jsx($J,{className:"playcanvas-app",graphicsDeviceOptions:{antialias:!1},children:ge.jsx(pee,{onClick:a,label:i.title,splatSrc:i.splatSrc,bgColor:t})})}),ge.jsxs("div",{className:"absolute overlay",children:[ge.jsxs("div",{className:"sidebar pointer-events-auto",children:[ge.jsxs("div",{className:"sidebar-header",children:[ge.jsx("div",{className:"home-button-area",children:ge.jsx("button",{className:"home-btn",onClick:()=>r("/"),children:" Home"})}),ge.jsxs("div",{className:"sidebar-top",children:[ge.jsx("div",{className:"sidebar-section-title",children:"Background Color"}),ge.jsxs("div",{className:"bg-preset-row",children:[ge.jsx("button",{className:"bg-btn",onClick:()=>s("#252525"),children:"Dark"}),ge.jsx("button",{className:"bg-btn",onClick:()=>s("#777777"),children:"Light Gray"}),ge.jsx("button",{className:"bg-btn",onClick:()=>s("#E4E4E4"),children:"Light"}),ge.jsx("button",{className:"bg-btn",onClick:()=>s("#f5f1e8"),children:"Ivory"})]})]})]}),ge.jsx("div",{className:"sidebar-body",children:ge.jsx(_ee,{works:Rx,currentIndex:c,onSelect:e})})]}),ge.jsx("div",{className:"grow",children:ge.jsxs("header",{className:"viewer-header",children:[ge.jsx("h1",{className:"viewer-title",children:i.title}),i.description&&ge.jsx("p",{className:"viewer-description",children:i.description})]})})]})]})}function vee(){return ge.jsxs(uF,{children:[ge.jsx(S_,{path:"/",element:ge.jsx(XF,{})}),ge.jsx(S_,{path:"/gallery",element:ge.jsx(gee,{})}),ge.jsx(S_,{path:"*",element:ge.jsx(cF,{to:"/",replace:!0})})]})}fN.createRoot(document.getElementById("root")).render(ge.jsx(q.StrictMode,{children:ge.jsx(NF,{children:ge.jsx(vee,{})})}));
